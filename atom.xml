<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭吉吉的瞎记空间</title>
  <subtitle>技术的，瞎说的，啥都有吧。。。希望。。。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-21T09:20:35.940Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>臭吉吉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>objc-公共头文件（Public Headers）的基本内容（下）</title>
    <link href="http://yoursite.com/2019/01/21/objc-%E5%85%AC%E5%85%B1%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%88Public%20Headers%EF%BC%89%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2019/01/21/objc-公共头文件（Public Headers）的基本内容（下）/</id>
    <published>2019-01-21T09:20:35.940Z</published>
    <updated>2019-01-21T09:20:35.940Z</updated>
    
    <content type="html"><![CDATA[<h3 id="runtime-h"><a href="#runtime-h" class="headerlink" title="runtime.h"></a>runtime.h</h3><h4 id="1-数据类型定义"><a href="#1-数据类型定义" class="headerlink" title="1.数据类型定义"></a>1.数据类型定义</h4><h5 id="1-1-方法Method"><a href="#1-1-方法Method" class="headerlink" title="1.1 方法Method"></a>1.1 方法Method</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> *<span class="title">Method</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></div><div class="line">    SEL name;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;</div><div class="line">    IMP imp;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SortBySELAddress</span> :</span></div><div class="line">        <span class="keyword">public</span> <span class="built_in">std</span>::binary_function&lt;<span class="keyword">const</span> <span class="keyword">method_t</span>&amp;,</div><div class="line">                                    <span class="keyword">const</span> <span class="keyword">method_t</span>&amp;, <span class="keyword">bool</span>&gt;</div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">method_t</span>&amp; lhs,</span></span></div><div class="line">                         <span class="keyword">const</span> <span class="keyword">method_t</span>&amp; rhs)</div><div class="line">        &#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>如上所述，Method即为method_t的结构体实例指针，其组成包含<strong>SEL选择器、IMP函数指针和方法类型描述</strong>。</p>
<h5 id="1-2-变量Ivar"><a href="#1-2-变量Ivar" class="headerlink" title="1.2 变量Ivar"></a>1.2 变量Ivar</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> *<span class="title">Ivar</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></div><div class="line">    <span class="keyword">int32_t</span> *offset;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;</div><div class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></div><div class="line">    <span class="keyword">uint32_t</span> alignment_raw;</div><div class="line">    <span class="keyword">uint32_t</span> size;</div><div class="line"></div><div class="line">    <span class="keyword">uint32_t</span> alignment() <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span> (alignment_raw == ~(<span class="keyword">uint32_t</span>)<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1U</span> &lt;&lt; WORD_SHIFT;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; alignment_raw;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Ivar为ivar_t的结构体实例指针，组成主要包括<strong>变量名，变量类型和偏移量（用于内存布局）</strong>。</p>
<h5 id="1-3-分类Category"><a href="#1-3-分类Category" class="headerlink" title="1.3 分类Category"></a>1.3 分类Category</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> *<span class="title">Category</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">classref_t</span> cls;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></div><div class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></div><div class="line"></div><div class="line">    <span class="keyword">method_list_t</span> *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</div><div class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">property_list_t</span> *propertiesForMeta(<span class="keyword">bool</span> isMeta, struct header_info *hi);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Category为category_t的结构体实例指针，内部主要包括<em>**分类名、所属类、实例方法列表指针、类方法列表指针和协议列表指针</em>。</p>
<h5 id="1-4-属性objc-property-t"><a href="#1-4-属性objc-property-t" class="headerlink" title="1.4 属性objc_property_t"></a>1.4 属性objc_property_t</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> *<span class="title">objc_property_t</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>指向property_t结构体实例的指针，内部包含名称和支持的特性。</p>
<h5 id="1-5-类Class"><a href="#1-5-类Class" class="headerlink" title="1.5 类Class"></a>1.5 类Class</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></div><div class="line">    Class _Nonnull isa;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Class即为指向objc_class结构体实例的指针。Class内部包含Class类型的isa指针。</li>
<li>由于Class的结构与id一致，均只包含isa的Class指针，故<strong>Class也是对象</strong>（面向对象中一切皆为对象）。</li>
<li>Class中的isa指向的是metaclass。</li>
</ul>
<h4 id="2-方法定义"><a href="#2-方法定义" class="headerlink" title="2.方法定义"></a>2.方法定义</h4><h5 id="2-1-使用对象的相关方法"><a href="#2-1-使用对象的相关方法" class="headerlink" title="2.1 使用对象的相关方法"></a>2.1 使用对象的相关方法</h5><h6 id="2-1-1-获取对象所属类"><a href="#2-1-1-获取对象所属类" class="headerlink" title="2.1.1 获取对象所属类"></a>2.1.1 获取对象所属类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class _<span class="function">Nullable </span></div><div class="line"><span class="title">object_getClass</span><span class="params">(id _Nullable obj)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-1-2-给对象设置所属类"><a href="#2-1-2-给对象设置所属类" class="headerlink" title="2.1.2 给对象设置所属类"></a>2.1.2 给对象设置所属类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class _<span class="function">Nullable</span></div><div class="line"><span class="title">object_setClass</span><span class="params">(id _Nullable obj, Class _Nonnull cls)</span>;</div></pre></td></tr></table></figure>
<p>返回值为设置之前的类</p>
<h6 id="2-1-3-判断执行对象是否为类"><a href="#2-1-3-判断执行对象是否为类" class="headerlink" title="2.1.3 判断执行对象是否为类"></a>2.1.3 判断执行对象是否为类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">object_isClass</span><span class="params">(id _Nullable obj)</span>;</div></pre></td></tr></table></figure>
<p>返回YES，则传入对象为Class或metaclass（印证了Class也是对象）。</p>
<h6 id="2-1-4-获取对象的实例变量的值"><a href="#2-1-4-获取对象的实例变量的值" class="headerlink" title="2.1.4 获取对象的实例变量的值"></a>2.1.4 获取对象的实例变量的值</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id _<span class="function">Nullable</span></div><div class="line"><span class="title">object_getIvar</span><span class="params">(id _Nullable obj, Ivar _Nonnull ivar)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-1-5-向对象的实例变量设置值"><a href="#2-1-5-向对象的实例变量设置值" class="headerlink" title="2.1.5 向对象的实例变量设置值"></a>2.1.5 向对象的实例变量设置值</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">object_setIvar</span><span class="params">(id _Nullable obj, Ivar _Nonnull ivar, id _Nullable value)</span>;</div></pre></td></tr></table></figure>
<p>对于实例变量Ivar来说，</p>
<ul>
<li>若其内存管理方式已知（如在ARC环境下），就会直接按照其进行设置；</li>
<li>若未知，则按照__unsafe_unretained方式进行设置；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">object_setIvarWithStrongDefault</span><span class="params">(id _Nullable obj, Ivar _Nonnull ivar, id _Nullable value)</span>;</div></pre></td></tr></table></figure>
<p>对于实例变量Ivar来说，</p>
<ul>
<li>若其内存管理方式已知（如在ARC环境下），就会直接按照其进行设置；</li>
<li>若未知，则按照__strong方式进行设置；</li>
</ul>
<h5 id="2-2-获取类定义的相关方法"><a href="#2-2-获取类定义的相关方法" class="headerlink" title="2.2 获取类定义的相关方法"></a>2.2 获取类定义的相关方法</h5><h6 id="2-2-1-根据名字获取类"><a href="#2-2-1-根据名字获取类" class="headerlink" title="2.2.1 根据名字获取类"></a>2.2.1 根据名字获取类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 1. 一般方式</span></div><div class="line">Class _<span class="function">Nullable</span></div><div class="line"><span class="title">objc_getClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name)</span>;</div><div class="line"></div><div class="line"><span class="comment">// 2. 第二种方式</span></div><div class="line">Class _<span class="function">Nullable</span></div><div class="line"><span class="title">objc_lookUpClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name)</span>;</div><div class="line"></div><div class="line"><span class="comment">// 3. 自杀式</span></div><div class="line">Class _<span class="function">Nonnull</span></div><div class="line"><span class="title">objc_getRequiredClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<ul>
<li>所有方式，均可以查询到是否存在改类。</li>
<li>区别：当Class没有注册到运行时系统中时，<em>objc_getClass</em>方法会在类的处理回调执行后，再次查询该类是否已存在；<em>objc_lookUpClass</em>则不会；<em>objc_getRequiredClass</em>则会自动终止进程（只会查询编译时已确定的Class）。</li>
</ul>
<h6 id="2-2-2-获取类的原类"><a href="#2-2-2-获取类的原类" class="headerlink" title="2.2.2 获取类的原类"></a>2.2.2 获取类的原类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class _<span class="function">Nullable</span></div><div class="line"><span class="title">objc_getMetaClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<p>类方法都是保存在metaclass中的。</p>
<h6 id="2-2-3-获取所有的类定义"><a href="#2-2-3-获取所有的类定义" class="headerlink" title="2.2.3 获取所有的类定义"></a>2.2.3 获取所有的类定义</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">objc_getClassList</span><span class="params">(Class _Nonnull * _Nullable buffer, <span class="keyword">int</span> bufferCount)</span>;</div></pre></td></tr></table></figure>
<p>注意：</p>
<blockquote>
<p>不要假定返回的所有类都继承自NSObject，故对其中的类调用方法时需要提前检查该方法是否已经实现。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class _Nonnull * _<span class="function">Nullable</span></div><div class="line"><span class="title">objc_copyClassList</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span>;</div></pre></td></tr></table></figure>
<p>我们一般使用此版本，不过使用完的列表对象，需要手动释放内存。</p>
<h5 id="2-3-使用类的相关方法"><a href="#2-3-使用类的相关方法" class="headerlink" title="2.3 使用类的相关方法"></a>2.3 使用类的相关方法</h5><h6 id="2-3-1-获取类的名字"><a href="#2-3-1-获取类的名字" class="headerlink" title="2.3.1 获取类的名字"></a>2.3.1 获取类的名字</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nonnull</span></div><div class="line"><span class="title">class_getName</span><span class="params">(Class _Nullable cls)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-3-2-判断类是否为原类（metaclass）"><a href="#2-3-2-判断类是否为原类（metaclass）" class="headerlink" title="2.3.2 判断类是否为原类（metaclass）"></a>2.3.2 判断类是否为原类（metaclass）</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">class_isMetaClass</span><span class="params">(Class _Nullable cls)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-3-3-获取类的父类"><a href="#2-3-3-获取类的父类" class="headerlink" title="2.3.3 获取类的父类"></a>2.3.3 获取类的父类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getSuperclass</span><span class="params">(Class _Nullable cls)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-3-4-返回类的实例的大小（OC对象的大小）"><a href="#2-3-4-返回类的实例的大小（OC对象的大小）" class="headerlink" title="2.3.4 返回类的实例的大小（OC对象的大小）"></a>2.3.4 返回类的实例的大小（OC对象的大小）</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span></div><div class="line">class_getInstanceSize(Class _Nullable cls);</div></pre></td></tr></table></figure>
<h6 id="2-3-5-获取类中的实例变量"><a href="#2-3-5-获取类中的实例变量" class="headerlink" title="2.3.5 获取类中的实例变量"></a>2.3.5 获取类中的实例变量</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Ivar _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getInstanceVariable</span><span class="params">(Class _Nullable cls, <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<p>返回的是指定名字的实例变量对象（非属性对象），类型为Ivar，即ivar<em>返回的是指定名字的实例变量对象（非属性对象），类型为Ivar，即ivar</em>返回构体指针。</p>
<h6 id="2-3-6-获取类中的类变量"><a href="#2-3-6-获取类中的类变量" class="headerlink" title="2.3.6 获取类中的类变量"></a>2.3.6 获取类中的类变量</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Ivar _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getClassVariable</span><span class="params">(Class _Nullable cls, <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<p>一般来说，Class中并没有所谓的“类变量”。我们可以使用此方法来返回“isa”指针的对象。</p>
<h6 id="2-3-7-拷贝并返回类的实例变量列表"><a href="#2-3-7-拷贝并返回类的实例变量列表" class="headerlink" title="2.3.7 拷贝并返回类的实例变量列表"></a>2.3.7 拷贝并返回类的实例变量列表</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Ivar _Nonnull * _<span class="function">Nullable</span></div><div class="line"><span class="title">class_copyIvarList</span><span class="params">(Class _Nullable cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span>;</div></pre></td></tr></table></figure>
<ul>
<li>返回的是包含所有实例变量Ivar指针的数组，使用完毕后需要手动释放内存；</li>
<li>只有自身类的实例变量，不包括父类</li>
</ul>
<h6 id="2-3-8-获取指定类的实例方法对象"><a href="#2-3-8-获取指定类的实例方法对象" class="headerlink" title="2.3.8 获取指定类的实例方法对象"></a>2.3.8 获取指定类的实例方法对象</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Method _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getInstanceMethod</span><span class="params">(Class _Nullable cls, SEL _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<p>注意：此方法会查找父类中的实现。</p>
<h6 id="2-3-9-获取指定类的类方法对象"><a href="#2-3-9-获取指定类的类方法对象" class="headerlink" title="2.3.9 获取指定类的类方法对象"></a>2.3.9 获取指定类的类方法对象</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Method _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getClassMethod</span><span class="params">(Class _Nullable cls, SEL _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<p>注意：此方法会查找父类中的实现。</p>
<h6 id="2-3-10-获取指定类中的指定方法实现"><a href="#2-3-10-获取指定类中的指定方法实现" class="headerlink" title="2.3.10 获取指定类中的指定方法实现"></a>2.3.10 获取指定类中的指定方法实现</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IMP _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getMethodImplementation</span><span class="params">(Class _Nullable cls, SEL _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<p>注意，返回的IMP为运行时中的内部对象，并非真正的函数指针。当找不到方法实现时，返回的是消息转发机制中的函数指针。</p>
<h6 id="2-3-11-拷贝并返回类中的方法列表"><a href="#2-3-11-拷贝并返回类中的方法列表" class="headerlink" title="2.3.11 拷贝并返回类中的方法列表"></a>2.3.11 拷贝并返回类中的方法列表</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Method _Nonnull * _<span class="function">Nullable</span></div><div class="line"><span class="title">class_copyMethodList</span><span class="params">(Class _Nullable cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span>;</div></pre></td></tr></table></figure>
<ul>
<li>返回的是包含所有方法Method指针的数组，使用完毕后需要手动释放内存；</li>
<li>只有自身类的方法，不包括父类</li>
</ul>
<h6 id="2-3-12-拷贝并返回类遵循的协议列表"><a href="#2-3-12-拷贝并返回类遵循的协议列表" class="headerlink" title="2.3.12 拷贝并返回类遵循的协议列表"></a>2.3.12 拷贝并返回类遵循的协议列表</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Protocol * __unsafe_unretained _Nonnull * _<span class="function">Nullable </span></div><div class="line"><span class="title">class_copyProtocolList</span><span class="params">(Class _Nullable cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span>;</div></pre></td></tr></table></figure>
<p>这里的Protocol实质上是NSObject的子类。</p>
<h6 id="2-3-13-获取类的属性对象（property）"><a href="#2-3-13-获取类的属性对象（property）" class="headerlink" title="2.3.13 获取类的属性对象（property）"></a>2.3.13 获取类的属性对象（property）</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">objc_property_t</span> _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getProperty</span><span class="params">(Class _Nullable cls, <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-3-14-拷贝并返回类的属性列表"><a href="#2-3-14-拷贝并返回类的属性列表" class="headerlink" title="2.3.14 拷贝并返回类的属性列表"></a>2.3.14 拷贝并返回类的属性列表</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">objc_property_t</span> _Nonnull * _<span class="function">Nullable</span></div><div class="line"><span class="title">class_copyPropertyList</span><span class="params">(Class _Nullable cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span>;</div></pre></td></tr></table></figure>
<ul>
<li>返回的是包含所有属性objc_property_t指针的数组，使用完毕后需要手动释放内存；</li>
<li>只有自身类的属性，不包括父类</li>
</ul>
<h6 id="2-3-15-获取类的实例变量布局"><a href="#2-3-15-获取类的实例变量布局" class="headerlink" title="2.3.15 获取类的实例变量布局"></a>2.3.15 获取类的实例变量布局</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getIvarLayout</span><span class="params">(Class _Nullable cls)</span>;</div></pre></td></tr></table></figure>
<p>得到的是类的实例变量的布局描述，这里留下疑问？？？</p>
<h6 id="2-3-16-获取类的weak的实例变量布局"><a href="#2-3-16-获取类的weak的实例变量布局" class="headerlink" title="2.3.16 获取类的weak的实例变量布局"></a>2.3.16 获取类的weak的实例变量布局</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getWeakIvarLayout</span><span class="params">(Class _Nullable cls)</span>;</div></pre></td></tr></table></figure>
<p>第二个疑问？？？</p>
<h6 id="2-3-17-给类添加新方法"><a href="#2-3-17-给类添加新方法" class="headerlink" title="2.3.17 给类添加新方法"></a>2.3.17 给类添加新方法</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">class_addMethod</span><span class="params">(</span></div><div class="line">    Class _Nullable cls, </div><div class="line">    SEL _Nonnull name, </div><div class="line">    IMP _Nonnull imp,</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nullable types</div><div class="line">);</div></pre></td></tr></table></figure>
<ul>
<li>可以向类中动态添加方法</li>
<li>可以覆盖父类的同名方法</li>
<li>不会替换本类中已存在方法的实现（修改方法实现，可使用<em>method_setImplementation</em>方法）</li>
</ul>
<h6 id="2-3-18-替换类中指定方法的实现"><a href="#2-3-18-替换类中指定方法的实现" class="headerlink" title="2.3.18 替换类中指定方法的实现"></a>2.3.18 替换类中指定方法的实现</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">IMP _<span class="function">Nullable</span></div><div class="line"><span class="title">class_replaceMethod</span><span class="params">(</span></div><div class="line">    Class _Nullable cls, </div><div class="line">    SEL _Nonnull name, </div><div class="line">    IMP _Nonnull imp, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nullable types</div><div class="line">);</div></pre></td></tr></table></figure>
<ul>
<li>若方法不存在，则向该类中自动添加方法；</li>
<li>方法已存在，则替换方法实现</li>
</ul>
<h6 id="2-3-19-向类中添加实例变量"><a href="#2-3-19-向类中添加实例变量" class="headerlink" title="2.3.19 向类中添加实例变量"></a>2.3.19 向类中添加实例变量</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">class_addIvar</span><span class="params">(</span></div><div class="line">    Class _Nullable cls, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name, </div><div class="line">    <span class="keyword">size_t</span> size, </div><div class="line">    <span class="keyword">uint8_t</span> alignment, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nullable types</div><div class="line">);</div></pre></td></tr></table></figure>
<ul>
<li>只能在<em>objc_allocateClassPair</em>之后（动态创建类）并在<em>objc_registerClassPair</em>（向运行时系统注册类）之前调用，将实例变量添加到类布局中；</li>
<li>只能添加到本类中，不能添加到metaclass中；</li>
<li>alignment对齐方式，最少为“1&lt;&lt;alignment”；对于指针类型变量，传入log2(sizeof(pointer_type))。</li>
</ul>
<h6 id="2-3-20-向类中新增遵循的协议"><a href="#2-3-20-向类中新增遵循的协议" class="headerlink" title="2.3.20 向类中新增遵循的协议"></a>2.3.20 向类中新增遵循的协议</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">class_addProtocol</span><span class="params">(Class _Nullable cls, Protocol * _Nonnull protocol)</span>;</div></pre></td></tr></table></figure>
<p>返回NO时，即该类已遵循该协议</p>
<h6 id="2-3-21-向类中新增属性"><a href="#2-3-21-向类中新增属性" class="headerlink" title="2.3.21 向类中新增属性"></a>2.3.21 向类中新增属性</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">class_addProperty</span><span class="params">(</span></div><div class="line">    Class _Nullable cls, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> * _Nullable attributes, </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount</div><div class="line">);</div></pre></td></tr></table></figure>
<h6 id="2-3-22-替换类中的指定属性"><a href="#2-3-22-替换类中的指定属性" class="headerlink" title="2.3.22 替换类中的指定属性"></a>2.3.22 替换类中的指定属性</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">class_replaceProperty</span><span class="params">(</span></div><div class="line">    Class _Nullable cls, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> * _Nullable attributes, </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount</div><div class="line">);</div></pre></td></tr></table></figure>
<h6 id="2-3-23-向类中设置实例变量布局"><a href="#2-3-23-向类中设置实例变量布局" class="headerlink" title="2.3.23 向类中设置实例变量布局"></a>2.3.23 向类中设置实例变量布局</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">class_setIvarLayout</span><span class="params">(Class _Nullable cls, <span class="keyword">const</span> <span class="keyword">uint8_t</span> * _Nullable layout)</span>;</div></pre></td></tr></table></figure>
<p>？？？</p>
<h6 id="2-3-24-向类中设置weak的实例变量布局"><a href="#2-3-24-向类中设置weak的实例变量布局" class="headerlink" title="2.3.24 向类中设置weak的实例变量布局"></a>2.3.24 向类中设置weak的实例变量布局</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">class_setWeakIvarLayout</span><span class="params">(Class _Nullable cls, <span class="keyword">const</span> <span class="keyword">uint8_t</span> * _Nullable layout)</span>;</div></pre></td></tr></table></figure>
<p>？？？</p>
<h5 id="2-4-类实例化的相关方法"><a href="#2-4-类实例化的相关方法" class="headerlink" title="2.4 类实例化的相关方法"></a>2.4 类实例化的相关方法</h5><h6 id="2-4-1-创建类的实例"><a href="#2-4-1-创建类的实例" class="headerlink" title="2.4.1 创建类的实例"></a>2.4.1 创建类的实例</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id _<span class="function">Nullable</span></div><div class="line"><span class="title">class_createInstance</span><span class="params">(Class _Nullable cls, <span class="keyword">size_t</span> extraBytes)</span></div><div class="line">    OBJC_RETURNS_RETAINED;</div></pre></td></tr></table></figure>
<h5 id="2-5-动态添加类的相关方法"><a href="#2-5-动态添加类的相关方法" class="headerlink" title="2.5 动态添加类的相关方法"></a>2.5 动态添加类的相关方法</h5><h6 id="2-5-1-创建类及对应的元类"><a href="#2-5-1-创建类及对应的元类" class="headerlink" title="2.5.1 创建类及对应的元类"></a>2.5.1 创建类及对应的元类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Class _<span class="function">Nullable</span></div><div class="line"><span class="title">objc_allocateClassPair</span><span class="params">(</span></div><div class="line">    Class _Nullable superclass, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name,  </div><div class="line">    <span class="keyword">size_t</span> extraBytes</div><div class="line">);</div></pre></td></tr></table></figure>
<p>在运行时向系统添加类，需要先调用此方法（默认创建了类及对应的元类），之后可以使用<em>class_addMethod</em>和<em>class_addIvar</em>等添加方法和实例变量；最后调用<em>objc_registerClassPair</em>将该类注册到runtime系统中（实例方法需添加到本类，类方法添加到对应的元类中）。</p>
<h6 id="2-5-2-注册新创建的类"><a href="#2-5-2-注册新创建的类" class="headerlink" title="2.5.2 注册新创建的类"></a>2.5.2 注册新创建的类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">objc_registerClassPair</span><span class="params">(Class _Nonnull cls)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-5-3-释放类及元类"><a href="#2-5-3-释放类及元类" class="headerlink" title="2.5.3 释放类及元类"></a>2.5.3 释放类及元类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">objc_disposeClassPair</span><span class="params">(Class _Nonnull cls)</span>;</div></pre></td></tr></table></figure>
<p>注意：若存在本类的子类，不要调用此方法。</p>
<h5 id="2-6-使用方法（Method）的相关方法"><a href="#2-6-使用方法（Method）的相关方法" class="headerlink" title="2.6 使用方法（Method）的相关方法"></a>2.6 使用方法（Method）的相关方法</h5><h6 id="2-6-1-获取方法中的选择器SEL"><a href="#2-6-1-获取方法中的选择器SEL" class="headerlink" title="2.6.1 获取方法中的选择器SEL"></a>2.6.1 获取方法中的选择器SEL</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SEL _<span class="function">Nonnull</span></div><div class="line"><span class="title">method_getName</span><span class="params">(Method _Nonnull m)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-6-2-获取方法的实现IMP"><a href="#2-6-2-获取方法的实现IMP" class="headerlink" title="2.6.2 获取方法的实现IMP"></a>2.6.2 获取方法的实现IMP</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IMP _<span class="function">Nonnull</span></div><div class="line"><span class="title">method_getImplementation</span><span class="params">(Method _Nonnull m)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-6-3-获取方法的类型编码"><a href="#2-6-3-获取方法的类型编码" class="headerlink" title="2.6.3 获取方法的类型编码"></a>2.6.3 获取方法的类型编码</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">method_getTypeEncoding</span><span class="params">(Method _Nonnull m)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-6-4-获取方法的参数个数"><a href="#2-6-4-获取方法的参数个数" class="headerlink" title="2.6.4 获取方法的参数个数"></a>2.6.4 获取方法的参数个数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span></span></div><div class="line"><span class="title">method_getNumberOfArguments</span><span class="params">(Method _Nonnull m)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-6-5-拷贝并返回方法的返回类型"><a href="#2-6-5-拷贝并返回方法的返回类型" class="headerlink" title="2.6.5 拷贝并返回方法的返回类型"></a>2.6.5 拷贝并返回方法的返回类型</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> * _<span class="function">Nonnull</span></div><div class="line"><span class="title">method_copyReturnType</span><span class="params">(Method _Nonnull m)</span>;</div></pre></td></tr></table></figure>
<p>需要手动释放返回值。</p>
<h6 id="2-6-6-拷贝并返回方法的参数类型"><a href="#2-6-6-拷贝并返回方法的参数类型" class="headerlink" title="2.6.6 拷贝并返回方法的参数类型"></a>2.6.6 拷贝并返回方法的参数类型</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">method_copyArgumentType</span><span class="params">(Method _Nonnull m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span>;</div></pre></td></tr></table></figure>
<p>需要手动释放返回值。</p>
<h6 id="2-6-7-获取方法的描述结构体信息"><a href="#2-6-7-获取方法的描述结构体信息" class="headerlink" title="2.6.7 获取方法的描述结构体信息"></a>2.6.7 获取方法的描述结构体信息</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description</span> * _<span class="title">Nonnull</span></span></div><div class="line"><span class="title">method_getDescription</span>(<span class="title">Method</span> _<span class="title">Nonnull</span> <span class="title">m</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description</span> &#123;</span></div><div class="line">    SEL _Nullable name;               <span class="comment">/**&lt; The name of the method */</span></div><div class="line">    <span class="keyword">char</span> * _Nullable types;           <span class="comment">/**&lt; The types of the method arguments */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h6 id="2-6-8-设置方法实现"><a href="#2-6-8-设置方法实现" class="headerlink" title="2.6.8 设置方法实现"></a>2.6.8 设置方法实现</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IMP _<span class="function">Nonnull</span></div><div class="line"><span class="title">method_setImplementation</span><span class="params">(Method _Nonnull m, IMP _Nonnull imp)</span>;</div></pre></td></tr></table></figure>
<p>返回值为先前的实现。</p>
<h6 id="2-6-9-交换两个方法的实现"><a href="#2-6-9-交换两个方法的实现" class="headerlink" title="2.6.9 交换两个方法的实现"></a>2.6.9 交换两个方法的实现</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">method_exchangeImplementations</span><span class="params">(Method _Nonnull m1, Method _Nonnull m2)</span>;</div></pre></td></tr></table></figure>
<h5 id="2-7-使用实例变量的相关方法"><a href="#2-7-使用实例变量的相关方法" class="headerlink" title="2.7 使用实例变量的相关方法"></a>2.7 使用实例变量的相关方法</h5><h6 id="2-7-1-获取实例变量的名称"><a href="#2-7-1-获取实例变量的名称" class="headerlink" title="2.7.1 获取实例变量的名称"></a>2.7.1 获取实例变量的名称</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">ivar_getName</span><span class="params">(Ivar _Nonnull v)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-7-2-获取实例变量的类型编码"><a href="#2-7-2-获取实例变量的类型编码" class="headerlink" title="2.7.2 获取实例变量的类型编码"></a>2.7.2 获取实例变量的类型编码</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">ivar_getTypeEncoding</span><span class="params">(Ivar _Nonnull v)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-7-3-获取实例变量的偏移量"><a href="#2-7-3-获取实例变量的偏移量" class="headerlink" title="2.7.3 获取实例变量的偏移量"></a>2.7.3 获取实例变量的偏移量</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ptrdiff_t</span></div><div class="line">ivar_getOffset(Ivar _Nonnull v);</div></pre></td></tr></table></figure>
<h5 id="2-7-使用属性的相关方法"><a href="#2-7-使用属性的相关方法" class="headerlink" title="2.7 使用属性的相关方法"></a>2.7 使用属性的相关方法</h5><h6 id="2-7-1-获取属性名称"><a href="#2-7-1-获取属性名称" class="headerlink" title="2.7.1 获取属性名称"></a>2.7.1 获取属性名称</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nonnull</span></div><div class="line"><span class="title">property_getName</span><span class="params">(<span class="keyword">objc_property_t</span> _Nonnull property)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-7-2-获取属性特性描述"><a href="#2-7-2-获取属性特性描述" class="headerlink" title="2.7.2 获取属性特性描述"></a>2.7.2 获取属性特性描述</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">property_getAttributes</span><span class="params">(<span class="keyword">objc_property_t</span> _Nonnull property)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-7-3-拷贝并返回属性的特性列表"><a href="#2-7-3-拷贝并返回属性的特性列表" class="headerlink" title="2.7.3 拷贝并返回属性的特性列表"></a>2.7.3 拷贝并返回属性的特性列表</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">objc_property_attribute_t</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">property_copyAttributeList</span><span class="params">(</span></div><div class="line">    <span class="keyword">objc_property_t</span> _Nonnull property, </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount</div><div class="line">);</div></pre></td></tr></table></figure>
<p>返回的属性列表数组需要手动释放。</p>
<h6 id="2-7-4-拷贝并返回属性特性的值"><a href="#2-7-4-拷贝并返回属性特性的值" class="headerlink" title="2.7.4 拷贝并返回属性特性的值"></a>2.7.4 拷贝并返回属性特性的值</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">property_copyAttributeValue</span><span class="params">(</span></div><div class="line">    <span class="keyword">objc_property_t</span> _Nonnull property, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull attributeName</div><div class="line">);</div></pre></td></tr></table></figure>
<p>返回值需要手动释放。</p>
<h5 id="2-8-选择器相关方法"><a href="#2-8-选择器相关方法" class="headerlink" title="2.8 选择器相关方法"></a>2.8 选择器相关方法</h5><h6 id="2-8-1-获取选择器的名称"><a href="#2-8-1-获取选择器的名称" class="headerlink" title="2.8.1 获取选择器的名称"></a>2.8.1 获取选择器的名称</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nonnull</span></div><div class="line"><span class="title">sel_getName</span><span class="params">(SEL _Nonnull sel)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-8-2-向运行时系统注册选择器"><a href="#2-8-2-向运行时系统注册选择器" class="headerlink" title="2.8.2 向运行时系统注册选择器"></a>2.8.2 向运行时系统注册选择器</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SEL _<span class="function">Nonnull</span></div><div class="line"><span class="title">sel_registerName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull str)</span>;</div></pre></td></tr></table></figure>
<ul>
<li>在向类定义中添加方法前，需要保证方法对应的SEL已注册到运行时系统中；</li>
<li>若同名SEL已注册，则直接返回</li>
</ul>
<h6 id="2-8-3-判断两个SEL是否相同"><a href="#2-8-3-判断两个SEL是否相同" class="headerlink" title="2.8.3 判断两个SEL是否相同"></a>2.8.3 判断两个SEL是否相同</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">sel_isEqual</span><span class="params">(SEL _Nonnull lhs, SEL _Nonnull rhs)</span>;</div></pre></td></tr></table></figure>
<p>与“==”等价。</p>
<h5 id="2-9-关联对象相关"><a href="#2-9-关联对象相关" class="headerlink" title="2.9 关联对象相关"></a>2.9 关联对象相关</h5><h6 id="2-9-1-关联规则"><a href="#2-9-1-关联规则" class="headerlink" title="2.9.1 关联规则"></a>2.9.1 关联规则</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">OBJC_ENUM</span><span class="params">(<span class="keyword">uintptr_t</span>, objc_AssociationPolicy)</span> </span>&#123;</div><div class="line">    <span class="comment">/** 关联对象为weak弱引用 */</span></div><div class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,</div><div class="line">    <span class="comment">/** 关联对象为strong强引用，非原子性 */</span></div><div class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>,</div><div class="line">    <span class="comment">/** 关联对象为copy强引用，非原子性 */</span></div><div class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</div><div class="line">    <span class="comment">/** 关联对象为strong强引用，原子性 */</span></div><div class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,</div><div class="line">    <span class="comment">/** 关联对象为copy强引用，原子性 */</span></div><div class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h6 id="2-9-2-设置对象的关联对象"><a href="#2-9-2-设置对象的关联对象" class="headerlink" title="2.9.2 设置对象的关联对象"></a>2.9.2 设置对象的关联对象</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">objc_setAssociatedObject</span><span class="params">(</span></div><div class="line">    id _Nonnull object, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull key, </div><div class="line">    id _Nullable value, objc_AssociationPolicy policy</div><div class="line">);</div></pre></td></tr></table></figure>
<h6 id="2-9-3-获取对象的关联对象值"><a href="#2-9-3-获取对象的关联对象值" class="headerlink" title="2.9.3 获取对象的关联对象值"></a>2.9.3 获取对象的关联对象值</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id _<span class="function">Nullable</span></div><div class="line"><span class="title">objc_getAssociatedObject</span><span class="params">(id _Nonnull object, <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull key)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-9-4-移除对象的所有关联对象"><a href="#2-9-4-移除对象的所有关联对象" class="headerlink" title="2.9.4 移除对象的所有关联对象"></a>2.9.4 移除对象的所有关联对象</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">objc_removeAssociatedObjects</span><span class="params">(id _Nonnull object)</span>;</div></pre></td></tr></table></figure>
<h4 id="3-类型编码的相关定义"><a href="#3-类型编码的相关定义" class="headerlink" title="3.类型编码的相关定义"></a>3.类型编码的相关定义</h4><h5 id="3-1-OC类型编码"><a href="#3-1-OC类型编码" class="headerlink" title="3.1 OC类型编码"></a>3.1 OC类型编码</h5><table>
<thead>
<tr>
<th>编码</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>char</td>
</tr>
<tr>
<td>i</td>
<td>int</td>
</tr>
<tr>
<td>s</td>
<td>short</td>
</tr>
<tr>
<td>l</td>
<td>long</td>
</tr>
<tr>
<td>q</td>
<td>long long</td>
</tr>
<tr>
<td>C</td>
<td>unsigned char</td>
</tr>
<tr>
<td>I</td>
<td>unsigned int</td>
</tr>
<tr>
<td>S</td>
<td>unsigned short</td>
</tr>
<tr>
<td>L</td>
<td>unsigned long</td>
</tr>
<tr>
<td>Q</td>
<td>unsigned long long</td>
</tr>
<tr>
<td>f</td>
<td>float</td>
</tr>
<tr>
<td>d</td>
<td>double</td>
</tr>
<tr>
<td>B</td>
<td>C++ bool 或 C99 _Bool</td>
</tr>
<tr>
<td>v</td>
<td>void</td>
</tr>
<tr>
<td>*</td>
<td>字符指针（C字符串）</td>
</tr>
<tr>
<td>@</td>
<td>id或OC类的对象</td>
</tr>
<tr>
<td>#</td>
<td>类对象（Class）</td>
</tr>
<tr>
<td>:</td>
<td>选择器（SEL）</td>
</tr>
<tr>
<td>[<em>array type</em>]</td>
<td>数组</td>
</tr>
<tr>
<td>{<em>name=type…</em>}</td>
<td>结构体</td>
</tr>
<tr>
<td>(<em>name=type…</em>)</td>
<td>联合体</td>
</tr>
<tr>
<td>^type</td>
<td>c指针</td>
</tr>
<tr>
<td>?</td>
<td>未知（可用于函数指针）</td>
</tr>
</tbody>
</table>
<h5 id="3-2-OC方法编码"><a href="#3-2-OC方法编码" class="headerlink" title="3.2 OC方法编码"></a>3.2 OC方法编码</h5><table>
<thead>
<tr>
<th>编码</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>const</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;runtime-h&quot;&gt;&lt;a href=&quot;#runtime-h&quot; class=&quot;headerlink&quot; title=&quot;runtime.h&quot;&gt;&lt;/a&gt;runtime.h&lt;/h3&gt;&lt;h4 id=&quot;1-数据类型定义&quot;&gt;&lt;a href=&quot;#1-数据类型定义&quot; class=&quot;headerlink&quot; title=&quot;1.数据类型定义&quot;&gt;&lt;/a&gt;1.数据类型定义&lt;/h4&gt;&lt;h5 id=&quot;1-1-方法Method&quot;&gt;&lt;a href=&quot;#1-1-方法Method&quot; class=&quot;headerlink&quot; title=&quot;1.1 方法Method&quot;&gt;&lt;/a&gt;1.1 方法Method&lt;/h5&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;method_t&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;Method&lt;/span&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;method_t&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    SEL name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *types;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    IMP imp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SortBySELAddress&lt;/span&gt; :&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::binary_function&amp;lt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;method_t&lt;/span&gt;&amp;amp;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;method_t&lt;/span&gt;&amp;amp;, &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;method_t&lt;/span&gt;&amp;amp; lhs,&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                         &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;method_t&lt;/span&gt;&amp;amp; rhs)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; lhs.name &amp;lt; rhs.name; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>objc-公共头文件（Public Headers）的基本内容（上）</title>
    <link href="http://yoursite.com/2019/01/21/objc-%E5%85%AC%E5%85%B1%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%88Public%20Headers%EF%BC%89%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2019/01/21/objc-公共头文件（Public Headers）的基本内容（上）/</id>
    <published>2019-01-21T09:19:35.705Z</published>
    <updated>2019-01-21T09:19:35.706Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-NSObject-h"><a href="#1-NSObject-h" class="headerlink" title="1. NSObject.h"></a>1. NSObject.h</h3><p>内部主要包含了<strong>NSObject协议</strong>和<strong>NSObject类</strong>。</p>
<ul>
<li><p>NSObject协议规定了主要几部分：</p>
<ul>
<li>class和self</li>
<li>执行方法api</li>
<li>判断所属类和遵循协议的方法</li>
<li>内存管理方法（ARC下禁止）</li>
<li>响应方法api</li>
</ul>
</li>
<li><p>NSObject类规定了主要几部分：</p>
<ul>
<li>内部结构：isa的Class指针</li>
<li>load和initialize类方法</li>
<li>init和dealloc等实例方法</li>
<li>声明并实现了消息转发的相关方法</li>
<li>声明了类方法版本的NSObject协议方法<a id="more"></a>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-message-h"><a href="#2-message-h" class="headerlink" title="2. message.h"></a>2. message.h</h3><h4 id="2-1-super关键字对应的objc-super结构体："><a href="#2-1-super关键字对应的objc-super结构体：" class="headerlink" title="2.1 super关键字对应的objc_super结构体："></a>2.1 super关键字对应的<strong>objc_super结构体</strong>：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span></div><div class="line">    <span class="comment">/** 接收者，当前类的实例，即使用super的self */</span></div><div class="line">    __unsafe_unretained _Nonnull id receiver;</div><div class="line">    <span class="comment">/** 父类的指针 */</span></div><div class="line">    __unsafe_unretained _Nonnull Class super_class;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-2-基本的消息原型"><a href="#2-2-基本的消息原型" class="headerlink" title="2.2 基本的消息原型"></a>2.2 基本的消息原型</h4><p>对象调用方法，即<strong>给对象发消息，调用objc_msgSend方法</strong>，而根据参数类型的不同，系统会自动调用对应的子版本；而<strong>通过对象，调用父类的方法，调用objc_msgSendSuper方法</strong>。</p>
<ul>
<li>objc_msgSend函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id _<span class="function">Nullable <span class="title">objc_msgSend</span><span class="params">(id _Nullable self, SEL _Nullable op, ...)</span></span></div></pre></td></tr></table></figure>
<p>说明：</p>
<blockquote>
<ul>
<li>self，对象，即为id（指向objc_object实例的指针）</li>
<li>op即为SEL，objc_selector的实例指针，运行时系统可以通过SEL找到方法实现IMP</li>
<li>后面为方法调用的参数</li>
</ul>
</blockquote>
<ul>
<li>objc_msgSendSuper函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">id _<span class="function">Nullable <span class="title">objc_msgSendSuper</span><span class="params">(</span></span></div><div class="line">    struct objc_super * _Nullable super, </div><div class="line">    SEL _Nullable op,</div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure>
<p>说明：</p>
<blockquote>
<ul>
<li>super，即为上述objc_super结构体实例的指针</li>
<li>op为SEL</li>
<li>后面传入调用参数</li>
</ul>
</blockquote>
<hr>
<h3 id="3-objc-h"><a href="#3-objc-h" class="headerlink" title="3. objc.h"></a>3. objc.h</h3><h4 id="3-1-Class"><a href="#3-1-Class" class="headerlink" title="3.1 Class"></a>3.1 Class</h4><p>Class，类对象，即objc_class的结构体实例指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></div></pre></td></tr></table></figure>
<h4 id="3-2-对象"><a href="#3-2-对象" class="headerlink" title="3.2 对象"></a>3.2 对象</h4><p>对象，指的是Class的实例，默认即为id类型的变量：</p>
<ul>
<li>id即objc_object结构体实例的指针：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></div></pre></td></tr></table></figure>
<ul>
<li>objc_object结构体，即<strong>对象真正的本质：包含类指针的结构体实例</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></div><div class="line">    Class _Nonnull isa;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-3-选择器及实现"><a href="#3-3-选择器及实现" class="headerlink" title="3.3 选择器及实现"></a>3.3 选择器及实现</h4><ul>
<li>选择器SEL：objc_selector结构体实例的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></div></pre></td></tr></table></figure>
<ul>
<li>方法实现IMP：c函数指针，参数为调用对象id、选择器SEL和参数列表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...)</div></pre></td></tr></table></figure>
<h4 id="3-4-主要方法API"><a href="#3-4-主要方法API" class="headerlink" title="3.4 主要方法API"></a>3.4 主要方法API</h4><ul>
<li>获取选择器对应的方法名：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nonnull <span class="title">sel_getName</span><span class="params">(SEL _Nonnull sel)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>根据指定的名称向运行时系统注册选择器：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SEL _<span class="function">Nonnull <span class="title">sel_registerName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull str)</span></span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>在将方法添加到类定义中之前，必须先注册SEL</p>
</blockquote>
<ul>
<li>返回对象所属类的名字：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nonnull <span class="title">object_getClassName</span><span class="params">(id _Nullable obj)</span></span>;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-NSObject-h&quot;&gt;&lt;a href=&quot;#1-NSObject-h&quot; class=&quot;headerlink&quot; title=&quot;1. NSObject.h&quot;&gt;&lt;/a&gt;1. NSObject.h&lt;/h3&gt;&lt;p&gt;内部主要包含了&lt;strong&gt;NSObject协议&lt;/strong&gt;和&lt;strong&gt;NSObject类&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NSObject协议规定了主要几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;class和self&lt;/li&gt;
&lt;li&gt;执行方法api&lt;/li&gt;
&lt;li&gt;判断所属类和遵循协议的方法&lt;/li&gt;
&lt;li&gt;内存管理方法（ARC下禁止）&lt;/li&gt;
&lt;li&gt;响应方法api&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSObject类规定了主要几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部结构：isa的Class指针&lt;/li&gt;
&lt;li&gt;load和initialize类方法&lt;/li&gt;
&lt;li&gt;init和dealloc等实例方法&lt;/li&gt;
&lt;li&gt;声明并实现了消息转发的相关方法&lt;/li&gt;
&lt;li&gt;声明了类方法版本的NSObject协议方法
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》17</title>
    <link href="http://yoursite.com/2019/01/18/GCD%E7%AF%87%EF%BC%9A1.GCD%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A6%81%E7%82%B9/"/>
    <id>http://yoursite.com/2019/01/18/GCD篇：1.GCD的使用要点/</id>
    <published>2019-01-18T05:43:36.161Z</published>
    <updated>2019-01-18T05:46:22.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCD篇：1-GCD的使用要点"><a href="#GCD篇：1-GCD的使用要点" class="headerlink" title="GCD篇：1.GCD的使用要点"></a>GCD篇：1.GCD的使用要点</h2><h4 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h4><p>一个CPU执行的CPU命令列为<strong>一条无分叉路径</strong>，即为<em>线程</em>。而这种无分叉路径存在多条，即为<em>多线程</em>。</p>
<ul>
<li>在多线程中，一个CPU核执行多条不同路径上的不同命令。</li>
<li>在CPU中，使用寄存器将执行“路径”的状态保存到各自的专用的内存块中。在切换不同目标路径时，从对应的内存块中读取并在CPU中将执行信息复原，继续执行目标路径的命令列。这个过程称为“上下文切换”。</li>
<li>多线程中需要注意的主要问题：<ul>
<li>数据竞争：多个线程同时更新相同资源；</li>
<li>死锁：执行等待事件的多个线程互相持续等待；</li>
<li>线程过多导致内存占用过大</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h4 id="2-GCD的API要点"><a href="#2-GCD的API要点" class="headerlink" title="2.GCD的API要点"></a>2.GCD的API要点</h4><h5 id="2-1-串行和并发队列的使用建议"><a href="#2-1-串行和并发队列的使用建议" class="headerlink" title="2.1 串行和并发队列的使用建议"></a>2.1 串行和并发队列的使用建议</h5><ul>
<li>多个线程同时更新相同资源时，避免产生数据竞争，可以使用Serial Dispatch Queue；</li>
<li>并行处理无数据竞争的问题时，使用Concurrent Dispatch Queue</li>
</ul>
<h5 id="2-2-GCD的内存管理"><a href="#2-2-GCD的内存管理" class="headerlink" title="2.2 GCD的内存管理"></a>2.2 GCD的内存管理</h5><ul>
<li>GCD使用引用计数的内存管理方式；</li>
<li>dispatch_queue_t对象可以保证在内部派发的block执行期间不被释放的原因：block对象通过dispatch_retain的方式保留队列，block对象执行完成后再释放引用；</li>
<li>iOS6之后，ARC可以完全胜任GCD的内存管理，不可再调用dispatch_release等相关API；</li>
</ul>
<h5 id="2-3-队列的优先级"><a href="#2-3-队列的优先级" class="headerlink" title="2.3 队列的优先级"></a>2.3 队列的优先级</h5><ul>
<li>对Global Dispatch Queue设置优先级，CGD会将各自使用该队列的线程设置为对应的优先级</li>
<li>手动创建的队列，其优先级均为DISPATCH_QUEUE_PRIORITY_DEFAULT</li>
<li>通过<em>dispatch_set_target_queue(targetQueue, originQueue)</em>修改队列的优先级：<ul>
<li><em>targetQueue</em>为待修改优先级的队列，<em>originQueue</em>为参照优先级的队列</li>
<li>此API可以设置队列的执行阶层：如多个串行队列同时修改相同资源时，将所有队列的优先级设置为同一个串行队列，可以防止并发处理，避免数据竞争的情况发生。</li>
</ul>
</li>
<li>通过XNU管理，在GCD中使用的线程并不能保证实时性。</li>
</ul>
<h5 id="2-4-dispatch-after"><a href="#2-4-dispatch-after" class="headerlink" title="2.4 dispatch_after"></a>2.4 dispatch_after</h5><p>任务的延迟执行，是指<strong>在指定时间后或到达指定时间，将block对象派发到任务队列中</strong>。注意是“派发”而不是“执行”，故可能存在一定时间延迟，且根据执行线程的任务拥挤程度，执行时间也不确定（派发的任务是由NSRunLoop对象在一次运行循环中取出并执行）。</p>
<h5 id="2-5-提高数据库或文件的读写效率"><a href="#2-5-提高数据库或文件的读写效率" class="headerlink" title="2.5 提高数据库或文件的读写效率"></a>2.5 提高数据库或文件的读写效率</h5><p>通过<em>COncurrent Dispatch Queue</em>和<em>dispatch_barrier_async函数</em>组合使用，异步读取，栅栏操作写入，既可以保证读取的高效，还能保证写入的有效性和安全性。</p>
<h5 id="2-6-确保安全地使用dispatch-sync"><a href="#2-6-确保安全地使用dispatch-sync" class="headerlink" title="2.6 确保安全地使用dispatch_sync"></a>2.6 确保安全地使用dispatch_sync</h5><p>对于个人目前的认知来说，只有在保证真正实现“原子性”的property时，才有可能会使用这个东西。</p>
<h5 id="2-7-Dispatch-Semaphore可以保证更细颗粒度的排他操作"><a href="#2-7-Dispatch-Semaphore可以保证更细颗粒度的排他操作" class="headerlink" title="2.7 Dispatch Semaphore可以保证更细颗粒度的排他操作"></a>2.7 Dispatch Semaphore可以保证更细颗粒度的排他操作</h5><ul>
<li>Dispatch Semaphore根据初始化传入的计数值来保证同时执行任务的最大数量</li>
<li>每次dispatch_semaphore_wait时，会从可用任务数中试图减1：<ul>
<li>本身是0，则没有可用执行空间，等待</li>
<li>可用执行空间大于0，则减去1，并执行下面的任务</li>
</ul>
</li>
<li>dispatch_semaphore_signal会对任务计数加1，释放占用的任务空间。</li>
</ul>
<h5 id="2-8-dispatch-once"><a href="#2-8-dispatch-once" class="headerlink" title="2.8 dispatch_once"></a>2.8 dispatch_once</h5><ul>
<li>dispatch_once可以保证真正的多线程访问安全</li>
<li>一般用于单例对象的创建</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GCD篇：1-GCD的使用要点&quot;&gt;&lt;a href=&quot;#GCD篇：1-GCD的使用要点&quot; class=&quot;headerlink&quot; title=&quot;GCD篇：1.GCD的使用要点&quot;&gt;&lt;/a&gt;GCD篇：1.GCD的使用要点&lt;/h2&gt;&lt;h4 id=&quot;1-多线程&quot;&gt;&lt;a href=&quot;#1-多线程&quot; class=&quot;headerlink&quot; title=&quot;1.多线程&quot;&gt;&lt;/a&gt;1.多线程&lt;/h4&gt;&lt;p&gt;一个CPU执行的CPU命令列为&lt;strong&gt;一条无分叉路径&lt;/strong&gt;，即为&lt;em&gt;线程&lt;/em&gt;。而这种无分叉路径存在多条，即为&lt;em&gt;多线程&lt;/em&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在多线程中，一个CPU核执行多条不同路径上的不同命令。&lt;/li&gt;
&lt;li&gt;在CPU中，使用寄存器将执行“路径”的状态保存到各自的专用的内存块中。在切换不同目标路径时，从对应的内存块中读取并在CPU中将执行信息复原，继续执行目标路径的命令列。这个过程称为“上下文切换”。&lt;/li&gt;
&lt;li&gt;多线程中需要注意的主要问题：&lt;ul&gt;
&lt;li&gt;数据竞争：多个线程同时更新相同资源；&lt;/li&gt;
&lt;li&gt;死锁：执行等待事件的多个线程互相持续等待；&lt;/li&gt;
&lt;li&gt;线程过多导致内存占用过大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》16</title>
    <link href="http://yoursite.com/2019/01/15/Blocks%E7%AF%87%EF%BC%9A7.%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/15/Blocks篇：7.循环引用问题/</id>
    <published>2019-01-15T04:12:59.642Z</published>
    <updated>2019-01-15T04:12:59.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Blocks篇：7-循环引用问题"><a href="#Blocks篇：7-循环引用问题" class="headerlink" title="Blocks篇：7.循环引用问题"></a>Blocks篇：7.循环引用问题</h2><h4 id="1-ARC下的Block循环引用"><a href="#1-ARC下的Block循环引用" class="headerlink" title="1.ARC下的Block循环引用"></a>1.ARC下的Block循环引用</h4><h5 id="1-1-使用weak或unsafe-unretained避免循环引用"><a href="#1-1-使用weak或unsafe-unretained避免循环引用" class="headerlink" title="1.1 使用weak或unsafe_unretained避免循环引用"></a>1.1 使用<strong>weak或</strong>unsafe_unretained避免循环引用</h5><p>一般来说，最简单的这种情况即：<em>block对象作为OC对象的成员，而在block函数体内部直接或间接捕获了该OC对象，造成互相强引用</em>。举例来说：<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(^MyBlock)</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">@interface TestObject : NSObject &#123;</div><div class="line">    <span class="comment">// block成员</span></div><div class="line">    MyBlock myBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TestObject</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        <span class="comment">// 初始化block成员</span></div><div class="line">        myBlock = ^&#123;</div><div class="line">            NSLog(@<span class="string">"%@"</span>, self);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>产生循环引用的过程：</p>
<blockquote>
<ul>
<li>由于myBlock对象捕获了OC对象（self），myBlock被自动拷贝到堆上，并自动对self产生强引用；</li>
<li>myBlock是self的成员，当myBlock分配到堆内存后，self负责对其进行内存管理，自动对myBlock对象产生强引用；</li>
<li>互相保留，引用循环产生</li>
</ul>
</blockquote>
<p>不过这种情况，编译器可以直接识别并给出引用循环警告。我们可以通过所有权修饰符<strong>weak或</strong>unsafe_unretained，使myBlock对象通过保留弱引用或不安全的对象指针，来避免对self产生强引用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        <span class="comment">// 初始化block成员</span></div><div class="line">        </div><div class="line">        __weak TestObject *weakSelf = self;</div><div class="line"><span class="comment">//        __unsafe_unretained TestObject *unsafeSelf = self;</span></div><div class="line">        myBlock = ^&#123;</div><div class="line">            NSLog(@<span class="string">"%@"</span>, weakSelf);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于在init方法中不比担心self对象释放的问题，可以安心使用__unsafe_unretained修饰符。</p>
<h5 id="1-2-通过-block变量，并适时将其释放来解除循环引用"><a href="#1-2-通过-block变量，并适时将其释放来解除循环引用" class="headerlink" title="1.2 通过__block变量，并适时将其释放来解除循环引用"></a>1.2 通过__block变量，并适时将其释放来解除循环引用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@implementation TestObject</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        <span class="comment">// 初始化block成员</span></div><div class="line">        </div><div class="line">        __block TestObject *blockSelf = self;</div><div class="line">        myBlock = ^&#123;</div><div class="line">            NSLog(@<span class="string">"blockSelf - %@"</span>, blockSelf);</div><div class="line">            </div><div class="line">            <span class="comment">// 释放__block变量，其释放对self的强引用</span></div><div class="line">            blockSelf = nil;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">// 通过执行block对象，在内部解除循环引用</span></div><div class="line">        myBlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    NSLog(@<span class="string">"%@"</span>, NSStringFromSelector(_cmd));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>由于在ARC下，复制到堆内存中的<strong>block对象会对内部的OC对象进行强引用，故可以让block对象捕获</strong>block对象，并在需要时释放__block对象（一般都是执行block时），以间接解除对self的强引用。</strong></p>
<p>补充：</p>
<blockquote>
<p>调用block后，直接将block对象释放也可以解除循环引用。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>一般来说，<strong>必须执行block后，引用循环才可以被解除</strong>，容易出现遗漏的情况。</p>
</blockquote>
<h4 id="2-非ARC下的Block内存控制"><a href="#2-非ARC下的Block内存控制" class="headerlink" title="2.非ARC下的Block内存控制"></a>2.非ARC下的Block内存控制</h4><h5 id="2-1-非ARC下的Block引用循环"><a href="#2-1-非ARC下的Block引用循环" class="headerlink" title="2.1 非ARC下的Block引用循环"></a>2.1 非ARC下的Block引用循环</h5><p>由于<strong>非ARC环境下</strong>，无法使用所有权修饰符，故<strong>只能通过__block变量的方式来解决引用循环问题</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        <span class="comment">// 初始化block成员</span></div><div class="line">        </div><div class="line">        __block TestObject *blockSelf = self;</div><div class="line">        myBlock = ^&#123;</div><div class="line">            NSLog(@<span class="string">"blockSelf - %@"</span>, blockSelf);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上述代码中，直接使用__block对象即可，无需释放，即可避免生成引用循环。</p>
<p>原因：</p>
<blockquote>
<p><strong>非ARC环境下，__block变量被分配到堆内存时，不会对内部的OC对象进行强引用</strong>；<br>因此，在block对象函数内部，不会对OC对象发生强引用，相当于ARC下的<strong>weak和</strong>unsafe_unretained的情况。</p>
</blockquote>
<h5 id="2-2-非ARC环境下的Block内存使用规则补充"><a href="#2-2-非ARC环境下的Block内存使用规则补充" class="headerlink" title="2.2 非ARC环境下的Block内存使用规则补充"></a>2.2 非ARC环境下的Block内存使用规则补充</h5><ul>
<li>对不同内存区域的block执行retain和copy操作的结果：</li>
</ul>
<table>
<thead>
<tr>
<th>block对象所在的内存区域</th>
<th>执行操作</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>栈</td>
<td>retain</td>
<td>无效</td>
</tr>
<tr>
<td>栈</td>
<td>copy</td>
<td>复制到堆内存</td>
</tr>
<tr>
<td>堆</td>
<td>retain</td>
<td>产生强引用</td>
</tr>
<tr>
<td>堆</td>
<td>copy</td>
<td>产生强引用</td>
</tr>
</tbody>
</table>
<ul>
<li>在C语言环境下，可以使用Block_copy()和Block_release()对堆内存的block对象进行内存管理。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Blocks篇：7-循环引用问题&quot;&gt;&lt;a href=&quot;#Blocks篇：7-循环引用问题&quot; class=&quot;headerlink&quot; title=&quot;Blocks篇：7.循环引用问题&quot;&gt;&lt;/a&gt;Blocks篇：7.循环引用问题&lt;/h2&gt;&lt;h4 id=&quot;1-ARC下的Block循环引用&quot;&gt;&lt;a href=&quot;#1-ARC下的Block循环引用&quot; class=&quot;headerlink&quot; title=&quot;1.ARC下的Block循环引用&quot;&gt;&lt;/a&gt;1.ARC下的Block循环引用&lt;/h4&gt;&lt;h5 id=&quot;1-1-使用weak或unsafe-unretained避免循环引用&quot;&gt;&lt;a href=&quot;#1-1-使用weak或unsafe-unretained避免循环引用&quot; class=&quot;headerlink&quot; title=&quot;1.1 使用weak或unsafe_unretained避免循环引用&quot;&gt;&lt;/a&gt;1.1 使用&lt;strong&gt;weak或&lt;/strong&gt;unsafe_unretained避免循环引用&lt;/h5&gt;&lt;p&gt;一般来说，最简单的这种情况即：&lt;em&gt;block对象作为OC对象的成员，而在block函数体内部直接或间接捕获了该OC对象，造成互相强引用&lt;/em&gt;。举例来说：&lt;br&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》15</title>
    <link href="http://yoursite.com/2019/01/15/Blocks%E7%AF%87%EF%BC%9A6.Blocks%E6%8D%95%E8%8E%B7%E7%9A%84OC%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/01/15/Blocks篇：6.Blocks捕获的OC对象及其内存管理/</id>
    <published>2019-01-15T04:12:24.974Z</published>
    <updated>2019-01-15T04:12:24.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Blocks篇：6-Blocks捕获的OC对象及其内存管理"><a href="#Blocks篇：6-Blocks捕获的OC对象及其内存管理" class="headerlink" title="Blocks篇：6.Blocks捕获的OC对象及其内存管理"></a>Blocks篇：6.Blocks捕获的OC对象及其内存管理</h2><blockquote>
<p>之前所说的，都是Block对象捕获基本数据类型变量时的处理方式。现在我们看一下对于OC对象被Block捕获时的情况。<br><a id="more"></a></p>
<h4 id="1-Block对象捕获OC对象"><a href="#1-Block对象捕获OC对象" class="headerlink" title="1.Block对象捕获OC对象"></a>1.Block对象捕获OC对象</h4></blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(^MyBlock)</span><span class="params">(id obj)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        MyBlock myBlock;</div><div class="line">        </div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 声明数组作为被捕获变量</span></div><div class="line">            NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</div><div class="line">        </div><div class="line">            <span class="comment">// 声明block</span></div><div class="line">            myBlock = ^(id obj)&#123;</div><div class="line">                <span class="comment">// 向捕获的数组中添加对象</span></div><div class="line">                [<span class="built_in">array</span> addObject:obj];</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"个数：%ld\n"</span>, <span class="built_in">array</span>.count);</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 执行block</span></div><div class="line">        myBlock([NSObject <span class="keyword">new</span>]);</div><div class="line">        myBlock([NSObject <span class="keyword">new</span>]);</div><div class="line">        myBlock([NSObject <span class="keyword">new</span>]);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此代码运行正常无误。这也直接证明了<strong>Block对象对该数组对象进行了强引用，使被捕获对象的生存周期超过了原始作用域</strong>。究其原因，查看部分转换后的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"></div><div class="line"><span class="comment">/** Block的完整结构体 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    <span class="comment">// 声明捕获的OC对象（ARC下为__strong修饰，强引用）</span></div><div class="line">    NSMutableArray *<span class="built_in">array</span>;</div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, NSMutableArray *_array, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="built_in">array</span>(_array) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp;</div><div class="line">        Desc = desc;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/** Block的执行函数 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself, id obj) &#123;</div><div class="line">    NSMutableArray *<span class="built_in">array</span> = __cself-&gt;<span class="built_in">array</span>; <span class="comment">// bound by copy</span></div><div class="line">    </div><div class="line">    ((<span class="keyword">void</span> (*)(id, SEL, ObjectType _Nonnull))(<span class="keyword">void</span> *)objc_msgSend)((id)<span class="built_in">array</span>, sel_registerName(<span class="string">"addObject:"</span>), (id)obj);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"个数：%ld\n"</span>, ((NSUInteger (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)<span class="built_in">array</span>, sel_registerName(<span class="string">"count"</span>)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Block复制到堆时附带执行的函数 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</div><div class="line">    <span class="comment">// _Block_object_assign相当于retain；BLOCK_FIELD_IS_OBJECT标明捕获对象为OC对象</span></div><div class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="built_in">array</span>, (<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Block复制从堆中释放时附带执行的函数 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</div><div class="line">    <span class="comment">// _Block_object_dispose相当于release；BLOCK_FIELD_IS_OBJECT标明捕获对象为OC对象</span></div><div class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Block描述信息结构体 */</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></div><div class="line">  <span class="keyword">size_t</span> reserved;</div><div class="line">  <span class="keyword">size_t</span> Block_size;</div><div class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div></pre></td></tr></table></figure>
<p>在转换代码中显而易见，Block将捕获的OC对象以强引用的方式（ARC下隐含为__strong），作为结构体的成员变量。并在Block的描述信息对象中提供了copy和dispose方法，在适当时机调用以配合内存管理。</p>
<p>注意：</p>
<blockquote>
<ul>
<li><strong>由于编译器支持Block结构的类引用计数的内存管理方式，即ARC下，系统可以在适当时机分配和释放Block对象的内存。故在Block的相关结构体中可以直接存入带有所有权修饰符的OC对象。</strong></li>
<li><strong>由于OC对象本身分配在堆内存中，Block对象只需通过指针传递即可完成捕获</strong>。</li>
<li>由于捕获后，<strong>Block对象也参与了OC对象的内存管理，故需要提供保留和释放相关函数</strong>，以备系统在堆内存中创建（copy操作）和释放Block对象（dispose操作）时进行调用。这里则与__block变量时一样，使用了<em>_Block_object_assign</em>和<em>_Block_object_dispose</em>函数对OC对象进行保留和释放操作。</li>
</ul>
</blockquote>
<p>补充：</p>
<p>在<em>_Block_object_assign</em>以及<em>_Block_object_dispose</em>中，用于区分捕获变量类型的标识：</p>
<table>
<thead>
<tr>
<th>捕获的对象</th>
<th>标识值</th>
</tr>
</thead>
<tbody>
<tr>
<td>OC对象</td>
<td>BLOCK_FIELD_IS_OBJECT</td>
</tr>
<tr>
<td>__block修饰的变量或对象</td>
<td>BLOCK_FIELD_IS_BYREF</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="2-block修饰的OC对象"><a href="#2-block修饰的OC对象" class="headerlink" title="2.__block修饰的OC对象"></a>2.__block修饰的OC对象</h4><h5 id="2-1-block修饰的强引用对象（strong所有权）"><a href="#2-1-block修饰的强引用对象（strong所有权）" class="headerlink" title="2.1 block修饰的强引用对象（strong所有权）"></a>2.1 <strong>block修饰的强引用对象（</strong>strong所有权）</h5><p>还是先看实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        <span class="comment">// 声明__block修饰的OC对象</span></div><div class="line">        __block NSObject *myObj = [[NSObject alloc] init];</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">            <span class="comment">// 修改捕获对象</span></div><div class="line">            myObj = [[NSArray alloc] init];</div><div class="line">        &#125;;</div><div class="line">        </div><div class="line">        <span class="comment">// 执行Block</span></div><div class="line">        myBlock();</div><div class="line">        </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (__bridge <span class="keyword">void</span> *)myObj);</div><div class="line">        </div><div class="line">        <span class="comment">// 修改__block对象</span></div><div class="line">        myObj = [[NSObject alloc] init];</div><div class="line">        </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (__bridge <span class="keyword">void</span> *)myObj);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，当Block执行后，在外部读取捕获的OC对象，可以发现仍然指向同一地址。这与__block修饰基本变量的情况一致，也是需要通过生成特定捕获变量的结构体实例，在拷贝到堆内存后，最终访问均指向相同的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"></div><div class="line"><span class="comment">/** 捕获对象的结构体 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_myObj_0</span> &#123;</span></div><div class="line">    <span class="keyword">void</span> *__isa;</div><div class="line">    <span class="comment">/** 指向自身结构体实例的指针 */</span></div><div class="line">    __Block_byref_myObj_0 *__forwarding;</div><div class="line">    <span class="keyword">int</span> __flags;</div><div class="line">    <span class="keyword">int</span> __size;</div><div class="line">    <span class="comment">/** 分配到堆内存时的执行函数 */</span></div><div class="line">    <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</div><div class="line">    <span class="comment">/** 在堆内存中释放时的执行函数 */</span></div><div class="line">    <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</div><div class="line">    <span class="comment">/** 真正的值（OC对象），在ARC下默认为__strong修饰 */</span></div><div class="line">    NSObject *myObj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_copy_131(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src) &#123;</div><div class="line">    <span class="comment">// 赋值并保留对象</span></div><div class="line">    _Block_object_assign((<span class="keyword">char</span>*)dst + <span class="number">40</span>, *(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_dispose_131(<span class="keyword">void</span> *src) &#123;</div><div class="line">    <span class="comment">// 释放对象</span></div><div class="line">    _Block_object_dispose(*(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    <span class="comment">/** 捕获对象的结构体实例 */</span></div><div class="line">    __Block_byref_myObj_0 *myObj; <span class="comment">// by ref</span></div><div class="line">    <span class="comment">/** 构造函数，其中捕获变量传递的是__forwarding指向的对象 */</span></div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_myObj_0 *_myObj, <span class="keyword">int</span> flags=<span class="number">0</span>) : myObj(_myObj-&gt;__forwarding) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp;</div><div class="line">        Desc = desc;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    </div><div class="line">    __Block_byref_myObj_0 *myObj = __cself-&gt;myObj; <span class="comment">// bound by ref</span></div><div class="line">    </div><div class="line">    <span class="comment">// 对堆中的__block对象（__forwarding实例中的OC对象）进行修改</span></div><div class="line">    (myObj-&gt;__forwarding-&gt;myObj) = ((NSArray *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((NSArray *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSArray"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** 在堆内存上生成时的回调函数 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</div><div class="line">    <span class="comment">// 对捕获生成的__block对象进行赋值并保留</span></div><div class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;myObj, (<span class="keyword">void</span>*)src-&gt;myObj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</div><div class="line">    <span class="comment">// 对捕获生成的__block对象进行释放</span></div><div class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;myObj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> reserved;</div><div class="line">    <span class="keyword">size_t</span> Block_size;</div><div class="line">    <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">    <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; </div><div class="line">    <span class="number">0</span>, </div><div class="line">    <span class="keyword">sizeof</span>(struct __main_block_impl_0), </div><div class="line">    __main_block_copy_0, </div><div class="line">    __main_block_dispose_0</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="comment">/* @autoreleasepool */</span> </div><div class="line">    &#123; </div><div class="line">        __AtAutoreleasePool __autoreleasepool; </div><div class="line">        </div><div class="line">        <span class="comment">// 生成__block修饰的对象</span></div><div class="line">        __attribute__((__blocks__(byref))) __Block_byref_myObj_0 myObj = &#123;</div><div class="line">            (<span class="keyword">void</span>*)<span class="number">0</span>,</div><div class="line">            (__Block_byref_myObj_0 *)&amp;myObj, </div><div class="line">            <span class="number">33554432</span>, </div><div class="line">            <span class="keyword">sizeof</span>(__Block_byref_myObj_0),</div><div class="line">            <span class="comment">// 赋值OC对象的内存保留函数</span></div><div class="line">            __Block_byref_id_object_copy_131, </div><div class="line">            <span class="comment">// 赋值OC对象的内存释放函数</span></div><div class="line">            __Block_byref_id_object_dispose_131, </div><div class="line">            <span class="comment">// 创建真正的OC对象</span></div><div class="line">            ((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>))</div><div class="line">        &#125;;</div><div class="line">        </div><div class="line">        <span class="comment">// 声明并创建Block对象</span></div><div class="line">        <span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_myObj_0 *)&amp;myObj, <span class="number">570425344</span>));</div><div class="line">        </div><div class="line">        <span class="comment">// 调用Block并传入本身指针</span></div><div class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">        </div><div class="line">        <span class="comment">// 访问栈上的__block对象</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (__bridge <span class="keyword">void</span> *)(myObj.__forwarding-&gt;myObj));</div><div class="line">        </div><div class="line">        <span class="comment">// 修改栈上的__block对象</span></div><div class="line">        (myObj.__forwarding-&gt;myObj) = ((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</div><div class="line">        </div><div class="line">        <span class="comment">// 访问栈上的__block对象</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (__bridge <span class="keyword">void</span> *)(myObj.__forwarding-&gt;myObj));</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>注意，这里相比较普通的<strong>block变量时，**在</strong>block变量结构体中，新增了对于__block变量在堆内存中进行分配和释放时的函数指针成员**：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 分配到堆内存时的执行函数 */</span></div><div class="line"><span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</div><div class="line"><span class="comment">/** 在堆内存中释放时的执行函数 */</span></div><div class="line"><span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</div></pre></td></tr></table></figure>
<p>这是<strong>由于__block修饰的是OC对象，其结构体实例赋值此OC对象的内存管理，故需要提供保留和释放操作。</strong></p>
<ul>
<li>同样的，<strong>在栈中（声明<strong>block对象所在的地方）或是堆中（Block对象执行的函数体中），都可以通过</strong>forwarding指针访问到相同的OC对象</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取堆内存中的__block对象【栈__block对象的__forwarding依然指向的是堆中的__block对象】</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_myObj_0</span> __<span class="title">blockVar_onHeap</span> = <span class="title">myObj</span>.__<span class="title">forwarding</span>;</span></div><div class="line"><span class="comment">// 得到真正的OC对象</span></div><div class="line">NSObject realObj = __blockVar_onStack-&gt;myObj;</div></pre></td></tr></table></figure>
<h4 id="2-2-block修饰的其他OC对象"><a href="#2-2-block修饰的其他OC对象" class="headerlink" title="2.2 __block修饰的其他OC对象"></a>2.2 __block修饰的其他OC对象</h4><ul>
<li>当__block修饰的OC对象为弱对象时，我们以最开始的例子进行修改验证：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(^MyBlock)</span><span class="params">(id obj)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        MyBlock myBlock;</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 声明数组</span></div><div class="line">            NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</div><div class="line">            </div><div class="line">            <span class="comment">// 将待捕获对象声明为弱对象</span></div><div class="line">            __block __weak NSMutableArray *weakArray = <span class="built_in">array</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 声明block</span></div><div class="line">            myBlock = ^(id obj)&#123;</div><div class="line">                [weakArray addObject:obj];</div><div class="line"></div><div class="line">                <span class="built_in">printf</span>(<span class="string">"个数：%ld\n"</span>, weakArray.count);</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 执行block（向数组中添加对象）</span></div><div class="line">        myBlock([NSObject <span class="keyword">new</span>]);</div><div class="line">        myBlock([NSObject <span class="keyword">new</span>]);</div><div class="line">        myBlock([NSObject <span class="keyword">new</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行情况为：</p>
<blockquote>
<p>个数：0<br>个数：0<br>个数：0<br>Program ended with exit code: 0</p>
</blockquote>
<p><strong>在<strong>block对象中保留的是数组的弱引用，当原数组对象释放后，</strong>block对象中的OC对象自动置为nil，故结果为0。</strong></p>
<ul>
<li>当<strong>block修饰的OC对象为</strong>unsafe_unretained修饰的对象时，与弱引用情况相同，只是需要保证不要访问野指针。</li>
<li><strong>block修饰的OC对象不允许标记为</strong>autoreleasing。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Blocks篇：6-Blocks捕获的OC对象及其内存管理&quot;&gt;&lt;a href=&quot;#Blocks篇：6-Blocks捕获的OC对象及其内存管理&quot; class=&quot;headerlink&quot; title=&quot;Blocks篇：6.Blocks捕获的OC对象及其内存管理&quot;&gt;&lt;/a&gt;Blocks篇：6.Blocks捕获的OC对象及其内存管理&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;之前所说的，都是Block对象捕获基本数据类型变量时的处理方式。现在我们看一下对于OC对象被Block捕获时的情况。&lt;br&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》14</title>
    <link href="http://yoursite.com/2019/01/15/Blocks%E7%AF%87%EF%BC%9A5.Blocks%E4%BF%AE%E6%94%B9%E6%8D%95%E8%8E%B7%E5%88%B0%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%88__block%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%89/"/>
    <id>http://yoursite.com/2019/01/15/Blocks篇：5.Blocks修改捕获到的变量（__block修饰符）/</id>
    <published>2019-01-15T04:11:24.722Z</published>
    <updated>2019-01-15T04:11:24.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Blocks篇：5-Blocks修改捕获到的变量（-block修饰符）"><a href="#Blocks篇：5-Blocks修改捕获到的变量（-block修饰符）" class="headerlink" title="Blocks篇：5.Blocks修改捕获到的变量（__block修饰符）"></a>Blocks篇：5.Blocks修改捕获到的变量（__block修饰符）</h2><blockquote>
<p>我们知道，在Block中，修改捕获变量的方式：</p>
<ul>
<li>对于全局变量，由于实质上Block并未对其进行捕获，故可以直接在Block函数体内部进行变量修改；</li>
<li>对于局部的静态变量，由于Block捕获的是其指针，故可以通过指针对原变量进行修改；</li>
<li>对于普通的局部变量，由于在Block函数体内使用的版本已经不是之前的变量了（是Block结构体中保存的成员），故编译器不支持直接修改。这种情况下，只能通过“__block”修饰变量进行处理。<a id="more"></a>
<h4 id="1-block修饰符带来的变化"><a href="#1-block修饰符带来的变化" class="headerlink" title="1.__block修饰符带来的变化"></a>1.__block修饰符带来的变化</h4></li>
</ul>
</blockquote>
<p>由于需修改局部变量，我们将栗子变成这个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        <span class="comment">// 声明__block修饰的局部变量</span></div><div class="line">        __block <span class="keyword">int</span> val = <span class="number">2</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">            <span class="comment">// 捕获后修改变量的值</span></div><div class="line">            val = <span class="number">3</span>;</div><div class="line">        &#125;;</div><div class="line">        myBlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用clang转换后，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"></div><div class="line"><span class="comment">/** Block数据结构体（没变） */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></div><div class="line">    <span class="keyword">void</span> *isa;</div><div class="line">    <span class="keyword">int</span> Flags;</div><div class="line">    <span class="keyword">int</span> Reserved;</div><div class="line">    <span class="keyword">void</span> *FuncPtr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** __block修饰的变量对应的结构体 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_val_0</span> &#123;</span></div><div class="line">    <span class="comment">/** 类型 */</span></div><div class="line">    <span class="keyword">void</span> *__isa;</div><div class="line">    <span class="comment">/** 指向自身结构体实例的指针 */</span></div><div class="line">    __Block_byref_val_0 *__forwarding;</div><div class="line">    <span class="keyword">int</span> __flags;</div><div class="line">    <span class="keyword">int</span> __size;</div><div class="line">    <span class="comment">/** 变量真正的值 */</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** Block完整结构体 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="comment">/** Block数据实例 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="comment">/** Block描述信息实例的指针 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    <span class="comment">/** __Block_byref_val_0实例的指针 */</span></div><div class="line">    __Block_byref_val_0 *val; <span class="comment">// by ref</span></div><div class="line">    <span class="comment">// 构造函数</span></div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp;</div><div class="line">        Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** Block的函数体 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    <span class="comment">// 取出保存的实例</span></div><div class="line">    __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></div><div class="line">    <span class="comment">// 取出对应的变量真实值？？？</span></div><div class="line">    (val-&gt;__forwarding-&gt;val) = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** __block变量对应的copy函数（复制Block对象时调用） */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** __block变量对应的dispose函数（释放Block对象时调用） */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Block描述信息结构体实例 */</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> reserved;</div><div class="line">    <span class="keyword">size_t</span> Block_size;</div><div class="line">    <span class="comment">/** copy函数指针 */</span></div><div class="line">    <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">    <span class="comment">/** dispose函数指针 */</span></div><div class="line">    <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; </div><div class="line">    <span class="number">0</span>, </div><div class="line">    <span class="keyword">sizeof</span>(struct __main_block_impl_0), </div><div class="line">    __main_block_copy_0, <span class="comment">// 赋值函数</span></div><div class="line">    __main_block_dispose_0 <span class="comment">// 赋值函数</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// main函数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="comment">/* @autoreleasepool */</span> </div><div class="line">    &#123; </div><div class="line">        __AtAutoreleasePool __autoreleasepool; </div><div class="line">        </div><div class="line">        <span class="comment">// 创建__block变量对应的__Block_byref_val_0结构体实例</span></div><div class="line">        <span class="comment">// （__attribute__部分表示需要变量为栈上的变量？？？）</span></div><div class="line">        __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;</div><div class="line">            (<span class="keyword">void</span>*)<span class="number">0</span>,</div><div class="line">            (__Block_byref_val_0 *)&amp;val, <span class="comment">// 指向自身实例</span></div><div class="line">            <span class="number">0</span>, </div><div class="line">            <span class="keyword">sizeof</span>(__Block_byref_val_0), </div><div class="line">            <span class="number">2</span> <span class="comment">// 真正的值</span></div><div class="line">        &#125;;</div><div class="line">        </div><div class="line">        <span class="comment">// 创建Block对象，并使用函数指针指向它</span></div><div class="line">        <span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = (</div><div class="line">            (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0(</div><div class="line">                (<span class="keyword">void</span> *)__main_block_func_0, <span class="comment">// 函数指针</span></div><div class="line">                &amp;__main_block_desc_0_DATA, <span class="comment">// 描述信息实例指针</span></div><div class="line">                (__Block_byref_val_0 *)&amp;val, <span class="comment">// 变量实例指针</span></div><div class="line">                <span class="number">570425344</span></div><div class="line">            )</div><div class="line">        );</div><div class="line">        </div><div class="line">        <span class="comment">// 调用Block中的函数</span></div><div class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在代码中可以看到，</p>
<ol>
<li>使用__block修饰的变量，由基本变量转变成了结构体实例；</li>
<li>当Block使用时，Block需要在其结构中保存此结构体实例的指针；</li>
<li>提供了copy和dispose函数用于管理捕获的__block变量的内存。</li>
</ol>
<h4 id="2-block变量的存储规则"><a href="#2-block变量的存储规则" class="headerlink" title="2.__block变量的存储规则"></a>2.__block变量的存储规则</h4><p>我们知道，当Block对象捕获变量后，ARC会自动将其复制到堆内存中。此时，被捕获的__block变量又会如何变化呢？</p>
<table>
<thead>
<tr>
<th>__block变量本身的存储域</th>
<th>Block从栈复制到堆时的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>栈</td>
<td>复制到堆内存中</td>
</tr>
<tr>
<td>堆</td>
<td>被该Block持有</td>
</tr>
</tbody>
</table>
<p>由上表可得出结论：</p>
<blockquote>
<ol>
<li>在Block捕获了__block变量的情况下，当Block在堆内存中生成后，该变量也会被自动拷贝到堆内存中，并继续被Block对象所持有。</li>
<li>__block变量的内存管理非常类似于引用计数的管理方式：被_NSConcreteMallocBlock对象持有时，变量存在；当没有被任何Block持有后，被系统释放。</li>
</ol>
</blockquote>
<p>现在，我们就可以来解释一下之前的疑问：为何<strong>block变量内部存在指向自身结构实例的</strong>forwarding指针；且取值或修改时，需要通过此指针取出val的值？</p>
<h5 id="2-1-block变量可以在Block内或外部随意修改"><a href="#2-1-block变量可以在Block内或外部随意修改" class="headerlink" title="2.1 __block变量可以在Block内或外部随意修改"></a>2.1 __block变量可以在Block内或外部随意修改</h5><p>开门见山，直接给出原因：</p>
<blockquote>
<p><strong><strong>block变量通过</strong>forwarding可以从任意内存区域访问同一块内存。</strong></p>
</blockquote>
<p>我们先来回顾一下__block变量在栈中的大体结构：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1547444843-%E5%AD%98%E5%82%A8%E5%9C%A8%E6%A0%88%E4%B8%AD%E7%9A%84__block%E5%8F%98%E9%87%8F%E7%BB%93%E6%9E%84.jpg" alt="存储在栈中的__block变量结构.jpg"></p>
<ol>
<li>我们知道，在普通情况下，Block函数体中的捕获变量是通过值传递复制进去的，其执行时，原变量早已释放；若需要同时可以访问或修改，必然需要该变量为同一块内存。</li>
<li>故<strong>block变量能够同时修改的原因，必然是在栈和堆中同时存在相同的变量指针，指向同一块内存。所以，根据存储规则，**当栈</strong>block变量被复制到堆内存时，原变量的__forwarding指针必然需要指向堆变量**，以满足此目的。</li>
</ol>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1547445309-%E5%A4%8D%E5%88%B6%E5%88%B0%E5%A0%86%E5%90%8E__block%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84.jpg" alt="复制到堆后__block变量的结构.jpg"></p>
<p>此时，<strong>无论是从栈中或是堆中访问<strong>block变量，均可以通过</strong>forwarding指针来访问到真正的变量值</strong>。如之前的Block函数体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    <span class="comment">// 取出保存的实例</span></div><div class="line">    __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></div><div class="line">    <span class="comment">// 通过__forwarding获取真正的变量实例，并取值</span></div><div class="line">    (val-&gt;__forwarding-&gt;val) = <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Block函数体中，由于val已经是<strong>堆<strong>block变量，故其</strong>forwarding指针指向自身</strong>，可以成功取到变量值。</p>
<p>而在Block外，直接访问或修改val的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val += <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>其转换后的代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val-&gt;__forwarding-&gt;val += <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>此时，<strong>栈变量val的__forwarding指针指向堆变量val</strong>，故其val与在堆中直接访问相同，均指向同一个val的地址。</p>
<h4 id="3-Block对象对捕获到的-block变量进行内存管理"><a href="#3-Block对象对捕获到的-block变量进行内存管理" class="headerlink" title="3.Block对象对捕获到的__block变量进行内存管理"></a>3.Block对象对捕获到的__block变量进行内存管理</h4><p>在上述实例中，Block对象的描述结构指定了copy和dispose两个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** copy函数 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** dispose函数 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> reserved;</div><div class="line">    <span class="keyword">size_t</span> Block_size;</div><div class="line">    <span class="comment">/** copy指针 */</span></div><div class="line">    <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">    <span class="comment">/** dispose指针 */</span></div><div class="line">    <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; </div><div class="line">    <span class="number">0</span>, </div><div class="line">    <span class="keyword">sizeof</span>(struct __main_block_impl_0),</div><div class="line">    <span class="comment">/** copy指针 */</span></div><div class="line">    __main_block_copy_0, </div><div class="line">    <span class="comment">/** dispose指针 */</span></div><div class="line">    __main_block_dispose_0</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li><strong>copy方法即为由_NSConcreteStackBlock对象copy生成_NSConcreteMallocBlock对象过程中进行的函数调用</strong>。这里即对捕获的__block变量进行指针复制（传递引用）。</li>
<li><strong>dispose方法为堆_NSConcreteMallocBlock对象释放时进行调用</strong>，内部即对捕获的__block变量进行释放操作，不再保留。</li>
</ul>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1547446878-%E6%A0%88Block%E5%A4%8D%E5%88%B6%E4%B8%BA%E5%A0%86Block%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="栈Block复制为堆Block的过程.jpg"></p>
<p>因此，经过此过程，<strong>堆内存中的Block对象强引用着同样处于堆内存中的<strong>block变量；当自身释放时，被保留的</strong>block变量的强引用失效</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Blocks篇：5-Blocks修改捕获到的变量（-block修饰符）&quot;&gt;&lt;a href=&quot;#Blocks篇：5-Blocks修改捕获到的变量（-block修饰符）&quot; class=&quot;headerlink&quot; title=&quot;Blocks篇：5.Blocks修改捕获到的变量（__block修饰符）&quot;&gt;&lt;/a&gt;Blocks篇：5.Blocks修改捕获到的变量（__block修饰符）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们知道，在Block中，修改捕获变量的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于全局变量，由于实质上Block并未对其进行捕获，故可以直接在Block函数体内部进行变量修改；&lt;/li&gt;
&lt;li&gt;对于局部的静态变量，由于Block捕获的是其指针，故可以通过指针对原变量进行修改；&lt;/li&gt;
&lt;li&gt;对于普通的局部变量，由于在Block函数体内使用的版本已经不是之前的变量了（是Block结构体中保存的成员），故编译器不支持直接修改。这种情况下，只能通过“__block”修饰变量进行处理。
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》13</title>
    <link href="http://yoursite.com/2019/01/15/Blocks%E7%AF%87%EF%BC%9A4.Blocks%E7%9A%84%E5%AD%98%E5%82%A8%E5%9F%9F%EF%BC%88ARC%E4%B8%8B_NSConcreteBlock%E7%9A%84%E9%99%B7%E9%98%B1%EF%BC%89/"/>
    <id>http://yoursite.com/2019/01/15/Blocks篇：4.Blocks的存储域（ARC下_NSConcreteBlock的陷阱）/</id>
    <published>2019-01-15T04:10:25.966Z</published>
    <updated>2019-01-15T04:10:25.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Blocks篇：4-Blocks的存储域（ARC下-NSConcreteBlock的陷阱）"><a href="#Blocks篇：4-Blocks的存储域（ARC下-NSConcreteBlock的陷阱）" class="headerlink" title="Blocks篇：4.Blocks的存储域（ARC下_NSConcreteBlock的陷阱）"></a>Blocks篇：4.Blocks的存储域（ARC下_NSConcreteBlock的陷阱）</h2><blockquote>
<p>在上一节中我们知道，在Block捕获不同种类的变量时，生成的Block对象的类型(isa指针)分为三种：</p>
<ul>
<li>_NSConcreteStackBlock</li>
<li>_NSConcreteGlobalBlock</li>
<li>_NSConcreteMallocBlock</li>
</ul>
<p>此三种类型的Block对象分别存储在栈区、全局（数据区）和堆区<br><a id="more"></a><br>我们知道，<strong>由于Block对象的函数体定义在Block实例化的生命周期外部，故其执行时早已不在原作用域内</strong>。况且，由于在函数中，定义的Block对象也是局部变量，超出作用域也会被自动回收。所以，<strong>要保证Block超出原作用域仍然可以存在的方式，就是将其转化为全局Block，或者复制到堆内存中</strong>，这样才可以保证其内存可控并正确执行Block的函数。在ARC环境下，LLVM在编译期已经可以在绝大多数情况下正确处理这种情况。通过测试，编码时定义的局部Block变量（即_NSConcreteStackBlock对象），在运行时可以得到如下结果：</p>
</blockquote>
<table>
<thead>
<tr>
<th>捕获变量情况</th>
<th>运行期生成的Block对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>_NSConcreteGlobalBlock</td>
</tr>
<tr>
<td>全局或静态变量</td>
<td>_NSConcreteGlobalBlock</td>
</tr>
<tr>
<td>普通局部变量</td>
<td>_NSConcreteMallocBlock</td>
</tr>
</tbody>
</table>
<p>但是，发现在一种情况下，ARC不会自动处理，需要我们对Block对象进行手动转换。</p>
<h4 id="1-ARC下的Blocks陷阱"><a href="#1-ARC下的Blocks陷阱" class="headerlink" title="1.ARC下的Blocks陷阱"></a>1.ARC下的Blocks陷阱</h4><p>先看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(^VoidBlock)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/** 返回包含Block对象的集合的函数 */</span></div><div class="line"><span class="function">NSArray *<span class="title">getBlocksArray</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> myVal = <span class="number">2</span>;</div><div class="line">    <span class="comment">// 内部的Block对象均为__NSConcreteStackBlock对象</span></div><div class="line">    <span class="keyword">return</span> [[NSArray alloc] initWithObjects:</div><div class="line">            ^&#123;NSLog(@<span class="string">"block1~%d"</span>, myVal);&#125;,</div><div class="line">            ^&#123;NSLog(@<span class="string">"block2~%d"</span>, myVal);&#125;,</div><div class="line">            nil</div><div class="line">            ];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        <span class="comment">// 获取该数组</span></div><div class="line">        NSArray *blocksArray = getBlocksArray();</div><div class="line">        <span class="comment">// 取出Block对象</span></div><div class="line">        VoidBlock voidBlock = blocksArray[<span class="number">0</span>];</div><div class="line">        <span class="comment">// 执行</span></div><div class="line">        voidBlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行情况，我们可以直接得到个漂亮的“EXC_BAD_ACCESS”。</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1547286721-Block%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%9D%91.jpg" alt="Block在集合中的坑"></p>
<blockquote>
<p>在图中已经看出，这种情况下，编译器并没有将捕获有变量的Block拷贝至堆中。故在准备执行时，Block对象已经被释放（第一个被转成__NSConcreteMallocBlock的原因是由于NSArray的init方法会自动保留对象，进而发生了Block的copy操作）。当执行完毕后，由于数组对象的释放，在对其内部元素依次释放时访问了野指针，导致崩溃。</p>
</blockquote>
<p>所以，在集合中使用Block对象时，为了保证其安全性，我们可以有两种方式：</p>
<ol>
<li>手动将Block复制到堆中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSArray *<span class="title">getBlocksArray</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> myVal = <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> [[NSArray alloc] initWithObjects:</div><div class="line">            [^&#123;NSLog(@<span class="string">"block1~%d"</span>, myVal);&#125; copy],</div><div class="line">            [^&#123;NSLog(@<span class="string">"block2~%d"</span>, myVal);&#125; copy],</div><div class="line">            nil</div><div class="line">            ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>由于Block是OC对象，故对其发送copy消息可以直接将其转换为__NSConcreteMallocBlock对象。</strong></p>
<ol>
<li>在初始化Block时，利用ARC的特性，<strong>对Block进行显式声明，以获取“<strong>strong”修饰的Block，自动生成</strong>NSConcreteMallocBlock对象</strong>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSArray *<span class="title">getBlocksArray</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> myVal = <span class="number">2</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 生成了强引用Block变量，自动分配到了堆内存中</span></div><div class="line">    VoidBlock block1 = ^&#123;NSLog(@<span class="string">"block1~%d"</span>, myVal);&#125;;</div><div class="line">    VoidBlock block2 = ^&#123;NSLog(@<span class="string">"block2~%d"</span>, myVal);&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [[NSArray alloc] initWithObjects:</div><div class="line">            block1,</div><div class="line">            block2,</div><div class="line">            nil</div><div class="line">            ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：例外情况</strong></p>
<blockquote>
<p>在系统带有Block参数的API中（如GCD或是Animation相关等等），无需手动对Block进行复制（其内部实现已经包含了复制操作）。</p>
</blockquote>
<h4 id="2-Blocks的保留操作"><a href="#2-Blocks的保留操作" class="headerlink" title="2.Blocks的保留操作"></a>2.Blocks的保留操作</h4><h5 id="2-1-Blocks的保留解析"><a href="#2-1-Blocks的保留解析" class="headerlink" title="2.1 Blocks的保留解析"></a>2.1 Blocks的保留解析</h5><p>我们知道，在生成__strong修饰的Block对象时，其实隐含的对生成的对象进行了retain操作。此操作实际为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">VoidBlock blockObj = ...;</div><div class="line"><span class="comment">// 对Block进行保留操作</span></div><div class="line">objc_retainBlock(blockObj);</div><div class="line">...</div></pre></td></tr></table></figure>
<p>在NSObject.mm中，我们找到了此方法的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSObject.mm</span></div><div class="line"></div><div class="line"><span class="function">id <span class="title">objc_retainBlock</span><span class="params">(id x)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (id)_Block_copy(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，<strong>对Block进行retain其实也就是进行了copy操作，进而在堆上生成了Block</strong>。</p>
<h5 id="2-2-Blocks的copy操作"><a href="#2-2-Blocks的copy操作" class="headerlink" title="2.2 Blocks的copy操作"></a>2.2 Blocks的copy操作</h5><p>现在，我们知道了对栈中的Block进行复制或保留操作，会在堆内存上生成对应的Block对象。但对于其他两者呢？</p>
<table>
<thead>
<tr>
<th>copy对应Block</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td>无作用</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>引用计数 + 1</td>
</tr>
</tbody>
</table>
<p>对于堆内存中的Block对象，其实是遵循了引用计数的内存管理方式。因此，在使用Block对象时，也要注意引用循环问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Blocks篇：4-Blocks的存储域（ARC下-NSConcreteBlock的陷阱）&quot;&gt;&lt;a href=&quot;#Blocks篇：4-Blocks的存储域（ARC下-NSConcreteBlock的陷阱）&quot; class=&quot;headerlink&quot; title=&quot;Blocks篇：4.Blocks的存储域（ARC下_NSConcreteBlock的陷阱）&quot;&gt;&lt;/a&gt;Blocks篇：4.Blocks的存储域（ARC下_NSConcreteBlock的陷阱）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在上一节中我们知道，在Block捕获不同种类的变量时，生成的Block对象的类型(isa指针)分为三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;_NSConcreteStackBlock&lt;/li&gt;
&lt;li&gt;_NSConcreteGlobalBlock&lt;/li&gt;
&lt;li&gt;_NSConcreteMallocBlock&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此三种类型的Block对象分别存储在栈区、全局（数据区）和堆区&lt;br&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》12</title>
    <link href="http://yoursite.com/2019/01/15/Blocks%E7%AF%87%EF%BC%9A3.Blocks%E4%BD%BF%E7%94%A8%E6%8D%95%E8%8E%B7%E5%88%B0%E7%9A%84%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2019/01/15/Blocks篇：3.Blocks使用捕获到的变量/</id>
    <published>2019-01-15T04:09:21.983Z</published>
    <updated>2019-01-15T04:09:33.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Blocks篇：3-Blocks使用捕获到的变量"><a href="#Blocks篇：3-Blocks使用捕获到的变量" class="headerlink" title="Blocks篇：3.Blocks使用捕获到的变量"></a>Blocks篇：3.Blocks使用捕获到的变量</h2><blockquote>
<p>所谓Blocks捕获变量，即在Block函数体内使用外部声明的变量。</p>
</blockquote>
<h4 id="1-捕获局部变量（自动变量）和静态局部变量"><a href="#1-捕获局部变量（自动变量）和静态局部变量" class="headerlink" title="1. 捕获局部变量（自动变量）和静态局部变量"></a>1. 捕获局部变量（自动变量）和静态局部变量</h4><a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        <span class="keyword">int</span> uselessVal = <span class="number">1</span>;</div><div class="line">        <span class="comment">// 局部变量</span></div><div class="line">        <span class="keyword">int</span> val = <span class="number">3</span>;</div><div class="line">        <span class="comment">// 静态局部变量</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">int</span> staticVal = <span class="number">4</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">            <span class="comment">// 捕获val和staticVal使用</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"val = %d\n"</span>, val);</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"staticVal = %d\n"</span>, staticVal);</div><div class="line">        &#125;;</div><div class="line">        myBlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转换后的C++代码部分如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"></div><div class="line"><span class="comment">/** Block的完整结构体声明 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    <span class="keyword">int</span> val; <span class="comment">// 内部捕获的局部变量</span></div><div class="line">    <span class="keyword">int</span> *staticVal; <span class="comment">// 内部捕获的静态局部变量</span></div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _val, <span class="keyword">int</span> *_staticVal, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val), staticVal(_staticVal) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock; <span class="comment">// 这里只按照MRC编译确定，ARC则不同</span></div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp;</div><div class="line">        Desc = desc;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** Block中函数体转换生成的C函数 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    <span class="comment">// 获取Block结构体实例中捕获的变量</span></div><div class="line">    <span class="keyword">int</span> val = __cself-&gt;val; <span class="comment">// bound by copy</span></div><div class="line">    <span class="keyword">int</span> *staticVal = __cself-&gt;staticVal; <span class="comment">// bound by copy</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"val = %d\n"</span>, val);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"staticVal = %d\n"</span>, (*staticVal));</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// main函数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line">        <span class="keyword">int</span> uselessVal = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> val = <span class="number">3</span>;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">int</span> staticVal = <span class="number">4</span>;</div><div class="line"></div><div class="line">        <span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, val, &amp;staticVal)); <span class="comment">// 初始化时赋值，将要捕获的变量传递进去</span></div><div class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上可以看出：</p>
<ol>
<li><strong>只有Block内部使用的变量才会被捕获；</strong></li>
<li><strong>普通的局部变量是通过值传递方式进行捕获，静态局部变量是通过指针传递方式进行的；</strong><ul>
<li>原因：<ol>
<li><em>由于C函数的声明和实现是在原局部变量的生命周期之外（这里是main函数外部），使用时原变量早已被释放，故需要直接将值保存到Block结构体实例中；</em></li>
<li><em>对于静态局部变量，由于静态变量是存储在专门的数据区（也就可以理解为全局），在C函数中也可以直接访问，故只需将其指针保存在Block结构体实例中即可。</em></li>
</ol>
</li>
</ul>
</li>
<li><strong>C函数内部使用时，通过传递进去的Block指针取出被捕获的变量值。</strong></li>
<li>补充：<strong>在ARC环境下，对于Block的类型（isa）</strong>，<ul>
<li><strong>捕获普通局部变量后，在运行时，系统会将Block拷贝到堆上，变为_NSConcreteMallocBlock</strong></li>
<li><strong>捕获静态局部变量，虽然使用，实际也只是记录该变量的指针，Block为_NSConcreteGlobalBlock</strong></li>
<li><strong>没有捕获任何变量的Block为_NSConcreteGlobalBlock类型</strong></li>
</ul>
</li>
</ol>
<h4 id="2-捕获全局变量和全局静态变量"><a href="#2-捕获全局变量和全局静态变量" class="headerlink" title="2. 捕获全局变量和全局静态变量"></a>2. 捕获全局变量和全局静态变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> globalVal = <span class="number">3</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> globalStaticVal = <span class="number">4</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        <span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"globalVal = %d\n"</span>, globalVal);</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"globalStaticVal = %d\n"</span>, globalStaticVal);</div><div class="line">        &#125;;</div><div class="line">        myBlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转换后的C++部分代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> globalVal = <span class="number">3</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> globalStaticVal = <span class="number">4</span>;</div><div class="line"></div><div class="line"><span class="comment">/** Block完整结构体声明 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="comment">// 没有保存全局变量</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp;</div><div class="line">        Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    <span class="comment">// 直接使用</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"globalVal = %d\n"</span>, globalVal);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"globalStaticVal = %d\n"</span>, globalStaticVal);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，</p>
<ol>
<li><strong>对于全局变量（包含静态全局变量），由于在Block的C函数中可以直接访问，故无需在Block结构中对其进行额外的保存工作</strong>。</li>
<li><strong>在ARC环境下，Block的类型（isa）为_NSConcreteGlobalBlock</strong></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Blocks篇：3-Blocks使用捕获到的变量&quot;&gt;&lt;a href=&quot;#Blocks篇：3-Blocks使用捕获到的变量&quot; class=&quot;headerlink&quot; title=&quot;Blocks篇：3.Blocks使用捕获到的变量&quot;&gt;&lt;/a&gt;Blocks篇：3.Blocks使用捕获到的变量&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;所谓Blocks捕获变量，即在Block函数体内使用外部声明的变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-捕获局部变量（自动变量）和静态局部变量&quot;&gt;&lt;a href=&quot;#1-捕获局部变量（自动变量）和静态局部变量&quot; class=&quot;headerlink&quot; title=&quot;1. 捕获局部变量（自动变量）和静态局部变量&quot;&gt;&lt;/a&gt;1. 捕获局部变量（自动变量）和静态局部变量&lt;/h4&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》11</title>
    <link href="http://yoursite.com/2019/01/15/Blocks%E7%AF%87%EF%BC%9A2.Blocks%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%85%B6%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%B4%A8/"/>
    <id>http://yoursite.com/2019/01/15/Blocks篇：2.Blocks的调用过程及其对象本质/</id>
    <published>2019-01-15T04:06:05.910Z</published>
    <updated>2019-01-15T04:06:17.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Blocks篇：2-Blocks的调用过程及其对象本质"><a href="#Blocks篇：2-Blocks的调用过程及其对象本质" class="headerlink" title="Blocks篇：2.Blocks的调用过程及其对象本质"></a>Blocks篇：2.Blocks的调用过程及其对象本质</h2><blockquote>
<ul>
<li>Blocks实际上是通过支持Block的编译器，将其转换为标准的C代码进行编译。</li>
<li>我们可以使用clang的“-rewrite-objc”命令，将包含Block的源代码转换为C++代码，帮助理解。<a id="more"></a>
<h4 id="1-Blocks的调用过程"><a href="#1-Blocks的调用过程" class="headerlink" title="1. Blocks的调用过程"></a>1. Blocks的调用过程</h4>多说无用，来个最简单的栗子说明吧：</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        <span class="comment">// 声明并赋值myBlock</span></div><div class="line">        <span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Hello Block~\n"</span>);</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">// 调用myBlock</span></div><div class="line">        myBlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>使用”<em>clang -rewrite-objc main.m</em>“转换后的代码为：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"></div><div class="line"><span class="comment">/** Block结构体 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></div><div class="line">  <span class="comment">/** 类型指针 */</span></div><div class="line">  <span class="keyword">void</span> *isa;</div><div class="line">  <span class="keyword">int</span> Flags;</div><div class="line">  <span class="keyword">int</span> Reserved;</div><div class="line">  <span class="comment">/** 函数指针 */</span></div><div class="line">  <span class="keyword">void</span> *FuncPtr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** Block变量完整结构体声明 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="comment">/** Block结构体实例 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="comment">/** 描述信息对象指针 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    </div><div class="line">    <span class="comment">/** 本结构体的构造函数 */</span></div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock; <span class="comment">// isa指针赋值，即证明了Block是“对象”（由于默认clang没有开启ARC，ARC下这里是__NSGlobalBlock__，即_NSConcreteGlobalBlock）</span></div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp; <span class="comment">// 函数指针赋值</span></div><div class="line">        Desc = desc; <span class="comment">// 描述信息指针赋值</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** Block中真正的函数体 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello Block~\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Block描述结构体声明，并实例化 */</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> reserved;</div><div class="line">    <span class="keyword">size_t</span> Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 原main函数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="comment">/* @autoreleasepool */</span> </div><div class="line">    &#123; </div><div class="line">        __AtAutoreleasePool __autoreleasepool; </div><div class="line">        </div><div class="line">        <span class="comment">// 声明了myBlock的C函数指针</span></div><div class="line">        <span class="comment">// 指向了__main_block_impl_0的结构体实例</span></div><div class="line">        <span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">        </div><div class="line">        <span class="comment">// 使用__block_impl实例中的函数指针FuncPtr进行函数调用（传入__block_impl实例的指针作为参数）</span></div><div class="line">        <span class="comment">// 即为原 myBlock()</span></div><div class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>以上代码中，在main函数中，简化后的myBlock声明为：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建 __main_block_impl_0结构体实例</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> <span class="title">tmp</span> = __<span class="title">main_block_impl_0</span>(__<span class="title">main_block_func_0</span>, &amp;__<span class="title">main_block_desc_0_DATA</span>);</span></div><div class="line"><span class="comment">// 赋值给__main_block_impl_0结构体的指针</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> *<span class="title">myBlock</span> = &amp;<span class="title">tmp</span>;</span></div></pre></td></tr></table></figure>
<ol>
<li>简化后的myBlock调用为：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取结构体实例中的myImpl成员</span></div><div class="line"> __block_impl myImpl = (*myBlock).impl;</div><div class="line"> <span class="comment">// myImpl的FuncPtr成员即为真正的函数指针，直接进行调用并传参</span></div><div class="line"> (myImpl.FuncPtr)(*myBlock);</div></pre></td></tr></table></figure>
<p>由此，在编译期间，我们了解了<strong>Blocks的声明和整个调用过程</strong>：</p>
<blockquote>
<ol>
<li>系统在原声明Block的生命周期外，生成静态的相关Block结构体、描述信息结构体和执行函数等。</li>
<li>在原声明Block的生命周期内部，使用相关结构体创建并生成Block的实例。</li>
<li>根据生成的Block实例，找到其中的C函数指针，进行调用。</li>
</ol>
</blockquote>
<h4 id="2-Blocks是对象"><a href="#2-Blocks是对象" class="headerlink" title="2.Blocks是对象"></a>2.Blocks是对象</h4><p>对于Block变量的本质，上面代码中可以看出：</p>
<blockquote>
<ol>
<li>在Block的结构体__block_impl中，包含了isa成员变量，是（void *）类型；</li>
<li>isa变量在初始化Block时，赋值的是_NSConcreteStackBlock的地址；</li>
</ol>
</blockquote>
<h5 id="2-1-isa"><a href="#2-1-isa" class="headerlink" title="2.1 isa"></a>2.1 isa</h5><p>我们知道，isa标识的是OC对象的类型。在<em>objc-private.h</em>中可以找到声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// objc_object</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">isa_t</span> isa;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// isa_t</span></div><div class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">// 指向的是对应的Class</span></div><div class="line">    Class cls;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** id是objc_object结构体指针（id即为OC对象）*/</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></div><div class="line"></div><div class="line"><span class="comment">/** Class是objc_class结构体指针 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// objc_class</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</div><div class="line">    <span class="comment">// Class ISA;</span></div><div class="line">    Class superclass;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在以上代码中可以看到：</p>
<blockquote>
<ol>
<li>id（我们说的OC对象），即objc_object结构体指针，其类型的实质，就是isa联合体的cls成员，也就是指向的Class；</li>
<li>由于objc_class“继承”了objc_object结构体，故其中也包含了isa成员，即“类”也标识了自己所属的类（metaclass，说多了…）。</li>
</ol>
</blockquote>
<h4 id="2-2-NSConcreteStackBlock类型"><a href="#2-2-NSConcreteStackBlock类型" class="headerlink" title="2.2 _NSConcreteStackBlock类型"></a>2.2 _NSConcreteStackBlock类型</h4><ol>
<li>对于_NSConcreteStackBlock，我们可以在main.cpp中找到其声明：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Runtime copy/destroy helper functions (from Block_private.h)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __OBJC_EXPORT_BLOCKS</span></div><div class="line">...</div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllexport) <span class="keyword">void</span> *_NSConcreteGlobalBlock[<span class="number">32</span>];</div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllexport) <span class="keyword">void</span> *_NSConcreteStackBlock[<span class="number">32</span>];</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">...</div><div class="line">__OBJC_RW_DLLIMPORT <span class="keyword">void</span> *_NSConcreteGlobalBlock[<span class="number">32</span>];</div><div class="line">__OBJC_RW_DLLIMPORT <span class="keyword">void</span> *_NSConcreteStackBlock[<span class="number">32</span>];</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>可以看到，_NSConcreteStackBlock声明的是一个数组的指针。</p>
<ol>
<li>而在GNUStep的开源版本中，我们找到了直接支持”Block是对象“的证据：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> _<span class="title">NSConcreteGlobalBlock</span>;</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> _<span class="title">NSConcreteStackBlock</span>;</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> _<span class="title">NSConcreteMallocBlock</span>;</span></div></pre></td></tr></table></figure>
<p>故我们可以将Block看做是OC对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Blocks篇：2-Blocks的调用过程及其对象本质&quot;&gt;&lt;a href=&quot;#Blocks篇：2-Blocks的调用过程及其对象本质&quot; class=&quot;headerlink&quot; title=&quot;Blocks篇：2.Blocks的调用过程及其对象本质&quot;&gt;&lt;/a&gt;Blocks篇：2.Blocks的调用过程及其对象本质&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Blocks实际上是通过支持Block的编译器，将其转换为标准的C代码进行编译。&lt;/li&gt;
&lt;li&gt;我们可以使用clang的“-rewrite-objc”命令，将包含Block的源代码转换为C++代码，帮助理解。
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》10</title>
    <link href="http://yoursite.com/2019/01/15/Blocks%E7%AF%87%EF%BC%9A1.Blocks%E7%9A%84%E5%A3%B0%E6%98%8E/"/>
    <id>http://yoursite.com/2019/01/15/Blocks篇：1.Blocks的声明/</id>
    <published>2019-01-15T04:05:21.255Z</published>
    <updated>2019-01-15T04:05:21.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Blocks篇：1-Blocks的声明"><a href="#Blocks篇：1-Blocks的声明" class="headerlink" title="Blocks篇：1.Blocks的声明"></a>Blocks篇：1.Blocks的声明</h2><blockquote>
<p><strong>Blocks是带有自动变量值的匿名函数。</strong></p>
</blockquote>
<p>写法：</p>
<ul>
<li>Blocks变量声明：与C函数指针声明基本相似，将指针符号”*”替换为“^”。</li>
<li>Blocks主体声明：省略了名称的C函数，在原函数名前添加“^”。<ul>
<li>无参数Blocks，可以省略参数列表</li>
<li>无返回值Blocks，可以省略返回值</li>
</ul>
</li>
</ul>
<a id="more"></a>
<p>举例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 完整声明</span></div><div class="line"><span class="keyword">void</span> (^myBlock)(<span class="keyword">int</span> a) = <span class="keyword">void</span> ^(<span class="keyword">int</span> a) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 无参数，无返回值</span></div><div class="line"><span class="keyword">void</span> (^myBlock2)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Blocks篇：1-Blocks的声明&quot;&gt;&lt;a href=&quot;#Blocks篇：1-Blocks的声明&quot; class=&quot;headerlink&quot; title=&quot;Blocks篇：1.Blocks的声明&quot;&gt;&lt;/a&gt;Blocks篇：1.Blocks的声明&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Blocks是带有自动变量值的匿名函数。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;写法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Blocks变量声明：与C函数指针声明基本相似，将指针符号”*”替换为“^”。&lt;/li&gt;
&lt;li&gt;Blocks主体声明：省略了名称的C函数，在原函数名前添加“^”。&lt;ul&gt;
&lt;li&gt;无参数Blocks，可以省略参数列表&lt;/li&gt;
&lt;li&gt;无返回值Blocks，可以省略返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》9</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A9.ARC%E5%AE%9E%E7%8E%B0%E4%B9%8B__autoreleasing/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇：9.ARC实现之__autoreleasing/</id>
    <published>2019-01-06T07:54:34.109Z</published>
    <updated>2019-01-06T07:54:34.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：9-ARC实现之-autoreleasing"><a href="#内存管理篇：9-ARC实现之-autoreleasing" class="headerlink" title="内存管理篇：9.ARC实现之__autoreleasing"></a>内存管理篇：9.ARC实现之__autoreleasing</h2><ol>
<li>__autoreleasing修饰的变量与在非ARC环境下，对对象调用autorelease方法效果一致：</li>
</ol>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasePool &#123;</div><div class="line">    id __autoreleasing obj = [[NSObject alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转换后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建pool</span></div><div class="line">id pool = objc_autoreleasePoolPush();</div><div class="line"></div><div class="line"><span class="comment">// 创建对象</span></div><div class="line">id obj = objc_msgSend(NSObject, @selector(alloc));</div><div class="line">objc_msgSend(obj, @selector(init));</div><div class="line"></div><div class="line"><span class="comment">// 加入到pool中</span></div><div class="line">objc_autorelease(obj);</div><div class="line"></div><div class="line"><span class="comment">// 释放pool中的对象</span></div><div class="line">objc_autoreleasePoolPop(pool);</div></pre></td></tr></table></figure>
<ol>
<li>对于将非调用方创建的对象，加入到autoreleasePool中的情况，生成的代码如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasePool &#123;</div><div class="line">    id __autoreleasing obj = [NSMutableArray <span class="built_in">array</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转换后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建pool</span></div><div class="line">id pool = objc_autoreleasePoolPush();</div><div class="line"></div><div class="line"><span class="comment">// 创建对象</span></div><div class="line">id obj = objc_msgSend(NSMutableArray, @selector(<span class="built_in">array</span>));</div><div class="line"><span class="comment">// 保留返回的自动释放对象（autorelease优化）</span></div><div class="line">objc_retainAutoreleasedReturnValue(obj);</div><div class="line"></div><div class="line"><span class="comment">// 加入到pool中</span></div><div class="line">objc_autorelease(obj);</div><div class="line"></div><div class="line"><span class="comment">// 释放pool中的对象</span></div><div class="line">objc_autoreleasePoolPop(pool);</div></pre></td></tr></table></figure>
<p>这里在前面<strong>strong的情况中有说过，<strong>对于函数的返回值，ARC使用objc_autoreleaseReturnValue和objc_retainAutoreleasedReturnValue方法进行优化，避免了将生成的对象在pool中进行进入和取出操作</strong>。但是由于接收变量是使用</strong>autoreleasing修饰的，故直接将其加入到pool中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：9-ARC实现之-autoreleasing&quot;&gt;&lt;a href=&quot;#内存管理篇：9-ARC实现之-autoreleasing&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇：9.ARC实现之__autoreleasing&quot;&gt;&lt;/a&gt;内存管理篇：9.ARC实现之__autoreleasing&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;__autoreleasing修饰的变量与在非ARC环境下，对对象调用autorelease方法效果一致：&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》8</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A8.ARC%E5%AE%9E%E7%8E%B0%E4%B9%8B__weak/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇：8.ARC实现之__weak/</id>
    <published>2019-01-06T07:53:26.381Z</published>
    <updated>2019-01-06T07:53:34.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：8-ARC实现之-weak"><a href="#内存管理篇：8-ARC实现之-weak" class="headerlink" title="内存管理篇：8.ARC实现之__weak"></a>内存管理篇：8.ARC实现之__weak</h2><blockquote>
<p>我们知道，weak修饰的变量，其地址是被存储在一个专用的散列表中，此散列表的键值为原内存的散列值（即对象地址的hash值）。</p>
</blockquote>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546747255-weak%E8%A1%A8.jpg" alt="img"></p>
<p>__weak修饰的变量，其主要存在两大功能：</p>
<ol>
<li><strong>当其引用的对象被释放时，此变量自动被赋值为nil</strong>；</li>
<li><strong>使用__weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象</strong>。</li>
</ol>
<a id="more"></a>
<h4 id="当-weak变量引用的对象被释放时，其自动被赋值为nil"><a href="#当-weak变量引用的对象被释放时，其自动被赋值为nil" class="headerlink" title="当__weak变量引用的对象被释放时，其自动被赋值为nil"></a>当__weak变量引用的对象被释放时，其自动被赋值为nil</h4><p>先看示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// obj为强引用变量且已经被赋值</span></div><div class="line">    id __weak obj1 = obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id obj1;</div><div class="line">objc_initWeak(&amp;obj1, obj);</div><div class="line">objc_destroyWeak(&amp;obj1);</div></pre></td></tr></table></figure>
<p>objc_initWeak方法，即为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj1 = <span class="number">0</span>;</div><div class="line">objc_storeWeak(&amp;obj1, obj);</div></pre></td></tr></table></figure>
<p>objc_destroyWeak方法，即为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_storeWeak(&amp;obj1, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>由此可以看出，</p>
<ol>
<li><strong>对于初始化的weak变量：为变量赋值为0，并将其地址存储到weak表中，对象内存的散列值所在的地址中</strong>。</li>
<li><strong>释放weak变量时：则是在weak表中，将对象内存散列值所在地址存储的数据中，将存储的变量清空</strong>。</li>
</ol>
<blockquote>
<p>由于可以使用多个weak变量指向同一对象，所以在weak表中，一个键值的散列地址中可以存储多个weak变量地址。</p>
</blockquote>
<p><em>结论：<br>weak对象释放时，自动置为nil的原因</em>：</p>
<ul>
<li><strong>在系统调用dealloc释放对象时（最后的objc_clear_deallocating方法），ARC会根据对象的引用状态，去weak表中查询对应的weak变量，将变量地址赋值为nil，并将其记录删除。最后将此键值记录一并删除。</strong></li>
<li>注意：此过程需要消耗CPU资源，故不要滥用，需要时再使用（如避免delegate和block导致的引用循环）。</li>
</ul>
<h4 id="使用-weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象"><a href="#使用-weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象" class="headerlink" title="使用__weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象"></a>使用__weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象</h4><p>还是先看实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// obj为强引用变量，且已被赋值</span></div><div class="line">    id __weak obj1 = obj;</div><div class="line">    NSLog(@<span class="string">"%@"</span>, obj1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 初始化weak变量并赋值</span></div><div class="line">id obj1;</div><div class="line">objc_initWeak(&amp;obj1, obj);</div><div class="line"><span class="comment">// ？？？</span></div><div class="line">id tmp = objc_loadWeakRetained(&amp;obj1);</div><div class="line"><span class="comment">// ？？？</span></div><div class="line">objc_autorelease(tmp);</div><div class="line">NSLog(@<span class="string">"%@"</span>, tmp);</div><div class="line"><span class="comment">// 释放weak变量</span></div><div class="line">objc_destroyWeak(&amp;obj1);</div></pre></td></tr></table></figure>
<p>其中：</p>
<ol>
<li><strong>先通过objc_loadWeakRetained方法，将weak变量对应引用的对象取出，并进行retain操作。</strong></li>
<li><strong>使用objc_autorelease方法，将生成的临时对象加入到autoreleasePool中，即可保证对象的生存期，以便正常使用。</strong></li>
</ol>
<p>注意：</p>
<ul>
<li>大量使用weak变量，会在autoreleasePool中插入大量临时变量，增加内存开销，并对CPU进行过多无畏的损耗。</li>
<li>正确的使用方法，是使用strong变量指向weak变量后，再进行使用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">id __weak obj1 = obj;</div><div class="line">id tmp = obj1;</div><div class="line">NSLog(@<span class="string">"1.%@"</span>, tmp);</div><div class="line">NSLog(@<span class="string">"2.%@"</span>, tmp);</div><div class="line">NSLog(@<span class="string">"3.%@"</span>, tmp);</div><div class="line">NSLog(@<span class="string">"4.%@"</span>, tmp);</div><div class="line">NSLog(@<span class="string">"5.%@"</span>, tmp);</div><div class="line"><span class="comment">// 这样，autoreleasePool只会将obj1插入一次</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：8-ARC实现之-weak&quot;&gt;&lt;a href=&quot;#内存管理篇：8-ARC实现之-weak&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇：8.ARC实现之__weak&quot;&gt;&lt;/a&gt;内存管理篇：8.ARC实现之__weak&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们知道，weak修饰的变量，其地址是被存储在一个专用的散列表中，此散列表的键值为原内存的散列值（即对象地址的hash值）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546747255-weak%E8%A1%A8.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;__weak修饰的变量，其主要存在两大功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;当其引用的对象被释放时，此变量自动被赋值为nil&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用__weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》7</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A7.ARC%E5%AE%9E%E7%8E%B0%E4%B9%8B__strong%E5%8F%8Aautorelease%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇：7.ARC实现之__strong及autorelease优化/</id>
    <published>2019-01-06T07:52:21.263Z</published>
    <updated>2019-01-06T07:52:21.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：7-ARC实现之-strong及autorelease优化"><a href="#内存管理篇：7-ARC实现之-strong及autorelease优化" class="headerlink" title="内存管理篇：7.ARC实现之__strong及autorelease优化"></a>内存管理篇：7.ARC实现之__strong及autorelease优化</h2><blockquote>
<p>对于持有非自己创建的对象的情况，我们知道，这种情况是指对于非“alloc、new、copy和mutableCopy”开头的并返回对象实例的方法，接收方不负责内存管理。<br>ARC会在方法实现中将返回值加入到autoreleasePool中，待接收方从中取出使用，延迟释放时机。</p>
</blockquote>
<a id="more"></a>
<p>但是实际上，代码并不会都如我们想象的那样，因为会有更优化的执行。先看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    id __strong obj = [NSMutableArray <span class="built_in">array</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 发消息创建对象</span></div><div class="line">id obj = objc_msgSend(NSMutableArray, @selector(<span class="built_in">array</span>));</div><div class="line"><span class="comment">// ???</span></div><div class="line">objc_retainAutoreleasedReturnValue(obj);</div><div class="line"><span class="comment">// 正常释放对象</span></div><div class="line">objc_release(obj);</div></pre></td></tr></table></figure>
<p>而对于NSMutableArray的array方法，编译后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (id)<span class="built_in">array</span> &#123;</div><div class="line">    <span class="comment">// 正常的二段式创建</span></div><div class="line">    id obj = objc_msgSend(NSMutableArray, @selector(alloc));</div><div class="line">    objc_msgSend(obj, @selector(init));</div><div class="line">    <span class="comment">// ???</span></div><div class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在以上代码中可以看到，在这种情况下，ARC使用了<em>objc_autoreleaseReturnValue</em>替代了autorelease操作，而调用方则使用<em>objc_retainAutoreleasedReturnValue</em>替代了传统的retain操作。作用是什么呢？</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546692024-AutoRelease%E4%BC%98%E5%8C%96.jpg" alt="img"></p>
<blockquote>
<p>使用这对方法（创建对象的方法返回使用objc_autoreleaseReturnValue返回的对象，而接收方使用objc_retainAutoreleasedReturnValue接收返回的对象）时，编译器实际上并没有将生成的对象加入到autoreleasePool中，而是直接将对象传递给接收方。避免了频繁地将对象在autoreleasePool中进行加入、取出操作，以达到最优效率。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：7-ARC实现之-strong及autorelease优化&quot;&gt;&lt;a href=&quot;#内存管理篇：7-ARC实现之-strong及autorelease优化&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇：7.ARC实现之__strong及autorelease优化&quot;&gt;&lt;/a&gt;内存管理篇：7.ARC实现之__strong及autorelease优化&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;对于持有非自己创建的对象的情况，我们知道，这种情况是指对于非“alloc、new、copy和mutableCopy”开头的并返回对象实例的方法，接收方不负责内存管理。&lt;br&gt;ARC会在方法实现中将返回值加入到autoreleasePool中，待接收方从中取出使用，延迟释放时机。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》6</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A%206.%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%88%E9%9D%9EOC%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%EF%BC%89/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇： 6.不要使用静态和动态数组（非OC集合对象）/</id>
    <published>2019-01-06T07:51:20.446Z</published>
    <updated>2019-01-06T07:51:20.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：-6-不要使用静态和动态数组（非OC集合对象）"><a href="#内存管理篇：-6-不要使用静态和动态数组（非OC集合对象）" class="headerlink" title="内存管理篇： 6.不要使用静态和动态数组（非OC集合对象）"></a>内存管理篇： 6.不要使用静态和动态数组（非OC集合对象）</h2><h4 id="静态数组（类似于c数组，非OC的集合对象）："><a href="#静态数组（类似于c数组，非OC的集合对象）：" class="headerlink" title="静态数组（类似于c数组，非OC的集合对象）："></a>静态数组（类似于c数组，非OC的集合对象）：</h4><ul>
<li>使用<strong>strong、</strong>weak和__autoreleasing修饰的静态数组（如：id objs[10]），其初始值也会自动赋值为nil，且当其释放时，子元素也会自动被释放；</li>
</ul>
<a id="more"></a>
<h4 id="动态数组（对象指针实现）："><a href="#动态数组（对象指针实现）：" class="headerlink" title="动态数组（对象指针实现）："></a>动态数组（对象指针实现）：</h4><ol>
<li>声明：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明，指向id的指针：</span></div><div class="line">id __strong *<span class="built_in">array</span> = nil;</div><div class="line"><span class="comment">// 或 指向对象的指针</span></div><div class="line"><span class="comment">// NSObject * __strong *array = nil;</span></div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>动态数组用对象指针表示；</li>
<li>由于对象指针默认为“<strong>autoreleasing”修饰符，所以需要显示指定为“</strong>strong”；</li>
<li>对象指针不会被ARC自动置为nil，需要显示指定。</li>
</ul>
</blockquote>
<ol>
<li>初始化：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 初始化：</span></div><div class="line"><span class="built_in">array</span> = (id __strong *)<span class="built_in">calloc</span>(entries, <span class="keyword">sizeof</span>(id)); </div><div class="line"><span class="comment">// calloc方法会自动将内存空间写入0数据，比malloc配合memset更为安全且简洁</span></div><div class="line"></div><div class="line"><span class="comment">// 使用malloc和memset的错误方式</span></div><div class="line"><span class="built_in">array</span> = (id __strong *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(id) * entries);</div><div class="line"><span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; entries; ++i) &#123;</div><div class="line">    <span class="built_in">array</span>[i] = nil; <span class="comment">// 错误：在ARC下相当于直接释放</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>使用：(与静态数组一致，同样不能放入nil)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">array</span>[<span class="number">0</span>] = [[NSObject alloc] init];</div></pre></td></tr></table></figure>
<ol>
<li>释放：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.依次释放子元素</span></div><div class="line"><span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; entries; ++i) &#123;</div><div class="line">    <span class="built_in">array</span>[i] = nil; <span class="comment">// 在ARC下相当于直接释放对象</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 2.释放动态数组本身</span></div><div class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>原因：由于动态数组是在运行期确定，ARC无法在编译器对其进行内存管理，直接释放数组本身会让子元素发生内存泄漏。</p>
</blockquote>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><p>使用memcpy拷贝数组中的元素和realloc重新分配内存，都可能导致对象内存泄漏或过度释放，所以ARC下也被禁止使用。</p>
<hr>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><blockquote>
<p>直接使用Foundation的集合对象就好了，不要用这种东西。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：-6-不要使用静态和动态数组（非OC集合对象）&quot;&gt;&lt;a href=&quot;#内存管理篇：-6-不要使用静态和动态数组（非OC集合对象）&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇： 6.不要使用静态和动态数组（非OC集合对象）&quot;&gt;&lt;/a&gt;内存管理篇： 6.不要使用静态和动态数组（非OC集合对象）&lt;/h2&gt;&lt;h4 id=&quot;静态数组（类似于c数组，非OC的集合对象）：&quot;&gt;&lt;a href=&quot;#静态数组（类似于c数组，非OC的集合对象）：&quot; class=&quot;headerlink&quot; title=&quot;静态数组（类似于c数组，非OC的集合对象）：&quot;&gt;&lt;/a&gt;静态数组（类似于c数组，非OC的集合对象）：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用&lt;strong&gt;strong、&lt;/strong&gt;weak和__autoreleasing修饰的静态数组（如：id objs[10]），其初始值也会自动赋值为nil，且当其释放时，子元素也会自动被释放；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》5</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A%205.ARC%E7%9A%84%E8%A7%84%E5%88%99%E8%A1%A5%E5%85%85/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇： 5.ARC的规则补充/</id>
    <published>2019-01-06T07:49:49.390Z</published>
    <updated>2019-01-06T07:49:49.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：-5-ARC的规则补充"><a href="#内存管理篇：-5-ARC的规则补充" class="headerlink" title="内存管理篇： 5.ARC的规则补充"></a>内存管理篇： 5.ARC的规则补充</h2><ol>
<li>ARC的方法命名</li>
</ol>
<blockquote>
<p>我们都知道，在内存管理的思考方式中，当方法命名以“alloc、new、copy、mutableCopy”开头或直接命名时，返回对象（必须返回对象）的内存由接收方进行管理。这种方式在ARC中同样适用。</p>
</blockquote>
<p>在ARC环境下，以init或init开头的方法，也需要遵循此规则。且init的方法规定更为严格：</p>
<ul>
<li>必须返回id或类型的对象</li>
<li>必须是实例方法</li>
</ul>
<a id="more"></a>
<hr>
<ol>
<li><strong>OC对象（这里代指Foundation框架中类的对象）不能直接作为C数据结构的成员。</strong><blockquote>
<p>原因：ARC为OC语言编译器特性，不支持对C语言进行内存管理（最新的iOS 12中，好像已经支持此特性了，LLVM真强大。。。）</p>
</blockquote>
</li>
</ol>
<p>对于需要作为成员的OC对象，解决方法：</p>
<ul>
<li>使用“__unsafe_unretained”进行所有权修饰，显示声明并告知编译器不要对其进行内存管理；</li>
<li>通过“__bridge”将OC对象转换为（void *）指针。</li>
</ul>
<hr>
<ol>
<li>显示转换“id”与“void *”</li>
</ol>
<p>对象与C指针之间是通过“__bridge”关键字进行转换，主要分为三种方式：</p>
<blockquote>
<ul>
<li>__bridge</li>
<li>__bridge_retained</li>
<li>__bridge_transfer</li>
</ul>
</blockquote>
<ul>
<li>__bridge:</li>
</ul>
<p>直接转换，忽略ARC内存管理，与添加__unsafe_unretained效果类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">id obj = [[NSObject alloc] init];</div><div class="line"><span class="comment">// 转换为c指针</span></div><div class="line"><span class="keyword">void</span> *p = (__bridge <span class="keyword">void</span> *)obj;</div><div class="line"><span class="comment">// 转换为OC对象</span></div><div class="line">id obj2 = (__bridge id)p;</div></pre></td></tr></table></figure>
<ul>
<li>__bridge_retained:</li>
</ul>
<p>意为“转换后进行保留”，接收方对其自动强引用（同时掌握所有权），与__strong的retain效果类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *p = <span class="number">0</span>;</div><div class="line">&#123;</div><div class="line">    id obj = [[NSObject alloc] init];</div><div class="line">    <span class="comment">// 转换为c指针</span></div><div class="line">    p = (__bridge_retained <span class="keyword">void</span> *)obj;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 出作用域后，obj强引用消失</span></div><div class="line"><span class="comment">// 由于__bridge_retained，p同时也是强引用，对象得以继续生存</span></div><div class="line">NSLog(<span class="string">"%@"</span>, [(__bridge id)p class]);</div></pre></td></tr></table></figure>
<ul>
<li>__bridge_transfer:</li>
</ul>
<p>意为“转换后释放”，原创建方在转换后自动释放自身引用，只由接收方进行内存管理（转换了所有权），与release效果类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *p = xxx;</div><div class="line">id obj = (__bridge_transfer id)p;</div><div class="line"><span class="comment">// 转换后相当于p进行了release操作，只有obj持有对象</span></div></pre></td></tr></table></figure>
<p><strong>OC（Foundation）对象与CF（Core Foundation）对象间的转换</strong>：</p>
<ul>
<li>由于二者基本是等效框架（只是实现语言不同），对象间的转换无需消耗CPU资源，是“免费桥接”（“toll-free bridge”）。</li>
<li>一般转换规则：<ul>
<li>OC -&gt; CF，使用“__bridge_retained”或“CFBridgingRetain”</li>
<li>CF -&gt; OC，使用“__bridge_transfer”或“CFBridgingRelease”（因为一般转换为OC对象后，ARC可以自动介入，防止忘记使用CFRelease手动释放内存）</li>
</ul>
</li>
</ul>
<blockquote>
<p>总结：<strong>尽量不要直接使用__bridge进行转换</strong>，使用时需再三考虑内存管理情况。</p>
</blockquote>
<hr>
<ol>
<li>使用<strong>strong、</strong>weak和__autoreleasing修饰的变量，其初始值会自动赋值为nil</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：-5-ARC的规则补充&quot;&gt;&lt;a href=&quot;#内存管理篇：-5-ARC的规则补充&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇： 5.ARC的规则补充&quot;&gt;&lt;/a&gt;内存管理篇： 5.ARC的规则补充&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;ARC的方法命名&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我们都知道，在内存管理的思考方式中，当方法命名以“alloc、new、copy、mutableCopy”开头或直接命名时，返回对象（必须返回对象）的内存由接收方进行管理。这种方式在ARC中同样适用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在ARC环境下，以init或init开头的方法，也需要遵循此规则。且init的方法规定更为严格：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须返回id或类型的对象&lt;/li&gt;
&lt;li&gt;必须是实例方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》4</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A%204.ARC%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇： 4.ARC的所有权修饰符/</id>
    <published>2019-01-06T07:47:20.057Z</published>
    <updated>2019-01-06T07:48:00.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：-4-ARC的所有权修饰符"><a href="#内存管理篇：-4-ARC的所有权修饰符" class="headerlink" title="内存管理篇： 4.ARC的所有权修饰符"></a>内存管理篇： 4.ARC的所有权修饰符</h2><h3 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h3><blockquote>
<ul>
<li>在ARC下，对象必须通过所有权修饰符进行修饰，系统会根据不同的所有权修饰符对对象进行相应的内存管理。</li>
<li>所有权修饰符包括：<strong>strong、</strong>weak、<strong>unsafe_unretained、</strong>autoreleasing。</li>
</ul>
</blockquote>
<a id="more"></a>
<h4 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="__strong修饰符"></a>__strong修饰符</h4><blockquote>
<ul>
<li>__strong作为默认的所有权修饰符，使用时可以直接省略；</li>
<li>__strong将修饰对象的指针变量声明为强引用（对象的引用计数+1）</li>
</ul>
</blockquote>
<p>__strong修饰的对象，依然符合内存管理的4条思考方式：</p>
<ul>
<li>自己创建的对象，自己持有：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// 作用域内，object负责内存管理</span></div><div class="line">    id __strong object = [[NSObject alloc] init];</div><div class="line">&#125;   <span class="comment">// 出作用域，对象的强引用失效，内存释放</span></div></pre></td></tr></table></figure>
<ul>
<li>非自己创建的对象，自己也能持有：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    id __strong object1 = [[NSObject alloc] init];</div><div class="line">    <span class="comment">// 通过赋值方式，持有别人创建的对象</span></div><div class="line">    id __strong object2 = object1</div><div class="line">&#125;   </div><div class="line"><span class="comment">// 出作用域，object2强引用失效，对象收到release消息；object1强引用也失效，对象收到release消息；最终内存释放</span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// 持有非自己创建的对象</span></div><div class="line">    id __strong object = [NSMutableArray <span class="built_in">array</span>];</div><div class="line">&#125;   <span class="comment">// 出作用域，对象的强引用失效，内存释放</span></div></pre></td></tr></table></figure>
<ul>
<li>当不再需要时，可以释放自己创建的对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    id __strong object = [[NSObject alloc] init];</div><div class="line">    <span class="comment">// 不需要时，直接置为nil或指向其他对象时，原对象收到release消息</span></div><div class="line">    object = nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>无法释放非自己创建的对象<ul>
<li>由于无法调用release方法，无需担心释放问题。</li>
</ul>
</li>
</ul>
<h4 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="__weak修饰符"></a>__weak修饰符</h4><blockquote>
<ul>
<li>与<strong>strong相对，</strong>weak为弱引用，不持有对象；</li>
<li>出作用域后，修饰的指针变量自动置为nil，访问安全；</li>
<li><strong>解决“引用循环”问题；</strong></li>
<li>iOS5以上适用（自动置nil是在运行期实现，故ARC不全是编译器特性）</li>
</ul>
</blockquote>
<h4 id="unsafe-unretained修饰符"><a href="#unsafe-unretained修饰符" class="headerlink" title="__unsafe_unretained修饰符"></a>__unsafe_unretained修饰符</h4><blockquote>
<ul>
<li>作为iOS5以前“__weak”的版本，编译器不对其内存进行管理；</li>
<li>出作用域后，指针变量不会置为nil，访问极其危险</li>
</ul>
</blockquote>
<p><strong>不建议使用。</strong></p>
<h4 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h4><blockquote>
<p>在ARC下，NSAutoreleasePool类的创建使用需要使用@autoreleasepool块来代替，且不能手动调用autorelease方法。</p>
</blockquote>
<ul>
<li>非显示使用的情况（编译器自动将对象标记为__autoreleasing）：</li>
</ul>
<ol>
<li><strong>在@autoreleasepool块中直接使用：</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line">    id obj = [[NSObject alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong>作为函数返回值：</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">+ (MyClass *)myObject &#123;</div><div class="line">    <span class="keyword">return</span> [[MyClass alloc] init];</div><div class="line">    <span class="comment">/** </span></div><div class="line">    * 相当于</div><div class="line">    *   id obj = [[MyClass alloc] init];</div><div class="line">    *   return obj;</div><div class="line">    */</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">隐含创建的obj变量会被赋值__strong修饰符，出作用域后会被释放，但由于对象作为函数返回值，编译器会将其标记为__autoreleasing，加入到最近的autoreleasepool对象中。</div><div class="line">&gt; 注意：对于此种情况，方法命名时需要遵循内存管理规则：即不得使用“alloc、<span class="keyword">new</span>、copy和mutableCopy”作为方法名开头（会将返回对象标记为__strong）。</div><div class="line"></div><div class="line"><span class="number">3.</span> **指向id的指针或指向对象的指针：**</div><div class="line"></div><div class="line">``` c</div><div class="line"><span class="comment">// 指向id的指针</span></div><div class="line">id __autoreleasing *obj;</div><div class="line"><span class="comment">// 指向NSObject对象的指针</span></div><div class="line">NSObject * __autoreleasing *obj;</div></pre></td></tr></table></figure>
<p>举例，API中的error参数，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSError ** 等同于 NSError * __autoreleasing *</span></div><div class="line">- (BOOL)performTaskWithError:(NSError **)error &#123;</div><div class="line">    <span class="keyword">if</span> (出现错误) &#123;</div><div class="line">        &amp;error = [NSError errorWithxxx];</div><div class="line">        <span class="keyword">return</span> NO;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用时：</span></div><div class="line">NSError *error; <span class="comment">// 相当于NSError __strong *error，值为nil（由于对象指针赋值时，二者的所有权修饰符必须一致。实际上这里error在下面赋值时，隐含地生成了__autoreleasing修饰的临时变量）</span></div><div class="line">[obj performTaskWithError:&amp;error];</div></pre></td></tr></table></figure>
<blockquote>
<p>原因：<br>这里其实也遵循了内存管理法则所述的方法命名规范，由于方法名不是由“alloc、new、copy和mutableCopy”开头，error作为返回对象与函数的返回值一样，且接收方相当于持有非自己创建的对象。所以会被编译器自动加入到autoreleasepool中。<br>所以指向对象的指针，会被自动标记为“__autoreleasing”。</p>
</blockquote>
<ul>
<li><strong>对象指针赋值时，二者的所有权修饰符必须一致</strong>。如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSError *error = nil; <span class="comment">// 默认为__strong</span></div><div class="line"><span class="comment">// 由于默认指向对象的指针为__autoreleasing，所以这里需要显示指定为__strong</span></div><div class="line">NSError * __strong *pError = &amp;error;</div></pre></td></tr></table></figure>
<ul>
<li><strong>在访问使用__weak修饰符的变量时，实际上该对象必定会被加到autoreleasepool中</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id __weak obj1 = obj0;</div><div class="line">NSLog(@<span class="string">"class = %@"</span>, [obj1 class]);</div></pre></td></tr></table></figure>
<p>与以下代码等效：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id __weak obj1 = obj0;</div><div class="line">id __autoreleasing tmp = obj1;</div><div class="line">NSLog(@<span class="string">"class = %@"</span>, [tmp class]);</div></pre></td></tr></table></figure>
<blockquote>
<p>原因：<br><strong>weak修饰的变量只是弱引用，其指向的对象随时可能被释放而变为nil；<br>为了保证使用过程中对象的持续存在，ARC会将生成</strong>autorelease修饰的临时变量指向该对象，从而将其加入到autoreleasepool中。</p>
</blockquote>
<ul>
<li>注意：<strong>使用__autoreleasing修饰的变量，必须为自动变量（局部变量、函数或方法参数），不能是其他。</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：-4-ARC的所有权修饰符&quot;&gt;&lt;a href=&quot;#内存管理篇：-4-ARC的所有权修饰符&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇： 4.ARC的所有权修饰符&quot;&gt;&lt;/a&gt;内存管理篇： 4.ARC的所有权修饰符&lt;/h2&gt;&lt;h3 id=&quot;所有权修饰符&quot;&gt;&lt;a href=&quot;#所有权修饰符&quot; class=&quot;headerlink&quot; title=&quot;所有权修饰符&quot;&gt;&lt;/a&gt;所有权修饰符&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在ARC下，对象必须通过所有权修饰符进行修饰，系统会根据不同的所有权修饰符对对象进行相应的内存管理。&lt;/li&gt;
&lt;li&gt;所有权修饰符包括：&lt;strong&gt;strong、&lt;/strong&gt;weak、&lt;strong&gt;unsafe_unretained、&lt;/strong&gt;autoreleasing。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》3</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A%203.autorelease/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇： 3.autorelease/</id>
    <published>2019-01-06T07:43:19.318Z</published>
    <updated>2019-01-06T07:44:11.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：-3-autorelease"><a href="#内存管理篇：-3-autorelease" class="headerlink" title="内存管理篇： 3.autorelease"></a>内存管理篇： 3.autorelease</h2><blockquote>
<p><strong>autorelease的实质：</strong><br><em>将创建的对象加入到NSAutoreleasePool管理“数组”中，并告知ARC系统暂时不要对此对象进行处理。待pool对象在其所属的NSRunLoop循环一次完成，准备释放（drain）时，对“数组”中的所有对象依次调用release方法。此时ARC再对对象进行内存管理。</em></p>
</blockquote>
<a id="more"></a>
<h3 id="GNUstep的实现"><a href="#GNUstep的实现" class="headerlink" title="GNUstep的实现"></a>GNUstep的实现</h3><p>GNUstep的版本使用了同NSMutableArray一样的连接列表，将被标记的对象加入到“正在使用中的”autoreleasePool对象中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSObject.m中：</span></div><div class="line">- (id)autorelease &#123;</div><div class="line">    [NSAutoreleasePool addObject:self];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// NSAutoreleasePool.m中：</span></div><div class="line">+ (<span class="keyword">void</span>)addObject:(id)anObj &#123;</div><div class="line">    NSAutoreleasePool *pool = 获取正在使用中的pool；</div><div class="line">    <span class="keyword">if</span> (pool != nil) &#123;</div><div class="line">        [pool addObject:anObj];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addObject:(id)anObj &#123;</div><div class="line">    <span class="comment">// 加入到内部管理的数组中</span></div><div class="line">    [<span class="built_in">array</span> addObject:anObj];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="方法调用优化：在GNUstep实现的版本中，为了提高autorelease方法执行的速度，使用了“IMP-Caching”的方式，及将函数指针提前缓存，需要时跳过了“objc-msgSend”的过程，直接调用："><a href="#方法调用优化：在GNUstep实现的版本中，为了提高autorelease方法执行的速度，使用了“IMP-Caching”的方式，及将函数指针提前缓存，需要时跳过了“objc-msgSend”的过程，直接调用：" class="headerlink" title="方法调用优化：在GNUstep实现的版本中，为了提高autorelease方法执行的速度，使用了“IMP Caching”的方式，及将函数指针提前缓存，需要时跳过了“objc_msgSend”的过程，直接调用："></a>方法调用优化：在GNUstep实现的版本中，为了提高autorelease方法执行的速度，使用了“IMP Caching”的方式，及将函数指针提前缓存，需要时跳过了“objc_msgSend”的过程，直接调用：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSObject.m中：</span></div><div class="line"></div><div class="line"><span class="comment">// 缓存类名</span></div><div class="line">id autorelease_class = [NSAutoreleasePool class];</div><div class="line"><span class="comment">// 缓存方法名</span></div><div class="line">SEL autorelease_sel = @selector(<span class="string">"addObject:"</span>);</div><div class="line"><span class="comment">// 缓存方法实现（函数指针）</span></div><div class="line">IMP autorelease_imp = [autorelease_class methodForSelector:autorelease_sel];</div><div class="line"></div><div class="line">- (id)autorelease &#123;</div><div class="line">    <span class="comment">// 直接调用</span></div><div class="line">    (*autorelease_imp)(autorelease_class, autorelease_sel, self);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>由于NSAutoreleasePool覆盖了autorelease的方法实现（其他对象执行的是NSObject的实现），对pool对象发送autorelease消息会抛出异常。<br>即<strong>不能对NSAutoreleasePool对象调用autorelease方法。</strong></p>
</blockquote>
<ul>
<li>补充：<strong>无论编译环境是否为ARC有效，都推荐使用@autoreleasepool块作为替代</strong>，以提高代码可读性。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：-3-autorelease&quot;&gt;&lt;a href=&quot;#内存管理篇：-3-autorelease&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇： 3.autorelease&quot;&gt;&lt;/a&gt;内存管理篇： 3.autorelease&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;autorelease的实质：&lt;/strong&gt;&lt;br&gt;&lt;em&gt;将创建的对象加入到NSAutoreleasePool管理“数组”中，并告知ARC系统暂时不要对此对象进行处理。待pool对象在其所属的NSRunLoop循环一次完成，准备释放（drain）时，对“数组”中的所有对象依次调用release方法。此时ARC再对对象进行内存管理。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》2</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A%202.alloc-retain-release-dealloc%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇： 2.alloc-retain-release-dealloc的实现/</id>
    <published>2019-01-06T07:42:32.544Z</published>
    <updated>2019-01-06T07:59:00.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：-2-alloc-retain-release-dealloc的实现"><a href="#内存管理篇：-2-alloc-retain-release-dealloc的实现" class="headerlink" title="内存管理篇： 2.alloc/retain/release/dealloc的实现"></a>内存管理篇： 2.alloc/retain/release/dealloc的实现</h2><h3 id="GNUstep的实现方式"><a href="#GNUstep的实现方式" class="headerlink" title="GNUstep的实现方式"></a>GNUstep的实现方式</h3><p><strong>GNUstep的版本将引用计数与对象的内存组合在一起，方便读写存取。</strong><br><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546151436-GNUstep%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84.jpg" alt="img"><br>如图所示，使用了一个objc_layout结构体来表示引用计数，其大体结构及alloc的简化代码为：</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_layout</span> &#123;</span></div><div class="line">    <span class="comment">// 引用计数</span></div><div class="line">    NSUInteger retained;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (id)alloc &#123;</div><div class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(struct objc_layout) + 对象大小；</div><div class="line">    <span class="comment">// 创建一段大小为size的连续内存，并写入0</span></div><div class="line">    <span class="comment">// 使用结构体指针指向此地址</span></div><div class="line">    struct objc_layout *p = <span class="built_in">calloc</span>(<span class="number">1</span>, size);</div><div class="line">    <span class="comment">// 返回id类型对象（地址+1即为对象的地址）</span></div><div class="line">    <span class="keyword">return</span> (id)(p + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>由此可知，retainCount即返回结构体中retained成员的值即可：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (NSUinteger)retainCount &#123;</div><div class="line">    <span class="keyword">return</span> NSExtraRefCount(self) + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> NSUInteger</span></div><div class="line"><span class="title">NSExtraRefCount</span><span class="params">(id anObject)</span> &#123;</div><div class="line">    <span class="comment">// 由于对象指向的是+1的地址，故-1即为结构体实例的地址</span></div><div class="line">    <span class="keyword">return</span> ((struct objc_layout *)anObject)[<span class="number">-1</span>].retained;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于初始化的内存中填充数据为0，故新对象的引用计数为1（0+1）。</p>
<p><strong>而对于retain和release操作，即对retained变量进行+1和-1操作即可。而且，在release操作时，当retained为0时，运行时系统即调用dealloc方法，将对象的内存释放。</strong></p>
<h3 id="苹果的实现方式"><a href="#苹果的实现方式" class="headerlink" title="苹果的实现方式"></a>苹果的实现方式</h3><p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546151340-Apple%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E8%A1%A8.jpg" alt="img"></p>
<p>直接看图，<strong>苹果使用了单独的引用计数表来存储所有对象的引用计数。且使用了对象内存地址的hash值作为key，将引用计数作为内容进行保存</strong>。简单的实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)retainCount &#123;</div><div class="line">    <span class="keyword">return</span> (NSUInteger)__CFDoExternRefOperation(OPERATION_retainCount, self);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)retain &#123;</div><div class="line">    <span class="keyword">return</span> (id)__CFDoExternRefOperation(OPERATION_retain, self);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)release &#123;</div><div class="line">    <span class="keyword">return</span> (id)__CFDoExternRefOperation(OPERATION_release, self);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所调用的方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __CFDoExternRefOperation(<span class="keyword">unitptr_t</span> op, id obj) &#123;</div><div class="line">    <span class="comment">// 获取引用计数表</span></div><div class="line">    CFBasicHashRef table = 取得对象对应的散列表(obj);</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    </div><div class="line">    <span class="comment">// 根据操作分发给不同函数</span></div><div class="line">    <span class="keyword">switch</span> (op) &#123;</div><div class="line">    <span class="keyword">case</span> OPERATION_retainCount:</div><div class="line">        <span class="comment">// retainCount</span></div><div class="line">        count = CFBasicHashGetCountOfKey(table, obj);</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    <span class="keyword">case</span> OPERATION_retain:</div><div class="line">        <span class="comment">// retain</span></div><div class="line">        CFBasicHashAddValue(table, obj);</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    <span class="keyword">case</span> OPERATION_release:</div><div class="line">        <span class="comment">// release</span></div><div class="line">        count = CFBasicHashRemoveValue(table, obj);</div><div class="line">        <span class="keyword">return</span> (<span class="number">0</span> == count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>苹果的实现虽然看似没有GNUstep的方式简单，实际上其优点也是显而易见：</p>
<ul>
<li>对象创建时，其内存分配无需考虑引用计数相关逻辑，结构纯粹。</li>
<li>引用计数表中，可以根据内存块的地址追溯对象的原始内存，方便调试及内存泄露检测等功能。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：-2-alloc-retain-release-dealloc的实现&quot;&gt;&lt;a href=&quot;#内存管理篇：-2-alloc-retain-release-dealloc的实现&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇： 2.alloc/retain/release/dealloc的实现&quot;&gt;&lt;/a&gt;内存管理篇： 2.alloc/retain/release/dealloc的实现&lt;/h2&gt;&lt;h3 id=&quot;GNUstep的实现方式&quot;&gt;&lt;a href=&quot;#GNUstep的实现方式&quot; class=&quot;headerlink&quot; title=&quot;GNUstep的实现方式&quot;&gt;&lt;/a&gt;GNUstep的实现方式&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;GNUstep的版本将引用计数与对象的内存组合在一起，方便读写存取。&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546151436-GNUstep%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84.jpg&quot; alt=&quot;img&quot;&gt;&lt;br&gt;如图所示，使用了一个objc_layout结构体来表示引用计数，其大体结构及alloc的简化代码为：&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》1</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A1.%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇：1.引用计数的思考方式/</id>
    <published>2019-01-06T07:40:57.232Z</published>
    <updated>2019-01-06T07:44:02.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：1-引用计数的思考方式"><a href="#内存管理篇：1-引用计数的思考方式" class="headerlink" title="内存管理篇：1.引用计数的思考方式"></a>内存管理篇：1.引用计数的思考方式</h2><h3 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h3><blockquote>
<p>支持条件：</p>
<ul>
<li>clang（LLVM编译器）3.0版本以上</li>
<li>objc4 OC运行时库 493.9版本以上</li>
<li>编译器设置中置为“ARC有效”</li>
<li>Xcode 4.2版本以上</li>
</ul>
</blockquote>
<a id="more"></a>
<p><strong>简单来说，ARC作为编译器特性（运行时库帮助解决weak自动置nil及autorelease优化等功能），系统在编译期根据情况，为代码自动添加retain、release等内存管理代码</strong>。开发者只需要集中精力在业务实现上即可，无需过多考虑内存问题。</p>
<h3 id="内存管理的思考方式"><a href="#内存管理的思考方式" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h3><p>实际上，<strong>无需过多考虑“引用计数”这个数字</strong>，编码时只需遵循如下四种规则：</p>
<ol>
<li>自己生成的对象，自己持有（alloc/new/copy/mutableCopy）</li>
<li>非自己生成的对象，自己也能持有（retain）</li>
<li>自己不再需要持有的对象，自己释放（release）</li>
<li>非自己持有的对象，自己无法释放（系统自动dealloc）</li>
</ol>
<h4 id="自己生成的对象，自己持有"><a href="#自己生成的对象，自己持有" class="headerlink" title="自己生成的对象，自己持有"></a>自己生成的对象，自己持有</h4><p>除了默认的四种创建对象方法，这里还需注意一点：<br>对于自定义的class，在编写API时，需要遵循“命名法则”：即将创建对象的方法，声明为：</p>
<ul>
<li>allocXXX…</li>
<li>newXXX…</li>
<li>copyXXX…</li>
<li>mutableCopyXXX…</li>
</ul>
<p>ARC环境下，系统会根据方法命名，自动将返回的对象使用__strong修饰，即新对象的内存由创建方负责管理，也就是“自己持有创建的对象”。</p>
<h4 id="非自己生成的对象，自己也能持有"><a href="#非自己生成的对象，自己也能持有" class="headerlink" title="非自己生成的对象，自己也能持有"></a>非自己生成的对象，自己也能持有</h4><ul>
<li>对于其他对象（非自己创建的），如果需要正常使用的话，需要对新对象进行“retain”操作。</li>
<li>对于类方法创建对象的API（如NSMutableArray的array方法），一般来说，内部返回的都是“autorelease”修饰的对象，内存是无需接收方管理的。直接使用即可。</li>
</ul>
<h4 id="自己不再需要持有的对象，自己释放"><a href="#自己不再需要持有的对象，自己释放" class="headerlink" title="自己不再需要持有的对象，自己释放"></a>自己不再需要持有的对象，自己释放</h4><ul>
<li>使用完毕后的对象，无论是否为自己创建，需要持有方对其调用“release”操作，放弃持有。</li>
<li>类方法创建得到的对象，无需释放。</li>
</ul>
<h4 id="非自己持有的对象，自己无法释放"><a href="#非自己持有的对象，自己无法释放" class="headerlink" title="非自己持有的对象，自己无法释放"></a>非自己持有的对象，自己无法释放</h4><p>dealloc为系统在运行期根据对象的引用情况自动调用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：1-引用计数的思考方式&quot;&gt;&lt;a href=&quot;#内存管理篇：1-引用计数的思考方式&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇：1.引用计数的思考方式&quot;&gt;&lt;/a&gt;内存管理篇：1.引用计数的思考方式&lt;/h2&gt;&lt;h3 id=&quot;自动引用计数&quot;&gt;&lt;a href=&quot;#自动引用计数&quot; class=&quot;headerlink&quot; title=&quot;自动引用计数&quot;&gt;&lt;/a&gt;自动引用计数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;支持条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clang（LLVM编译器）3.0版本以上&lt;/li&gt;
&lt;li&gt;objc4 OC运行时库 493.9版本以上&lt;/li&gt;
&lt;li&gt;编译器设置中置为“ARC有效”&lt;/li&gt;
&lt;li&gt;Xcode 4.2版本以上&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Objective-C 20 编写高质量iOS与OS X代码的52个有效方法》读书笔记</title>
    <link href="http://yoursite.com/2018/12/25/%E3%80%8AEffective%20Objective-C%2020%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/25/《Effective Objective-C 20 编写高质量iOS与OS X代码的52个有效方法》读书笔记/</id>
    <published>2018-12-25T02:49:27.623Z</published>
    <updated>2019-01-06T07:41:16.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第1章：熟悉Objective-C"><a href="#第1章：熟悉Objective-C" class="headerlink" title="第1章：熟悉Objective-C"></a>第1章：熟悉Objective-C</h2><h3 id="第4条：多用类型常量，少用-define预处理指令"><a href="#第4条：多用类型常量，少用-define预处理指令" class="headerlink" title="第4条：多用类型常量，少用#define预处理指令"></a>第4条：多用类型常量，少用#define预处理指令</h3><ul>
<li>声明类型常量好处是，编译器可以知道此变量的类型，且可以防止外部随意修改</li>
<li>声明规则：<a id="more"></a>
<ul>
<li><strong>全局常量</strong>：<em>使用extern开头，类名作为常量前缀（OC无命名空间，避免冲突），const修饰常量名，头文件声明，实现文件赋值</em>。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在ViewController.h中声明通知名</span></div><div class="line"><span class="comment">/** ViewController视图已加载通知 */</span></div><div class="line"><span class="keyword">extern</span> NSString * <span class="keyword">const</span> ViewControllerViewDidLoadNotification;</div><div class="line"></div><div class="line"><span class="comment">// 在ViewController.m中赋值通知名</span></div><div class="line">NSString *<span class="keyword">const</span> ViewControllerViewDidLoadNotification = @<span class="string">"ViewControllerViewDidLoadNotification"</span>;</div></pre></td></tr></table></figure>
<pre><code>- **局部常量**（类内使用的）：*使用static开头，“k”作为常量前缀，const修饰常量名，在实现文件中声明及赋值*。这种局部常量（static + const）的优点是：**编译器不会创建符号，会像#define一样，把遇到的所有变量直接替换，但是带有类型信息**。
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 动画时长 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> NSTimeInterval kAnimationDuration = <span class="number">0.3</span>;</div></pre></td></tr></table></figure>
<h3 id="第5条：用枚举表示状态、选项、状态码"><a href="#第5条：用枚举表示状态、选项、状态码" class="headerlink" title="第5条：用枚举表示状态、选项、状态码"></a>第5条：用枚举表示状态、选项、状态码</h3><ul>
<li>如果枚举值的选项可以进行组合，则使用时，用“按位或”操作（“|”）。声明枚举时，使用二进制进行表示。</li>
<li><p>NS_OPTIONS和NS_ENUM其实都是定义的宏，可以向下兼容（编译器支持新枚举特性时生成的enum带有类型声明，否则没有）。</p>
<blockquote>
<p>凡是需要以按位或操作来组合的枚举都应使用NS_OPTIONS定义。若是枚举不需要相互组合，则应使用NS_ENUM来定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_OPTIONS</span><span class="params">(NSUInteger, UIViewAutoresizing)</span> </span>&#123;</div><div class="line">    UIViewAutoresizingNone                 = <span class="number">0</span>,</div><div class="line">    UIViewAutoresizingFlexibleLeftMargin   = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    UIViewAutoresizingFlexibleWidth        = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    UIViewAutoresizingFlexibleRightMargin  = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    UIViewAutoresizingFlexibleTopMargin    = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    UIViewAutoresizingFlexibleHeight       = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    UIViewAutoresizingFlexibleBottomMargin = <span class="number">1</span> &lt;&lt; <span class="number">5</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_ENUM</span><span class="params">(NSInteger, UIViewAnimationTransition)</span> </span>&#123;</div><div class="line">    UIViewAnimationTransitionNone,</div><div class="line">    UIViewAnimationTransitionFlipFromLeft,</div><div class="line">    UIViewAnimationTransitionFlipFromRight,</div><div class="line">    UIViewAnimationTransitionCurlUp,</div><div class="line">    UIViewAnimationTransitionCurlDown,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>在switch语句中，使用枚举变量时，不要加default分支，这样编译器会提示是否还有未枚举的分支。</p>
</li>
</ul>
<h2 id="第2章：对象、消息、运行期"><a href="#第2章：对象、消息、运行期" class="headerlink" title="第2章：对象、消息、运行期"></a>第2章：对象、消息、运行期</h2><h3 id="第7条：在对象内部尽量直接访问实例变量"><a href="#第7条：在对象内部尽量直接访问实例变量" class="headerlink" title="第7条：在对象内部尽量直接访问实例变量"></a>第7条：在对象内部尽量直接访问实例变量</h3><blockquote>
<ul>
<li>在对象内部读取数据时，应该直接通过实例变量来读；而写入数据时，则应通过属性来写。</li>
<li>在初始化和dealloc方法中，总应该直接通过实例变量来读写数据。</li>
<li>有时会使用惰性初始化技术配置某份数据，这种情况下，需要通过属性来读取数据。</li>
</ul>
</blockquote>
<h3 id="第8条：理解“对象等同性”这一概念"><a href="#第8条：理解“对象等同性”这一概念" class="headerlink" title="第8条：理解“对象等同性”这一概念"></a>第8条：理解“对象等同性”这一概念</h3><ul>
<li><p>NSObject协议中用于判定对象相等的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isEqual:(id)object;</div><div class="line">- (NSUInteger)hash;</div><div class="line"><span class="comment">// 协议里hash为只读属性： @property (readonly) NSUInteger hash;</span></div></pre></td></tr></table></figure>
</li>
<li><p><em>如果两个对象相等，则其hash值必然相等；反之则不一定</em>（因为isEqual:方法先回判断两者是否为相同类型）。</p>
</li>
<li>自定义类型中，若提供判定对象相等方法，可以实现上述方法和属性。</li>
</ul>
<h3 id="第11条：理解objc-msgSend的作用"><a href="#第11条：理解objc-msgSend的作用" class="headerlink" title="第11条：理解objc_msgSend的作用"></a>第11条：理解objc_msgSend的作用</h3><ul>
<li><em>objc_msgSend使用了“<strong>尾调用优化</strong>”技术（tail-call optimization），实质上即为<strong>函数调用的栈帧的复用</strong></em>。<ul>
<li>一般来说，函数调用时，会在栈中生成新的栈帧（申请一块新的栈内存），跳转过去进行新函数的调用。当在函数执行过程中，如果再次调用其他函数，会再次压入新的栈帧并跳转，直到依次调用完毕再返回并释放栈帧的内存。</li>
<li>对于OC来说，<strong>当函数调用中，如果返回值“仅仅”是调用其他函数（没有其他任何操作，如进行其他运算等），则会把当前函数调用的栈帧直接交给调用的新函数（自身数据变为新函数的）</strong>。这样即避免了重复申请内存，而且调用地址不必来回跳转，在多个函数调用时对效率的提升和内存控制尤其有效。</li>
<li><a href="https://www.jianshu.com/p/9e3cd9b1095a?from=timeline&amp;isappinstalled=0" target="_blank" rel="external">iOS objc_msgSend尾调用优化机制详解</a></li>
</ul>
</li>
</ul>
<h3 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h3><ul>
<li><strong>动态方法解析</strong>：<em>在方法未找到时执行的第一步操作，即</em>resolveInstanceMethod<em>和</em>resolveClassMethod<em>方法。在此函数中使用class_addMethod可以为当前类添加动态实例方法或类方法（类方法要添加到class的meta class中）</em>。之后，当前实例即会缓存并调用新添加的方法，且以后会在缓存列表内直接调用，不再进行方法解析步骤。一般来说，我们会在存在@dymamic修饰的属性所属的类中通过此方法来提供实现，比如Core Data的数据类中。</li>
<li><strong>备援接收者</strong>：动态解析过程若没有提供方法时，则进入此步骤。<em>在方法</em>forwardingTargetForSelector<em>方法中，运行时系统会将此selector对应的消息原封不动转发给返回的对象</em>。利用<em>此方法可以模拟出”多继承“</em>：即将对应方法转发给可以执行的类实例。</li>
<li><strong>完整的消息转发机制</strong>：上一步只能转发原始消息，如果对方法参数等需要二次修改，则需要通过此步骤（上一步没有成功执行即会进入此步，所以性能代价会大一些）。<em>系统会通过forwardInvocation方法，将原target、selector和parameter等封装为NSInvocation对象。我们需要将此invocation的目标改为对应的接收者，使其执行。也可以对selector进行修改，如增删改参数，甚至改变selector。不能处理时，通过super返回给父类实例进行处理，直到NSObject最终触发doesNotRecognizeSelector方法，抛出异常</em>。</li>
</ul>
<h2 id="接口与API设计"><a href="#接口与API设计" class="headerlink" title="接口与API设计"></a>接口与API设计</h2><h3 id="第15条：用前缀避免命名空间冲突"><a href="#第15条：用前缀避免命名空间冲突" class="headerlink" title="第15条：用前缀避免命名空间冲突"></a>第15条：用前缀避免命名空间冲突</h3><ul>
<li>双字符前缀是苹果官方使用的，自己需要使用至少三字符的前缀，避免冲突。</li>
<li>类的实现文件中定义的c函数在编译后的目标文件（.o）中会成为顶级符号（全局符号），所有也需要添加前缀。</li>
<li>自己封装的库中，若引用了其他第三方库，应对第三方库的类文件分别添加前缀命名。防止其他项目引入本库后，再引入同样的第三方库产生命名冲突。</li>
</ul>
<h3 id="第16条：提供“全能初始化”方法"><a href="#第16条：提供“全能初始化”方法" class="headerlink" title="第16条：提供“全能初始化”方法"></a>第16条：提供“全能初始化”方法</h3><ul>
<li>类中存在多个初始化方法是，需要指定一个作为“全能初始化”方法（designed initializer），使其余方法都通过此方法进行实例的初始化。对后期修改维护有利。</li>
<li><p>子类继承时，<strong>如果子类存在自己独特的“全能初始化”方法，则必须要覆盖父类的全能初始化方法（防止使用父类的方法创建子类实例）</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 父类：矩形类</span></div><div class="line"></div><div class="line"><span class="comment">// EOCRectangle.h</span></div><div class="line">@interface EOCRectangle: NSObject</div><div class="line"></div><div class="line">@property (nonatomic, assign, readonly) <span class="keyword">float</span> width;</div><div class="line">@property (nonatomic, assign, readonly) <span class="keyword">float</span> height;</div><div class="line"></div><div class="line">- (id)initWithWidth:(<span class="keyword">float</span>)width </div><div class="line">         andHeight:(<span class="keyword">float</span>)height;</div><div class="line">         </div><div class="line">@end</div><div class="line"></div><div class="line"><span class="comment">// EOCRectangle.m</span></div><div class="line">@implementation EOCRectangle</div><div class="line"></div><div class="line"><span class="comment">/** designed initializer */</span></div><div class="line">- (id)initWithWidth:(<span class="keyword">float</span>)width </div><div class="line">         andHeight:(<span class="keyword">float</span>)height &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        _width = width;</div><div class="line">        _height = height;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** overrided initializer */</span></div><div class="line">- (id)init &#123;</div><div class="line">    <span class="keyword">return</span> [self initWithWidth:<span class="number">5.0f</span> andHeight:<span class="number">10.0f</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"><span class="comment">// 子类：正方形类</span></div><div class="line"></div><div class="line"><span class="comment">// EOCSquare.h</span></div><div class="line">@interface EOCSquare: EOCRectangle</div><div class="line"></div><div class="line">- (id)initWithDimension:(<span class="keyword">float</span>)dimension;</div><div class="line">         </div><div class="line">@end</div><div class="line"><span class="comment">// EOCSquare.m</span></div><div class="line">@implementation EOCSquare</div><div class="line"><span class="comment">/** designed initializer */</span></div><div class="line">- (id)initWithDimension:(<span class="keyword">float</span>)dimension &#123;</div><div class="line">    <span class="keyword">return</span> [super initWithWidth:dimension height:dimension];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** overrided initializer */</span></div><div class="line">- (id)initWithWidth:(<span class="keyword">float</span>)width </div><div class="line">         andHeight:(<span class="keyword">float</span>)height &#123;</div><div class="line">    <span class="keyword">float</span> dimension = MAX(width, height);</div><div class="line">    <span class="keyword">return</span> [self initWithDimension:dimenson];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
<li><p><em>如果类中存在多种完全不同的初始化方式，则需要多个“全能初始化”方法</em>。如遵循NSCoding协议的类，需要实现<em>initWithCoder</em>方法作为单独的“全能初始化”方法。</p>
</li>
</ul>
<h3 id="第18条：尽量使用不可变对象"><a href="#第18条：尽量使用不可变对象" class="headerlink" title="第18条：尽量使用不可变对象"></a>第18条：尽量使用不可变对象</h3><ul>
<li><p>需要公开的属性，尽量用“readonly”进行语义修饰，防止外部进行修改；内部修改时，在分类中可以修改为“readwrite”</p>
<ol>
<li>由于iOS的属性一般使用“nonatomic”进行修饰，为了防止极端情况下，内部修改属性时，外部读取产生的数据不统一的情况，可以使用GCD的同步操作对读取和修改进行统一处理。</li>
<li>不考虑外部使用“KVC”的方式对只读属性设置，甚至是根据实例内存布局通过内存偏移量对属性进行强制修改的情况，还是应该尽量遵循此属性声明方式。</li>
</ol>
</li>
<li><p>对于可变集合对象，尽量不要作为公开属性。</p>
<ol>
<li>可以声明为分类中的属性，或是类的成员变量。在外部使用不可变的版本进行属性公开。</li>
<li>增删改等方式，提供公开方法用以外部调用。</li>
</ol>
</li>
</ul>
<h3 id="第20条：为私有方法名加前缀"><a href="#第20条：为私有方法名加前缀" class="headerlink" title="第20条：为私有方法名加前缀"></a>第20条：为私有方法名加前缀</h3><ul>
<li>为普通类的私有方法（在实现文件中的声明并只提供内部调用的方法）的方法名前，添加“p_”作为前缀，提高调试效率。</li>
<li>对于自定义的库文件类，甚至可以使用“类名 + _”的方式为私有方法命名，尽量减少命名冲突。</li>
</ul>
<h3 id="第21条：理解Objective-C错误类型"><a href="#第21条：理解Objective-C错误类型" class="headerlink" title="第21条：理解Objective-C错误类型"></a>第21条：理解Objective-C错误类型</h3><ul>
<li>在ARC下，代码不是“异常安全”（exception safe）的：即当抛出异常时，本应该在作用域末尾自动释放的内存，便不会释放了（MRC下，需要开发者在抛出异常之前手动释放所有内存，极易出错）。</li>
</ul>
<h2 id="第4章-协议与分类"><a href="#第4章-协议与分类" class="headerlink" title="第4章 协议与分类"></a>第4章 协议与分类</h2><h3 id="第23条：通过委托与数据源协议进行对象间通信"><a href="#第23条：通过委托与数据源协议进行对象间通信" class="headerlink" title="第23条：通过委托与数据源协议进行对象间通信"></a>第23条：通过委托与数据源协议进行对象间通信</h3><ul>
<li><p>协议分类及数据流向</p>
<ol>
<li><em>若某类实例需要让其他对象代替实现某些逻辑功能，则可以把需要实现逻辑的方法抽象为协议，让“其他对象”成为其“委托对象”，实现协议的方法</em>。此模式即为“<strong>委托模式</strong>”，数据流向为“Class -&gt; Delegate”。如：UITableViewDelegate，tableView实例将处理列表点击等行为委托给代理对象（如UIViewController实例）。 </li>
<li><em>若某类实例需要通过一些方法获取数据，则可以把这些方法抽象为协议，让“其他对象”成为其“委托对象”，实现协议的方法</em>。这种委托模式也称为“<strong>数据源模式</strong>”，数据流向为“Data Source -&gt; Class”。如：UITableViewDataSource，tableView实例从代理对象（如UIViewController实例）中获取列表的数据等。<br><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F.jpg" alt="img"></li>
</ol>
</li>
<li><p>提高协议方法的调用效率</p>
<ol>
<li>众所周知，对于optional的协议方法，调用前需要进行实现判断（使用respondsToSelector方法）。若在委托对象中频繁调用此方法（如下载progress等），每次进行响应判断，意义不大，且效率可能会出现瓶颈。针对此情况，可以使用“位段”方式（bitField）进行优化，对于是否能够响应协议方法调用，只需要一个二进制位（bit）即可进行表示。所以，可以为委托对象所属的类声明一个结构体成员变量。此结构体内部的成员与所有的optional协议方法一一对应，成员值均为0或1。然后，在设置代理对象时，将所有的实现情况进行判断并赋值到此结构体成员变量中。即可在实际回调协议方法是免去每次进行响应判断，提高效率。<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">@porotocol DownloadProtocol: NSObject</div><div class="line">...</div><div class="line">@optional</div><div class="line">- (<span class="keyword">void</span>)onDownloadingProgress:(CGFloat)progress;</div><div class="line">...</div><div class="line">@end</div><div class="line"></div><div class="line">...</div><div class="line"><span class="meta">#import <span class="meta-string">"DownloadProtocol.h"</span></span></div><div class="line"></div><div class="line">@interface MyClass: NSObject</div><div class="line"></div><div class="line">@property (nonatomic, weak) id&lt;DownloadProtocol&gt; delegate;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@<span class="function">interface <span class="title">MyClass</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 声明结构体变量成员</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">        NSInteger onDownloadProgress: <span class="number">0</span></div><div class="line">    &#125; _downloadProtocolFlag;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MyClass: NSObject </div><div class="line"></div><div class="line"><span class="comment">// 手动实现delegate的setter，对代理对象的方法实现情况进行检查并缓存</span></div><div class="line">- (<span class="keyword">void</span>)setDelegate:(id&lt;DownloadProtocol&gt;)delegate &#123;</div><div class="line">    _delegate = delegate;</div><div class="line">    <span class="comment">// 对所有optional方法依次检查，这里只是一个</span></div><div class="line">    _downloadProtocolFlag.onDownloadProgress = [_delegate respondsToSelector:@selector(onDownloadProgress:)]; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实际调用时，即可简化判断，提高效率</span></div><div class="line">- (<span class="keyword">void</span>)testMyDownloadProgress:(CGFloat)progress &#123;</div><div class="line">    <span class="keyword">if</span> (_downloadProtocolFlag.onDownloadProgress) &#123;</div><div class="line">    [self.delegate onDownloadProgress: progress];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="第24条：将类的实现代码分散到便于管理的数个分类之中"><a href="#第24条：将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="第24条：将类的实现代码分散到便于管理的数个分类之中"></a>第24条：将类的实现代码分散到便于管理的数个分类之中</h3><ul>
<li>有时无需继承父类时，可有使用分类（Category）方式扩展类的功能。</li>
<li>使用分类将不同功能的的代码分隔到不同区块中，可以防止原始类过于庞大，代码逻辑清晰，便于调试（调用信息的符号中会显示为不同的分类）。</li>
<li>对于类或模块内部的私有方法，可以创建private分类，且不对外公开。</li>
</ul>
<h3 id="第25条：总是为第三方类的分类名称加前缀"><a href="#第25条：总是为第三方类的分类名称加前缀" class="headerlink" title="第25条：总是为第三方类的分类名称加前缀"></a>第25条：总是为第三方类的分类名称加前缀</h3><ul>
<li>在OC中，由于分类是在运行期进行加载，且各分类的加载顺序依照编译顺序而定（在build phrase中可以手动修改，当然分类的加载是在本类之后），故分类中可以覆盖本类的方法。但是，当多个分类同时覆盖本类方法后，便无法确定调用时的版本了（只能依靠build phrase顺序）【分类的方法在加载时，依照类似链表“头插法”的方式，将方法添加到类的方法列表头部，原始方法则被挤到了后面，所以当调用方法时，系统只找到第一个方法后便直接跳转执行】。所以，为了避免分类异常覆盖本类方法时，需要如下做法进行改进（OC没有命名空间）：<ul>
<li>创建类的分类时，需要为分类名前添加自定义的前缀</li>
<li>创建分类的方法时，需要为各方法名前也添加自定义的前缀</li>
</ul>
</li>
</ul>
<h3 id="第26条：勿在分类中声明属性"><a href="#第26条：勿在分类中声明属性" class="headerlink" title="第26条：勿在分类中声明属性"></a>第26条：勿在分类中声明属性</h3><ul>
<li><strong>“属性”实质上是数据的封装，背后有成员变量作为数据支持，系统只是合成了setter和getter</strong>。</li>
<li>分类中不能生成真正属性的原因：由于编译期，本类的内存布局结构已经确定（实例变量区域的偏移量及大小已经确定），分类在运行期加载时，已经无法在本类的实例变量区域进行操作。</li>
<li><p>分类中声明并实现“属性”的方法：</p>
<ol>
<li>使用正常语法声明，使用相关对象（associate object）实现属性的setter和getter（只是模拟属性，添加了内存管理语义）。</li>
<li>使用@dynamic关键字告知编译器，在运行期再提供实现。可以通过方法转发的方式（如resolveInstanceMethod）提供动态实现。</li>
</ol>
</li>
<li><p>由于属性是实例变量的封装，所以建议属性依照实例变量的方式，在主类的头文件中直接进行声明。</p>
</li>
<li><strong>分类只是用于扩展类的功能，而非提供类的额外存储</strong>。</li>
</ul>
<h3 id="第27条：使用“class-continuation分类”隐藏实现细节"><a href="#第27条：使用“class-continuation分类”隐藏实现细节" class="headerlink" title="第27条：使用“class-continuation分类”隐藏实现细节"></a>第27条：使用“class-continuation分类”隐藏实现细节</h3><ul>
<li>此”class-continuation分类”即为类的扩展（extension）。这是唯一可以在其中同时声明实例变量、属性和方法的匿名“分类”。原因：<strong>类的扩展是与本类源码一起在编译期共同确定类的内存布局</strong>，所以此时会将扩展的实例变量等一同加载到类的对应部分。</li>
<li>可以将不对外公开的方法、属性和实例变量等放在扩展中。</li>
<li>在扩展中引用C++代码，可以只在当前类中引入C++编译器进行混合编译（类实现文件要用“.mm”为后缀），头文件对外仍然只公布简洁的OC风格接口。</li>
<li>可以在头文件中声明只读属性，扩展中重新声明为可读写属性，内部使用setter进行数据修改时，可以正常触发KVO监听回调。</li>
<li>在扩展中遵循只在内部使用的协议。</li>
</ul>
<h3 id="第28条：通过协议提供匿名对象"><a href="#第28条：通过协议提供匿名对象" class="headerlink" title="第28条：通过协议提供匿名对象"></a>第28条：通过协议提供匿名对象</h3><ul>
<li>对于无需外部关心的类（只关心提供的功能），可以将所需功能封装为协议，将类名淡化为遵循此协议的匿名对象（id<myprotocol>）。</myprotocol></li>
<li>此种设计方法可以在后端进行实现替换，而对前端调用方完全透明，增加了编码的灵活程度，也降低了耦合（例如使用不同类数据库进行数据存取，协议中只提供通用的连接、断开、增删改查等方法即可）。</li>
</ul>
<h2 id="第5章-内存管理"><a href="#第5章-内存管理" class="headerlink" title="第5章 内存管理"></a>第5章 内存管理</h2><h3 id="第29条：理解引用计数"><a href="#第29条：理解引用计数" class="headerlink" title="第29条：理解引用计数"></a>第29条：理解引用计数</h3><p>在手动管理内存模式下，内存管理语义为“strong”的属性，其setter一般都是如此实现的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setFoo:(id)foo &#123;</div><div class="line">    <span class="comment">// 1.保留新值</span></div><div class="line">    [foo retain];</div><div class="line">    <span class="comment">// 2.释放原有值</span></div><div class="line">    [_foo release];</div><div class="line">    <span class="comment">// 3.赋值</span></div><div class="line">    _foo = foo</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，为何1和2步骤不能交换呢？<br>因为，当使用重复的foo对象进行设置时（假设foo对象只被本类实例保留），先释放，会导致foo对象内存被系统回收。致使setter失败【使用ARC即可避免此问题发生】。</p>
<h3 id="第30条：以ARC简化引用计数"><a href="#第30条：以ARC简化引用计数" class="headerlink" title="第30条：以ARC简化引用计数"></a>第30条：以ARC简化引用计数</h3><ul>
<li><p>使用ARC时必须遵循的方法命名规则</p>
<ul>
<li>方法名以“alloc、new、copy和mutableCopy”为开头时，其返回对象的内存管理由调用方负责。即在方法中，系统不会自动添加内存管理语句。</li>
<li>方法名以其他方式命名的，其返回对象的内存管理由方法自身负责。即在方法中，系统会自动给返回的对象添加autorelease操作。</li>
<li>ARC对代码的额外优化：<ul>
<li>编译期：对于多次的retain和release操作，ARC会根据情况适当成对的抵消掉此调用操作。</li>
<li>运行期：例如，对于使用方法调用返回autorelease的对象，ARC会使用objc_autoreleaseReturnValue来替代传统的autorelease方法，此时会检查函数返回之后的代码：若调用方需要对此对象进行保留，则不会执行autorelease操作，而是设置全局标志位；调用方retain时，使用objc_retainAutoreleasedReturnValue函数，检查此标志位，若已置位，则不执行retain操作，直接使用。这样，通过检测标志位代替传统的autorelease和retain，优化了执行效率。</li>
</ul>
</li>
</ul>
</li>
<li><p>ARC如何清理实例变量</p>
<ul>
<li>在ARC环境下，系统会利用Objective-C++的清理例程（cleanup routine）特性，待回收的对象会调用所有C++对象的析构函数。ARC借住此特性，会在dealloc中生成清理内存的代码。</li>
<li>对于非OC对象，如CF对象或手动malloc的对象，在dealloc方法中还是需要手动释放这些对象的内存</li>
<li>在deallc中无需调用super方法。</li>
</ul>
</li>
<li><p>覆写内存管理方法</p>
<ul>
<li>不能调用或覆盖release和retain等内存管理方法【单例中尤其注意】：ARC会优化retain、release等相关操作，使其不经过OC的消息派发机制（方法调用），底层使用了c函数版本进行了实现。</li>
</ul>
</li>
</ul>
<h3 id="第31条：在dealloc方法中只释放引用并解除监听"><a href="#第31条：在dealloc方法中只释放引用并解除监听" class="headerlink" title="第31条：在dealloc方法中只释放引用并解除监听"></a>第31条：在dealloc方法中只释放引用并解除监听</h3><ul>
<li>ARC下，dealloc方法会自动释放创建的OC对象的引用，但需要手动释放Core Foundation创建的对象和其他手动申请内存并创建的c对象。</li>
<li>dealloc中尽量不要调用其他方法（如实例方法等）</li>
<li>dealloc过程中，由于实例已经处于“释放状态”，无法确保代码会执行在确定的线程上。故不能在释放是执行异步多线程代码。</li>
<li>dealloc中释放KVO监听和NSNotificationCenter中注册的通知</li>
<li>对于创建和释放开销较大和系统稀缺的资源，一般单独创建自己的清理方法（如数据库对象的“连接”和“关闭”操作等）。使用完成后即提示调用者进行及时的资源清理，而不是在dealloc中释放内存【dealloc中可以检查是否正确清理此对象，没有则自动调用并给出debug提示】。</li>
</ul>
<h3 id="第35条：用“僵尸对象”调试内存管理问题"><a href="#第35条：用“僵尸对象”调试内存管理问题" class="headerlink" title="第35条：用“僵尸对象”调试内存管理问题"></a>第35条：用“僵尸对象”调试内存管理问题</h3><ul>
<li>在“XCode-&gt;Scheme-&gt;Run-&gt;Diagnostics”中，勾选“Enable Zombie Objects”选项，开启功能。</li>
<li>在调试模式中，开启此功能，可以防止已释放对象的内存被覆盖重用，可以帮助追溯调用过程和类型信息等。</li>
<li><p>已释放对象转化为“僵尸对象”的过程（“僵尸模式”开启的情况下，NSObject的dealloc会在运行期swizzle成类似以下代码）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取待释放对象所属的类</span></div><div class="line">Class cls = object_getClass(self);</div><div class="line"></div><div class="line"><span class="comment">// 获取类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *clsName = class_getName(cls);</div><div class="line"></div><div class="line"><span class="comment">// 生成僵尸类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *zombieClsName = <span class="string">"_NSZombie_"</span> + clsName;</div><div class="line"></div><div class="line"><span class="comment">// 查看是否存在此类</span></div><div class="line">Class zombieCls = objc_lookUpClass(zombieClsName);</div><div class="line"></div><div class="line"><span class="comment">// 不存在，则创建此类</span></div><div class="line"><span class="keyword">if</span> (!zombieCls) &#123;</div><div class="line">    <span class="comment">// 获取名为“_NSZombie_”的样板类</span></div><div class="line">    Class baseZombieCls = objc_lookUpClass(<span class="string">"_NSZombie_"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 复制样板类来创建此类</span></div><div class="line">    zombieCls = objc_duplicateClass(baseZombieCls, zombieClsName, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 正常释放实例</span></div><div class="line">objc_destructInstance(self);</div><div class="line"></div><div class="line"><span class="comment">// 将实例所属类指向新的僵尸类（替换isa指向）</span></div><div class="line">objc_setClass(self, zombieCls);</div><div class="line"></div><div class="line"><span class="comment">// 现在，self即为“_NSZombie_原始类名”的实例了</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>“僵尸类“为”根类“，只存在isa指针，没有任何方法实现（样本类的拷贝）。故其实例接收到的所有消息都需要进行完整的消息转发</strong>。被转发的消息响应过程的伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取对象类名</span></div><div class="line">Class cls = objc_getClass(self);</div><div class="line"></div><div class="line"><span class="comment">// 查看是否为”僵尸类“</span></div><div class="line"><span class="keyword">if</span> (String_has_prefix(clsName, <span class="string">"_NSZombie_"</span>)) &#123;</div><div class="line">    <span class="comment">// 是，则对象是”僵尸对象“</span></div><div class="line">    </div><div class="line">    <span class="comment">// 获取原始类名（去掉前缀）</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *originClsName = substring_from(clsName, <span class="number">10</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取消息的选择器名</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *selectorName = sel_getName(_cmd);</div><div class="line">    </div><div class="line">    <span class="comment">// 输出消息</span></div><div class="line">    Log(<span class="string">"*** -[%s %s]: message sent to deallocated instance %p"</span>, originClsName, selectorName, self);</div><div class="line">    </div><div class="line">    <span class="comment">// 结束程序</span></div><div class="line">    <span class="built_in">abort</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="第6章-块与大中枢派发"><a href="#第6章-块与大中枢派发" class="headerlink" title="第6章 块与大中枢派发"></a>第6章 块与大中枢派发</h2><h3 id="第37条：理解“块”这一概念"><a href="#第37条：理解“块”这一概念" class="headerlink" title="第37条：理解“块”这一概念"></a>第37条：理解“块”这一概念</h3><ul>
<li>块的内部结构（内存布局）：</li>
</ul>
<table>
<thead>
<tr>
<th>Block</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>void*</td>
<td>isa</td>
<td>指向Class对象的指针</td>
</tr>
<tr>
<td>int</td>
<td>flags</td>
<td></td>
</tr>
<tr>
<td>int</td>
<td>reserved</td>
<td></td>
</tr>
<tr>
<td>void (<em>)(void </em>, …)</td>
<td>invoke</td>
<td>实现函数的指针</td>
</tr>
<tr>
<td>struct *</td>
<td>descriptor</td>
<td>块的描述信息</td>
</tr>
<tr>
<td>捕获到的外部变量…</td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>isa指针，指向的是Block的类型。Block分为三种类型：_NSConcreteStackBlock，_NSConcreteMallocBlock和_NSConcreteGlobalBlock。其中，_NSConcreteStackBlock分配在占内存上；_NSConcreteMallocBlock分配在堆内存上，有引用计数（即为对象），会捕获外部变量；_NSConcreteGlobalBlock不捕获变量（内部不使用外部变量的Block即为全局Block），内存在编译期即可确定，相当于单例。</li>
<li>其中，<strong>invoke实现函数的参数为Block结构体实例的指针</strong>，使用它<em>可以方便地从内存中读取出捕获到的变量</em>。</li>
<li>捕获到的变量，对于对象，只是拷贝了其指针（对象的引用计数+1）</li>
</ol>
<table>
<thead>
<tr>
<th>descriptor</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>unsigned long int</td>
<td>reserved</td>
<td></td>
</tr>
<tr>
<td>unsigned long int</td>
<td>size</td>
<td></td>
</tr>
<tr>
<td>void (<em>)(void </em>, void *)</td>
<td>copy</td>
<td>拷贝辅助函数</td>
</tr>
<tr>
<td>void (<em>)(void </em>, coid *)</td>
<td>dispose</td>
<td>释放辅助函数</td>
</tr>
</tbody>
</table>
<p>描述结构体中，copy和dispose函数的作用是拷贝和释放Block实例时，对捕获到的变量进行拷贝和释放操作。</p>
<h3 id="第39条：用handler块降低代码分散程度"><a href="#第39条：用handler块降低代码分散程度" class="headerlink" title="第39条：用handler块降低代码分散程度"></a>第39条：用handler块降低代码分散程度</h3><ul>
<li>使用Block代替Delegate，可以使代码分布整体化，降低分散程度。特别是<strong>对于自身实例作为多个不同对象的Delegate时（如多个UITableView实例均使用self作为delegate），由于每个Delegate均存在自己单独的handler回调，省去了对于不同对象判断执行的过程，使代码更加简洁</strong>。</li>
<li>设置带有handler回调的API时，根据需要可以添加执行队列（NSOperation或GCD等）参数。外部调用时，可以根据不同需要灵活配置（如系统添加通知的方法addObserverForName方法）。</li>
</ul>
<h3 id="第41条：多用派发队列，少用同步锁"><a href="#第41条：多用派发队列，少用同步锁" class="headerlink" title="第41条：多用派发队列，少用同步锁"></a>第41条：多用派发队列，少用同步锁</h3><p>我们知道，在iOS端，为了保证性能，类中property的内存语义一般被设置为“nonatomic”。但是极端情况下，为了保证属性的读写为原子操作，需要单独进行处理。一般来说，可以使用synchronized关键字对self进行同步加锁，或者使用NSLock进行锁操作，但是频繁读写时效率会很低。<br>为了保证效率，使用GCD的派发队列进行property的读写操作优化：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TestClass.h</span></div><div class="line">@interface TestClass : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSString *testName;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"><span class="comment">// TestClass.m</span></div><div class="line">@<span class="function">interface <span class="title">TestClass</span> <span class="params">()</span> </span>&#123;</div><div class="line">    NSString *_testName;</div><div class="line">    <span class="keyword">dispatch_queue_t</span> _propertyQueue;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation</div><div class="line">- (instancetype)init &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        <span class="comment">// 创建并发队列</span></div><div class="line">        _propertyQueue = dispatch_queue_create(<span class="string">"com.TestClass.p_queue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div><div class="line">- (NSString *)testName &#123;</div><div class="line">    <span class="comment">// 并发队列读取（使用async是因为需要同步返回函数值，实质上也是并发执行）</span></div><div class="line">    __block NSString *tmpValue;</div><div class="line">    dispatch_sync(_propertyQueue, ^&#123;</div><div class="line">        tmpValue = self-&gt;_testName;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> tmpValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setTestName:(NSString *)testName &#123;</div><div class="line">    <span class="comment">// 使用barrier，可以保证此处为原子操作（其余操作等待完成后才开始执行）</span></div><div class="line">    dispatch_barrier_async(_propertyQueue, ^&#123;</div><div class="line">        self-&gt;_testName = testName;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：</p>
<ul>
<li>使用dispatch_barrier_async或dispatch_barrier_sync方法时，必须保证执行的队列是手动创建的并发队列，不能是串行或者系统的全局队列**。</li>
<li>栅栏方法同步和异步版本的区别是：同步添加Block时，队列会等待Block执行完毕后再返回（继续执行下面的代码）；异步时，则立即返回，可以将后面的任务派发的队列中（但是不会执行），等待栅栏Block执行完毕后，继续执行其他任务。</li>
<li>在property中两种版本均可。但是同步版本的效率更高（异步版本需要拷贝Block）。</li>
</ul>
<p><strong>对于property，getter使用自定义并发队列的async操作，setter使用自定义并发队列的barrier操作。</strong></p>
<h3 id="第42条：多用GCD，少用performSelector系列方法"><a href="#第42条：多用GCD，少用performSelector系列方法" class="headerlink" title="第42条：多用GCD，少用performSelector系列方法"></a>第42条：多用GCD，少用performSelector系列方法</h3><p>除了performSelector系列方法的API局限性以外（不能传多于两个参数、线程相关API参数过少、参数只能为对象类型、不能调用c方法等），最重要的是内存管理方面的缺失。示例如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SEL selector;</div><div class="line"><span class="keyword">if</span> (<span class="comment">/** 条件1 */</span>) &#123;</div><div class="line">    selector = @SEL(newObject);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/** 条件2 */</span>) &#123;</div><div class="line">    selector = @SEL(copy);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    selector = @SEL(someProperty)</div><div class="line">&#125;</div><div class="line"><span class="comment">// object为类实例，包含newObject构造器、copy方法和someProperty属性</span></div><div class="line">id ret = [object performSelector:selector];</div></pre></td></tr></table></figure></p>
<p>在ARC环境下，如果是条件1和2，编译器会将执行后返回对象的内存管理权交给接收者；如果是直接设置属性，则不进行内存管理。由于现在selector的选择是在运行时进行绑定，编译器就无法根据方法签名（名称、参数及返回值类型）使用ARC进行内存管理了（甚至不知道改selector是否存在）。所以，这种写法下，编译器会提示警告，可能会发生内存泄漏。<br>使用Block配合GCD的相关方法可以有效解决这些问题，如参数、线程、内存管理等。</p>
<h3 id="第43条：掌握GCD及操作队列的使用时机"><a href="#第43条：掌握GCD及操作队列的使用时机" class="headerlink" title="第43条：掌握GCD及操作队列的使用时机"></a>第43条：掌握GCD及操作队列的使用时机</h3><ul>
<li>在解决多线程与任务管理的问题时，可以根据需要灵活选用GCD或操作队列（NSOperationQueue）进行处理。</li>
<li>操作队列是Objective-C的API，底层使用GCD进行实现，具备了大多数GCD的功能，其优点如下：<ul>
<li>可以取消尚未执行的任务（NSOperation对象）。</li>
<li>可以对操作的执行状况使用KVO进行监听，如“isCancelled”、“isFinished”等。</li>
<li>可以对单个的操作进行优先级设置（即执行线程的优先级）；GCD只能对并发的派发队列进行优先级设置，颗粒度不够细。</li>
<li>对不同操作之间可以设置依赖关系。通过设置依赖，更容易控制不同任务之间的执行顺序。</li>
<li>可以重用任务对象（NSOperation），系统默认实现了NSBlockOperation子类。由于支持了面向对象，我们可以根据需要对父类进行继承，扩展操作对象的功能。</li>
</ul>
</li>
</ul>
<h3 id="第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务："><a href="#第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务：" class="headerlink" title="第44条：通过Dispatch Group机制，根据系统资源状况来执行任务："></a>第44条：通过Dispatch Group机制，根据系统资源状况来执行任务：</h3><p><strong>在后台自动执行一系列任务，完成后通知主线程</strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对象数组，这里是模拟多个需要执行任务的对象</span></div><div class="line">NSArray *objects = @[...];</div><div class="line"></div><div class="line"><span class="comment">// 后台执行，需要获取并发队列</span></div><div class="line"><span class="keyword">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 一系列任务，可以编写成组</span></div><div class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</div><div class="line"></div><div class="line"><span class="comment">// 自动执行：异步加入组中，不能阻塞执行队列</span></div><div class="line"><span class="keyword">for</span> (id object in objects) &#123;</div><div class="line">    dispatch_group_async(</div><div class="line">        group, </div><div class="line">        globalQueue,</div><div class="line">        ^&#123; [object performTask]; &#125;</div><div class="line">    );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 完成后通知主线程</span></div><div class="line">dispatch_group_notify(</div><div class="line">    group,</div><div class="line">    dispatch_get_main_queue(),</div><div class="line">    ^&#123;</div><div class="line">        <span class="comment">// 主线程执行代码</span></div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>主要是利用了GCD并发队列的强大功能，GCD会根据系统资源占用情况，自动分配CPU核心和不同数量的执行线程去并发执行任务，可以最大限度的优化多线程编程性能。通过dispatch_group_t对象，可以根据需要阻塞（可以使用dispatch_group_wait）执行队列或是监控任务的执行过程。</p>
<h3 id="第46条：不要使用dispatch-get-current-queue"><a href="#第46条：不要使用dispatch-get-current-queue" class="headerlink" title="第46条：不要使用dispatch_get_current_queue"></a>第46条：不要使用dispatch_get_current_queue</h3><blockquote>
<p>首先结论是：<strong>dispatch_get_current_queue对避免代码死锁没有任何作用，因为它返回的只是当前队列的名称，而不是当前执行任务所在的队列！！！</strong></p>
</blockquote>
<p>我们以队列层级的例子一步步进行验证：</p>
<ol>
<li>父队列为串行队列rootQueue；子队列有两个，分别为串行队列serialQueue和并行队列concurrentQueue。我们分别向两个子队列中派发任务，看一下实际的执行情况：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根队列</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">void</span> *rootQueueKey = <span class="string">"com.jiji.rootQueue"</span>;</div><div class="line"><span class="keyword">dispatch_queue_t</span> rootQueue = dispatch_queue_create(rootQueueKey, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line"><span class="comment">// 创建两个队列</span></div><div class="line"><span class="keyword">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.jiji.concurrent1"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="keyword">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.jiji.serial1"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line"><span class="comment">// 设置两个子队列的根队列为rootQueue（串行）</span></div><div class="line">dispatch_set_target_queue(concurrentQueue, rootQueue);</div><div class="line">dispatch_set_target_queue(serialQueue, rootQueue);</div><div class="line"></div><div class="line"><span class="comment">// 配置任务：</span></div><div class="line"><span class="comment">// 并行子队列异步派发两个任务</span></div><div class="line">dispatch_async(concurrentQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task1"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_async(concurrentQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task2"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 串行子队列异步派发两个任务</span></div><div class="line">dispatch_async(serialQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task3"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_async(serialQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task4"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行结果如下：</p>
<blockquote>
<p>TestIos[32776:25904922] task1<br>TestIos[32776:25904922] task2<br>TestIos[32776:25904922] task3<br>TestIos[32776:25904922] task4</p>
</blockquote>
<p>以上情况表明：不管子队列是串行还是并行队列，由于根队列为串行，最终任务的执行情况为串行执行。</p>
<ol>
<li>现在，我的疑问是，由于任务串行执行，是否证明真正执行任务的队列是串行队列（根队列）？带着这个疑问，我们先验证一下：<br>我们修改一下代码，在task1的执行块中，查看一下当前队列：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_async(concurrentQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task1"</span>);</div><div class="line">    NSLog(@<span class="string">"%@"</span>, dispatch_get_current_queue());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>执行结果：</p>
<blockquote>
<p>TestIos[32776:25904922] <os_dispatch_queue: com.jiji.concurrent1=""></os_dispatch_queue:></p>
</blockquote>
<p>看来不是，还是在并发队列这个子队列中。<br>那现在做个假设，如果在此任务中，再向其根队列派发一个同步任务进行验证（如果死锁，证明实际任务运行在根队列中；否则就在当前子队列中）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_async(concurrentQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task1"</span>);</div><div class="line">    NSLog(@<span class="string">"%@"</span>, dispatch_get_current_queue());</div><div class="line">    <span class="comment">// 添加同步任务</span></div><div class="line">    dispatch_sync(rootQueue, ^&#123;</div><div class="line">        NSLog(@<span class="string">"new task!!!"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>结果很显然，发生了死锁，证明实际上此任务是在根队列（target queue）中执行（向serialQueue中派发同步任务也会如此，虽然不会死锁，但线程一直等待，永远不会返回）。</p>
<p><strong>这也就证明了，实际上<em>dispatch_get_current_queue</em>方法并没有返回真正的运行队列</strong>。如果以此API返回值进行判断，则无法保证多线程环境下代码执行的准确性。</p>
<ol>
<li>那若是如此，如何来确保任务执行在正确的队列中？使用<em>dispatch_queue_set_specfic</em>和<em>dispatch_get_specific</em>两个API即可。我们修改一下示例代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根队列</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">void</span> *rootQueueKey = <span class="string">"com.jiji.rootQueue"</span>;</div><div class="line"><span class="keyword">dispatch_queue_t</span> rootQueue = dispatch_queue_create(rootQueueKey, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="comment">// 根队列用指定key进行标记</span></div><div class="line">dispatch_queue_set_specific(rootQueue, rootQueueKey, &amp;rootQueueKey, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建两个队列</span></div><div class="line"><span class="keyword">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.jiji.concurrent1"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="keyword">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.jiji.serial1"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line"><span class="comment">// 设置两个子队列的根队列为rootQueue（串行）</span></div><div class="line">dispatch_set_target_queue(concurrentQueue, rootQueue);</div><div class="line">dispatch_set_target_queue(serialQueue, rootQueue);</div><div class="line"><span class="comment">// 配置任务：</span></div><div class="line">dispatch_async(concurrentQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task1"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 根据key获取队列绑定的值（存在，则当前队列即为key所对应的队列）</span></div><div class="line">    <span class="keyword">void</span> *context = dispatch_get_specific(rootQueueKey);</div><div class="line">    <span class="keyword">if</span> (context) &#123;</div><div class="line">        <span class="comment">// 当前执行在根队列上，不可以向根队列及任何子队列派发同步任务</span></div><div class="line">        NSLog(@<span class="string">"NO!!!!!!"</span>);</div><div class="line">        <span class="comment">// 但是，调用dispatch_get_current_queue()返回的队列，可以让你误以为是在本队列执行，所以可能会向其他队列派发同步任务，继而发生死锁。这也就是绝对不要使用此API的原因。</span></div><div class="line">        NSLog(@<span class="string">"%@"</span>, dispatch_get_current_queue());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 可以派发任意任务</span></div><div class="line">        NSLog(@<span class="string">"OK~"</span>);</div><div class="line">        dispatch_sync(rootQueue, ^&#123;</div><div class="line">            NSLog(@<span class="string">"new task!!!"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如代码所示，<strong>当dispatch_get_specific返回对应的数据时，证明当前运行队列即为检查的目标队列</strong>。如果此时还需要向此队列派发同步任务，只要直接执行任务即可，无需派发。</p>
<ul>
<li>注意：对于实现真正原子操作的property来说，由于实现setter和getter时使用了自定义队列，且setter中使用同步方式返回实例的值。为了防止死锁发生，一定要避免他人使用相同队列对属性进行访问。</li>
</ul>
<h2 id="第7章-系统框架"><a href="#第7章-系统框架" class="headerlink" title="第7章 系统框架"></a>第7章 系统框架</h2><h3 id="第48条：多用块枚举，少用for循环"><a href="#第48条：多用块枚举，少用for循环" class="headerlink" title="第48条：多用块枚举，少用for循环"></a>第48条：多用块枚举，少用for循环</h3><ol>
<li><p>快速枚举（for…in）：</p>
<ul>
<li>比传统for循环更高效，与NSEnumerator一样但语法更简洁。</li>
<li>可以遍历如NSArray、NSDictionary、NSSet及自定义Collection（需遵循NSFastEnumeration协议）。</li>
<li>NSEnumerator由于也遵循NSFastEnumeration协议，所以可以支持用快速枚举对集合进行反向遍历。</li>
<li>缺点是不支持获取对象索引。</li>
</ul>
</li>
<li><p>使用集合带有Block参数的遍历API进行集合遍历：</p>
<ul>
<li>方便获取对象索引及字典键值</li>
<li>可以直接修改Block的参数类型为对象类型，利用编译器特性，省去了进行显示地类型转换</li>
<li>对于可以配置NSEnumerationOptions的版本，可以方便设置如反向遍历、并发遍历（底层使用GCD队列）等功能。</li>
</ul>
</li>
</ol>
<h3 id="第49条：对自定义其内存管理语义的collection使用无缝桥接"><a href="#第49条：对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="第49条：对自定义其内存管理语义的collection使用无缝桥接"></a>第49条：对自定义其内存管理语义的collection使用无缝桥接</h3><ol>
<li><p>主要先说一下OC对象和CF变量指针的转换方式：</p>
<ul>
<li>__bridge: 互相转换均可，不进行内存所有权转换。即转换后仍然使用原系统对对象或变量进行内存管理（OC使用ARC，CF手动使用CFRelease）</li>
<li>__bridge_transfer：一般用于CF-&gt;OC的过程中，转换所有权。转换后的OC对象，系统自动使用ARC对其进行内存管理。</li>
<li>__bridge_retained：一般用于OC-&gt;CF的过程中，转换所有权。转换后的CF变量，其指针的引用计数+1，需要使用CFRelease等函数进行手动内存管理。</li>
</ul>
</li>
<li><p>可以通过CF框架，使用C语言API创建集合对象，之后利用桥接转换为OC对象，即可得到符合自定义内存管理语义的集合对象。</p>
<ul>
<li>如使用NSDictionary时，需要key无需支持NSCopy协议，则可以使用此方法，创建CFDictionaryRef指针（在CFDictionaryRetainCallBack和CFDictionaryReleaseCallBack中进行修改）后，使用__bridge_transfer转换为OC对象并转换所有权。</li>
</ul>
</li>
</ol>
<h3 id="第51条：精简initialize与load的实现代码"><a href="#第51条：精简initialize与load的实现代码" class="headerlink" title="第51条：精简initialize与load的实现代码"></a>第51条：精简initialize与load的实现代码</h3><ol>
<li><strong>+(void)load</strong>:</li>
</ol>
<ul>
<li>运行时系统启动时，加载Class或Category时会调用（只有Class和Category存在此方法，且只执行一次）。</li>
<li>load方法不遵循继承体系，只有对应的Class活Category实现后才会被调用。</li>
<li>系统首先加载所有Class，后加载Category。Class间加载顺序无法确定（不要在Class的load方法中调用其他Class）。</li>
<li>load方法执行时会阻塞程序运行，所以不要执行复杂任务或加锁。<blockquote>
<p>自己只在Category中利用load方法，swizzle过所属Class的方法，在内部实现自定义功能（如记录日志）。</p>
</blockquote>
</li>
</ul>
<ol>
<li><strong>+(void)initialize</strong>:</li>
</ol>
<ul>
<li>被调用时为“懒加载”：运行时系统在首次调用Class时，先调用本方法；不访问不调用。</li>
<li>initialize方法执行时，运行时系统已启动完毕，加载（load）了所有相关类，可以在此调用任意类的任意方法。但是<em>需要注意避免“循环引用”导致的死锁</em>（如ClassA的initialize中调用ClassB，ClassB首次执行，initialize中使用ClassA）。</li>
<li>本方法遵循继承体系，本类未实现时会执行父类的版本。</li>
<li>initialize方法执行时，是“线程安全”的，会阻塞其他类运行，无需加锁。但是，方法无法确定其执行线程，所以仍然不能运行过于复杂的任务（如果是UI线程则会导致APP无响应）。</li>
</ul>
<blockquote>
<p>正确用法举例：</p>
<ol>
<li>在initialize中初始化声明为全局static的OC对象（由于在编译期只能初始化基本数据类型或NSString变量或常量）。</li>
<li>单例类可以用于初始化内部数据。</li>
</ol>
</blockquote>
<h3 id="第52条：别忘了NSTimer会保留其目标对象"><a href="#第52条：别忘了NSTimer会保留其目标对象" class="headerlink" title="第52条：别忘了NSTimer会保留其目标对象"></a>第52条：别忘了NSTimer会保留其目标对象</h3><p>举例来说，以常用的直接在当前runloop中配置计时器“<em>scheduledTimerWithTimeInterval: target: selector: userInfo: repeats:</em>”为例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@interface EOCClass: NSObject &#123;</div><div class="line">    NSTimer *_pollTimer;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)startPolling;</div><div class="line">- (<span class="keyword">void</span>)stopPolling;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClass</div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    [_pollTimer invalidate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)stopPolling &#123;</div><div class="line">    [_pollTimer invalidate];</div><div class="line">    _pollTimer = nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)startPolling &#123;</div><div class="line">    _pollTimer = [NSTimer scheduledTimerWithTimeInterval:<span class="number">5.0</span></div><div class="line">        target:self</div><div class="line">        selector:@selector(p_doPoll)</div><div class="line">        userInfo:nil</div><div class="line">        repeat:YES</div><div class="line">    ];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)p_doPoll &#123;</div><div class="line">    <span class="comment">// ...task</span></div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>以上代码可以很明显地看出，由于_pollTimer的target是self，即NSTimer保留了EOCClass实例，且_pollTimer是EOCClass的实例变量，在ARC下隐含为强引用的内存管理方式，最终导致了引用循环。</p>
<p><strong>解决方法：</strong><br><em>由于类对象本身即为单例，使用类对象作为NSTimer的target即可巧妙“避免”此问题发生。</em></p>
<p>这里使用了NSTimer的Category进行处理，免除使用第三方类或者自定义单例对象：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@interface NSTimer (EOCBlocksSupport)</div><div class="line">+ (NSTimer *)scheduledTimerWithTimerInterval:(NSTimeInterval)interval</div><div class="line">    block:(void (^)())block</div><div class="line">    repeats:(BOOL)repeats;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation NSTimer (EOCBlocksSupport)</div><div class="line"></div><div class="line">+ (NSTimer *)scheduledTimerWithTimerInterval:(NSTimeInterval)interval</div><div class="line">    block:(void (^)())block</div><div class="line">    repeats:(BOOL)repeats &#123;</div><div class="line">    </div><div class="line">    return [self scheduledTimerWithTimerInterval:interval</div><div class="line">        target:self</div><div class="line">        selector:@selector(eoc_blockInvoke:)</div><div class="line">        userInfo:[block copy]</div><div class="line">        repeats:repeats</div><div class="line">    ];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)eoc_blockInvoke:(NSTimer *)timer &#123;</div><div class="line">    // 取出timer中设置的userInfo，并转换为block对象</div><div class="line">    void (^block)() = timer.userInfo;</div><div class="line">    if (block) &#123;</div><div class="line">        // 执行</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>配置定时器时，按如下方式:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)startPolling &#123;</div><div class="line">    <span class="comment">// 声明self的弱引用指针（使Block对象通过弱指针保留对象，引用计数不变）</span></div><div class="line">    __weak EOCClass *weakSelf = self;</div><div class="line">    _pollTimer = [NSTimer scheduledTimerWithTimerInterval:<span class="number">5.0</span></div><div class="line">    block:^&#123;</div><div class="line">        <span class="comment">// 声明强指针指向weakSelf，可防止使用时对象被释放</span></div><div class="line">        __strong EOCClass *strongSelf = weakSelf;</div><div class="line">        [strongSelf p_doPoll];</div><div class="line">    &#125;</div><div class="line">    repeats:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上所示，</p>
<ul>
<li>此时只有EOCClass的实例保留了定时器，定时器对象并不会保留self。完成使用后，self即可被正常释放，同时定时器被取消。</li>
<li>使用<strong>weak指针还可以保证更加安全（相比</strong>unsafe_unretain），因为self实例释放后，若是忘记取消定时器，对weak指针发消息是安全的。</li>
</ul>
<blockquote>
<p><em>注意</em>：NSTimer类在iOS10中新增了带有Block参数的API，不过使用时依然要注意循环引用的问题。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第1章：熟悉Objective-C&quot;&gt;&lt;a href=&quot;#第1章：熟悉Objective-C&quot; class=&quot;headerlink&quot; title=&quot;第1章：熟悉Objective-C&quot;&gt;&lt;/a&gt;第1章：熟悉Objective-C&lt;/h2&gt;&lt;h3 id=&quot;第4条：多用类型常量，少用-define预处理指令&quot;&gt;&lt;a href=&quot;#第4条：多用类型常量，少用-define预处理指令&quot; class=&quot;headerlink&quot; title=&quot;第4条：多用类型常量，少用#define预处理指令&quot;&gt;&lt;/a&gt;第4条：多用类型常量，少用#define预处理指令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;声明类型常量好处是，编译器可以知道此变量的类型，且可以防止外部随意修改&lt;/li&gt;
&lt;li&gt;声明规则：
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
