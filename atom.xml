<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭吉吉的瞎记空间</title>
  <subtitle>技术的，瞎说的，啥都有吧。。。希望。。。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-05T09:33:05.507Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>臭吉吉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NSNotification学习</title>
    <link href="http://yoursite.com/2019/09/05/NSNotification%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/09/05/NSNotification学习/</id>
    <published>2019-09-05T09:32:07.380Z</published>
    <updated>2019-09-05T09:33:05.507Z</updated>
    
    <content type="html"><![CDATA[<p>主要分为NSNotification、NSNotificationCenter和底层队列NSNotificationQueue。</p>
<p>优点：跨层通信、解耦。</p>
<p>使用注意点：尽量将所有的通知名和观察对象的关联关系放置在独立文件中，方便维护与查找。<br><a id="more"></a></p>
<h4 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h4><p>包含了<em>通知名name</em>、<em>发送通知的对象object</em>以及<em>保存信息userInfo</em>。<br>其中，NSNotificationName作为区分通知的存在。</p>
<p>一般通过NSNotificationCenter的相关API来自动创建通知对象，无需手动创建（NSNotification是类簇，调用init初始化会抛异常）。</p>
<h4 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h4><p>系统默认为APP通过实现了名为<em>defaultCenter</em>的单例通知中心对象。所有的通知（跨层，跨线程）默认都通过此对象进行通知的分发。</p>
<p>系统收到post通知请求时，会扫描注册到NSNotificationCenter对象中的所有观察者分发表。因此在大量频繁使用通知进行通信时，可以考虑使用自定义的NSNotificationCenter对象来提高性能。</p>
<p>系统提供了<em>target+selector</em>和<em>block+queue</em>两种方式来向NSNotificationCenter注册观察者。</p>
<p>默认在哪个线程发送通知（post），就在哪个线程执行回调。除非通过block的方式发送通知，指定执行的队列。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<p>在block+queue的方式中，由于执行时机的不同（runloop的不同时机）NSNotificationCenter会将block拷贝到堆中进行保留。因此需要注意对象的捕获即内存引用循环问题。</p>
</blockquote>
<h4 id="NSNotificationCenter的同步执行"><a href="#NSNotificationCenter的同步执行" class="headerlink" title="NSNotificationCenter的同步执行"></a>NSNotificationCenter的同步执行</h4><p><strong>不管接收通知的观察者回调在什么线程上执行，通过NSNotificationCenter调用postNotification时都是同步执行的</strong>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line">    <span class="comment">// 主线程监听</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(testSelector1) name:<span class="string">@"jiji.notification.test"</span> object:<span class="literal">nil</span>];</div><div class="line">   </div><div class="line">   <span class="comment">// 后台线程监听</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(testSelector1) name:<span class="string">@"jiji.notification.test"</span> object:<span class="literal">nil</span>];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">// 主线程监听，block方式，强制在主队列执行（主线程）</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"jiji.notification.test"</span> object:<span class="literal">nil</span> queue:[<span class="built_in">NSOperationQueue</span> mainQueue] usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"thread - %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">   </div><div class="line">    <span class="comment">// 在后台线程发送通知</span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.jiji.queue1"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), queue, ^&#123;</div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"jiji.notification.test"</span> object:<span class="literal">nil</span>];</div><div class="line">        <span class="built_in">NSNotificationQueue</span></div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"post finish----"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)testSelector1 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"thread - %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2019-09-05 13:39:36.594370+0800 TestAPP[52913:2455622] -[ViewController testSelector1]<br>2019-09-05 13:39:36.594797+0800 TestAPP[52913:2455622] thread - <nsthread: 0x6000001bd640="">{number = 4, name = (null)}<br>2019-09-05 13:39:36.595147+0800 TestAPP[52913:2455622] -[ViewController testSelector1]<br>2019-09-05 13:39:36.595537+0800 TestAPP[52913:2455622] thread - <nsthread: 0x6000001bd640="">{number = 4, name = (null)}<br>2019-09-05 13:39:36.596740+0800 TestAPP[52913:2455552] -[ViewController viewDidLoad]_block_invoke<br>2019-09-05 13:39:36.597015+0800 TestAPP[52913:2455552] thread - <nsthread: 0x6000001d1f00="">{number = 1, name = main}<br>2019-09-05 13:39:36.597354+0800 TestAPP[52913:2455622] post finish—-</nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>可以看到：</p>
<ol>
<li>除block版本监听外，其他的通知回调执行线程都与发送通知的线程相同（<strong>保证线程安全</strong>）。</li>
<li><strong>NSNotificationCenter主动发送通知为同步操作：在所有监听者的回调执行结束之后，被阻塞的发送操作才向下继续执行</strong>。因此，对于消耗性能或长时间的操作需要尽量避免。</li>
</ol>
<p><strong>发送同步通知的过程，就是直接的消息发送</strong>。</p>
<h4 id="NSNotificationQueue的异步调用"><a href="#NSNotificationQueue的异步调用" class="headerlink" title="NSNotificationQueue的异步调用"></a>NSNotificationQueue的异步调用</h4><p>那如果监听方需要执行的任务确实需要长时间怎么办？除了可以在回调中将任务放在子线程中运行（GCD或NSOperationQueue），Foundation框架本身也提供了一个异步发送通知的方式，也就是NSNotificationQueue。</p>
<p>NSNotificationQueue，顾名思义，是一个保存着NSNotification的FIFO队列。</p>
<p><strong>每个线程都有自己默认的NSNotificationQueue对象，可以与NSNotificationCenter进行关联，通过center异步发送通知</strong>。</p>
<ul>
<li>NSNotificationQueue可以根据线程所属的runloop确定通知发送的时机：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSPostingStyle</span>) &#123;</div><div class="line">    <span class="built_in">NSPostWhenIdle</span> = <span class="number">1</span>, <span class="comment">// runloop空闲时发送</span></div><div class="line">    <span class="built_in">NSPostASAP</span> = <span class="number">2</span>, <span class="comment">// runloop中尽快发送（as soon as possible）</span></div><div class="line">    <span class="built_in">NSPostNow</span> = <span class="number">3</span> <span class="comment">// 实时发送（直接通过NSNotificationCenter发送）</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>NSNotificationQueue可以根据类型将相同的通知进行合并发送。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSNotificationCoalescing</span>) &#123;</div><div class="line">    <span class="built_in">NSNotificationNoCoalescing</span> = <span class="number">0</span>, <span class="comment">// 不合并</span></div><div class="line">    <span class="built_in">NSNotificationCoalescingOnName</span> = <span class="number">1</span>, <span class="comment">// 同名通知合并</span></div><div class="line">    <span class="built_in">NSNotificationCoalescingOnSender</span> = <span class="number">2</span> <span class="comment">// 相同object合并</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>完整类定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNotificationQueue</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line"><span class="keyword">@private</span></div><div class="line">    <span class="comment">// 关联的NSNotificationCenter对象</span></div><div class="line">    <span class="keyword">id</span>	_notificationCenter; </div><div class="line">    <span class="comment">// runloop尽快发送队列</span></div><div class="line">    <span class="keyword">id</span>	_asapQueue;</div><div class="line">    <span class="comment">// 尽快发送队列对应的首个观察者</span></div><div class="line">    <span class="keyword">id</span>	_asapObs;</div><div class="line">    <span class="comment">// runloop空闲时刻队列</span></div><div class="line">    <span class="keyword">id</span>	_idleQueue;</div><div class="line">    <span class="comment">// 空闲时刻队列对应的首个观察者</span></div><div class="line">    <span class="keyword">id</span>	_idleObs;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** 默认队列 */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSNotificationQueue</span> *defaultQueue;</div><div class="line"></div><div class="line"><span class="comment">/** 绑定NSNotificationCenter对象并初始化自身 */</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithNotificationCenter:(<span class="built_in">NSNotificationCenter</span> *)notificationCenter <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div><div class="line"></div><div class="line"><span class="comment">/** NSNotification入队，并指定发送时机（根据时机进入不同的私有队列） */</span></div><div class="line">- (<span class="keyword">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle;</div><div class="line"><span class="comment">/** 针对指定的runloop的mode，NSNotification入队，并指定发送时机及合并方式 */</span></div><div class="line">- (<span class="keyword">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle coalesceMask:(<span class="built_in">NSNotificationCoalescing</span>)coalesceMask forModes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</div><div class="line"></div><div class="line"><span class="comment">/** NSNotification出队，并指定合并方式 */</span></div><div class="line">- (<span class="keyword">void</span>)dequeueNotificationsMatching:(<span class="built_in">NSNotification</span> *)notification coalesceMask:(<span class="built_in">NSUInteger</span>)coalesceMask;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>根据实现，根据私有成员变量，可以猜想一下：</p>
<ol>
<li>NSNotificationQueue可能只是一个对象封装，内部的_asapQueue和_idleQueue才是真正的队列容器。根据入队NSNotification对象时设置的配置信息，插入到相应的队列中。 </li>
<li>在NSNotification对象出队准备执行时，需要在绑定的NSNotificationCenter的分发表中查询出通知名对应的观察者信息（应该包含观察者对象及回调SEL），赋值给如_asapObs的观察者信息指针，runloop则通过此观察者进行通知回调。</li>
</ol>
<p>作为对比，看个发送异步通知的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(testSelector1) name:<span class="string">@"jiji.notification.test"</span> object:<span class="literal">nil</span>];</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(testSelector2) name:<span class="string">@"jiji.notification.test"</span> object:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 强制主线程执行</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"jiji.notification.test"</span> object:<span class="literal">nil</span> queue:[<span class="built_in">NSOperationQueue</span> mainQueue] usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"thread - %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(</div><div class="line">        dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>),</div><div class="line">        ^&#123;</div><div class="line">            <span class="comment">// 在runloop的mcurrentMode中插入item（source1），防止线程退出</span></div><div class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[<span class="built_in">NSPort</span> port] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</div><div class="line"></div><div class="line">            <span class="comment">// 在子线程发送异步通知（异步通知依赖runloop）</span></div><div class="line">            <span class="built_in">NSNotification</span> *noti = [<span class="built_in">NSNotification</span> notificationWithName:<span class="string">@"jiji.notification.test"</span> object:<span class="literal">nil</span>];</div><div class="line">            [[<span class="built_in">NSNotificationQueue</span> defaultQueue] enqueueNotification:noti postingStyle:<span class="built_in">NSPostASAP</span> coalesceMask:<span class="built_in">NSNotificationNoCoalescing</span> forModes:@[<span class="built_in">NSDefaultRunLoopMode</span>]];</div><div class="line"></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"post finish---"</span>);</div><div class="line"></div><div class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</div><div class="line">        &#125;</div><div class="line">    );</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)testSelector1 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"thread - %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)testSelector2 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"thread - %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2019-09-05 16:48:29.744888+0800 TestAPP[56766:2652270] post finish—<br>2019-09-05 16:48:29.745274+0800 TestAPP[56766:2652270] -[ViewController testSelector1]<br>2019-09-05 16:48:29.745815+0800 TestAPP[56766:2652270] thread - <nsthread: 0x6000015193c0="">{number = 5, name = (null)}<br>2019-09-05 16:48:29.746069+0800 TestAPP[56766:2652270] -[ViewController testSelector2]<br>2019-09-05 16:48:29.746229+0800 TestAPP[56766:2652270] thread - <nsthread: 0x6000015193c0="">{number = 5, name = (null)}<br>2019-09-05 16:48:29.825634+0800 TestAPP[56766:2652197] -[ViewController viewDidLoad]_block_invoke<br>2019-09-05 16:48:29.841702+0800 TestAPP[56766:2652197] thread - <nsthread: 0x600001562c00="">{number = 1, name = main}</nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>可以看到，<strong>在将NSNotification对象入队后，方法直接返回，继续向下执行。而通知则通过runloop在适当的时刻进行发出</strong>。</p>
<p>其中，若修改入队参数coalesceMask为<em>NSNotificationCoalescingOnName</em>，即可实现对于回调频率的控制（高频多次调用只发送一个通知）。对于参数postingStyle，若设置为<em>NSPostNow</em>，则为同步消息发送，与postNotification相同。</p>
<p>而且，通过调用栈信息可以看出，<strong>发送异步通知的过程，实际上是在线程runloop的指定mode中插入了一个Observer的item，待需要执行时进行调用</strong>。</p>
<h4 id="NSNotification与KVO的区别"><a href="#NSNotification与KVO的区别" class="headerlink" title="NSNotification与KVO的区别"></a>NSNotification与KVO的区别</h4><p>KVO是在对象的keyPath上添加观察者的，而NSNotification是在通知名上添加观察者。</p>
<p>NSNotification使用范围广，更加灵活，只不过需要主动发送通知才能触发给观察者。</p>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><blockquote>
<ul>
<li><a href="http://southpeak.github.io/2015/03/20/cocoa-foundation-nsnotificationcenter/" target="_blank" rel="external">Foundation: NSNotificationCenter</a></li>
<li><a href="http://southpeak.github.io/2015/03/14/nsnotification-and-multithreading/" target="_blank" rel="external">Notification与多线程</a></li>
<li><a href="https://www.jianshu.com/p/83770200d476" target="_blank" rel="external">深入理解iOS NSNotification</a></li>
<li><a href="https://philm.gitbook.io/philm-ios-wiki/mei-zhou-yue-du/shen-ru-si-kao-nsnotification" target="_blank" rel="external">深入思考NSNotification</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要分为NSNotification、NSNotificationCenter和底层队列NSNotificationQueue。&lt;/p&gt;
&lt;p&gt;优点：跨层通信、解耦。&lt;/p&gt;
&lt;p&gt;使用注意点：尽量将所有的通知名和观察对象的关联关系放置在独立文件中，方便维护与查找。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>分组并翻转链表</title>
    <link href="http://yoursite.com/2019/09/02/%E5%88%86%E7%BB%84%E5%B9%B6%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/09/02/分组并翻转链表/</id>
    <published>2019-09-02T06:35:38.957Z</published>
    <updated>2019-09-02T06:35:38.957Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个单链表的头节点 head,实现一个调整单链表的函数，使得每K个节点之间为一组进行逆序，并且从链表的尾部开始组起，头部剩余节点数量不够一组的不需要逆序。（不能使用队列或者栈作为辅助）<br><a id="more"></a><br>例如：</p>
<blockquote>
<p>链表:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;null, K = 3。<br>那么 6-&gt;7-&gt;8，3-&gt;4-&gt;5，1-&gt;2各为一组。<br>调整后：1-&gt;2-&gt;5-&gt;4-&gt;3-&gt;8-&gt;7-&gt;6-&gt;null。<br>其中 1，2不调整，因为不够一组。</p>
</blockquote>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>首先，这里先分为几个子部分进行分析：</p>
<h5 id="1-翻转链表"><a href="#1-翻转链表" class="headerlink" title="1. 翻转链表"></a>1. 翻转链表</h5><p>整体使用递归的思想。</p>
<p>若size为1时，翻转不发生，返回自身。</p>
<p>若size为2时，翻转的方式为：tail-&gt;next = head; head-&gt;next = nil; 然后返回tail。</p>
<p>若size大于2，则将head后面的子链表继续递归，之后与head进行操作：result-&gt;next = head; head-&gt;next = nil; 最后返回result。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 翻转链表 */</span></div><div class="line">LinkNode *reverseLinkList(LinkNode *linkList) &#123;</div><div class="line">    <span class="comment">// 只有自身一个</span></div><div class="line">    <span class="keyword">if</span> (!linkList.data || !linkList.next) &#123;</div><div class="line">        <span class="comment">// 直接返回自身</span></div><div class="line">        <span class="keyword">return</span> linkList;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 超过一个的，子链表递归翻转</span></div><div class="line">    LinkNode *result = reverseLinkList(linkList.next);</div><div class="line">    </div><div class="line">    <span class="comment">// 头结点的next这时已经指向的是，翻转后result链表的尾部节点，</span></div><div class="line">    <span class="comment">// 让尾部节点的next指向原头节点</span></div><div class="line">    linkList.next.next = linkList;</div><div class="line">    <span class="comment">// 原头节点作为尾部节点</span></div><div class="line">    linkList.next = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 返回反转后的头节点</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-链表分组。"><a href="#2-链表分组。" class="headerlink" title="2. 链表分组。"></a>2. 链表分组。</h5><p>还是使用递归的思想。</p>
<p>从头遍历链表，取出指定索引为k的子链表。</p>
<p>若子链表个数不够，根据题目要求，不翻转，直接返回。</p>
<p>若子链表符合要求，将此子表与其他部分分割为两个链表。</p>
<p>将子表翻转并返回；其他部分则继续进行递归操作。</p>
<p>最后，合并两部分，则得到最终结果链表。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 分组并翻转链表 */</span></div><div class="line">LinkNode *groupAndReverseLinkList(LinkNode *linkList, <span class="built_in">NSInteger</span> groupSize) &#123;</div><div class="line">    <span class="comment">// 声明头指针</span></div><div class="line">    LinkNode *head = linkList;</div><div class="line">    </div><div class="line">    <span class="comment">// 取出一组</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">1</span>; index &lt; groupSize &amp;&amp; head; index += <span class="number">1</span>) &#123;</div><div class="line">        head = head.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!head) &#123;</div><div class="line">        <span class="comment">// 不足一组（不足groupSize时，当前node已经为空）</span></div><div class="line">        <span class="comment">// 不做反转，直接返回</span></div><div class="line">        <span class="keyword">return</span> linkList;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 够一组，将此组与后面链表分隔</span></div><div class="line">    </div><div class="line">    <span class="comment">// 后面的子表</span></div><div class="line">    LinkNode *tail = head.next;</div><div class="line">    </div><div class="line">    <span class="comment">// 原满足的组作为单独组</span></div><div class="line">    head.next = <span class="literal">nil</span>;</div><div class="line">    <span class="comment">// 将满足的组进行反转</span></div><div class="line">    LinkNode *resultHead = reverseLinkList(linkList);</div><div class="line">    </div><div class="line">    <span class="comment">// 子表继续递归操作</span></div><div class="line">    LinkNode *result = groupAndReverseLinkList(tail, groupSize);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 连接两部分（反转后的满足组，尾部节点为原头节点）</span></div><div class="line">    linkList.next = result;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> resultHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-从前向后-gt-从后向前"><a href="#3-从前向后-gt-从后向前" class="headerlink" title="3. 从前向后 -&gt; 从后向前"></a>3. 从前向后 -&gt; 从后向前</h5><p>由于单链表访问的局限性，我们只能从头向后访问，因此，此题目我们转化为从前向后的分组翻转（两次翻转，负负得正）：</p>
<ol>
<li>整体链表翻转。</li>
<li>从前向后进行分组操作。</li>
<li>将结果链表再次整体翻转，得到最终结果。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// head为头结点，没有实际意义</span></div><div class="line"></div><div class="line"><span class="comment">// 翻转链表</span></div><div class="line">head.next = reverseLinkList(head.next);</div><div class="line"></div><div class="line"><span class="comment">// 从前向后进行分组翻转，3个为一组</span></div><div class="line">LinkNode *result = groupAndReverseLinkList(head.next, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="comment">// 翻转链表（得到从后向前的分组结果）</span></div><div class="line">head.next = reverseLinkList(result);</div></pre></td></tr></table></figure>
<blockquote>
<p>代码地址：<a href="https://github.com/Choujiji/Coding-in-iOS-interview/tree/master/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E9%93%BE%E8%A1%A8/GroupAndReverse" target="_blank" rel="external">GroupAndReverse</a></p>
<p>参考链接：<br><a href="https://www.jianshu.com/p/3dc5e73ab69c" target="_blank" rel="external">一道字节跳动的算法面试题，你能做出来吗？</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;给定一个单链表的头节点 head,实现一个调整单链表的函数，使得每K个节点之间为一组进行逆序，并且从链表的尾部开始组起，头部剩余节点数量不够一组的不需要逆序。（不能使用队列或者栈作为辅助）&lt;br&gt;
    
    </summary>
    
    
      <category term="算法学习" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>RunLoop学习记录</title>
    <link href="http://yoursite.com/2019/08/30/RunLoop%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/08/30/RunLoop学习记录/</id>
    <published>2019-08-29T17:00:43.218Z</published>
    <updated>2019-08-29T17:00:43.219Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：以Core Foundation的实现作为参考（版本为CF-855.17）。</p>
</blockquote>
<h4 id="1-相关数据结构"><a href="#1-相关数据结构" class="headerlink" title="1. 相关数据结构"></a>1. 相关数据结构</h4><h5 id="1-1-run-loop的基本结构"><a href="#1-1-run-loop的基本结构" class="headerlink" title="1.1 run loop的基本结构"></a>1.1 run loop的基本结构</h5><p>CFRunLoopRef，是__CFRunLoop的结构体指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> * <span class="title">CFRunLoopRef</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></div><div class="line">    CFRuntimeBase _base; <span class="comment">// CF对象类型，相当于OC对象的isa</span></div><div class="line">    </div><div class="line">    <span class="keyword">pthread_mutex_t</span> _lock; <span class="comment">// 访问mode列表时保证同步</span></div><div class="line">    __CFPort _wakeUpPort; <span class="comment">// 线程被唤醒时使用 </span></div><div class="line">    Boolean _unused;</div><div class="line">    <span class="keyword">volatile</span> _per_run_data *_perRunData; <span class="comment">// 每次运行的相关状态数据</span></div><div class="line">    <span class="keyword">pthread_t</span> _pthread; <span class="comment">// 绑定的线程</span></div><div class="line">    <span class="keyword">uint32_t</span> _winthread;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 标记为“common”的mode的名称组成的集合</span></div><div class="line">    CFMutableSetRef _commonModes;</div><div class="line">    <span class="comment">// “common”的mode对应的统一item的集合</span></div><div class="line">    CFMutableSetRef _commonModeItems;</div><div class="line">    <span class="comment">// runloop当前所处的mode</span></div><div class="line">    CFRunLoopModeRef _currentMode;</div><div class="line">    <span class="comment">// 所有的mode的集合</span></div><div class="line">    CFMutableSetRef _modes;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_head</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_tail</span>;</span></div><div class="line">    CFTypeRef _counterpart;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>作为RunLoop的基本数据结构，CFRunLoopRef内部主要包含了：</p>
<ul>
<li><strong>_commonModes</strong>：标记为“common”的mode的集合</li>
<li><strong>_commonModeItems</strong>：所有“common”mode中共享的item，即修改此内部的item，就会对所有的“common”的mode内部的item进行更新。</li>
<li><strong>_currentMode</strong>：当前所在的mode模式，切换时要退出重新指定</li>
<li><strong>_modes</strong>：所有支持的mode。</li>
</ul>
<blockquote>
<p>常用API：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取当前线程的run loop（延迟加载，不访问不创建）</span></div><div class="line"><span class="function">CF_EXPORT CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// 获取主线程的run loop（APP启动后自动创建并运行）</span></div><div class="line"><span class="function">CF_EXPORT CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>既然引入了mode这一概念，我们就看看mode到底是个啥。</p>
<h5 id="1-2-RunLoop的Mode"><a href="#1-2-RunLoop的Mode" class="headerlink" title="1.2 RunLoop的Mode"></a>1.2 RunLoop的Mode</h5><p>RunLoop的mode为内部数据，没有对外公开。类型为CFRunLoopModeRef，即__CFRunLoopMode的结构体指针。看一下简化过的代码结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> *<span class="title">CFRunLoopModeRef</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></div><div class="line">    CFRuntimeBase _base;</div><div class="line">    <span class="keyword">pthread_mutex_t</span> _lock; <span class="comment">// 在对mode加锁之前必须持有了run loop的锁</span></div><div class="line">    </div><div class="line">    </div><div class="line">    CFStringRef _name; <span class="comment">// mode名称，区分mode使用</span></div><div class="line">    Boolean _stopped;</div><div class="line">    <span class="keyword">char</span> _padding[<span class="number">3</span>];</div><div class="line">    </div><div class="line">    </div><div class="line">    CFMutableSetRef _sources0;</div><div class="line">    CFMutableSetRef _sources1;</div><div class="line">    CFMutableArrayRef _observers;</div><div class="line">    CFMutableArrayRef _timers;</div><div class="line">    </div><div class="line">    </div><div class="line">    CFMutableDictionaryRef _portToV1SourceMap;</div><div class="line">    __CFPortSet _portSet;</div><div class="line">    CFIndex _observerMask;</div><div class="line"></div><div class="line">    <span class="keyword">mach_port_t</span> _timerPort;</div><div class="line">    Boolean _mkTimerArmed;</div><div class="line"></div><div class="line">    <span class="keyword">uint64_t</span> _timerSoftDeadline; <span class="comment">/* TSR */</span></div><div class="line">    <span class="keyword">uint64_t</span> _timerHardDeadline; <span class="comment">/* TSR */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，CFRunLoopModeRef中主要包含了如下几个内容：</p>
<ul>
<li><strong>_name</strong>：用于识别区分不同的mode实例。切换mode时可以使用。</li>
<li><strong>_sources0</strong>：非基于端口的源的集合（我们在线程中自己添加的一般都是source0）</li>
<li><strong>_sources1</strong>：基于端口的源的集合（通过Mach Port进行线程间通信使用）</li>
<li><strong>_observers</strong>：观察者的数组，用于runloop在不同状态时发送通知的接收对象。</li>
<li><strong>_timers</strong>：定时器数组，包含的就是NSTimer对象。</li>
</ul>
<blockquote>
<p>常用API：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 启动run loop</span></div><div class="line"><span class="function">CF_EXPORT <span class="keyword">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// 以指定mode的方式启动run loop</span></div><div class="line"><span class="function">CF_EXPORT SInt32 <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// 将指定mode加入到run loop的commonMode数组中（加入的是modeName）</span></div><div class="line"><span class="function">CF_EXPORT <span class="keyword">void</span> <span class="title">CFRunLoopAddCommonMode</span><span class="params">(CFRunLoopRef rl, CFStringRef mode)</span></span>;</div></pre></td></tr></table></figure>
<p>下面我们分着来看各部分的数据结构。</p>
<h5 id="1-3-RunLoop源"><a href="#1-3-RunLoop源" class="headerlink" title="1.3 RunLoop源"></a>1.3 RunLoop源</h5><p>CFRunLoopSourceRef，即__CFRunLoopSource结构体的指针。其基本结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopSource</span> * <span class="title">CFRunLoopSourceRef</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopSource</span> &#123;</span></div><div class="line">    CFRuntimeBase _base;</div><div class="line">    <span class="keyword">uint32_t</span> _bits;</div><div class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</div><div class="line">    CFIndex _order;	<span class="comment">// 优先级，不可变</span></div><div class="line">    CFMutableBagRef _runLoops; <span class="comment">// 绑定的runloop对象</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        CFRunLoopSourceContext version0;	<span class="comment">/* immutable, except invalidation */</span></div><div class="line">        CFRunLoopSourceContext1 version1;	<span class="comment">/* immutable, except invalidation */</span></div><div class="line">    &#125; _context;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，联合体中的成员version0和version1即为上面mode中的source0和source1。大概看一下二者的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    CFIndex	version;</div><div class="line">    <span class="keyword">void</span> *	info;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    CFStringRef	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    Boolean	(*equal)(<span class="keyword">const</span> <span class="keyword">void</span> *info1, <span class="keyword">const</span> <span class="keyword">void</span> *info2);</div><div class="line">    CFHashCode	(*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    <span class="keyword">void</span>	(*schedule)(<span class="keyword">void</span> *info, CFRunLoopRef rl, CFStringRef mode);</div><div class="line">    <span class="keyword">void</span>	(*cancel)(<span class="keyword">void</span> *info, CFRunLoopRef rl, CFStringRef mode);</div><div class="line">    <span class="keyword">void</span>	(*perform)(<span class="keyword">void</span> *info);</div><div class="line">&#125; CFRunLoopSourceContext;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    CFIndex	version;</div><div class="line">    <span class="keyword">void</span> *	info;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    CFStringRef	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    Boolean	(*equal)(<span class="keyword">const</span> <span class="keyword">void</span> *info1, <span class="keyword">const</span> <span class="keyword">void</span> *info2);</div><div class="line">    CFHashCode	(*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)</span></div><div class="line">    <span class="keyword">mach_port_t</span>	(*getPort)(<span class="keyword">void</span> *info);</div><div class="line">    <span class="keyword">void</span> *	(*perform)(<span class="keyword">void</span> *msg, CFIndex size, CFAllocatorRef allocator, <span class="keyword">void</span> *info);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="keyword">void</span> *	(*getPort)(<span class="keyword">void</span> *info);</div><div class="line">    <span class="keyword">void</span>	(*perform)(<span class="keyword">void</span> *info);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125; CFRunLoopSourceContext1;</div></pre></td></tr></table></figure>
<p>可以看到，二者内容基本相同，都是包含了内存管理、相等性、hash等信息。不同的是source1的结构体（CFRunLoopSourceContext1）包含了mach_port相关函数。</p>
<p>因此，可以将source根据类型（version成员的0和1）分为source0和source1。</p>
<blockquote>
<p>常用API：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建source（传入不同类型的context即可得到source0或source1）</span></div><div class="line"><span class="function">CF_EXPORT CFRunLoopSourceRef <span class="title">CFRunLoopSourceCreate</span><span class="params">(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// 向run loop的指定mode中添加source</span></div><div class="line"><span class="function">CF_EXPORT <span class="keyword">void</span> <span class="title">CFRunLoopAddSource</span><span class="params">(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// 从run loop的指定mode中移除source</span></div><div class="line"><span class="function">CF_EXPORT <span class="keyword">void</span> <span class="title">CFRunLoopRemoveSource</span><span class="params">(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode)</span></span>;</div></pre></td></tr></table></figure>
<h5 id="1-4-Run-Loop的定时器"><a href="#1-4-Run-Loop的定时器" class="headerlink" title="1.4 Run Loop的定时器"></a>1.4 Run Loop的定时器</h5><p>定时器为CFRunLoopTimerRef类型，也就是__CFRunLoopTimer的结构体指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopTimer</span> * <span class="title">CFRunLoopTimerRef</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopTimer</span> &#123;</span></div><div class="line">    CFRuntimeBase _base;</div><div class="line">    <span class="keyword">uint16_t</span> _bits;</div><div class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</div><div class="line">    CFRunLoopRef _runLoop; <span class="comment">// 绑定的run loop</span></div><div class="line">    CFMutableSetRef _rlModes;</div><div class="line">    CFAbsoluteTime _nextFireDate; <span class="comment">// 下次触发时间</span></div><div class="line">    CFTimeInterval _interval; <span class="comment">// 时间间隔</span></div><div class="line">    CFTimeInterval _tolerance; <span class="comment">// 宽容度</span></div><div class="line">    <span class="keyword">uint64_t</span> _fireTSR;			<span class="comment">/* TSR units */</span></div><div class="line">    CFIndex _order;			<span class="comment">/* immutable */</span></div><div class="line">    CFRunLoopTimerCallBack _callout; <span class="comment">// 回调</span></div><div class="line">    CFRunLoopTimerContext _context;	<span class="comment">/* immutable, except invalidation */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，主要包含了：</p>
<ul>
<li>_runLoop：绑定到的run loop</li>
<li>_interval：执行事件间隔（重复执行的定时器）</li>
<li>_tolerance：宽容度，也就是指定执行时间的最大延迟时间</li>
<li>_callout：执行的回调函数指针</li>
<li>_context：定时器上下文对象，包含内存管理等相关函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    CFIndex	version;</div><div class="line">    <span class="keyword">void</span> *	info;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    CFStringRef	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">&#125; CFRunLoopTimerContext;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*CFRunLoopTimerCallBack)</span><span class="params">(CFRunLoopTimerRef timer, <span class="keyword">void</span> *info)</span></span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>常用API:</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 以callback回调函数指针的形式创建timer</div><div class="line">CF_EXPORT CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context);</div><div class="line"></div><div class="line">// 以block的形式创建timer</div><div class="line">CF_EXPORT CFRunLoopTimerRef CFRunLoopTimerCreateWithHandler(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, void (^block) (CFRunLoopTimerRef timer)) CF_AVAILABLE(10_7, 5_0);</div><div class="line"></div><div class="line">// 向run loop的指定mode中添加timer</div><div class="line">CF_EXPORT void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div><div class="line"></div><div class="line">// 从run loop的指定mode中移除timer</div><div class="line">CF_EXPORT void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div></pre></td></tr></table></figure>
<h5 id="1-5-Run-Loop的观察者"><a href="#1-5-Run-Loop的观察者" class="headerlink" title="1.5 Run Loop的观察者"></a>1.5 Run Loop的观察者</h5><p>观察者为CFRunLoopObserverRef类型，即__CFRunLoopObserver的结构体指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopObserver</span> * <span class="title">CFRunLoopObserverRef</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopObserver</span> &#123;</span></div><div class="line">    CFRuntimeBase _base;</div><div class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</div><div class="line">    CFRunLoopRef _runLoop;</div><div class="line">    CFIndex _rlCount;</div><div class="line">    CFOptionFlags _activities;		<span class="comment">/* immutable */</span></div><div class="line">    CFIndex _order;			<span class="comment">/* immutable */</span></div><div class="line">    CFRunLoopObserverCallBack _callout;	<span class="comment">/* immutable */</span></div><div class="line">    CFRunLoopObserverContext _context;	<span class="comment">/* immutable, except invalidation */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，主要包含：</p>
<ul>
<li>_runLoop：对应的run loop</li>
<li>_activities：用于监听的run loop的指定运行状态。</li>
<li>_order：优先级</li>
<li>_callout：收到监听通知的回调函数指针。</li>
<li>_context：上下文对象</li>
</ul>
<p>activities，即CFOptionFlags，用于识别run loop在不同执行时刻的运行状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Run Loop Observer Activities */</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</div><div class="line">    <span class="comment">/** 进入loop */</span></div><div class="line">    kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),</div><div class="line">    <span class="comment">/** 准备执行timer */</span></div><div class="line">    kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</div><div class="line">    <span class="comment">/** 准备执行source */</span></div><div class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>),</div><div class="line">    <span class="comment">/** 线程准备进入休眠 */</span></div><div class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>),</div><div class="line">    <span class="comment">/** 线程刚被唤醒，还没有进行任务处理 */</span></div><div class="line">    kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>),</div><div class="line">    <span class="comment">/** 退出loop */</span></div><div class="line">    kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>),</div><div class="line">    </div><div class="line">    <span class="comment">/** 所有的状态 */</span></div><div class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上下文对象为CFRunLoopObserverContext结构体，内部包含了内存管理的相关函数指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    CFIndex	version;</div><div class="line">    <span class="keyword">void</span> *	info;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">    CFStringRef	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</div><div class="line">&#125; CFRunLoopObserverContext;</div></pre></td></tr></table></figure>
<p>回调函数的类型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*CFRunLoopObserverCallBack)</span><span class="params">(CFRunLoopObserverRef observer, CFRunLoopActivity activity, <span class="keyword">void</span> *info)</span></span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>常用API：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 创建新的run loop观察者，使用callback回调函数指针的方式</div><div class="line">CF_EXPORT CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context);</div><div class="line"></div><div class="line">// 创建新的run loop观察者，使用block的方式</div><div class="line">CF_EXPORT CFRunLoopObserverRef CFRunLoopObserverCreateWithHandler(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, void (^block) (CFRunLoopObserverRef observer, CFRunLoopActivity activity)) CF_AVAILABLE(10_7, 5_0);</div><div class="line"></div><div class="line">// 向run loop的指定mode中添加观察者</div><div class="line">CF_EXPORT void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode);</div><div class="line"></div><div class="line">// 从run loop的指定mode中移除观察者</div><div class="line">CF_EXPORT void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode);</div></pre></td></tr></table></figure>
<h4 id="2-重点API基本实现"><a href="#2-重点API基本实现" class="headerlink" title="2. 重点API基本实现"></a>2. 重点API基本实现</h4><h5 id="2-1-CFRunLoopGetMain-amp-CFRunLoopGetCurrent"><a href="#2-1-CFRunLoopGetMain-amp-CFRunLoopGetCurrent" class="headerlink" title="2.1 CFRunLoopGetMain &amp; CFRunLoopGetCurrent"></a>2.1 CFRunLoopGetMain &amp; CFRunLoopGetCurrent</h5><p>系统隐藏了生成过程，通过获取线程对应的runloop对象，即可完成创建。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取主线程的runloop</span></div><div class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    <span class="keyword">static</span> CFRunLoopRef __main = <span class="literal">NULL</span>; <span class="comment">// no retain needed</span></div><div class="line">    <span class="keyword">if</span> (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); <span class="comment">// no CAS needed</span></div><div class="line">    <span class="keyword">return</span> __main;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取当前线程的runloop</span></div><div class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</div><div class="line">    <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</div><div class="line">    <span class="keyword">return</span> _CFRunLoopGet0(pthread_self());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，真正的实现都在 <em>_CFRunLoopGet0</em> 函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> CFMutableDictionaryRef __CFRunLoops = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">static</span> CFSpinLock_t loopsLock = CFSpinLockInit;</div><div class="line"></div><div class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(<span class="keyword">pthread_t</span> t) &#123;</div><div class="line">    <span class="comment">// t为0，即为主线程</span></div><div class="line">    <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;</div><div class="line">        t = pthread_main_thread_np();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获取锁</span></div><div class="line">    __CFSpinLock(&amp;loopsLock);</div><div class="line">    </div><div class="line">    <span class="comment">// 懒加载，第一次调用为主线程，创建全局字典，并将新创建的主线程runloop加入其中</span></div><div class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</div><div class="line">        <span class="comment">// 释放锁</span></div><div class="line">        __CFSpinUnlock(&amp;loopsLock);</div><div class="line">        </div><div class="line">        <span class="comment">// 创建字典容器，用于存储runloop</span></div><div class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line">        </div><div class="line">        <span class="comment">// 创建主线程的runloop</span></div><div class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</div><div class="line">        <span class="comment">// 插入到字典中（key为线程指针）</span></div><div class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</div><div class="line">        </div><div class="line">        <span class="comment">// __CFRunLoops全局字典指针指向此字典容器</span></div><div class="line">        <span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, dict, (<span class="keyword">void</span> * <span class="keyword">volatile</span> *)&amp;__CFRunLoops)) &#123;</div><div class="line">            CFRelease(dict);</div><div class="line">        &#125;</div><div class="line">        CFRelease(mainLoop);</div><div class="line">        </div><div class="line">        <span class="comment">// 再次获取锁</span></div><div class="line">        __CFSpinLock(&amp;loopsLock);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 从全局字典容器中获取指定runloop</span></div><div class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class="line">    <span class="comment">// 释放锁</span></div><div class="line">    __CFSpinUnlock(&amp;loopsLock);</div><div class="line">    </div><div class="line">    <span class="comment">// 懒加载</span></div><div class="line">    <span class="keyword">if</span> (!loop) &#123;</div><div class="line">        <span class="comment">// 创建新runloop</span></div><div class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</div><div class="line">        </div><div class="line">        __CFSpinLock(&amp;loopsLock);</div><div class="line">        </div><div class="line">        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</div><div class="line">        <span class="keyword">if</span> (!loop) &#123;</div><div class="line">            <span class="comment">// 在全局字典容器中插入runloop</span></div><div class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</div><div class="line">            loop = newLoop;</div><div class="line">        &#125;</div><div class="line">        __CFSpinUnlock(&amp;loopsLock);</div><div class="line">        CFRelease(newLoop);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (pthread_equal(t, pthread_self())) &#123;</div><div class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="keyword">void</span> *)loop, <span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</div><div class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="keyword">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *))__CFFinalizeRunLoop);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> loop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过实现可以看到：</p>
<ul>
<li>runloop对象整体懒加载，不调用不生成。</li>
<li>runloop对象保存在全局字典中，key为线程指针。</li>
<li>系统第一次调用时，生成全局字典，且自动创建主线程的runloop，插入其中，因此APP可以保持运行。</li>
</ul>
<h5 id="2-2-CFRunLoopRun"><a href="#2-2-CFRunLoopRun" class="headerlink" title="2.2 CFRunLoopRun"></a>2.2 CFRunLoopRun</h5><p>首先看一下run loop的启动过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;	<span class="comment">/* DOES CALLOUT */</span></div><div class="line">    <span class="keyword">int32_t</span> result;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</div><div class="line">        CHECK_FOR_FORK();</div><div class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class="comment">/* DOES CALLOUT */</span></div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    <span class="keyword">return</span> CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在以上两个启动run loop的函数中，真正的实现都包含在CFRunLoopRunSpecific中，且此函数会返回run loop的执行状态（由CFRunLoopRunInMode()函数返回）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    kCFRunLoopRunFinished = <span class="number">1</span>,</div><div class="line">    kCFRunLoopRunStopped = <span class="number">2</span>,</div><div class="line">    kCFRunLoopRunTimedOut = <span class="number">3</span>,</div><div class="line">    kCFRunLoopRunHandledSource = <span class="number">4</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在，我们看一下运行循环，到底是如何循环的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class="comment">/* DOES CALLOUT */</span></div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    </div><div class="line">    <span class="comment">// 正在释放，直接返回</span></div><div class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span> kCFRunLoopRunFinished;</div><div class="line">    </div><div class="line">    <span class="comment">// run loop获取锁</span></div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    </div><div class="line">    <span class="comment">// 根据指定modeName，获取到mode对象</span></div><div class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 若不存在此mode，或内部没有mode item</span></div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</div><div class="line">        <span class="comment">// 返回</span></div><div class="line">        Boolean did = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span> (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line">        <span class="keyword">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 设置新的perRunData，返回旧值</span></div><div class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</div><div class="line">    </div><div class="line">    <span class="comment">// 之前所处的mode</span></div><div class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</div><div class="line">    </div><div class="line">    <span class="comment">// 记录为新的运行mode</span></div><div class="line">    rl-&gt;_currentMode = currentMode;</div><div class="line">    </div><div class="line">    <span class="comment">// 设置为已完成，待返回</span></div><div class="line">    <span class="keyword">int32_t</span> result = kCFRunLoopRunFinished;</div><div class="line"></div><div class="line">    <span class="comment">// 如果存在监听进入loop状态的观察者</span></div><div class="line">	<span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry )</div><div class="line">        <span class="comment">// 通知观察者，run loop已进入（新mode进入）</span></div><div class="line">        __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</div><div class="line">    </div><div class="line">    <span class="comment">// ** 核心：切换运行新mode（循环在这里面实现） **</span></div><div class="line">	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</div><div class="line">    </div><div class="line">    <span class="comment">// 如果存在监听退出loop状态的观察者</span></div><div class="line">	<span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit )</div><div class="line">        <span class="comment">// 通知观察者，run loop已退出</span></div><div class="line">        __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class="line"></div><div class="line">    <span class="comment">// 释放mode的锁</span></div><div class="line">    __CFRunLoopModeUnlock(currentMode);</div><div class="line">    </div><div class="line">    <span class="comment">// 恢复为原始的perRunData，恢复状态</span></div><div class="line">    __CFRunLoopPopPerRunData(rl, previousPerRun);</div><div class="line">    </div><div class="line">    <span class="comment">// run loop的运行mode恢复为原mode</span></div><div class="line">	rl-&gt;_currentMode = previousMode;</div><div class="line">    </div><div class="line">    <span class="comment">// 释放run loop自身的锁</span></div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CFRunLoopRunSpecific函数的整体运行，是一个“创建新现场 – 执行loop – 恢复旧现场”的过程。</p>
<ol>
<li>根据指定的modeName名称，获取run loop内部保存的mode对象。将其设置为currentMode，然后创建新的perRunData进行设置。且如果存在进入循环的观察者，发通知进行告知。<blockquote>
<p>其中，_per_run_data指针标记为volatile，即告知编译器要直接从原地址读取值，而不是从寄存器中读取（防止多线程更改时不修改寄存器中的值导致的数据不一致问题）。<em>__CFRunLoopPushPerRunData</em>函数的内部实现为：</p>
</blockquote>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">per_run_data</span> &#123;</span></div><div class="line">    <span class="keyword">uint32_t</span> a;</div><div class="line">    <span class="keyword">uint32_t</span> b;</div><div class="line">    <span class="keyword">uint32_t</span> stopped;</div><div class="line">    <span class="keyword">uint32_t</span> ignoreWakeUps;</div><div class="line">&#125; _per_run_data;</div><div class="line"></div><div class="line">CF_INLINE <span class="keyword">volatile</span> _per_run_data *__CFRunLoopPushPerRunData(CFRunLoopRef rl) &#123;</div><div class="line">    <span class="keyword">volatile</span> _per_run_data *previous = rl-&gt;_perRunData;</div><div class="line">    rl-&gt;_perRunData = (<span class="keyword">volatile</span> _per_run_data *)CFAllocatorAllocate(kCFAllocatorSystemDefault, <span class="keyword">sizeof</span>(_per_run_data), <span class="number">0</span>);</div><div class="line">    rl-&gt;_perRunData-&gt;a = <span class="number">0x4346524C</span>;</div><div class="line">    rl-&gt;_perRunData-&gt;b = <span class="number">0x4346524C</span>; <span class="comment">// 'CFRL'</span></div><div class="line">    rl-&gt;_perRunData-&gt;stopped = <span class="number">0x00000000</span>;</div><div class="line">    rl-&gt;_perRunData-&gt;ignoreWakeUps = <span class="number">0x00000000</span>;</div><div class="line">    <span class="keyword">return</span> previous;</div><div class="line">&#125;</div><div class="line">```    </div><div class="line">可以看到，runloop的_perRunData成员每次都是创建固定的新值。用来管理runloop的相关设置（stop状态，是否允许唤醒等）</div><div class="line"></div><div class="line"><span class="number">2.</span> 调用 *__CFRunLoopRun* 函数，此函数才是真正的运行循环过程。后面进行单独说明。</div><div class="line"><span class="number">3.</span> 运行循环执行结束后，恢复现场。将上一次的运行mode、_perRunData等数据进行恢复。且如果存在监听退出状态的观察者，发通知告知。</div><div class="line"></div><div class="line">这里，我们看一下runloop是如何给观察者发送通知的。</div><div class="line"></div><div class="line">##### <span class="number">2.2</span> __CFRunLoopDoObservers</div><div class="line"></div><div class="line">``` c</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRunLoopDoObservers() __attribute__((noinline));</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRunLoopDoObservers(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopActivity activity) &#123;	<span class="comment">/* DOES CALLOUT */</span></div><div class="line">    CHECK_FOR_FORK();</div><div class="line"></div><div class="line">    <span class="comment">// 查看mode中observers的个数</span></div><div class="line">    CFIndex cnt = rlm-&gt;_observers ? CFArrayGetCount(rlm-&gt;_observers) : <span class="number">0</span>;</div><div class="line">    <span class="comment">// 不存在，直接返回</span></div><div class="line">    <span class="keyword">if</span> (cnt &lt; <span class="number">1</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Fire the observers */</span></div><div class="line">    STACK_BUFFER_DECL(CFRunLoopObserverRef, buffer, (cnt &lt;= <span class="number">1024</span>) ? cnt : <span class="number">1</span>);</div><div class="line">    <span class="comment">// cnt超过1024后，开辟cnt个内存空间，相当于数组</span></div><div class="line">    CFRunLoopObserverRef *collectedObservers = (cnt &lt;= <span class="number">1024</span>) ? buffer : (CFRunLoopObserverRef *)<span class="built_in">malloc</span>(cnt * <span class="keyword">sizeof</span>(CFRunLoopObserverRef));</div><div class="line">    CFIndex obs_cnt = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>; idx &lt; cnt; idx++) &#123;</div><div class="line">        <span class="comment">// 依次取出observer</span></div><div class="line">        CFRunLoopObserverRef rlo = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx);</div><div class="line">        <span class="comment">// 若observer中存在需要的activity</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> != (rlo-&gt;_activities &amp; activity) &amp;&amp; __CFIsValid(rlo) &amp;&amp; !__CFRunLoopObserverIsFiring(rlo)) &#123;</div><div class="line">            <span class="comment">// retain后，插入数组中</span></div><div class="line">            collectedObservers[obs_cnt++] = (CFRunLoopObserverRef)CFRetain(rlo);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 释放mode的锁</span></div><div class="line">    __CFRunLoopModeUnlock(rlm);</div><div class="line">    <span class="comment">// 释放run loop锁</span></div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    </div><div class="line">    <span class="comment">// **** 由此可以看出，为了提高访问效率，将所有的观察者添加到额外的数组中，是为了释放锁后，其他对象的高效访问。 ****</span></div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>; idx &lt; obs_cnt; idx++) &#123;</div><div class="line">        <span class="comment">// 从数组中依次取出observer</span></div><div class="line">        CFRunLoopObserverRef rlo = collectedObservers[idx];</div><div class="line">        <span class="comment">// 对observer加锁</span></div><div class="line">        __CFRunLoopObserverLock(rlo);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (__CFIsValid(rlo)) &#123;</div><div class="line">            <span class="comment">// 根据是否重复确定是否需要置为无效</span></div><div class="line">            Boolean doInvalidate = !__CFRunLoopObserverRepeats(rlo);</div><div class="line">            <span class="comment">// 设置对应位的值（标记为正在调用）</span></div><div class="line">            __CFRunLoopObserverSetFiring(rlo);</div><div class="line">            <span class="comment">// 释放锁</span></div><div class="line">            __CFRunLoopObserverUnlock(rlo);</div><div class="line">            </div><div class="line">           <span class="comment">// 调用观察者对应的回调方法（_callout）</span></div><div class="line">            __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(rlo-&gt;_callout, rlo, activity, rlo-&gt;_context.info);</div><div class="line">            </div><div class="line">            <span class="comment">// 需要置为无效，则释放此observer</span></div><div class="line">            <span class="keyword">if</span> (doInvalidate) &#123;</div><div class="line">                CFRunLoopObserverInvalidate(rlo);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 设置对应位的值（标记为没有调用）</span></div><div class="line">            __CFRunLoopObserverUnsetFiring(rlo);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 观察者对象错误，直接释放锁</span></div><div class="line">            __CFRunLoopObserverUnlock(rlo);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 释放observer（数组不再保留observer）</span></div><div class="line">        CFRelease(rlo);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 释放runloop和mode的锁</span></div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    __CFRunLoopModeLock(rlm);</div><div class="line"></div><div class="line">    <span class="comment">// 创建了新数组，则释放内存</span></div><div class="line">    <span class="keyword">if</span> (collectedObservers != buffer) <span class="built_in">free</span>(collectedObservers);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>将指定run loop mode中的_observers取出，单独放到一个指定数组中进行处理（超出1024个observer后要单独开辟内存）。由于调用callback函数为同步操作，由可能会长时间锁住runloop和mode。故单独处理，防止影响runloop的执行效率。</li>
<li>将监听的activity对应的observer插入到数组容器中。activity即上面说过的CFOptionFlags，也就是runloop运行过程中的各种监控时间点。</li>
<li>插入到数组容器时要对observer进行保留操作，使用后要对observer进行释放操作，内存管理要时刻谨记。</li>
<li>在observer数组中依次取出，通过 <em><strong>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</strong></em> 函数对observer的_callout进行函数调用。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__() __attribute__((noinline));</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(CFRunLoopObserverCallBack func, CFRunLoopObserverRef observer, CFRunLoopActivity activity, <span class="keyword">void</span> *info) &#123;</div><div class="line">    <span class="keyword">if</span> (func) &#123;</div><div class="line">        func(observer, activity, info);</div><div class="line">    &#125;</div><div class="line">    getpid(); <span class="comment">// thwart tail-call optimization</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要就是直接进行函数调用（getpid神马进程相关的，就不动了。。。）。</p>
<h5 id="2-3-CFRunLoopRun"><a href="#2-3-CFRunLoopRun" class="headerlink" title="2.3 __CFRunLoopRun"></a>2.3 __CFRunLoopRun</h5><p>前面说了，__CFRunLoopRun个才是核心所在，真正的“loop”在这里执行。</p>
<p>由于代码过长，我们分步骤看。</p>
<h6 id="2-3-1-其他（非do-while循环）"><a href="#2-3-1-其他（非do-while循环）" class="headerlink" title="2.3.1 其他（非do-while循环）"></a>2.3.1 其他（非do-while循环）</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 1. 状态判断</span></div><div class="line">    <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        <span class="comment">// 如果runloop已经stop（_perRunData中的stop的值）</span></div><div class="line">        <span class="comment">// 恢复stop为初值，返回已stop状态</span></div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">        <span class="keyword">return</span> kCFRunLoopRunStopped;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</div><div class="line">        <span class="comment">// 若当前mode已经stop</span></div><div class="line">        <span class="comment">// 恢复stop为初值，返回已stop状态</span></div><div class="line">        rlm-&gt;_stopped = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 2. dispatchPort的获取</span></div><div class="line">    </div><div class="line">    <span class="comment">// 派发端口，如果当前runloop是主线程runloop，则为主队列port，否则为NULL</span></div><div class="line">    <span class="keyword">mach_port_name_t</span> dispatchPort = MACH_PORT_NULL;</div><div class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="literal">NULL</span> == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="number">0</span> == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class="line">    <span class="keyword">if</span> (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) &#123;</div><div class="line">        dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 3. 超时定时器的设置</span></div><div class="line">    </div><div class="line">    <span class="keyword">dispatch_source_t</span> timeout_timer = <span class="literal">NULL</span>;</div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">timeout_context</span> *<span class="title">timeout_context</span> = (<span class="title">struct</span> __<span class="title">timeout_context</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(*<span class="title">timeout_context</span>));</span></div><div class="line">    <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>) &#123; <span class="comment">// instant timeout</span></div><div class="line">        <span class="comment">// 不设置超时的情况，即运行完就散</span></div><div class="line">        </div><div class="line">        seconds = <span class="number">0.0</span>;</div><div class="line">        timeout_context-&gt;termTSR = <span class="number">0U</span>LL;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</div><div class="line">        <span class="comment">// 有超时，但是未达到上限的情况</span></div><div class="line">        </div><div class="line">        <span class="comment">// 通过global队列，添加一个超时的timer，到时间唤醒线程，释放runloop</span></div><div class="line">        <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);</div><div class="line">        timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">queue</span>);</div><div class="line">            dispatch_retain(timeout_timer);</div><div class="line">        timeout_context-&gt;ds = timeout_timer;</div><div class="line">        timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</div><div class="line">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</div><div class="line">        dispatch_set_context(timeout_timer, timeout_context);</div><div class="line">            <span class="comment">// source gets ownership of context</span></div><div class="line">        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class="line">        <span class="keyword">uint64_t</span> ns_at = (<span class="keyword">uint64_t</span>)((__CFTSRToTimeInterval(startTSR) + seconds) * <span class="number">1000000000U</span>LL);</div><div class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(<span class="number">1</span>, ns_at), DISPATCH_TIME_FOREVER, <span class="number">1000U</span>LL);</div><div class="line">        dispatch_resume(timeout_timer);</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// infinite timeout</span></div><div class="line">        <span class="comment">// 超过上限，即无限运行时间的情况</span></div><div class="line">        </div><div class="line">        seconds = <span class="number">9999999999.0</span>;</div><div class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">int32_t</span> retVal = <span class="number">0</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        ...</div><div class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</div><div class="line">    </div><div class="line">    <span class="comment">// retVal只要不为0，则runloop结束循环，退出</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (timeout_timer) &#123;</div><div class="line">        <span class="comment">// 存在超时定时器，移除</span></div><div class="line">        dispatch_source_cancel(timeout_timer);</div><div class="line">        dispatch_release(timeout_timer);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">free</span>(timeout_context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> retVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非核心部分主要做了三件事：</p>
<ol>
<li>对runloop和currentMode的运行状态进行判断，防止无畏的运行。</li>
<li>根据情况，查看端口是否为GCD的主队列端口（用于后面通过主线程自身端口调用mach_msg函数，执行主队列的异步任务）。</li>
<li>根据设置的超时时间，使用GCD添加一个定时器，超时时直接释放runloop。最后结尾时检查移除此定时器。</li>
</ol>
<h5 id="2-3-2-do-while运行循环"><a href="#2-3-2-do-while运行循环" class="headerlink" title="2.3.2 do-while运行循环"></a>2.3.2 do-while运行循环</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int32_t</span> retVal = <span class="number">0</span>;</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="comment">// 1. 根据运行状态，进行预处理（发通知、执行block、准备处理GCD事件、休眠）</span></div><div class="line"></div><div class="line">    <span class="comment">// 存在kCFRunLoopBeforeTimers的观察者，发通知</span></div><div class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class="line">    </div><div class="line">    <span class="comment">// 存在kCFRunLoopBeforeSources的观察者，发通知</span></div><div class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class="line"></div><div class="line">    <span class="comment">// 调用block的时机1</span></div><div class="line">    __CFRunLoopDoBlocks(rl, rlm);</div><div class="line"></div><div class="line">    <span class="comment">// 执行source0（手动source）</span></div><div class="line">    Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class="line">    <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</div><div class="line">        <span class="comment">// 执行source0后，调用block（调用block的时机2）</span></div><div class="line">        __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// GCD的主队列</span></div><div class="line">    <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort) &#123;</div><div class="line">        msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</div><div class="line">        <span class="comment">// 通过主队列端口直接发送消息（内部的source1消息，mach_msg执行），进行处理</span></div><div class="line">        <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>)) &#123;</div><div class="line">            <span class="keyword">goto</span> handle_msg;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 存在监听kCFRunLoopBeforeWaiting的观察者，发通知</span></div><div class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class="line">    </div><div class="line">    </div><div class="line">    msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</div><div class="line">    <span class="comment">// 尝试通过mach_msg函数进入休眠状态，接收到消息后（即被唤醒），返回true</span></div><div class="line">    __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY);</div><div class="line">            </div><div class="line">    </div><div class="line">    <span class="comment">// 如果存在监听kCFRunLoopAfterWaiting的观察者，发通知</span></div><div class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 2. 处理消息部分（线程已被唤醒 或 直接进入处理）</span></div><div class="line">    </div><div class="line">    <span class="comment">// ** 处理消息：**       </span></div><div class="line">    handle_msg:;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class="line">        <span class="comment">// timer唤醒的</span></div><div class="line">        <span class="comment">// 以当前时间为时间点，执行相应的timer</span></div><div class="line">        __CFRunLoopDoTimers(rl, rlm, mach_absolute_time());</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</div><div class="line">        <span class="comment">// GCD主队列唤醒的（dispatchPort不为NULL，即证明是主队列唤醒的）</span></div><div class="line">        <span class="comment">// 执行主队列的任务block</span></div><div class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);            </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 其他线程的source1唤醒的</span></div><div class="line">        <span class="comment">// 根据livePort，查询获取source1对象</span></div><div class="line">        CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class="line">        <span class="keyword">if</span> (rls) &#123;</div><div class="line">      <span class="keyword">mach_msg_header_t</span> *reply = <span class="literal">NULL</span>;</div><div class="line">            <span class="comment">// 执行source1</span></div><div class="line">      sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">     &#125;</div><div class="line">    &#125; </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (msg &amp;&amp; msg != (<span class="keyword">mach_msg_header_t</span> *)msg_buffer) <span class="built_in">free</span>(msg);</div><div class="line">    </div><div class="line">    <span class="comment">// 执行block的时机3</span></div><div class="line">    __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 3. 根据状态设置retVal值，决定运行循环是否继续</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">        <span class="comment">// 单次执行完source</span></div><div class="line">        retVal = kCFRunLoopRunHandledSource;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">        <span class="comment">// runloop超时</span></div><div class="line">        retVal = kCFRunLoopRunTimedOut;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        <span class="comment">// runloop已停止</span></div><div class="line">        retVal = kCFRunLoopRunStopped;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</div><div class="line">        <span class="comment">// runloop的对应mode已停止</span></div><div class="line">        retVal = kCFRunLoopRunStopped;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">        <span class="comment">// runloop执行完成</span></div><div class="line">        retVal = kCFRunLoopRunFinished;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</div></pre></td></tr></table></figure>
<p>虽然代码很多（已经大幅度简化），但实际上只是分为三部分：</p>
<ol>
<li>根据运行状态，进行预处理：<ul>
<li>在不同运行状态，给观察者发通知（准备执行timer、准备执行source）</li>
<li>执行block</li>
<li>执行配置到mode中的source0，成功后再次检测执行block。实现函数为 <em><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong></em> </li>
<li>准备处理GCD事件（通过mach_msg函数，自身主队列的port执行，存在则直接去处理任务）</li>
<li>没有其他事件时，通过mach_msg函数，让线程进入睡眠，同时在接收消息后自动唤醒</li>
</ul>
</li>
<li>处理消息部分（线程已被唤醒 或 直接进入处理），根据端口类型，对执行的工作进行区分：<ul>
<li>执行timer：<em><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong></em>，其入口函数 <em>__CFRunLoopDoTimers</em> 与 <em>__CFRunLoopDoObservers</em> 实现相似：先将符合要求（刚刚到达或者稍微过时一点的）的timer加入到数组中，防止长时间锁住runloop，然后依次调用 <em>__CFRunLoopDoTimer</em> ，也就是calling_out函数，完成回调。</li>
<li>执行GCD主队列的异步任务：<em><strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong></em></li>
<li>source1的主动唤醒任务：<em>mach_msg</em>，进入内核态，直接进行线程通信</li>
<li>再次检测执行block</li>
</ul>
</li>
<li>根据状态设置retVal值，决定运行循环是否继续。如果状态都不满足，仍为0，则继续执行循环，保证线程不退出。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：以Core Foundation的实现作为参考（版本为CF-855.17）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-相关数据结构&quot;&gt;&lt;a href=&quot;#1-相关数据结构&quot; class=&quot;headerlink&quot; title=&quot;1. 相关数据结构&quot;&gt;&lt;/a&gt;1. 相关数据结构&lt;/h4&gt;&lt;h5 id=&quot;1-1-run-loop的基本结构&quot;&gt;&lt;a href=&quot;#1-1-run-loop的基本结构&quot; class=&quot;headerlink&quot; title=&quot;1.1 run loop的基本结构&quot;&gt;&lt;/a&gt;1.1 run loop的基本结构&lt;/h5&gt;&lt;p&gt;CFRunLoopRef，是__CFRunLoop的结构体指针：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;CFRunLoop&lt;/span&gt; * &lt;span class=&quot;title&quot;&gt;CFRunLoopRef&lt;/span&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;CFRunLoop&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    CFRuntimeBase _base; &lt;span class=&quot;comment&quot;&gt;// CF对象类型，相当于OC对象的isa&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pthread_mutex_t&lt;/span&gt; _lock; &lt;span class=&quot;comment&quot;&gt;// 访问mode列表时保证同步&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    __CFPort _wakeUpPort; &lt;span class=&quot;comment&quot;&gt;// 线程被唤醒时使用 &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Boolean _unused;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; _per_run_data *_perRunData; &lt;span class=&quot;comment&quot;&gt;// 每次运行的相关状态数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pthread_t&lt;/span&gt; _pthread; &lt;span class=&quot;comment&quot;&gt;// 绑定的线程&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; _winthread;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 标记为“common”的mode的名称组成的集合&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    CFMutableSetRef _commonModes;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// “common”的mode对应的统一item的集合&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    CFMutableSetRef _commonModeItems;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// runloop当前所处的mode&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    CFRunLoopModeRef _currentMode;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 所有的mode的集合&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    CFMutableSetRef _modes;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _&lt;span class=&quot;title&quot;&gt;block_item&lt;/span&gt; *_&lt;span class=&quot;title&quot;&gt;blocks_head&lt;/span&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _&lt;span class=&quot;title&quot;&gt;block_item&lt;/span&gt; *_&lt;span class=&quot;title&quot;&gt;blocks_tail&lt;/span&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    CFTypeRef _counterpart;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>线程编程指南----关于线程的编程</title>
    <link href="http://yoursite.com/2019/08/27/%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97----%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/27/线程编程指南----关于线程的编程/</id>
    <published>2019-08-27T06:07:16.472Z</published>
    <updated>2019-08-27T06:12:41.395Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文翻译自<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/AboutThreads/AboutThreads.html#//apple_ref/doc/uid/10000057i-CH6-SW2" target="_blank" rel="external">About Threaded Programming</a></p>
</blockquote>
<h3 id="关于线程的编程"><a href="#关于线程的编程" class="headerlink" title="关于线程的编程"></a>关于线程的编程</h3><p>多年来，几乎所有的电脑性能都被单核处理器的运算速度限制地非常严重。当单个处理器的运行速度达到瓶颈之后，芯片就切换到了多核设计，这就为电脑提供了可以同时执行多个任务的机会。虽然OS X在执行系统相关的任务时已经利用好了多核心处理器，但你的应用也需要通过线程来利用好它们。<br><a id="more"></a></p>
<h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><p>线程是一种在应用程序中相对轻量级地实现多条路径执行指令的方式。在系统层面，所有程序一个接一个地执行，系统会根据需要为每一个程序腾出执行时间并同时满足其他程序。但是，在每一个程序内部，存在着一个或多个线程，它们被用于同时或几乎同时去执行多个任务。实际上系统自身管理着这些线程，根据需要调度它们到可用核心中或主动打断它们的执行来允许其他线程执行。</p>
<p>从技术的角度来看，一个线程就是一个核心级和应用级数据结构的组合用以管理代码的执行。核心级结构将事件派发给指定线程并使用此线程抢占可用核心。应用级结构包含了用于存储函数调用的调用栈和应用程序需要的数据结构，用它来管理并控制线程的属性和状态。</p>
<p>在一个非并发的应用中，只有唯一一个线程在执行。此线程随着应用的主程序从开始到结束，一个接一个地从不同的方法或函数中切换分支，来实现应用的所有行为。作为对比差异，支持并发的应用以一个线程开始，之后根据需要添加更多的线程来创建额外的执行路径。每一个新路径都有它自己的开始程序，且此程序与应用的主程序相对独立。在应用中包含多个线程可以提供两个非常重要的优点：</p>
<ul>
<li>多线程可以提升应用的响应性。</li>
<li>多线程可以在多核心系统中提高应用的实时性能。</li>
</ul>
<p>如果你的应用只有一个线程，此线程就必须做每一件事。它必须响应事件、更新应用的窗口并执行所有需要的运算来实现应用的行为。但只有一个线程的问题在于同一时刻只能做一件事。所以当一个计算任务花费时间过长会发生什么？当你的代码正在忙于计算需要的值时，你的应用会停止响应用户的事件并停止更新窗口。如果这个行为持续太长时间，用户可能就认为你的应用已经卡死并试图强退了。如果你把这个自定的计算任务放到一个单独线程中去执行，应用的主线程就会被释放以一个比较实时地状态来响应用户的交互。</p>
<p>随着多核心电脑普及的这些日子，线程提供了一种方式为某些类型的应用提升了性能。执行不同任务的线程可以在不同的处理器核心上同时执行，使一个应用在指定时间内完成更多任务成为了可能。</p>
<p>当然，线程也不是解决应用性能问题的万能药。随着线程带来的性能提升也带来了一些潜在问题。在应用中的多个执行路径会让你的代码更加复杂。每个线程都要与其他线程定位好对应的行为来防止应用的状态信息被搞乱。因为在一个应用中的所有线程会在同一时间共享相同的内存空间，一个线程可能会覆盖了其他线程的修改最终导致了结果数据的混乱。虽然在指定位置进行了适当保护，你还是需要警惕编译器对代码的优化可能引入的微小概率的bug。</p>
<h4 id="线程术语"><a href="#线程术语" class="headerlink" title="线程术语"></a>线程术语</h4><p>在深入讨论线程之前，关于线程和支持的技术，有必要定义一些基本的术语。</p>
<p>如果你比较熟悉UNIX系统，你可能会发现“任务”这个术语在此文档中用于不同的目的。在UNIX系统中，“任务”被用于指代一个正在执行的进程。</p>
<p>本文中使用了如下术语：</p>
<ul>
<li><em>线程</em> 被用于指代一个执行代码的单独路径。</li>
<li><em>进程</em> 被用于指代一个正在执行的，包含多个线程的可执行程序。</li>
<li><em>任务</em> 被用于指代一个需要被执行的工作的抽象概念。</li>
</ul>
<h4 id="线程的替代方案"><a href="#线程的替代方案" class="headerlink" title="线程的替代方案"></a>线程的替代方案</h4><p>自己创建线程的一个问题是它们会给你的代码带来不确定性。线程是一种的相对底层且比较复杂的方式来为应用添加并发能力。如果你没有完全理解你定义的选择方式，你可能会很容易就遇到同步或者时间上的问题，这几种问题可以将微小的修改变为应用程序的崩溃或者用户数据的混乱。</p>
<p>另一个考虑的因素就是你是否真的需要多线程或者并发功能。线程可以解决指定的问题，如在一个进程中同时执行多个路径的代码。也许存在一些情况，比如，大多情况下，你所执行的工作并不是并发的。线程会给你的进程引入大量的额外工作，包括内存占用和CPU时间占用。你要考虑好对于本来任务引入的这些额外工作，或者是否存在其他方式可以更容易地实现。</p>
<p>表1-1列出了一些对于线程的替代方案。这个表不仅包含了对于多线程的替代技术（如operation对象和GCD），还包含了使用单线程也能提高效率的替代方案。</p>
<table>
<thead>
<tr>
<th>技术</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Operation对象</td>
<td>OS X v10.5引入，一个operation对象是一个任务的封装，可以在次要线程中执行。此封装隐藏了执行任务时的线程管理方面，让你专注于任务自身。你只需要结合着一个操作队列对象使用operation对象，这个操作队列会在一个或多个线程中管理着operation的执行。 （查看<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091" target="_blank" rel="external">并发编程指南</a>以学习如何使用）</td>
</tr>
<tr>
<td>大中枢派发（GCD）</td>
<td>OS X v10.6引入，大中枢派发是另一个线程的替代方案，可以让你专注于需要的任务而不是线程的管理。使用GCD，你定义好需要执行的任务并将其添加到工作队列中，此队列负责将你的任务调度到合适的线程中。工作队列专注于可用核心数和当前加载并执行的任务，这比你自己使用线程进行处理要更加高效。 （查看<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091" target="_blank" rel="external">并发编程指南</a>以学习如何使用）</td>
</tr>
<tr>
<td>闲时通知（Idle-time notifications）</td>
<td>对于那些相对短时间且低优先级的任务来说，闲时通知可以让你在应用不忙时执行任务。Cocoa提供了<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSNotificationQueue/Description.html#//apple_ref/occ/cl/NSNotificationQueue" target="_blank" rel="external">NSNotificationQueue</a>对象来支持闲时通知。要要请求一个闲时通知，使用<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/TypesAndConstants/FoundationTypesConstants/Description.html#//apple_ref/c/econst/NSPostWhenIdle" target="_blank" rel="external">NSPostWhenIdle</a>参数，发送一个notification给默认的NSNotificationQueue对象。直到运行循环（run loop）空闲时，队列则传递你的notification对象。  （查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Notifications/Introduction/introNotifications.html#//apple_ref/doc/uid/10000043i" target="_blank" rel="external">通知编程指南</a>以获取更多信息）</td>
</tr>
<tr>
<td>异步函数</td>
<td>系统接口中包含了许多异步函数可以提供自动并发功能。这些API可以用于系统进程或者创建自定义线程来执行任务并返回结果给你。（实际实现无关紧要，因为它们与你的代码是分隔开的。）在你开发应用时，查找一下提供异步功能的函数并考虑使用它们，从而避免在一个自定义线程中使用等价的同步函数。</td>
</tr>
<tr>
<td>定时器</td>
<td>在任务没有重要到需要创建线程时，你可以在应用的主线程中使用定时器来执行周期性的任务，但是定时器依然需要遵循正常的间隔。 （查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW21" target="_blank" rel="external">定时器资源</a>来获取更多信息）</td>
</tr>
<tr>
<td>独立进程</td>
<td>虽然要比线程更重，但是当指定任务与你的应用基本无关时，创建一个独立进程也许更有用。如果一个任务需要分配一块重要的内存或者必须使用根权限执行时，你可以使用一个进程来实现。举例来说，你可以使用一个64位的服务器进程来计算大数据集，而使用一个32位的应用将结果显示给用户。</td>
</tr>
</tbody>
</table>
<h4 id="线程支持"><a href="#线程支持" class="headerlink" title="线程支持"></a>线程支持</h4><p>如果你有使用线程的现有代码，在你的应用中，OS X和iOS已经提供了几种技术来创建线程。此外，此两种系统都提供了对于在多线程中进行管理和同步的功能。下面的小结描述了一些关键技术，在OS X和iOS中使用线程时，这些技术你都需要了解。</p>
<h5 id="线程的封装"><a href="#线程的封装" class="headerlink" title="线程的封装"></a>线程的封装</h5><p>虽然对于线程来说，底层的实现机制是Mach线程，你几乎不会在Mach层级去使用线程。相反，你经常使用更方便的POSIX API或者是派生子对象。可是，Mach的实现确实提供了所有线程的基本特性，包括主动抢占式执行模型和调度线程的能力，因此他们彼此独立。</p>
<p>表1-2列出了你可以在应用中使用的线程技术。</p>
<table>
<thead>
<tr>
<th>技术</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cocoa线程</td>
<td>Cocoa使用<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSThread/Description.html#//apple_ref/occ/cl/NSThread" target="_blank" rel="external">NSThread</a>类实现了线程。Cocoa还在NSObject中提供了创建新线程的功能和在已经运行的线程上执行代码的功能。（更多信息请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW11" target="_blank" rel="external">使用NSThread</a>和<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW13" target="_blank" rel="external">使用NSObject创建一个新线程</a>）</td>
</tr>
<tr>
<td>POSIX线程</td>
<td>POSIX线程提供了一个基于C的接口来创建线程。如果你没有编写Cocoa应用，这就是创建线程的最好选择。对于线程的配置，POSIX接口相对简单易用且提供了足够的扩展性。（更多信息请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW12" target="_blank" rel="external">使用POSIX线程</a>）</td>
</tr>
<tr>
<td>多进程服务</td>
<td>多进程服务是从老版本Mac OS中转换应用时遗留下的基于C的接口。这项技术只在OS X中可用且在新的开发中应当避免使用。作为替代，你应该使用NSThread类或是POSIX线程。（更多信息请查看<a href="https://developer.apple.com/library/archive/documentation/Carbon/Conceptual/Multitasking_MultiproServ/01introduction/introduction.html#//apple_ref/doc/uid/TP40000853" target="_blank" rel="external">多核心服务编程指南</a>）</td>
</tr>
</tbody>
</table>
<p>在应用程序级来看，所有线程的行为看起来就和在其他平台上看起来一样。在开启一个线程之后，线程就会处于三种状态：运行态、就绪态和阻塞态。如果一个线程当前没处在运行态，那么它或者是被阻塞了正在等待输入，或者是准备好运行但是还没有被调度。线程会继续返回并执行第四个状态（就是循环会开始状态）直到它最终退出并且变为终止状态。</p>
<p>当你创建一个新线程时，你必须为线程指定一个入口点函数（在Cocoa的线程中为入口点方法）。此入口点函数组成了你要在线程中执行的代码。当函数返回时，或者当你主动结束此线程时，线程会永久停止且会被系统回收。由于线程的创建在内存和时间上的开销比较大，因此建议让你的入口点函数做一些重要的工作或者配置一个运行循环以便可以反复执行工作。</p>
<p>查看更多关于可用线程技术和如何使用的相关信息，请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW2" target="_blank" rel="external">线程管理</a>。</p>
<h5 id="运行循环"><a href="#运行循环" class="headerlink" title="运行循环"></a>运行循环</h5><p>运行循环是用于在线程中处理异步接收事件的一种基础设施。一个线程指定的运行循环通过监控一个或多个事件源进行工作。一旦收到事件，系统就会唤醒线程并把事件派发给运行循环，之后此运行循环就会将它发送给你指定的处理对象。如果当前没有事件出现且准备好要处理，运行循环就会使线程休眠。</p>
<p>你无需使用一个带有你创建线程的运行循环，但是这样做可以给用户带来更好的体验。运行循环可以让使用最小内存占用来创建长期生存的线程成为可能。因为运行循环可以在没事可做时让线程进入休眠，它排除了需要轮询的可能，因为轮询会浪费CPU资源且阻止处理器自身进入休眠状态，省电。</p>
<p>要配置一个运行循环，所有你需要做的就是启动一个线程，获取一个运行循环对象的索引，安装你的事件处理器，并告知运行循环启动运行。OS X系统自动为你配置了主线程的运行循环。可是，如果你想要创建一个长期生存的子线程，你就必须要自己配置那些线程的运行循环。</p>
<p>有关运行循环的详细信息和使用方式在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="external">运行循环</a>中提供说明。</p>
<h5 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h5><p>多线程编程中的其中一个危险点就是多个线程间的资源竞争。如果多个线程在同一时间试图使用或修改相同资源，问题就可能发生。减轻此问题的一种方式就是尽量避免共享资源并且确保每个线程都有自己的资源集合并在里面进行操作。当处理完全独立的资源不是一个可选项时，你可能必须通过锁、条件、原子操作或者其他技术来同步访问资源。</p>
<p>锁通过一种简单粗暴地保护代码的方式来使每次同时只能有一个线程可以被执行。最普通的锁的类型就是互斥锁，也被叫做<em>mutex</em>。当一个线程试图获取一个已经被其他线程保留的互斥锁时，此线程会被阻塞直到其他线程释放此锁。好几个系统框架提供了对于互斥锁的支持，虽然它们都基于同样的底层技术。此外，Cocoa还提供了多种互斥锁的变体以支持不同种类的行为，比如递归。要获取更多关于可用类型锁的相关信息，请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-126320" target="_blank" rel="external">锁</a>。</p>
<p>除了锁以外，系统还提供了条件支持，条件对象可以确保在你的应用中的任务以指定的顺序执行。一个条件对象扮演了门卫的角色，阻塞指定线程直到它设置的条件变为真。当此情况发生时，条件对象释放此线程并允许它继续执行。POSIX层和Foundation框架都直接支持了条件对象。（如果你使用了operation对象，你可以在你的operation对象间设置依赖以使任务按顺序执行，这种行为与条件对象提供的行为非常相似。）</p>
<p>虽然在并发设计中，锁和条件对象非常常见，但原子操作也是保护并同步访问数据的另一种方式。在你需要对纯数据类型执行数学或逻辑运算时，原子操作是一种轻量级的锁的替代方案。原子操作使用特别的硬件指令来确保在其他线程有机会访问之前就对指定变量完成修改。</p>
<p>要查看关于可用的同步工具的更多信息，请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-124887" target="_blank" rel="external">同步工具</a>。</p>
<h5 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h5><p>虽然一个好的设计可以将必要的通信降为最少，但是，在某些点看来，线程间的通信变得很有必要。（一个线程的职责就是为你的应用工作，但是如果工作的结果从来不会使用，那又有什么用呢？）线程也许需要处理新的工作请求或者向你的应用的主线程汇报它们的工作进度。在这些情况下，你需要一种方式将一个线程的信息获取到另一个线程中。幸运的是，真相是所有线程都共享着相同的进程空间，这意味着你可以有许多种选择进行通信。</p>
<p>这里有许多种方式用于线程间通信，每一种都有自己的优点和缺点。配置线程局部存储（TLS）列举出了大多数的在OS X中可用的通信机制。（除了消息队列和Cocoa发布对象以外，这些技术都可以用于iOS中。）这些技术按照复杂性的增长顺序列举在了下表中。</p>
<table>
<thead>
<tr>
<th>机制</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接发送消息</td>
<td>Cocoa应用支持直接在其他线程中执行选择器的能力。这项能力意味着一个线程在本质上可以在任意其它线程上执行方法。因为这些方法是在目标线程的上下文对象中执行，这种方式发送的消息可以在目标线程中自动序列化。要查看相关的输入资源信息，请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW44" target="_blank" rel="external">Cocoa执行选择器资源</a>。</td>
</tr>
<tr>
<td>全局变量、共享内存和对象</td>
<td>在两个线程间交换信息的另一种简单方法就是使用全局变量、共享对象或者共享的内存块。虽然共享变量又快又简单，但此方式相比直接发送消息更加脆弱。共享变量必须使用锁或者其它同步机制进行小心保护来确保代码的正确。忘记使用此方式会导致竞争条件、混乱的数据或者崩溃。</td>
</tr>
<tr>
<td>条件</td>
<td>当一个线程执行一部分指定代码时，条件是一种你可以用于控制使用的同步工具。你可以将其看做门卫，只有当条件状态满足时才会让线程执行。对于更多信息，请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW4" target="_blank" rel="external">使用条件</a>。</td>
</tr>
<tr>
<td>运行循环源</td>
<td>一个自定义的运行循环源是你在一个线程中用于接收指定的应用程序消息。由于是事件驱动，在无事可做时运行循环会让你的线程进入睡眠状态，这会提高线程效率。对于更多关于运行循环和运行循环源，请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="external">运行循环</a>。</td>
</tr>
<tr>
<td>端口和套接字</td>
<td>基于端口的通信是一种两个线程间更加精细的通信方式，而且是一个更可靠的技术。更重要的是，端口和套接字可以用于和外部实体进行通信，如其它进程和服务。为了提升效率，端口使用运行循环源进行实现，因此在端口没有数据等待时，你的线程会进入休眠。对于更多关于运行循环和基于端口的输入源，请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="external">运行循环</a>。</td>
</tr>
<tr>
<td>消息队列</td>
<td>iOS不可用</td>
</tr>
<tr>
<td>Cocoa发布对象</td>
<td>iOS不可用</td>
</tr>
</tbody>
</table>
<h4 id="设计技巧"><a href="#设计技巧" class="headerlink" title="设计技巧"></a>设计技巧</h4><p>下面几节提供了一些指导来帮助你以某种方式确保代码的正确性，进而提升线程的使用效果。某些指导还提供了一些关于使用你自己的线程代码来获得更好性能的相关技巧。就任何的性能技巧来说，你应该在每次修改代码之后，都要在执行之前、执行中和执行之后统计出相关的性能表现。</p>
<h5 id="避免直接创建线程"><a href="#避免直接创建线程" class="headerlink" title="避免直接创建线程"></a>避免直接创建线程</h5><p>是移动编写创建线程的代码是单调的并且容易有潜在的错误出现，因此可能的话尽量避免这样做。OS X和iOS在内部都通过其他API实现了并发支持。考虑使用异步API、GCD或者operation对象来完成工作，而不是自己创建线程。这些技术在幕后帮你完成了线程相关的工作且能够保证准确性。此外，如GCD和operation对象这种技术，在设计时就是为了在线程管理上比你自己的代码要更加高效（通过基于当前系统的状态自动调整可用线程的数量）。要了解更多关于GCD和operation对象的信息，查看<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091" target="_blank" rel="external">并发编程指南</a>。</p>
<h5 id="保持线程合理地执行"><a href="#保持线程合理地执行" class="headerlink" title="保持线程合理地执行"></a>保持线程合理地执行</h5><p>如果你要要手动创建并管理线程，记住线程会消耗相当多的系统资源，你应该尽最大努力来确保交付给线程的任务要合理地生存并有产出。同时，你不要害怕终止那些在大多时间都处于空闲状态下的线程。线程占用了非同一般的内存大小，有些数据发生了错误，因此释放一个闲置线程不仅有助于降低应用的内存占用，还可以释放更多的物理内存以便为其他的系统进程所使用。</p>
<blockquote>
<p><strong>重点</strong>：在你准备终止空闲线程之前，你总是应当对应用的当前性能进行一系列的测试并记录。在完成修改之后，进行额外的测试来验证此修改确实提高了性能，而不是降低了。</p>
</blockquote>
<h5 id="避免共享数据"><a href="#避免共享数据" class="headerlink" title="避免共享数据"></a>避免共享数据</h5><p>在程序中，最简单最容易去避免线程资源冲突的方式就是给每个线程都配备一份所需数据的拷贝。在你的线程间最小化通信和资源竞争时，平行无关的代码效果最好。</p>
<p>创建一个多线程的应用是很困难的。就算你非常认真并且在所有正确的时间点在代码中对共享数据进行加锁操作，你的代码可能在语义上依然是不安全的。比如，如果你希望共享数据按照指定顺序被修改，但是你的代码可能还会遇到问题。将代码修改为基于事务的模型作为补偿反而可能会抵消掉多线程的性能优势。将排除资源竞争作为第一要务可能会得到更简单的设计和更棒的性能。</p>
<h5 id="线程和你的用户界面"><a href="#线程和你的用户界面" class="headerlink" title="线程和你的用户界面"></a>线程和你的用户界面</h5><p>如果你的应用包含用户图形界面，极力建议你将接收用户相关事件和进行界面更新放到应用的主线程中。这种做法有助于避免在处理用户事件和绘制界面相关内容时出现同步问题。一些框架，如Cocoa，一般都作为必要行为，但是对于那些即使没有这么做的框架，将这些行为放到主线程中对于管理你的UI界面也有简化逻辑的优势。</p>
<p>在其他线程中执行图形操作时，还是存在几个例外事件是有性能优势的。比如，你可以使用子线程来创建并处理图片或者是其他的图片相关的计算。对这些操作使用子线程可以有效地提高性能。如果你不确定某个指定的图形操作能否提高性能，就计划将它放到主线程中进行处理吧。</p>
<p>对于更多关于Cocoa的线程安全，请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1" target="_blank" rel="external">线程安全总结</a>。对于更多的关于Cocoa的绘制信息，请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40003290" target="_blank" rel="external">Cocoa绘制指南</a>。</p>
<h5 id="在退出时注意线程行为"><a href="#在退出时注意线程行为" class="headerlink" title="在退出时注意线程行为"></a>在退出时注意线程行为</h5><p>一个进程会持续运行直到所有的非分离线程（non-detatched thread）都退出为止。默认来说，只有应用的主线程是非分离的，但是你也可以按照这种方式来创建其他线程。当用户退出应用时，通常要做正确行为的就是直接终止所有的分离线程执行，因为分离线程默认将此工作（关闭应用时自动退出）作为了可选操作。如果你的应用正在使用后台线程向磁盘中保存数据或者做一些其他的重要工作，可是，你也许要要将那些线程创建为非分离的方式来防止应用退出时出现的数据丢失。</p>
<p>创建非分离的线程（也叫做可绑定线程）需要你做额外的工作。因为大多数的上层线程技术默认都不会创建这种可绑定线程，你需要不得不使用POSIX的API来创建线程。此外，你还必须在主线程中添加代码来绑定这个非分离线程，以便它们可以在最终自动退出。要了解更多信息，请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW3" target="_blank" rel="external">设置分离状态的线程</a>。</p>
<h5 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h5><p>当异常抛出时，异常处理机制依赖于当前的调用栈来执行所有必要的清理工作。因为每个线程都有自己的调用栈，因此每个线程都要负责捕获自己的异常。在子线程中没有捕获异常与在主线程中没有捕获异常的结果一样：自身进程被终止。你不能抛出一个未捕获的异常给其他线程去处理。</p>
<p>如果你需要在当前线程通知另一个线程（比如主线程）有异常情况发送，你需要捕获这个异常后，直接给那个线程发送消息并说明发生的状况。依照你的模型和你所做的工作，捕获到异常的线程可以在之后继续处理（如果可以）、等待指示或者直接退出。</p>
<blockquote>
<p><strong>注意</strong>：在Cocoa中，一个NSException对象是一个自我包含的对象，即一旦被捕获到，就可以从一个线程传递到另一个线程中（即NSException对象是线程安全的）。</p>
</blockquote>
<p>在某些情况下，一个异常处理对象可能会是自动创建的。比如，<em>@synchronized</em> 指令在Objective-C中就包含一个隐含的异常处理对象。</p>
<h5 id="干净地终止线程"><a href="#干净地终止线程" class="headerlink" title="干净地终止线程"></a>干净地终止线程</h5><p>退出线程的最好方式就是自然地，通过让它执行到主入口点程序的结尾。虽然也存在一些可以直接终止线程的函数，可那些函数应该只作为最后的办法来使用。在线程执行到自然结束之前终止它会阻止线程的自动清除功能。如果线程已经开辟了内存、打开了文件或者获取了其他类型的资源，你的代码也许不能再回收那些资源，导致了内存泄漏或者其他的潜在问题。</p>
<p>对于以适当的方式来退出线程的更多其他信息，请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW10" target="_blank" rel="external">终止线程</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/AboutThreads/AboutThreads.html#//apple_ref/doc/uid/10000057i-CH6-SW2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;About Threaded Programming&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;关于线程的编程&quot;&gt;&lt;a href=&quot;#关于线程的编程&quot; class=&quot;headerlink&quot; title=&quot;关于线程的编程&quot;&gt;&lt;/a&gt;关于线程的编程&lt;/h3&gt;&lt;p&gt;多年来，几乎所有的电脑性能都被单核处理器的运算速度限制地非常严重。当单个处理器的运行速度达到瓶颈之后，芯片就切换到了多核设计，这就为电脑提供了可以同时执行多个任务的机会。虽然OS X在执行系统相关的任务时已经利用好了多核心处理器，但你的应用也需要通过线程来利用好它们。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Block复习</title>
    <link href="http://yoursite.com/2019/08/22/Block%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/08/22/Block复习/</id>
    <published>2019-08-22T08:40:27.374Z</published>
    <updated>2019-08-22T08:40:27.374Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Block的基本结构"><a href="#1-Block的基本结构" class="headerlink" title="1. Block的基本结构"></a>1. Block的基本结构</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"臭吉吉~"</span>);</div><div class="line">&#125;;</div><div class="line">testBlock();</div></pre></td></tr></table></figure>
<p>将包含Block的代码通过clang转换为c++代码（只用了c++的扩展struct，实际上还是c）。我们一句一句看：<br><a id="more"></a></p>
<ol>
<li>Block变量的声明：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (*testBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div></pre></td></tr></table></figure>
<p>可以看到，<strong>testBlock变量，实际上是 <em>__main_block_impl_0</em> 结构体实例的指针</strong>。</p>
<p>__main_block_impl_0的结构为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="comment">// 内容信息</span></div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="comment">// 描述信息</span></div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  </div><div class="line">  <span class="comment">// 保存捕获到的变量或指针（本代码无）</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  </div><div class="line">  <span class="comment">// 构造函数</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，用以识别Block对象的类型信息和Block的函数体都在 <em>__block_impl</em> 结构体中声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></div><div class="line">    <span class="comment">// 类型</span></div><div class="line">    <span class="keyword">void</span> *isa;</div><div class="line">    <span class="comment">// 引用计数等会存在这里</span></div><div class="line">    <span class="keyword">int</span> Flags;</div><div class="line">    <span class="comment">// 保留位</span></div><div class="line">    <span class="keyword">int</span> Reserved;</div><div class="line">    <span class="comment">// 函数指针</span></div><div class="line">    <span class="keyword">void</span> *FuncPtr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，<strong>FuncPtr指向的就是我们在Block中提供的函数体</strong>。而<em>isa</em>，即作为描述Block类型使用。由于Block在堆中也是遵循类似自动引用计数的内存管理机制，故可以把Block看做为对象。</p>
<p>而Block的描述信息，则是指向全局的 <em>__main_block_desc_0</em> 结构体的实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></div><div class="line">    <span class="comment">// 保留位</span></div><div class="line">    <span class="keyword">size_t</span> reserved;</div><div class="line">    <span class="comment">// Block整体的内存占用</span></div><div class="line">    <span class="keyword">size_t</span> Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; </div><div class="line">    <span class="number">0</span>, </div><div class="line">    <span class="keyword">sizeof</span>(struct __main_block_impl_0)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>Block的执行</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);</div></pre></td></tr></table></figure>
<p>了解了Block的结构，这一句就很好理解了。由于testBlock的地址与 <em>__block_impl</em> 指针的地址相同，因此直接转换为 <em>__block_impl</em> 类型。然后，获取其中的 <em>FuncPtr</em> 函数指针，传入自身作为参数后，直接调用执行。</p>
<blockquote>
<p><strong>传入自身作为 <em>FuncPtr</em> 的参数的目的</strong>：</p>
<p>由于Block的函数体在编译后成为了全局静态c函数（无状态保存）。因此，为了在调用时可以正常访问到捕获的变量，则将自身实例作为参数传入（这与OC调用方法的传参目的一样）。</p>
</blockquote>
<h4 id="2-Block捕获的变量"><a href="#2-Block捕获的变量" class="headerlink" title="2.Block捕获的变量"></a>2.Block捕获的变量</h4><h5 id="2-1-没有捕获变量"><a href="#2-1-没有捕获变量" class="headerlink" title="2.1 没有捕获变量"></a>2.1 没有捕获变量</h5><p><strong>Block在没有捕获任何变量时，其类型（isa）为<strong>NSGlobalBlock</strong></strong>。</p>
<h5 id="2-2-捕获基本类型变量"><a href="#2-2-捕获基本类型变量" class="headerlink" title="2.2 捕获基本类型变量"></a>2.2 捕获基本类型变量</h5><p>测试代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSInteger</span> value = <span class="number">3</span>;</div><div class="line"><span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, value);</div><div class="line">&#125;;</div><div class="line">testBlock();</div></pre></td></tr></table></figure>
<p><strong>在运行时，此Block的类型为<strong>NSMallocBlock</strong></strong>。已经被copy到堆中。</p>
<p>对于基本数据类型的变量，捕获后，其值直接保存到 <em>__main_block_impl_0</em> 结构体中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    </div><div class="line">    <span class="comment">// 直接保存值</span></div><div class="line">    NSInteger value;</div><div class="line">    </div><div class="line">    </div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, NSInteger _value, <span class="keyword">int</span> flags=<span class="number">0</span>) : value(_value) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp;</div><div class="line">        Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>由于是<strong>值传递，直接修改此Block变量中的value是不会影响原value的值</strong>。因此，编译器则直接不允许修改捕获的变量。</p>
<p>而且，这也解释了为何在 <em>FuncPtr</em> 中的需要传入block自身作为参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    <span class="comment">// 通过自身取出捕获的变量</span></div><div class="line">    NSInteger value = __cself-&gt;value;</div><div class="line"></div><div class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_z5_zmhjsn0s5szgbxdxfqvbgqlc0000gn_T_main_cf26fa_mi_0, value);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h5 id="2-3-捕获对象类型变量"><a href="#2-3-捕获对象类型变量" class="headerlink" title="2.3 捕获对象类型变量"></a>2.3 捕获对象类型变量</h5><p>测试代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, obj);</div><div class="line">&#125;;</div><div class="line">testBlock();</div></pre></td></tr></table></figure>
<p><strong>在运行时，此Block的类型为<strong>NSMallocBlock</strong></strong>。已经被copy到堆中。</p>
<p>由于捕获的是对象类型，因此编译后的c++代码与刚才有些不同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    </div><div class="line">    <span class="comment">// 直接保存对象（也就是地址）</span></div><div class="line">    id obj;</div><div class="line">    </div><div class="line"></div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, id _obj, <span class="keyword">int</span> flags=<span class="number">0</span>) : obj(_obj) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp;</div><div class="line">        Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>核心结构还是一样，直接将捕获对象保存到了 <em>__main_block_impl_0</em> 结构体中。产生变化的，是 <em>__main_block_desc_0</em> 的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> reserved;</div><div class="line">    <span class="keyword">size_t</span> Block_size;</div><div class="line">    </div><div class="line">    <span class="comment">// Block被copy时，捕获的变量执行的copy函数</span></div><div class="line">    <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">    </div><div class="line">    <span class="comment">// Block释放时，捕获的变量执行的释放函数</span></div><div class="line">    <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</div><div class="line">    </div><div class="line">&#125; __main_block_desc_0_DATA = &#123; </div><div class="line">    <span class="number">0</span>, </div><div class="line">    <span class="keyword">sizeof</span>(struct __main_block_impl_0), </div><div class="line">    __main_block_copy_0, </div><div class="line">    __main_block_dispose_0</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>由于捕获的变量是对象类型，因此，需要在结构体中指定实现内存管理方式的相应实现（clang可以在Block的相关结构体中对OC对象进行内存管理，但需要提供相应实现）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;obj, (<span class="keyword">void</span>*)src-&gt;obj, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;obj, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，当Block变量被copy到堆上时，系统则会调用 <em>_Block_object_assign</em> 函数，对捕获的obj进行retain；而当堆上的Block变量被释放时，系统则会调用 <em>_Block_object_dispose</em> 函数，对捕获的obj进行release操作。</p>
<p>为了行为一致，编译器也不允许对捕获的对象类型变量进行修改。</p>
<p>这可以保证捕获的对象在超出自身作用域后，继续生存（因为已经被堆上的Block保留）。</p>
<h5 id="2-4-捕获-block修饰的基本类型变量"><a href="#2-4-捕获-block修饰的基本类型变量" class="headerlink" title="2.4 捕获__block修饰的基本类型变量"></a>2.4 捕获__block修饰的基本类型变量</h5><p>测试代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__block <span class="built_in">NSInteger</span> value = <span class="number">3</span>;</div><div class="line"><span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">    value -= <span class="number">1</span>;</div><div class="line">&#125;;</div><div class="line">testBlock();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, value);</div></pre></td></tr></table></figure>
<p>首先，还是可以确认的是，<strong>在运行时，Block的类型是<strong>NSMallocBlock</strong></strong>。</p>
<p>转换代码后，就可以看到，使用了 <em>__block</em> 修饰符的实现就变了很多。我们还是一句一句来看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__attribute__((__blocks__(byref))) __Block_byref_value_0 value = &#123;</div><div class="line">    (<span class="keyword">void</span>*)<span class="number">0</span>,</div><div class="line">    (__Block_byref_value_0 *)&amp;value, </div><div class="line">    <span class="number">0</span>, </div><div class="line">    <span class="keyword">sizeof</span>(__Block_byref_value_0), </div><div class="line">    <span class="number">3</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，<strong><em>__block</em> 修饰的变量，实际上是一个全局的 <em>__Block_byref_value_0</em> 结构体的实例</strong>。我们看一下此结构体的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_value_0</span> &#123;</span></div><div class="line">    <span class="comment">// 类型标识</span></div><div class="line">    <span class="keyword">void</span> *__isa;</div><div class="line">    <span class="comment">// 指向自身实例的指针</span></div><div class="line">    __Block_byref_value_0 *__forwarding;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> __flags;</div><div class="line">    <span class="keyword">int</span> __size;</div><div class="line">    </div><div class="line">    <span class="comment">// 真正的值</span></div><div class="line">    NSInteger value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，原始变量的真实值保存在结构体中。此结构体中不仅包含了类型标识、尺寸等信息，还包含了一个指向自身实例的指针。</p>
<p>下面是Block变量声明，只是将 <em>__Block_byref_value_0</em> 的地址传入，没有什么异常：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// testBlock变量声明及赋值</span></div><div class="line"><span class="keyword">void</span> (*testBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0(</div><div class="line">    (<span class="keyword">void</span> *)__main_block_func_0, </div><div class="line">    &amp;__main_block_desc_0_DATA, </div><div class="line">    (__Block_byref_value_0 *)&amp;value, </div><div class="line">    <span class="number">570425344</span>)</div><div class="line">);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// __main_block_impl_0的结构体</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    </div><div class="line">    <span class="comment">// 引用传递捕获的变量</span></div><div class="line">    __Block_byref_value_0 *value;</div><div class="line">    </div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_value_0 *_value, <span class="keyword">int</span> flags=<span class="number">0</span>) : value(_value-&gt;__forwarding) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp;</div><div class="line">        Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，唯一的区别就是，<strong>在捕获的带有 <em>__block</em> 修饰的变量，生成的Block变量中，是以引用传递的方式进行储存的</strong>。这也就意味着捕获的变量的内容是可以随意修改的，而且，<strong>访问或者修改的是 <em>__Block_byref_value_0</em> 的实例，而不是原始的变量</strong>。</p>
<p>对于Block中的描述信息，其实现也有些许变化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> reserved;</div><div class="line">    <span class="keyword">size_t</span> Block_size;</div><div class="line">    <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">    <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; </div><div class="line">    <span class="number">0</span>, </div><div class="line">    <span class="keyword">sizeof</span>(struct __main_block_impl_0), </div><div class="line">    __main_block_copy_0, </div><div class="line">    __main_block_dispose_0</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，使用 <em>__block</em> 修饰的变量，在捕获到Block中后，也需要在Block被copy到堆上、或从堆中释放时提供对应的内存管理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;value, (<span class="keyword">void</span>*)src-&gt;value, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;value, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里<strong>与捕获对象类型变量时，生成的内存管理函数中，区别只是类型不同，是 <em>BLOCK_FIELD_IS_BYREF</em> （捕获的对象类型变量是 <em>BLOCK_FIELD_IS_OBJECT</em> ）</strong>。</p>
<p>与对象的保留关系不同，这种方式，实际上是创建一个新对象（结构体实例，如 <em>__Block_byref_value_0</em> ，内部包含着被捕获的变量的值）直接存储在Block中。<strong>当Block被copy到堆上时，再创建一个新的 <em>__Block_byref_value_0</em> 实例，并保存在堆上的Block中</strong>。</p>
<blockquote>
<p><strong>在 <em>__Block_byref_value_0</em> 的结构中，为什么会包含一个指向自身实例的指针 <em>__forwarding</em> ？</strong></p>
<p>为了保证访问到捕获变量的一致性。<br>在Block被copy到堆上时，不仅生成一个新的 <em>__Block_byref_value_0</em> 实例。而且将原始 <em>__Block_byref_value_0</em> 的 <em>__forwarding</em> 指针指向了新的实例。因此，通过形如 <em>value.__forwarding-&gt;value</em> 的方式，不管是在栈上，还是在堆上，都可以访问到堆中的同一个变量。</p>
</blockquote>
<p>所以，我们最后看一下在Block执行之后，打印语句NSLog。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSLog(</div><div class="line">    (NSString *)&amp;__NSConstantStringImpl__var_folders_z5_zmhjsn0s5szgbxdxfqvbgqlc0000gn_T_main_316d85_mi_0, </div><div class="line">    (value.__forwarding-&gt;value)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>由于是在栈上执行，因此 <em>value.__forwarding-&gt;value</em> 最终指向的是堆上的Block中的新 <em>__Block_byref_value_0</em> 实例。</p>
<h5 id="2-5-捕获-block修饰的对象类型变量"><a href="#2-5-捕获-block修饰的对象类型变量" class="headerlink" title="2.5 捕获__block修饰的对象类型变量"></a>2.5 捕获__block修饰的对象类型变量</h5><p>测试代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__block <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">    obj = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">&#125;;</div><div class="line">testBlock();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, obj);</div></pre></td></tr></table></figure>
<p>转换后的代码与 <em>__block</em> 修饰的基本类型变量很相似，都是生成一个对应的结构体实例，然后将变量存储在内部。</p>
<p>我们看一下生成过程（代码经过简化）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">__attribute__((__blocks__(byref))) __Block_byref_obj_0 obj = &#123;</div><div class="line">    (<span class="keyword">void</span>*)<span class="number">0</span>,</div><div class="line">    (__Block_byref_obj_0 *)&amp;obj, </div><div class="line">    <span class="number">33554432</span>, </div><div class="line">    <span class="keyword">sizeof</span>(__Block_byref_obj_0), </div><div class="line">    __Block_byref_id_object_copy_131, </div><div class="line">    __Block_byref_id_object_dispose_131, </div><div class="line">    [[NSObject alloc] init]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，<em>__Block_byref_obj_0</em> 的结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_obj_0</span> &#123;</span></div><div class="line">    <span class="keyword">void</span> *__isa;</div><div class="line">    <span class="comment">// 指向自身实例的指针</span></div><div class="line">    __Block_byref_obj_0 *__forwarding;</div><div class="line">    <span class="keyword">int</span> __flags;</div><div class="line">    <span class="keyword">int</span> __size;</div><div class="line">    </div><div class="line">    <span class="comment">// obj</span></div><div class="line">    <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</div><div class="line">    </div><div class="line">    <span class="comment">// obj释放函数</span></div><div class="line">    <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</div><div class="line">    </div><div class="line">    <span class="comment">// 真正的对象</span></div><div class="line">    id obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，<em>__block</em> 修饰的对象类型结构体，不仅包含与基本类型一样的成员，<strong>额外还包含了两个内存管理函数，用于在自身实例因Block的内存变化导致的变化时，包含的obj进行的保留和释放操作</strong>（Block的内存管理 -&gt; __Block_byref_obj_0的内存变化 -&gt; obj的内存变化）。</p>
<p>这里，我们看一下这一对内存管理函数的简单实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_copy_131(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src) &#123;</div><div class="line">    _Block_object_assign((<span class="keyword">char</span>*)dst + <span class="number">40</span>, *(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_dispose_131(<span class="keyword">void</span> *src) &#123;</div><div class="line">    _Block_object_dispose(*(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，以copy方法为例，实际上与描述信息 <em>__main_block_desc_0_DATA</em> 中的 <em>__main_block_copy_0</em> 函数实现一样，都是调用了 <em>_Block_object_assign</em> 函数。只不过参数有些许不同：</p>
<p>src+40偏移量即为 <em>__Block_byref_obj_0</em> 结构体中的obj的地址。131即 <em>BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT</em> 。</p>
<p>以 <em>_Block_object_assign</em> 实现为例（节选自苹果的Blocks源代码 <em>Blocks/Sources/runtime.c</em>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> _Block_object_assign(<span class="keyword">void</span> *destAddr, <span class="keyword">const</span> <span class="keyword">void</span> *object, <span class="keyword">const</span> <span class="keyword">int</span> flags) &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT:</div><div class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK:</div><div class="line">        <span class="comment">/*******</span></div><div class="line">         // copy the actual field held in the __block container</div><div class="line">         __block id object;</div><div class="line">         __block void (^object)(void);</div><div class="line">         [^&#123; object; &#125; copy];</div><div class="line">         ********/</div><div class="line"></div><div class="line">        <span class="comment">// under manual retain release __block object/block variables are dangling</span></div><div class="line">        _Block_assign((<span class="keyword">void</span> *)object, destAddr);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">        </div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*_Block_assign)</span><span class="params">(<span class="keyword">void</span> *value, <span class="keyword">void</span> **destptr)</span> </span>= _Block_assign_default;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _Block_assign_default(<span class="keyword">void</span> *value, <span class="keyword">void</span> **destptr) &#123;</div><div class="line">    *destptr = value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在这种情况下，copy操作只是使用一个新的指针指向原始obj。</p>
<p>在ARC下，实际上就是对obj进行了强引用，也就是retain操作；但是在非ARC下，这只是一个指针指向，可能造成悬垂指针访问，切记。</p>
<p>而在 <em>__main_block_desc_0_DATA</em> 中，使用的copy和dispose函数与 <em>__block</em> 修饰的基本类型变量一致：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;obj, (<span class="keyword">void</span>*)src-&gt;obj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;obj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，再看一下我们在Block函数体中对捕获变量的修改（代码已简化）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    <span class="comment">// 通过引用访问</span></div><div class="line">    __Block_byref_obj_0 *obj = __cself-&gt;obj; </div><div class="line">    </div><div class="line">    <span class="comment">// 通过__forwarding指针访问到的永远是相同的obj</span></div><div class="line">    (obj-&gt;__forwarding-&gt;obj) = [[NSMutableArray alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><ol>
<li>在ARC环境下，Block在不捕获变量时，是<strong>NSGlobalBlock</strong>类型；否则，都是<strong>NSMallocBlock</strong>类型。</li>
<li>捕获到的基本数据类型变量或OC对象，直接存储值到Block的数据结构中，为值传递，外部修改无效。</li>
<li>捕获到的__block修饰的基本类型变量或OC对象，是以包装成的新的结构体实例的方式存储到Block的数据结构中，为引用传递，可以进行修改。</li>
<li>ARC环境下，Block从栈上到被copy到堆上时，捕获的OC对象或是<strong>block的OC对象，都会被retain；捕获的</strong>block的基本类型变量，会创建一个新的结构体，保存在copy后的Block中。</li>
<li>非ARC环境下，使用<strong>block修饰的OC对象，在被Block捕获后，可以防止循环引用（只是指针指向，没有retain操作，ARC下才是默认retain）。在ARC下，使用</strong>weak修饰变量替代。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-Block的基本结构&quot;&gt;&lt;a href=&quot;#1-Block的基本结构&quot; class=&quot;headerlink&quot; title=&quot;1. Block的基本结构&quot;&gt;&lt;/a&gt;1. Block的基本结构&lt;/h4&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (^testBlock)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) = ^&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;臭吉吉~&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;testBlock();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将包含Block的代码通过clang转换为c++代码（只用了c++的扩展struct，实际上还是c）。我们一句一句看：&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>使用__weak变量，指向的对象就会被加到autoreleasepool中？</title>
    <link href="http://yoursite.com/2019/08/20/%E4%BD%BF%E7%94%A8__weak%E5%8F%98%E9%87%8F%EF%BC%8C%E6%8C%87%E5%90%91%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%B1%E4%BC%9A%E8%A2%AB%E5%8A%A0%E5%88%B0autoreleasepool%E4%B8%AD%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/08/20/使用__weak变量，指向的对象就会被加到autoreleasepool中？/</id>
    <published>2019-08-20T06:04:29.479Z</published>
    <updated>2019-08-20T06:04:56.099Z</updated>
    
    <content type="html"><![CDATA[<p>在《Objective-C高级编程》的第一部分内存管理中，有这么一节，其中说明了一个结论：</p>
<blockquote>
<p>使用附有__weak修饰符的变量，即是使用注册到autoreleasepool中的对象。</p>
</blockquote>
<p>按道理来说没有错。在ARC环境下，为了防止在使用过程中__weak指针指向的对象被释放，运行时系统就会自动将对象加入自动释放池中（ <em>-autorelease</em> ），延后释放过程。<br><a id="more"></a></p>
<h4 id="1-对于书中结论的验证"><a href="#1-对于书中结论的验证" class="headerlink" title="1. 对于书中结论的验证"></a>1. 对于书中结论的验证</h4><p>可是，按照书中的验证方式，我并没有发现autoreleasepool的容器中插入了对象。更离奇的是，书中还有说：</p>
<blockquote>
<p>如果大量地使用附有__weak修饰符的变量，注册到autoreleasepool的对象也会大量增加。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> o = obj;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1 %@"</span>, o);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2 %@"</span>, o);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3 %@"</span>, o);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"4 %@"</span>, o);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"5 %@"</span>, o);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用 <em>_objc_autoreleasePoolPrint()</em> 函数，书中得到的结果是：</p>
<blockquote>
<p>#########<br>AUTORELEASE POOLS for thread 0xad0392c0<br>6 releases pending<br>[0x6a85000] ………… PAGE (hot) (cold)<br>[0x6a85028] ############ POOL 0x6a85028<br>[0x6a8502c]       0x6719e40 NSObject<br>[0x6a85030]       0x6719e40 NSObject<br>[0x6a85034]       0x6719e40 NSObject<br>[0x6a85038]       0x6719e40 NSObject<br>[0x6a8503c]       0x6719e40 NSObject</p>
<p>########</p>
</blockquote>
<p>可是实际上，我的到的结果是</p>
<blockquote>
<p>objc[4106]: ##############<br>objc[4106]: AUTORELEASE POOLS for thread 0x1000a95c0<br>objc[4106]: 1 releases pending.<br>objc[4106]: [0x102801000]  ……………. PAGE  (hot) (cold)<br>objc[4106]: [0x102801038]  ##############  POOL 0x102801038<br>objc[4106]: ##############</p>
</blockquote>
<p>明显不一致。那么问题出在哪呢？</p>
<p>因为我想，使用<strong>weak对象，即是对</strong>weak对象发消息。因此，换一种方式，调用任意一个方法，比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">    <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> weakObj = obj;</div><div class="line">    [weakObj description];</div><div class="line">    [weakObj description];</div><div class="line">    [weakObj description];</div><div class="line">    [weakObj description];</div><div class="line">    [weakObj description];</div><div class="line">    _objc_autoreleasePoolPrint();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>得到的结果是</p>
<blockquote>
<p>objc[4279]: ##############<br>objc[4279]: AUTORELEASE POOLS for thread 0x1000a95c0<br>objc[4279]: 6 releases pending.<br>objc[4279]: [0x101003000]  …………….  PAGE  (hot) (cold)<br>objc[4279]: [0x101003038]  ################  POOL 0x101003038<br>objc[4279]: [0x101003040]       0x102025d00  <strong>NSCFString<br>objc[4279]: [0x101003048]       0x1020022e0  </strong>NSCFString<br>objc[4279]: [0x101003050]       0x102025cb0  <strong>NSCFString<br>objc[4279]: [0x101003058]       0x102025db0  </strong>NSCFString<br>objc[4279]: [0x101003060]       0x102025de0  __NSCFString<br>objc[4279]: ##############</p>
</blockquote>
<p>这便与书中的结论不谋而合了。</p>
<p>同时，这也证实了“<u><em>使用附有__weak修饰符的变量，即是使用注册到autoreleasepool中的对象</em></u>”这一结论。</p>
<p>那么，添加到autoreleasepool的这一过程是如何实现的呢。</p>
<p>按书中所说，使用<strong>weak对象之前，</strong>weak指针进行了如下操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> tmp = objc_loadWeakRetained(&amp;obj);</div><div class="line">objc_autorelease(tmp);</div></pre></td></tr></table></figure>
<p>其中，<em>objc_loadWeakRetained</em>实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span></div><div class="line">objc_loadWeakRetained(<span class="keyword">id</span> *location)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// id *location即指向对象的指针（也就是weak指针的地址）</span></div><div class="line">    </div><div class="line">    <span class="keyword">id</span> obj;</div><div class="line">    <span class="keyword">id</span> result;</div><div class="line">    Class cls;</div><div class="line"></div><div class="line">    SideTable *table;</div><div class="line">    </div><div class="line"> retry:</div><div class="line">    obj = *location; <span class="comment">// 取出对象</span></div><div class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span> obj;</div><div class="line">    </div><div class="line">    table = &amp;SideTables()[obj]; <span class="comment">// 获取对应的SideTable</span></div><div class="line">    </div><div class="line">    table-&gt;lock();</div><div class="line">    <span class="keyword">if</span> (*location != obj) &#123;</div><div class="line">        table-&gt;unlock();</div><div class="line">        <span class="keyword">goto</span> retry;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    result = obj;</div><div class="line"></div><div class="line">    cls = obj-&gt;ISA();</div><div class="line">    <span class="keyword">if</span> (! cls-&gt;hasCustomRR()) &#123;</div><div class="line">        assert(cls-&gt;isInitialized());</div><div class="line">        </div><div class="line">        <span class="comment">// 没有覆盖内存管理的相关方法，</span></div><div class="line">        <span class="comment">// 则对obj进行retain操作</span></div><div class="line">        <span class="keyword">if</span> (! obj-&gt;rootTryRetain()) &#123;</div><div class="line">            <span class="comment">// 不成功，返回nil</span></div><div class="line">            result = <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (cls-&gt;isInitialized() || _thisThreadIsInitializingClass(cls)) &#123;</div><div class="line">            <span class="built_in">BOOL</span> (*tryRetain)(<span class="keyword">id</span>, SEL) = (<span class="built_in">BOOL</span>(*)(<span class="keyword">id</span>, SEL))</div><div class="line">                class_getMethodImplementation(cls, SEL_retainWeakReference);</div><div class="line">            <span class="keyword">if</span> ((IMP)tryRetain == _objc_msgForward) &#123;</div><div class="line">                result = <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// tryRetain的IMP存在（函数指针存在）</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (! (*tryRetain)(obj, SEL_retainWeakReference)) &#123;</div><div class="line">                <span class="comment">// 指行retain不成功，返回nil</span></div><div class="line">                result = <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// class没有初始化（首次访问）</span></div><div class="line">            table-&gt;unlock();</div><div class="line">            <span class="comment">// 对cls进行初始化，之后重新检查</span></div><div class="line">            _class_initialize(cls);</div><div class="line">            <span class="keyword">goto</span> retry;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    table-&gt;unlock();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由代码可知，</p>
<ol>
<li>真正的操作即是对weak指向对象的 <em>obj-&gt;rootTryRetain()</em> 操作。在其中根据对象类型进行retain。</li>
<li>之后，返回的tmp对象即为指向的对象（与obj相同），对其进行autorelease操作，将对象添加到底层当前的AutoReleasePoolPage中，以延后释放。</li>
<li>最后，才可以正常使用__weak对象进行操作。</li>
<li>当autoreleasepool准备drain时，才会将weak指向的对象进行release。</li>
</ol>
<p>从此过程中，我们可以知道：</p>
<p><strong>每使用一次<strong>weak对象，运行时系统都会将其指向的原始对象先retain，之后保存到自动释放池中（ <em>AutoReleasePoolPage的add()</em> 函数）。因此如果大量调用</strong>weak对象，则会重复进行此工作。不仅耗费无意义的性能（重复存储同一对象），还会使内存在短时间内大量增长</strong>。</p>
<h4 id="2-NSLog引发的猜想"><a href="#2-NSLog引发的猜想" class="headerlink" title="2. NSLog引发的猜想"></a>2. NSLog引发的猜想</h4><p>虽然过程明白了，但是还有一个问题，为什么按照书中，使用<em>NSLog</em>函数访问__weak对象，就不会将指向的对象加入到autoreleasepool中呢？</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1566280780-NSLog%E8%AE%BF%E9%97%AEweak%E5%8F%98%E9%87%8F.jpg" alt="NSLog访问weak变量"></p>
<p>如图，在调试代码过程中，偶然发现，在每次执行<em>NSLog</em>语句时，都会触发调用<em>objc_autoreleasePoolPush</em>函数，调用完成之后，还会执行<em>objc_autoreleasePoolPop</em>函数。这不就是明显的 @autoreleasepool{} 的实现吗？</p>
<p>通过调试不难发现，通过NSLog访问<strong>weak对象并不是不触发添加到自动释放池的过程，而是<strong>在NSLog自身实现中，包含了自己的autoreleasepool</strong>，在调用过程中，**</strong>weak指向的对象被retain后，加入到了此内部的autoreleasepool中**。待NSLog执行完成后，autoreleasepool在RunLoop的循环中被释放，其内部的对象也被移除出autoreleasepool后被执行release了。<br>因此，在外部方法执行过程中，__weak指针指向的对象的引用计数不发生变化，且所在的autoreleasepool中并不包含此对象就不难理解了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《Objective-C高级编程》的第一部分内存管理中，有这么一节，其中说明了一个结论：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用附有__weak修饰符的变量，即是使用注册到autoreleasepool中的对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按道理来说没有错。在ARC环境下，为了防止在使用过程中__weak指针指向的对象被释放，运行时系统就会自动将对象加入自动释放池中（ &lt;em&gt;-autorelease&lt;/em&gt; ），延后释放过程。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS内存管理及ARC相关实现学习</title>
    <link href="http://yoursite.com/2019/08/19/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8F%8AARC%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/08/19/iOS内存管理及ARC相关实现学习/</id>
    <published>2019-08-19T09:34:20.798Z</published>
    <updated>2019-08-19T09:34:20.798Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-对象与类"><a href="#1-对象与类" class="headerlink" title="1. 对象与类"></a>1. 对象与类</h4><h5 id="1-1-对象"><a href="#1-1-对象" class="headerlink" title="1.1 对象"></a>1.1 对象</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></div><div class="line">    <span class="keyword">isa_t</span> isa;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对象（Class或id）内部只有一个isa_t联合体指针。</p>
<a id="more"></a>
<p>isa_t联合体内部只有两种成员： Class和bits。其内存结构依照下面的匿名struct进行分配（使用“位域”方式）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    Class cls;</div><div class="line">    <span class="keyword">uintptr_t</span> bits;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">        ...</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以x86_64架构为例，bits的内存结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></div><div class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></div><div class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></div><div class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">        <span class="comment">// 指针优化标识</span></div><div class="line">        <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;</div><div class="line">        <span class="comment">// 存在相关对象标识</span></div><div class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</div><div class="line">        <span class="comment">// 包含c++析构函数标识（.cxx_destruct）</span></div><div class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</div><div class="line">        <span class="comment">// nonpointer为1时，此数据即为相关信息</span></div><div class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x7fffffe00000</span></div><div class="line">        <span class="comment">// 类的初始化标识</span></div><div class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</div><div class="line">        <span class="comment">// 有弱引用标识</span></div><div class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</div><div class="line">        <span class="comment">// 正在释放标识</span></div><div class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</div><div class="line">        <span class="comment">// 存在外部SideTable中的引用计数标识（extra_rc &gt; 255后，存储在外部）</span></div><div class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</div><div class="line">        <span class="comment">// 引用计数（&lt; 256时使用），比真实计数少1</span></div><div class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span>;</div><div class="line">        <span class="comment">// 引用计数的最低位为1</span></div><div class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;56)</span></div><div class="line">        <span class="comment">// extra_rc引用计数最大值的一半 128</span></div><div class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;7)</span></div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>故可以看出，<strong>在64位环境下，对象占用的内存是8字节</strong>。</p>
<h5 id="1-2-类"><a href="#1-2-类" class="headerlink" title="1.2 类"></a>1.2 类</h5><p><strong>类Class是objc_class的结构体指针</strong>。其继承了objc_object。主要结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</div><div class="line">    Class superClass;</div><div class="line">    <span class="keyword">cache_t</span> cache;</div><div class="line">    <span class="keyword">class_data_bits_t</span> bits;</div><div class="line">    </div><div class="line">    <span class="keyword">class_rw_t</span> *data() &#123;</div><div class="line">        <span class="keyword">return</span> bits.data();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了isa_t数据成员，还包含了父类指针，缓存成员及class_data_bits_t数据。<br>其中，在运行时，类中的相关信息（成员、方法列表、协议列表等）都保存在bits中，也就是class_rw_t指向的数据中。</p>
<blockquote>
<p>在编译期，data方法获取到的是class_ro_t的数据，其内部包含的都是在编译期决议的东西。在运行期（runtime系统加载时），其他信息才会加载到类中（如category实现的相关对象、方法等），data返回的才是完整的class_rw_t指针信息。</p>
</blockquote>
<h4 id="2-内存管理容器"><a href="#2-内存管理容器" class="headerlink" title="2. 内存管理容器"></a>2. 内存管理容器</h4><h5 id="2-1-SideTable"><a href="#2-1-SideTable" class="headerlink" title="2.1 SideTable"></a>2.1 SideTable</h5><p>SideTable作为内存管理信息保存的容器，在系统中存储多个。系统通过实例对象的hash值与SideTable进行绑定。<br>一个实例对象对应一个SideTable，而一个SideTable可以供多个实例对象共用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></div><div class="line">    <span class="comment">/** 自旋锁 */</span></div><div class="line">    <span class="keyword">spinlock_t</span> slock;</div><div class="line">    <span class="comment">/** 引用计数表（散列表） */</span></div><div class="line">    RefcountMap refcnts;</div><div class="line">    <span class="comment">/** weak表（内部使用数组或二级表实现） */</span></div><div class="line">    <span class="keyword">weak_table_t</span> weak_table;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// 相关初始化</span></div><div class="line"></div><div class="line"><span class="comment">// 返回内存对齐后的SideTable指针</span></div><div class="line">alignas(StripedMap&lt;SideTable&gt;) <span class="keyword">static</span> <span class="keyword">uint8_t</span> </div><div class="line">    SideTableBuf[<span class="keyword">sizeof</span>(StripedMap&lt;SideTable&gt;)];</div><div class="line"></div><div class="line"><span class="comment">// 初始化SideTable</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SideTableInit</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> (SideTableBuf) StripedMap&lt;SideTable&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 获取SideTable数组</span></div><div class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中说明，由于libc在C++初始化对象之前就调用了SideTable，且没有使用全局指针。故使用了这种方式初始化。</p>
<p>根据源码可以看到，SideTables是模板类StripedMap使用SideTable结构体初始化的类实例的指针。StripedMap是一个使用分离锁实现的类，内部成员是一个数组，使用hash算法进行索引存储。其算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span>&#123;</div><div class="line">    <span class="keyword">uintptr_t</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(p);</div><div class="line">    <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>故在生成SideTable时，系统使用实例对象的地址，将其进行hash计算后，得到index索引，最终从数组中取出SideTable对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// StripedMap重载了“[]”运算符</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">T&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) &#123; </div><div class="line">    <span class="keyword">return</span> <span class="built_in">array</span>[indexForPointer(p)].value; </div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) <span class="keyword">const</span> &#123; </div><div class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;StripedMap&lt;T&gt;&gt;(<span class="keyword">this</span>)[p]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SideTable的获取：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSObject</span> obj;</div><div class="line">SideTable *table = &amp;SideTables()[obj];</div></pre></td></tr></table></figure>
<h5 id="2-2-RefcountMap"><a href="#2-2-RefcountMap" class="headerlink" title="2.2 RefcountMap"></a>2.2 RefcountMap</h5><p>RefcountMap是引用计数表存储的数据结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,<span class="keyword">size_t</span>,<span class="literal">true</span>&gt; RefcountMap;</div></pre></td></tr></table></figure>
<p>其中存储的key是objc_object的指针。</p>
<p>根据继承关系可以发现，DenseMap继承的是DenseMapBase类，其内部存储的元素BucketT是c++键值对，而其主要功能，就是返回c++的迭代器iterator。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DenseMapBase类</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;KeyT, ValueT&gt; BucketT; <span class="comment">// 键值对定义为BucketT</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// public API示例</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// When the map is empty, avoid the overhead of AdvancePastEmptyBuckets().</span></div><div class="line"><span class="keyword">return</span> empty() ? end() : iterator(getBuckets(), getBucketsEnd());</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">inline</span> iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> iterator(getBucketsEnd(), getBucketsEnd(), <span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DenseMap类</span></div><div class="line">BucketT *Buckets;</div><div class="line"><span class="keyword">unsigned</span> NumEntries;</div><div class="line"><span class="keyword">unsigned</span> NumTombstones;</div><div class="line"><span class="keyword">unsigned</span> NumBuckets;</div></pre></td></tr></table></figure>
<p>因此，从代码可以知道，<strong>RefcountMap是一个存储键值对（实例对象指针作为key，size_t作为value），使用迭代器进行索引的散列表</strong>。</p>
<h4 id="3-内存管理相关"><a href="#3-内存管理相关" class="headerlink" title="3. 内存管理相关"></a>3. 内存管理相关</h4><h5 id="3-1-alloc-amp-init"><a href="#3-1-alloc-amp-init" class="headerlink" title="3.1 alloc &amp; init"></a>3.1 alloc &amp; init</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>)alloc &#123;</div><div class="line">    <span class="keyword">return</span> _objc_rootAlloc(<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">id</span></div><div class="line">_objc_rootAlloc(Class cls)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> callAlloc(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span></div><div class="line">callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line"></div><div class="line"><span class="meta">#if __OBJC2__</span></div><div class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</div><div class="line">        <span class="comment">// No alloc/allocWithZone implementation. Go straight to the allocator.</span></div><div class="line">        <span class="comment">// fixme store hasCustomAWZ in the non-meta class and </span></div><div class="line">        <span class="comment">// add it to canAllocFast's summary</span></div><div class="line">        <span class="keyword">if</span> (fastpath(cls-&gt;canAllocFast())) &#123;</div><div class="line">            <span class="comment">// No ctors, raw isa, etc. Go straight to the metal.</span></div><div class="line">            <span class="keyword">bool</span> dtor = cls-&gt;hasCxxDtor();</div><div class="line">            <span class="keyword">id</span> obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, cls-&gt;bits.fastInstanceSize());</div><div class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</div><div class="line">            obj-&gt;initInstanceIsa(cls, dtor);</div><div class="line">            <span class="keyword">return</span> obj;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Has ctor or raw isa or something. Use the slower path.</span></div><div class="line">            <span class="keyword">id</span> obj = class_createInstance(cls, <span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</div><div class="line">            <span class="keyword">return</span> obj;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">// No shortcuts available.</span></div><div class="line">    <span class="keyword">if</span> (allocWithZone) <span class="keyword">return</span> [cls allocWithZone:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> [cls alloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据调用流程，NSObject的实例创建中，实际上调用的是 <em>id obj = class_createInstance(cls, 0);</em> 。在内部实现中，可以发现zone已经被忽略。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> __attribute__((always_inline)) </div><div class="line"><span class="keyword">id</span></div><div class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="keyword">void</span> *zone, </div><div class="line">                              <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>, </div><div class="line">                              size_t *outAllocatedSize = <span class="literal">nil</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    assert(cls-&gt;isRealized());</div><div class="line"></div><div class="line">    <span class="comment">// Read class's info bits all at once for performance</span></div><div class="line">    <span class="keyword">bool</span> hasCxxCtor = cls-&gt;hasCxxCtor();</div><div class="line">    <span class="keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();</div><div class="line">    <span class="keyword">bool</span> fast = cls-&gt;canAllocNonpointer();</div><div class="line"></div><div class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</div><div class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;</div><div class="line"></div><div class="line">    <span class="keyword">id</span> obj;</div><div class="line">    <span class="keyword">if</span> (!zone  &amp;&amp;  fast) &#123;</div><div class="line">        obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, size);</div><div class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (zone) &#123;</div><div class="line">            obj = (<span class="keyword">id</span>)malloc_zone_calloc ((malloc_zone_t *)zone, <span class="number">1</span>, size);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, size);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be </span></div><div class="line">        <span class="comment">// doing something weird with the zone or RR.</span></div><div class="line">        obj-&gt;initIsa(cls);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</div><div class="line">        obj = _objc_constructOrFree(obj, cls);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而最终，经过多步跳转，<strong>最后执行的是 <em>obj = (id)calloc(1, size);</em> ，也就是给对象分配内存</strong>。<br>然后通过 <em>obj-&gt;initInstanceIsa(cls, hasCxxDtor);</em> 给对象初始化isa_t中的相关信息。</p>
<blockquote>
<p>注：<br>在创建实例对象的过程中，我们发现，系统在类的结构中会尽量使用nonpointer的方式创建对象，以便直接使用自身指针所占空间进行信息保存，提高效率。</p>
</blockquote>
<p>最后的isa_t信息赋值过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </div><div class="line">objc_object::initIsa(Class cls, <span class="keyword">bool</span> nonpointer, <span class="keyword">bool</span> hasCxxDtor) </div><div class="line">&#123; </div><div class="line">    assert(!isTaggedPointer()); </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!nonpointer) &#123;</div><div class="line">        isa.cls = cls;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        assert(!DisableNonpointerIsa);</div><div class="line">        assert(!cls-&gt;instancesRequireRawIsa());</div><div class="line"></div><div class="line">        <span class="keyword">isa_t</span> newisa(<span class="number">0</span>);</div><div class="line"></div><div class="line">        newisa.bits = ISA_MAGIC_VALUE;</div><div class="line">        <span class="comment">// isa.magic is part of ISA_MAGIC_VALUE</span></div><div class="line">        <span class="comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></div><div class="line">        newisa.has_cxx_dtor = hasCxxDtor;</div><div class="line">        newisa.shiftcls = (<span class="keyword">uintptr_t</span>)cls &gt;&gt; <span class="number">3</span>;</div><div class="line"></div><div class="line">        isa = newisa;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，我们也并<strong>未发现系统对新对象的引用计数进行过操作</strong>。</p>
<p>而对于init方法，系统默认只是简单地返回了实例对象自身：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)init &#123;</div><div class="line">    <span class="keyword">return</span> _objc_rootInit(<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">id</span></div><div class="line">_objc_rootInit(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// In practice, it will be hard to rely on this function.</span></div><div class="line">    <span class="comment">// Many classes do not properly chain -init calls.</span></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>总结：</p>
<p>二段式初始化实例对象，只是分配内存空间，并给isa成员赋值，然后通过init方法返回实例对象。且 <em><u>并没有</u></em> 将引用计数设置为1。</p>
</blockquote>
<h5 id="3-2-retainCount"><a href="#3-2-retainCount" class="headerlink" title="3.2 retainCount"></a>3.2 retainCount</h5><p>由于初始化时系统没有处理引用计数，故我们可以从retainCount中下手，查看如何实现。实例对象的引用计数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)retainCount &#123;</div><div class="line">    <span class="keyword">return</span> ((id)self)-&gt;rootRetainCount();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">uintptr_t</span> </div><div class="line">objc_object::rootRetainCount()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)<span class="keyword">this</span>;</div><div class="line"></div><div class="line">    sidetable_lock();</div><div class="line">    </div><div class="line">    <span class="comment">// 获取bits数据</span></div><div class="line">    <span class="keyword">isa_t</span> bits = LoadExclusive(&amp;isa.bits);</div><div class="line">    ClearExclusive(&amp;isa.bits);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (bits.nonpointer) &#123;</div><div class="line">        <span class="comment">// 优化过的nonpointer</span></div><div class="line">        <span class="keyword">uintptr_t</span> rc = <span class="number">1</span> + bits.extra_rc; <span class="comment">// 使用extra_rc位记录8位，即255以内的计数</span></div><div class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</div><div class="line">            <span class="comment">// 超过上限，加上SideTable的额外计数</span></div><div class="line">            rc += sidetable_getExtraRC_nolock();</div><div class="line">        &#125;</div><div class="line">        sidetable_unlock();</div><div class="line">        <span class="keyword">return</span> rc;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sidetable_unlock();</div><div class="line">    <span class="keyword">return</span> sidetable_retainCount();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实现中可以看出，<strong>新对象的引用计数的1是由retainCount质检设置的</strong>。而较小数量的计数时，则直接从Class中的<em>extra_rc</em>数据域中进行读取；而较大计数（超过255以上的）则从SideTable中的refcountMap中进行读取累加后返回。</p>
<blockquote>
<p>注意：读取SideTable中的引用计数时需要保证线程安全，进行加锁操作（SideTable内部的是自旋锁，性能好）。</p>
</blockquote>
<p>在SideTable中读取引用计数的方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_SHIFT 2</span></div><div class="line"></div><div class="line"><span class="keyword">size_t</span> </div><div class="line">objc_object::sidetable_getExtraRC_nolock()</div><div class="line">&#123;</div><div class="line">    assert(isa.nonpointer);</div><div class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</div><div class="line">    <span class="comment">// 找到对象对应的引用计数</span></div><div class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (it == table.refcnts.end()) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，<em>table.reccnts.find(this)</em> 就是通过开始提到的<em>DenseMapBase</em>中的查找方法得到引用计数表的迭代器对象。</p>
<h5 id="3-3-retain"><a href="#3-3-retain" class="headerlink" title="3.3 retain"></a>3.3 retain</h5><p>说到了读取retainCount值，保留操作又是如何实现的呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (id)retain &#123;</div><div class="line">    <span class="keyword">return</span> ((id)self)-&gt;rootRetain();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于在ARC环境下，系统在编译期添加的retain实现为底层的c函数（跳过消息发送流程，直接执行函数，效率高），故我们从c的retain方法看起：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">__attribute__((aligned(<span class="number">16</span>)))</div><div class="line"><span class="function">id </span></div><div class="line"><span class="title">objc_retain</span><span class="params">(id obj)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj; <span class="comment">// nil直接返回</span></div><div class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span> obj; <span class="comment">// taggedPointer指针对象，直接返回该指针</span></div><div class="line">    <span class="keyword">return</span> obj-&gt;retain(); <span class="comment">// 正常retain</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于我们创建的对象一般不是taggedPointer，故执行的是标准retain函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Equivalent to calling [this retain], with shortcuts if there is no override</span></div><div class="line"><span class="keyword">inline</span> id </div><div class="line">objc_object::retain()</div><div class="line">&#123;</div><div class="line">    assert(!isTaggedPointer());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</div><div class="line">        <span class="keyword">return</span> rootRetain();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ((id(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_retain);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于默认没有自定义引用计数相关方法，走的是rootRetain函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">ALWAYS_INLINE id </div><div class="line">objc_object::rootRetain()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> rootRetain(<span class="literal">false</span>, <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">ALWAYS_INLINE id </div><div class="line">objc_object::rootRetain(<span class="keyword">bool</span> tryRetain, <span class="keyword">bool</span> handleOverflow)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>; <span class="comment">// 标识是否加锁</span></div><div class="line">    <span class="keyword">bool</span> transcribeToSideTable = <span class="literal">false</span>; <span class="comment">// 标识是否使用SideTable</span></div><div class="line"></div><div class="line">    <span class="keyword">isa_t</span> oldisa;</div><div class="line">    <span class="keyword">isa_t</span> newisa;</div><div class="line"></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        transcribeToSideTable = <span class="literal">false</span>;</div><div class="line">        <span class="comment">// 获取isa数据</span></div><div class="line">        oldisa = LoadExclusive(&amp;isa.bits);</div><div class="line">        newisa = oldisa;</div><div class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</div><div class="line">            <span class="comment">// 由于一般创建的对象都是nonpointer的，故这里表示为非nonpointer</span></div><div class="line">            <span class="comment">// 即不使用isa数据的内部引用计数，直接使用SideTable的情况</span></div><div class="line">            </div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</div><div class="line">            <span class="keyword">if</span> (tryRetain) <span class="keyword">return</span> sidetable_tryRetain() ? (id)<span class="keyword">this</span> : nil;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> sidetable_retain();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// don't check newisa.fast_rr; we already called any RR overrides</span></div><div class="line">        <span class="keyword">if</span> (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</div><div class="line">            <span class="keyword">return</span> nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 使用isa的情况，直接给内部的extra_rc加1，carry作为溢出标识（extra_rc为8位，最大为255）</span></div><div class="line">        <span class="comment">// RC_ONE从第57位开始，也就是说8位中是从左到右是从低到高排列</span></div><div class="line">        <span class="keyword">uintptr_t</span> carry;</div><div class="line">        newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</div><div class="line">            <span class="comment">// carry不是0了，则extra_rc超过最大值，溢出</span></div><div class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</div><div class="line">                <span class="comment">// 不处理溢出情况</span></div><div class="line">                ClearExclusive(&amp;isa.bits);</div><div class="line">                <span class="keyword">return</span> rootRetain_overflow(tryRetain);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 处理溢出</span></div><div class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</div><div class="line">            sideTableLocked = <span class="literal">true</span>;</div><div class="line">            transcribeToSideTable = <span class="literal">true</span>; <span class="comment">// 准备从SideTable进行处理</span></div><div class="line">            newisa.extra_rc = RC_HALF; <span class="comment">// 只留下一半128</span></div><div class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>; <span class="comment">// 标识为使用SideTable保存引用计数</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</div><div class="line">        <span class="comment">// transcribeToSideTable为true，使用ideTable进行处理（引用计数加上之前减少的128）</span></div><div class="line">        sidetable_addExtraRC_nolock(RC_HALF);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</div><div class="line">    <span class="keyword">return</span> (id)<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可以看到，<strong>在isa_t中的数据位extra_rc没有超限（小于255）时，直接操作其值+1，完成retain；如果超限，则将extra_rc中的一半（128）拷贝到SideTable中的refcnts中进行存储</strong>。其中，在SideTable中进行retain操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从isa位域中copy部分引用计数值到SideTable中。</span></div><div class="line"><span class="comment">// 如果对象的引用计数达到上限，返回true</span></div><div class="line"><span class="keyword">bool</span> </div><div class="line">objc_object::sidetable_addExtraRC_nolock(<span class="keyword">size_t</span> delta_rc)</div><div class="line">&#123;</div><div class="line">    assert(isa.nonpointer);</div><div class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 得到SideTable中自身对象对应的引用计数值</span></div><div class="line">    <span class="keyword">size_t</span>&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</div><div class="line">    <span class="keyword">size_t</span> oldRefcnt = refcntStorage;</div><div class="line">    <span class="comment">// isa-side bits should not be set here</span></div><div class="line">    assert((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == <span class="number">0</span>);</div><div class="line">    assert((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 若已经达到最大值，就不加了，直接返回（最高位为1证明计数达到上限）</span></div><div class="line">    <span class="keyword">if</span> (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 溢出标识</span></div><div class="line">    <span class="keyword">uintptr_t</span> carry;</div><div class="line">    </div><div class="line">    <span class="comment">// 进行 + 1操作（第三低位为引用计数最低位）</span></div><div class="line">    <span class="keyword">size_t</span> newRefcnt = </div><div class="line">        addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, <span class="number">0</span>, &amp;carry);</div><div class="line">    <span class="keyword">if</span> (carry) &#123;</div><div class="line">        <span class="comment">// 溢出了，证明到达或超过最大值了（间接证明了共有64 - 2 - 1 = 61位用来存储引用计数）</span></div><div class="line">        <span class="comment">// 记录最高位为1，其余位不变</span></div><div class="line">        <span class="comment">// 011 &amp; oldRefcnt代表排除最后两位的影响</span></div><div class="line">        refcntStorage =</div><div class="line">            SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 没有溢出，直接使用结果，retain成功</span></div><div class="line">        refcntStorage = newRefcnt;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可以看出，<strong>SideTable的refcnts中存储的对象的引用计数值（<em>size_t类型，即8字节</em>）中，最高位为上限标识，最低位为weak标识，次低位为deallocating标识，故共有61位用于存储引用计数</strong>。</p>
<p>若对象不是nonpointer的，则是使用SideTable直接进行引用计数的，实现就简单多了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">id</div><div class="line">objc_object::sidetable_retain()</div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></div><div class="line">    assert(!isa.nonpointer);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</div><div class="line">    </div><div class="line">    table.lock();</div><div class="line">    <span class="keyword">size_t</span>&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</div><div class="line">    <span class="keyword">if</span> (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</div><div class="line">        <span class="comment">// 没有到达上限（最高位为1），引用计数 + 1 （100，第三低位开始是引用计数最低位）</span></div><div class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (id)<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-4-release"><a href="#3-4-release" class="headerlink" title="3.4 release"></a>3.4 release</h5><p>由于ARC环境，我们也从objc_release函数说起。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">__attribute__((aligned(<span class="number">16</span>)))</div><div class="line"><span class="function"><span class="keyword">void</span> </span></div><div class="line"><span class="title">objc_release</span><span class="params">(id obj)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span>; <span class="comment">// nil无效</span></div><div class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span>; <span class="comment">// tagPointer的，直接返回（直接存到指针里了）</span></div><div class="line">    <span class="keyword">return</span> obj-&gt;release(); <span class="comment">// 正常释放</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Equivalent to calling [this release], with shortcuts if there is no override</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span></div><div class="line">objc_object::release()</div><div class="line">&#123;</div><div class="line">    assert(!isTaggedPointer());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</div><div class="line">        rootRelease();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_release);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，最终执行的是<em>rootRelease</em>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line">ALWAYS_INLINE <span class="keyword">bool</span> </div><div class="line">objc_object::rootRelease()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> rootRelease(<span class="literal">true</span>, <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ALWAYS_INLINE <span class="keyword">bool</span> </div><div class="line">objc_object::rootRelease(<span class="keyword">bool</span> performDealloc, <span class="keyword">bool</span> handleUnderflow)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">isa_t</span> oldisa;</div><div class="line">    <span class="keyword">isa_t</span> newisa;</div><div class="line"></div><div class="line"> retry:</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="comment">// 获取isa指针</span></div><div class="line">        oldisa = LoadExclusive(&amp;isa.bits);</div><div class="line">        newisa = oldisa;</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</div><div class="line">            <span class="comment">// 对象不是nonpointer的优化指针，直接通过SideTable进行释放操作</span></div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</div><div class="line">            <span class="keyword">return</span> sidetable_release(performDealloc);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// don't check newisa.fast_rr; we already called any RR overrides</span></div><div class="line">        <span class="comment">// 下溢出标识</span></div><div class="line">        <span class="keyword">uintptr_t</span> carry;</div><div class="line">        <span class="comment">// extra_rc - 1（减去的是引用计数的最低位，从左到右是从低到高，在x86_64下即减去1）</span></div><div class="line">        <span class="comment">// 这里是因为若extra_rc是0，减去1则会发生下溢出，也就是说，</span></div><div class="line">        <span class="comment">// 此时已经没有引用计数了，需要dealloc</span></div><div class="line">        newisa.bits = subc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc--</span></div><div class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</div><div class="line">            <span class="comment">// don't ClearExclusive()</span></div><div class="line">            <span class="comment">// 非0，即下溢出发生（得到了负值，此时证明引用计数已经为0，需要dealloc了）</span></div><div class="line">            <span class="keyword">goto</span> underflow;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </div><div class="line">                                             oldisa.bits, newisa.bits)));</div><div class="line"></div><div class="line">    <span class="comment">// 没有释放锁，释放</span></div><div class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line"> <span class="comment">// 下溢出情况（引用计数已经为0，需要dealloc）</span></div><div class="line"> underflow:</div><div class="line">    newisa = oldisa;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (slowpath(newisa.has_sidetable_rc)) &#123;</div><div class="line">        <span class="comment">// 检测是使用了SideTable进行引用计数存储</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!handleUnderflow) &#123;</div><div class="line">            <span class="comment">// 不处理下溢出</span></div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            <span class="comment">// 这里重新强制设置为处理</span></div><div class="line">            <span class="keyword">return</span> rootRelease_underflow(performDealloc);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Transfer retain count from side table to inline storage.</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!sideTableLocked) &#123;</div><div class="line">            ClearExclusive(&amp;isa.bits);</div><div class="line">            sidetable_lock();</div><div class="line">            sideTableLocked = <span class="literal">true</span>;</div><div class="line">            <span class="comment">// Need to start over to avoid a race against </span></div><div class="line">            <span class="comment">// the nonpointer -&gt; raw pointer transition.</span></div><div class="line">            <span class="keyword">goto</span> retry;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 从SideTable的refcnts中减去128，作为借的值（结果只能是128或0）</span></div><div class="line">        <span class="comment">// 相当于把以前从extra_rc中移过去的128恢复回来</span></div><div class="line">        <span class="keyword">size_t</span> borrowed = sidetable_subExtraRC_nolock(RC_HALF);</div><div class="line"></div><div class="line">        <span class="comment">// To avoid races, has_sidetable_rc must remain set </span></div><div class="line">        <span class="comment">// even if the side table count is now zero.</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (borrowed &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 存储isa_t内容中的extra_rc位的值为127，并存储回去（减去的1是alloc默认的1）</span></div><div class="line">            newisa.extra_rc = borrowed - <span class="number">1</span>;  <span class="comment">// redo the original decrement too</span></div><div class="line">            <span class="keyword">bool</span> stored = StoreReleaseExclusive(&amp;isa.bits, </div><div class="line">                                                oldisa.bits, newisa.bits);</div><div class="line">            <span class="keyword">if</span> (!stored) &#123;</div><div class="line">                <span class="comment">// Inline update failed. </span></div><div class="line">                <span class="comment">// Try it again right now. This prevents livelock on LL/SC </span></div><div class="line">                <span class="comment">// architectures where the side table access itself may have </span></div><div class="line">                <span class="comment">// dropped the reservation.</span></div><div class="line">                <span class="keyword">isa_t</span> oldisa2 = LoadExclusive(&amp;isa.bits);</div><div class="line">                <span class="keyword">isa_t</span> newisa2 = oldisa2;</div><div class="line">                <span class="keyword">if</span> (newisa2.nonpointer) &#123;</div><div class="line">                    <span class="keyword">uintptr_t</span> overflow;</div><div class="line">                    newisa2.bits = </div><div class="line">                        addc(newisa2.bits, RC_ONE * (borrowed<span class="number">-1</span>), <span class="number">0</span>, &amp;overflow);</div><div class="line">                    <span class="keyword">if</span> (!overflow) &#123;</div><div class="line">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </div><div class="line">                                                       newisa2.bits);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!stored) &#123;</div><div class="line">                <span class="comment">// Inline update failed.</span></div><div class="line">                <span class="comment">// Put the retains back in the side table.</span></div><div class="line">                sidetable_addExtraRC_nolock(borrowed);</div><div class="line">                <span class="keyword">goto</span> retry;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Decrement successful after borrowing from side table.</span></div><div class="line">            <span class="comment">// This decrement cannot be the deallocating decrement - the side </span></div><div class="line">            <span class="comment">// table lock and has_sidetable_rc bit ensure that if everyone </span></div><div class="line">            <span class="comment">// else tried to -release while we worked, the last one would block.</span></div><div class="line">            sidetable_unlock();</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 没有借到值，即SideTable的refcnts存储的引用计数就是0。直接dealloc就可以了</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Really deallocate.</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (slowpath(newisa.deallocating)) &#123;</div><div class="line">        <span class="comment">// isa_t中已经标记为需要dealloc了</span></div><div class="line">        ClearExclusive(&amp;isa.bits);</div><div class="line">        <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</div><div class="line">        <span class="comment">// 报错（正常release过程的引用计数必定不为0）</span></div><div class="line">        <span class="keyword">return</span> overrelease_error();</div><div class="line">        <span class="comment">// does not actually return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// isa_t对应数据位标记为需要dealloc，并保存</span></div><div class="line">    newisa.deallocating = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) <span class="keyword">goto</span> retry;</div><div class="line"></div><div class="line">    <span class="comment">// 没有释放锁，释放</span></div><div class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</div><div class="line"></div><div class="line">    <span class="comment">// 同步执行默认的dealloc方法</span></div><div class="line">    __sync_synchronize();</div><div class="line">    <span class="keyword">if</span> (performDealloc) &#123;</div><div class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注：</p>
<p><strong>extra_rc的8位（x86_64架构下）从左往右是低位到高位的存储，故1是0b10000000。<br>故<em>RC_ONE</em>的 <em>1ULL &lt;&lt; 57</em> 对应的正好是extra_rc的最低位，也就是最左边的位</strong>。<br>所以，release时，isa.bits - RC_ONE时，如果引用计数为0，则会出现负值，也就是下溢出。</p>
</blockquote>
<p>总结一下，其实release干了这几件事：</p>
<ol>
<li>如果本身不是nonpointer，则直接从SideTable对应的refcnts中进行计数减1操作。</li>
<li>是nonpointer的情况：直接对extra_rc引用计数减1。根据结果进行区分：<ol>
<li>如果原来extra_rc是0，减1后发生下溢出。但是此时需要看一下是否SideTable中还存储着额外的引用计数：如果存在，则“借位”，将原来移过去的128挪回来，减去alloc的1后，将127存储到extra_rc中，结束；SideTable中的引用计数时0，则代表彻底没有引用计数了，需要dealloc。</li>
<li>原来extra_rc不是0，减1后，结束。</li>
</ol>
</li>
</ol>
<p>其中，在SideTable的refcnts计数表中对计数进行减1操作，则很简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uintptr_t</span></div><div class="line">objc_object::sidetable_release(<span class="keyword">bool</span> performDealloc)</div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></div><div class="line">    assert(!isa.nonpointer);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">// 根据对象获取SideTable</span></div><div class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> do_dealloc = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    table.lock();</div><div class="line">    <span class="comment">// 在SideTable的refconts中查找自身对象的引用计数信息</span></div><div class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (it == table.refcnts.end()) &#123;</div><div class="line">        <span class="comment">// 未找到，证明没有计数记录，需要dealloc对象</span></div><div class="line">        do_dealloc = <span class="literal">true</span>;</div><div class="line">        <span class="comment">// 在引用计数表中标记自身的数据为“正在释放”（10）</span></div><div class="line">        table.refcnts[<span class="keyword">this</span>] = SIDE_TABLE_DEALLOCATING;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;</div><div class="line">        <span class="comment">// 存在记录数据，且数据 &lt; 10（即01 或 00），也许设置了包含弱引用（01），不要修改</span></div><div class="line">        <span class="comment">// 证明引用计数已经为0（低两位为保留位，第三低位才是最低位）</span></div><div class="line">        do_dealloc = <span class="literal">true</span>;</div><div class="line">        it-&gt;second |= SIDE_TABLE_DEALLOCATING; <span class="comment">// 将第二低位设置为1（正在释放）</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</div><div class="line">        <span class="comment">// 引用计数未达到上限（最高位不是1）</span></div><div class="line">        it-&gt;second -= SIDE_TABLE_RC_ONE; <span class="comment">// 引用计数 - 1（第三低位为引用计数的最低位）</span></div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;</div><div class="line">        <span class="comment">// 需要dealloc对象，且计数已为0，调用释放方法</span></div><div class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> do_dealloc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终，<strong>同步执行的<em>SEL_dealloc</em>就是我们NSObject释放对象时的<em>dealloc</em>实例方法</strong>。</p>
<h5 id="3-5-dealloc"><a href="#3-5-dealloc" class="headerlink" title="3.5 dealloc"></a>3.5 dealloc</h5><p>不废话，直接上流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    _objc_rootDealloc(self);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span></div><div class="line">_objc_rootDealloc(id obj)</div><div class="line">&#123;</div><div class="line">    assert(obj);</div><div class="line"></div><div class="line">    obj-&gt;rootDealloc();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span></div><div class="line">objc_object::rootDealloc()</div><div class="line">&#123;</div><div class="line">    <span class="comment">// taggedPointer，不处理（只是指针）</span></div><div class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  </div><div class="line">                 !isa.weakly_referenced  &amp;&amp;  </div><div class="line">                 !isa.has_assoc  &amp;&amp;  </div><div class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </div><div class="line">                 !isa.has_sidetable_rc))</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 类是nonpointer优化对象，且没有存储相关附带信息</span></div><div class="line">    </div><div class="line">        <span class="comment">// 不能在SideTable中的weak_table和refcnts中存储信息</span></div><div class="line">        assert(!sidetable_present());</div><div class="line">    </div><div class="line">        <span class="comment">// 直接释放内存</span></div><div class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 存在其他配置信息，正常释放</span></div><div class="line">        object_dispose((id)<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可以看到，当对象的isa指针数据中没有相关信息的标志位，也就是说，没有其他额外信息（优化指针，且没有weak指向、没有相关对象、没有实现自定义的c++释放函数且没有使用SideTable进行外部引用计数存储），则直接释放内存（因为相关信息都保存在了isa的位域中了，不存在外部关联内存，故可以直接释放）。因此，<strong>如果类没有其他相关设置，释放对象操作会特别高效</strong>。</p>
<p>其他情况下，则会调用<em>object_dispose</em>函数进行正常释放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function">id </span></div><div class="line"><span class="title">object_dispose</span><span class="params">(id obj)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</div><div class="line"></div><div class="line">    objc_destructInstance(obj);</div><div class="line">    </div><div class="line">    <span class="comment">// 释放内存</span></div><div class="line">    <span class="built_in">free</span>(obj);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (obj) &#123;</div><div class="line">        <span class="comment">// Read all of the flags at once for performance.</span></div><div class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</div><div class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</div><div class="line"></div><div class="line">        <span class="comment">// This order is important.</span></div><div class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</div><div class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</div><div class="line">        obj-&gt;clearDeallocating();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<em>object_dispose</em>中，需要额外进行的，就是在<em>objc_destructInstance</em>函数中，依照顺序将相关联的其他信息移除。顺序如下：</p>
<p>**1. 执行自定义的c++释放方法（如过存在）</p>
<ol>
<li>将相关对象从全局相关信息表中移除（如果存在）</li>
<li>移除SideTable中的weak信息及引用计数信息</li>
<li><p>最终，返回<em>object_dispose</em>中，释放指针内存，结束。**</p>
</li>
<li><p>检查并执行c++的释放函数，依照“子类 -&gt; 父类” 的继承体系依次查找执行。没有实现则直接返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">object_cxxDestructFromClass</span><span class="params">(id obj, Class cls)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> (*dtor)(id);</div><div class="line"></div><div class="line">    <span class="comment">// Call cls's dtor first, then superclasses's dtors.</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> ( ; cls; cls = cls-&gt;superclass) &#123;</div><div class="line">        <span class="keyword">if</span> (!cls-&gt;hasCxxDtor()) <span class="keyword">return</span>; </div><div class="line">        dtor = (<span class="keyword">void</span>(*)(id))</div><div class="line">            lookupMethodInClassAndLoadCache(cls, SEL_cxx_destruct);</div><div class="line">        <span class="keyword">if</span> (dtor != (<span class="keyword">void</span>(*)(id))_objc_msgForward_impcache) &#123;</div><div class="line">            <span class="keyword">if</span> (PrintCxxCtors) &#123;</div><div class="line">                _objc_inform(<span class="string">"CXX: calling C++ destructors for class %s"</span>, </div><div class="line">                             cls-&gt;nameForLogging());</div><div class="line">            &#125;</div><div class="line">            (*dtor)(obj);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>注：</p>
<p>这个c++的析构函数（SEL_cxx_destruct，对应的是.cxx_destruct），实际上系统将对象的ivar变量的释放操作插入了这里进行。因此<strong>实现了在ARC环境下，对象的成员变量自动释放的功能</strong>。<br>且<strong>实现了自动在最后执行[super dealloc]的功能</strong>(<a href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/" target="_blank" rel="external">ARC下dealloc过程及.cxx_destruct的探究</a>，后面llvm实现看不懂，mark一下)。</p>
</blockquote>
<ol>
<li>移除相关对象，则是从全局hash表AssociationsHashMap中根据对象地址获取到存储该相关对象的子表，然后移除子表，并将子表中所有指向的对象依次释放。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">void _object_remove_assocations(id object) &#123;</div><div class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</div><div class="line">    </div><div class="line">    &#123;</div><div class="line">        // 获取全局相关对象的整体哈希表</div><div class="line">        AssociationsManager manager;</div><div class="line">        AssociationsHashMap &amp;associations(manager.associations());</div><div class="line">    </div><div class="line">        // 本身没有存储任何信息，直接返回</div><div class="line">        if (associations.size() == 0) return;</div><div class="line">    </div><div class="line">        // 将object指针转换为查询的指针</div><div class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</div><div class="line">        // 试图查询是否存在object的相关对象容器信息</div><div class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">        if (i != associations.end()) &#123;</div><div class="line">            // copy all of the associations that need to be removed.</div><div class="line">            // 已查到，获取入口地址</div><div class="line">            ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">            </div><div class="line">            // 依次遍历子哈希表（ObjectAssociationMap对象的键值对信息）</div><div class="line">            for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</div><div class="line">                // 头插法插入到向量对象中</div><div class="line">                elements.push_back(j-&gt;second);</div><div class="line">            &#125;</div><div class="line">            // remove the secondary table.</div><div class="line">            // 删除入口地址信息</div><div class="line">            delete refs;</div><div class="line">            // 清除子表（object容器中存储的所有信息，即ObjectAssociationMap对象）</div><div class="line">            associations.erase(i);</div><div class="line">            // 清除之后，object便没有任何相关对象保存</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // the calls to releaseValue() happen outside of the lock.</div><div class="line">    // 对向量中存储的所有相关对象信息，依次释放内存</div><div class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>释放每个相关对象的操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReleaseValue</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(ObjcAssociation &amp;association)</span> </span>&#123;</div><div class="line">        releaseValue(association.value(), association.policy());</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseValue</span><span class="params">(id value, <span class="keyword">uintptr_t</span> policy)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) &#123;</div><div class="line">        <span class="comment">// 通过按位与运算，确认是retain的对象，才进行释放操作</span></div><div class="line">        <span class="keyword">return</span> objc_release(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>最后，清除链接到的其他信息。如外部SideTable中的引用计数表和weak表。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </div><div class="line">objc_object::clearDeallocating()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</div><div class="line">        <span class="comment">// Slow path for raw pointer isa.</span></div><div class="line">        sidetable_clearDeallocating();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</div><div class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></div><div class="line">        clearDeallocating_slow();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    assert(!sidetable_present());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过查看对象是否为nonpointer优化指针，根据情况进行SideTable中信息的移除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> </div><div class="line">objc_object::sidetable_clearDeallocating()</div><div class="line">&#123;</div><div class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</div><div class="line"></div><div class="line">    <span class="comment">// clear any weak table items</span></div><div class="line">    <span class="comment">// clear extra retain count and deallocating bit</span></div><div class="line">    <span class="comment">// (fixme warn or abort if extra retain count == 0 ?)</span></div><div class="line">    table.lock();</div><div class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (it != table.refcnts.end()) &#123;</div><div class="line">        <span class="keyword">if</span> (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123;</div><div class="line">            weak_clear_no_lock(&amp;table.weak_table, (id)<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">        table.refcnts.erase(it);</div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line">NEVER_INLINE <span class="keyword">void</span></div><div class="line">objc_object::clearDeallocating_slow()</div><div class="line">&#123;</div><div class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</div><div class="line"></div><div class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</div><div class="line">    table.lock();</div><div class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</div><div class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</div><div class="line">        table.refcnts.erase(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，二者实现的功能相同，都是在自身对应的SideTable中将refcnts和weak_table对应的信息移除。唯一区别是，nonpointer的优化对象指针需要在执行前判断对应的isa位域的值。</p>
<p>但是重要的是，<strong>在对象清除自身引用计数表之前，将weak_table中自身的所有weak指针清除，置为nil</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> </span></div><div class="line"><span class="title">weak_clear_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent_id)</span> </div><div class="line">&#123;</div><div class="line">    objc_object *referent = (objc_object *)referent_id;</div><div class="line">    </div><div class="line">    <span class="comment">// 获取全局weak_table_t中referent对应的weak_entry_t数据</span></div><div class="line">    <span class="keyword">weak_entry_t</span> *entry = weak_entry_for_referent(weak_table, referent);</div><div class="line">    <span class="keyword">if</span> (entry == nil) &#123;</div><div class="line">        <span class="comment">/// XXX shouldn't happen, but does with mismatched CF/objc</span></div><div class="line">        <span class="comment">//printf("XXX no entry for clear deallocating %p\n", referent);</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// zero out references</span></div><div class="line">    <span class="keyword">weak_referrer_t</span> *referrers;</div><div class="line">    <span class="keyword">size_t</span> count;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</div><div class="line">        <span class="comment">// 使用的外部动态数组（weak指针超过4个），配置信息</span></div><div class="line">        referrers = entry-&gt;referrers;</div><div class="line">        count = TABLE_SIZE(entry);</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 未超过4个，使用的是自身内部的静态数组，配置信息</span></div><div class="line">        referrers = entry-&gt;inline_referrers;</div><div class="line">        count = WEAK_INLINE_COUNT;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 依次将weak指针设置为nil</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">        objc_object **referrer = referrers[i];</div><div class="line">        <span class="keyword">if</span> (referrer) &#123;</div><div class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</div><div class="line">                *referrer = nil;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</div><div class="line">                _objc_inform(<span class="string">"__weak variable at %p holds %p instead of %p. "</span></div><div class="line">                             <span class="string">"This is probably incorrect use of "</span></div><div class="line">                             <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></div><div class="line">                             <span class="string">"Break on objc_weak_error to debug.\n"</span>, </div><div class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</div><div class="line">                objc_weak_error();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 在全局weak_table_t表中，移除entry（清除容器）</span></div><div class="line">    weak_entry_remove(weak_table, entry);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，我们可以看到，<strong>在dealloc执行的最后一步（free指针之前），运行时系统将所有指向释放对象的weak指针置为了nil，完成了weak在ARC下的功能。然后清除引用计数表</strong>。</p>
<h5 id="3-6-autorelease"><a href="#3-6-autorelease" class="headerlink" title="3.6 autorelease"></a>3.6 autorelease</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)autorelease &#123;</div><div class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootAutorelease();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Base autorelease implementation, ignoring overrides.</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">id</span> </div><div class="line">objc_object::rootAutorelease()</div><div class="line">&#123;</div><div class="line">    <span class="comment">// taggedPointer对象，不处理</span></div><div class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 返回值优化（若调用方为strong对象，则使用objc_autoreleaseReturnValue替代）</span></div><div class="line">    <span class="comment">// 直接返回，不执行autorelease（ReturnAtPlus1即true）</span></div><div class="line">    <span class="keyword">if</span> (prepareOptimizedReturn(ReturnAtPlus1)) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 标准autorelease</span></div><div class="line">    <span class="keyword">return</span> rootAutorelease2();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于autorelease优化涉及到汇编知识，自己不懂。只明白大体意思：在通过查看调用方的入口地址，通过偏移量算出自身函数返回的地址，得到返回值的接收方的内存管理方式。如果接受对象为strong对象，则使用<em>objc_autoreleaseReturnValue</em>替代autorelease函数（将对象地址保存到当前线程绑定的地址空间中—-TLS，Thread Local Storage，线程局部存储）。</p>
<p>这里我们先看标准的autorelease—-<em>rootAutorelease2</em>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__attribute__((noinline,used))</div><div class="line">id </div><div class="line">objc_object::rootAutorelease2()</div><div class="line">&#123;</div><div class="line">    assert(!isTaggedPointer());</div><div class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease((id)<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里实际上使用的是AutoReleasePoolPage类进行实现。主要功能如下：</p>
<h6 id="3-6-1-AutoReleasePoolPage的基本结构"><a href="#3-6-1-AutoReleasePoolPage的基本结构" class="headerlink" title="3.6.1 AutoReleasePoolPage的基本结构"></a>3.6.1 AutoReleasePoolPage的基本结构</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 为了节省内存，在没有任何对象进行autorelease操作之前，在，在所在线程中的绑定内存中保存一个指定信息（1）作为占位pool。</span></div><div class="line"><span class="meta">#   <span class="meta-keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)</span></div><div class="line"></div><div class="line">    <span class="comment">// 占位pool存储首个对象前的分隔符</span></div><div class="line"><span class="meta">#   <span class="meta-keyword">define</span> POOL_BOUNDARY nil</span></div><div class="line"></div><div class="line">    <span class="comment">// 在所在线程的绑定地址中保存hotPage对象的key</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">pthread_key_t</span> <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</div><div class="line">    </div><div class="line">    <span class="comment">// 虚拟内存页尺寸，4096bytes</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE = PAGE_MAX_SIZE;</div><div class="line">    </div><div class="line">    <span class="comment">// 4096 / 8 = 512个对象</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(id);</div><div class="line">    </div><div class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic; <span class="comment">// 完整性数据</span></div><div class="line">    id *next; <span class="comment">// 指向新位置（相当于栈顶指针）</span></div><div class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread; <span class="comment">// 所在线程（一一对应）</span></div><div class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent; <span class="comment">// 父page</span></div><div class="line">    AutoreleasePoolPage *child; <span class="comment">// 子page</span></div><div class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth; <span class="comment">// 深度（根page为0，子为1，以此类推）</span></div><div class="line">    <span class="keyword">uint32_t</span> hiwat;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">// 基本功能函数</span></div><div class="line">    </div><div class="line">    <span class="comment">// 获取AutoReleasePoolPage实例对象的存储区域开头</span></div><div class="line">    <span class="function">id * <span class="title">begin</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (id *) ((<span class="keyword">uint8_t</span> *)<span class="keyword">this</span>+<span class="keyword">sizeof</span>(*<span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 获取AutoReleasePoolPage实例对象的存储区域结尾</span></div><div class="line">    <span class="function">id * <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (id *) ((<span class="keyword">uint8_t</span> *)<span class="keyword">this</span>+SIZE); <span class="comment">// 自身地址偏移4096字节，为end</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 判定AutoReleasePoolPage实例对象的存储空间是否为空</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> next == begin();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 判定AutoReleasePoolPage实例对象的存储空间是否已满</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> </span>&#123; </div><div class="line">        <span class="keyword">return</span> next == end();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 向当前AutoReleasePoolPage实例对象中插入obj，返回插入地址</span></div><div class="line">    <span class="function">id *<span class="title">add</span><span class="params">(id obj)</span></span></div><div class="line">    &#123;</div><div class="line">        assert(!full());</div><div class="line">        unprotect(); <span class="comment">// 设置对象为可读可写</span></div><div class="line">        id *ret = next;  <span class="comment">// faster than `return next-1` because of aliasing</span></div><div class="line">        *next++ = obj; <span class="comment">// 将next指向obj。next后移</span></div><div class="line">        protect(); <span class="comment">// 设置对象为只可读</span></div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 释放AutoReleasePoolPage实例对象中的所有对象</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">releaseAll</span><span class="params">()</span> </span></div><div class="line">    &#123;</div><div class="line">        releaseUntil(begin());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据AutoReleasePoolPage类的基本结构可以看出：</p>
<ol>
<li>其在内存中的<strong>存储结构为：地址由低到高，首先保存的是类中的成员变量，然后是大小为4096字节的存储空间，用于保存设置为autorelease的对象实例</strong>。</li>
<li><strong>两个指针<em>begin</em>和<em>end</em>分别指向存储空间开始和末尾，使用<em>next</em>指针指向空间中最后一个对象的下一位置</strong>，相当于栈结构中的栈顶指针。</li>
<li><strong>整体的自动释放池是由一个个AutoReleasePoolPage对象通过<em>parent</em>和<em>child</em>指针连接而成的<u><em>双向链表</em></u></strong>。其中，<em>EMPTY_POOL_PLACEHOLDER</em>占位pool并不相当于头指针或头节点，而是只是一个标记位，在尚未使用AutoReleasePool之前节省内存。</li>
</ol>
<p>现在，我们回到刚才的问题。</p>
<h6 id="3-6-2-objc-object-autorelease的实现"><a href="#3-6-2-objc-object-autorelease的实现" class="headerlink" title="3.6.2 objc_object::autorelease的实现"></a>3.6.2 objc_object::autorelease的实现</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    assert(obj);</div><div class="line">    assert(!obj-&gt;isTaggedPointer());</div><div class="line">    <span class="keyword">id</span> *dest __unused = autoreleaseFast(obj);</div><div class="line">    assert(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出autorelease的本质是通过<em>autoreleaseFast</em>将obj插入到AutoReleasePoolPage实例对象中。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> *autoreleaseFast(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage *page = hotPage();</div><div class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</div><div class="line">        <span class="comment">// page未满，插入新对象（next指向obj，然后返回next指针地址）</span></div><div class="line">        <span class="keyword">return</span> page-&gt;add(obj);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</div><div class="line">        <span class="comment">// page已满，创建新page并插入新对象</span></div><div class="line">        <span class="keyword">return</span> autoreleaseFullPage(obj, page);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 没有存在page，创建第一个page并插入新对象</span></div><div class="line">        <span class="keyword">return</span> autoreleaseNoPage(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，根据当前使用的AutoreleasePoolPage对象的存储状态，分情况进行处理：</p>
<ol>
<li>当前page没有存满，则直接插入；</li>
<li>当前page已经存满，创建新page然后插入；</li>
<li>不存在page（只有一个<em>EMPTY_POOL_PLACEHOLDER</em>占位用），创建新page然后插入。</li>
</ol>
<p>相关实现如下（直接插入的不用说了，将next指针的数据域存储上obj地址，然后next后移即可）：</p>
<ul>
<li>向已存满的AutoReleasePoolPage对象插入新对象：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> __attribute__((noinline))</div><div class="line"><span class="keyword">id</span> *autoreleaseFullPage(<span class="keyword">id</span> obj, AutoreleasePoolPage *page)</div><div class="line">&#123;</div><div class="line">    assert(page == hotPage());</div><div class="line">    assert(page-&gt;full()  ||  DebugPoolAllocation);</div><div class="line"></div><div class="line">    <span class="comment">// 如果当前page已满（next == end），检查并创建新page对象</span></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="comment">// 子page存在，向子page中尝试插入</span></div><div class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</div><div class="line">        <span class="comment">// 没有，则创建新page对象</span></div><div class="line">        <span class="keyword">else</span> page = new AutoreleasePoolPage(page);</div><div class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</div><div class="line"></div><div class="line">    <span class="comment">// 设置为hotPage（绑定到当前线程）</span></div><div class="line">    setHotPage(page);</div><div class="line"></div><div class="line">    <span class="comment">// 插入对象</span></div><div class="line">    <span class="keyword">return</span> page-&gt;add(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>只有一个初始状态下的占位pool，没有真正用于存储的AutoReleasePoolPage对象，创建新的page对象，然后插入。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> __attribute__((noinline))</div><div class="line"><span class="keyword">id</span> *autoreleaseNoPage(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 没有page，可能意味着是根本没有pool对象，或者是一个占位pool存在但是没有内容（后者是正确的）</span></div><div class="line">    assert(!hotPage());</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> pushExtraBoundary = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (haveEmptyPoolPlaceholder()) &#123;</div><div class="line">        <span class="comment">// 只有占位pool对象（正常情况1）</span></div><div class="line">    </div><div class="line">        <span class="comment">// 我们正在空的占位pool后面插入一个新pool，</span></div><div class="line">        <span class="comment">// 或者在占位空pool中插入第一个对象。</span></div><div class="line">        <span class="comment">// 在开始之前，插入一个pool分隔符（nil）来代表一个空标志位</span></div><div class="line">        </div><div class="line">        <span class="comment">// 存在占位空pool（当前只有占位空pool，没有任何其他内容），需要插入分隔符</span></div><div class="line">        pushExtraBoundary = <span class="literal">true</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// 题外话：</span></div><div class="line">        <span class="comment">// 由于分隔符是nil，那么如何区分插入到AutoReleasePool中的nil对象呢？</span></div><div class="line">        <span class="comment">// 在最上层，对nil发送消息实际上在最开始就被忽略掉了，所以这里不会有其他nil因素干扰。</span></div><div class="line">        <span class="comment">// 所以，只要是nil，就可以将其认定为这次的AutoReleasePool的开端（drain时会释放到此nil位置）。</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</div><div class="line">        <span class="comment">// obj存在（对象或新pool），但是没有占位pool对象【错误情况】</span></div><div class="line">        _objc_inform(<span class="string">"MISSING POOLS: (%p) Object %p of class %s "</span></div><div class="line">                     <span class="string">"autoreleased with no pool in place - "</span></div><div class="line">                     <span class="string">"just leaking - break on "</span></div><div class="line">                     <span class="string">"objc_autoreleaseNoPool() to debug"</span>, </div><div class="line">                     pthread_self(), (<span class="keyword">void</span>*)obj, object_getClassName(obj));</div><div class="line">        <span class="comment">// 添加breakpoint崩溃处理</span></div><div class="line">        objc_autoreleaseNoPool(obj);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;</div><div class="line">        <span class="comment">// 不存在占位空pool，且obj是nil，即需要创建并返回一个占位空pool（正确情况2，不用于存储对象，只是用于创建占位pool）</span></div><div class="line">        <span class="keyword">return</span> setEmptyPoolPlaceholder();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 插入实例对象 或者  插入非占位的正常AutoReleasePoolPage对象（新pool）过程：</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 创建根pool</span></div><div class="line">    AutoreleasePoolPage *page = new AutoreleasePoolPage(<span class="literal">nil</span>);</div><div class="line">    <span class="comment">// 设置为hot（当前pool）</span></div><div class="line">    setHotPage(page);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (pushExtraBoundary) &#123;</div><div class="line">        <span class="comment">// 插入分割位（nil）</span></div><div class="line">        page-&gt;add(POOL_BOUNDARY);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 插入obj（对象或是新子pool）</span></div><div class="line">    <span class="keyword">return</span> page-&gt;add(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有两个点要注意：</p>
<ol>
<li>获取和创建占位pool：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 判定是否存在占位pool */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> haveEmptyPoolPlaceholder()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> *tls = (<span class="keyword">id</span> *)tls_get_direct(key);</div><div class="line">    <span class="keyword">return</span> (tls == EMPTY_POOL_PLACEHOLDER);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** 设置保存占位pool */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span>* setEmptyPoolPlaceholder()</div><div class="line">&#123;</div><div class="line">    assert(tls_get_direct(key) == <span class="literal">nil</span>);</div><div class="line">    tls_set_direct(key, (<span class="keyword">void</span> *)EMPTY_POOL_PLACEHOLDER);</div><div class="line">    <span class="keyword">return</span> EMPTY_POOL_PLACEHOLDER;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用的<em>tls_get_direct</em>和<em>tls_set_direct</em>函数的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">tls_get_direct</span><span class="params">(<span class="keyword">tls_key_t</span> k)</span> </span></div><div class="line">&#123; </div><div class="line">    assert(is_valid_direct_key(k));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (_pthread_has_direct_tsd()) &#123;</div><div class="line">        <span class="comment">// 返回当前线程中绑定的指定位的值</span></div><div class="line">        <span class="keyword">return</span> _pthread_getspecific_direct(k);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> pthread_getspecific(k);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tls_set_direct</span><span class="params">(<span class="keyword">tls_key_t</span> k, <span class="keyword">void</span> *value)</span> </span></div><div class="line">&#123; </div><div class="line">    assert(is_valid_direct_key(k));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (_pthread_has_direct_tsd()) &#123;</div><div class="line">        _pthread_setspecific_direct(k, value);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        pthread_setspecific(k, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它们实际上就是<strong>使用一个固定的内存空间来供指定线程来进行数据存取</strong>（线程与内存空间一对一绑定）。这种方式叫做TLS—-Thread Local Storage，线程局部存储。</p>
<p>这里就是使用此方式，将1（id指针）存储到当前线程的绑定存储区域中，使用<em>key</em>进行绑定（key - value方式存取）。</p>
<ol>
<li>hotPage的读取与设置。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> AutoreleasePoolPage *hotPage()</div><div class="line">&#123;</div><div class="line">    <span class="comment">// key是AUTORELEASE_POOL_KEY，即返回线程绑定的AutoreleasePoolPage对象</span></div><div class="line">    AutoreleasePoolPage *result = (AutoreleasePoolPage *)</div><div class="line">        tls_get_direct(key); <span class="comment">// 返回当前线程中key绑定的值</span></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">id</span> *)result == EMPTY_POOL_PLACEHOLDER) <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">// 不存在poolPage，返回</span></div><div class="line">    <span class="keyword">if</span> (result) result-&gt;fastcheck(); <span class="comment">// 检查AutoreleasePoolPage对象信息是否完整</span></div><div class="line">    <span class="comment">// 不完整，fastCheck函数中直接崩溃</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> setHotPage(AutoreleasePoolPage *page) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (page) page-&gt;fastcheck();</div><div class="line">    tls_set_direct(key, (<span class="keyword">void</span> *)page); <span class="comment">// 绑定到当前线程</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>hotPage</em>，即代表当前正在使用的AutoReleasePoolPage对象</strong>（一般意味着自动释放池链表的最后一个pool对象）。<strong>也是使用了TLS的方式</strong>将当前使用的pool对象的地址与key绑定存储到指定区域中。</p>
<h6 id="3-6-3-建立新的-autoreleasepool"><a href="#3-6-3-建立新的-autoreleasepool" class="headerlink" title="3.6.3 建立新的@autoreleasepool{}"></a>3.6.3 建立新的@autoreleasepool{}</h6><blockquote>
<p><strong>注意</strong>：<br>一定要明确，<strong>在上层创建@autoreleasepool{}代码块，与底层实现中的AutoReleasePoolPage对象的创建没有任何关系！</strong><br>底层的整体释放池存储使用的是链表结构，一个AutoReleasePoolPage对象存满之后才会创建新的对象，而创建@autoreleasepool{}代码块，只是在当前的<em>hotPage</em>对应的AutoReleasePoolPage对象中插入一个标志位，用于在RunLoop执行drain时，标记此代码块在<em>hotPage</em>对象中开始的位置。</p>
</blockquote>
<ul>
<li>代码块开始对应着<em>objc_autoreleasePoolPush</em>函数：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *</div><div class="line">objc_autoreleasePoolPush(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push() </div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> *dest;</div><div class="line">    <span class="keyword">if</span> (DebugPoolAllocation) &#123;</div><div class="line">        <span class="comment">// Each autorelease pool starts on a new pool page.</span></div><div class="line">        dest = autoreleaseNewPage(POOL_BOUNDARY);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dest = autoreleaseFast(POOL_BOUNDARY);</div><div class="line">    &#125;</div><div class="line">    assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</div><div class="line">    <span class="keyword">return</span> dest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在非debug模式下，实际上就是<em>autoreleaseFast(nil)</em> 。即在<em>hotPage</em>对应的AutoReleasePoolPage对象中插入一个标志位。<br>而在debug模式下，执行的是<em>autoreleaseNewPage(nil)</em> 。也就是每次创建一个新AutoReleasePoolPage对象，然后再插入标志位。只有此时与@autoreleasepool{}代码块是一一对应的。</p>
<ul>
<li>代码块结束对应着<em>objc_autoreleasePoolPop</em>函数：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span></div><div class="line">objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> pop(<span class="keyword">void</span> *token) </div><div class="line">&#123;</div><div class="line">    <span class="comment">// token实际上是内容为nil的指针（调用push时，插入分隔符nil后返回的地址）</span></div><div class="line"></div><div class="line">    AutoreleasePoolPage *page;</div><div class="line">    <span class="keyword">id</span> *stop;</div><div class="line">    </div><div class="line">    <span class="comment">// 处理token为占位pool的情况</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// 根据token（实际上是内容为nil的指针）找到所属的AutoReleasePoolPage对象</span></div><div class="line">    page = pageForPointer(token);</div><div class="line">    stop = (<span class="keyword">id</span> *)token;</div><div class="line">    <span class="keyword">if</span> (*stop != POOL_BOUNDARY) &#123;</div><div class="line">        <span class="comment">// 若stop的数据域中不是nil（分隔符）</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</div><div class="line">            <span class="comment">// stop指向的就是根page对象的begin位置，即无需做额外工作（用于以后复用）</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 错误，只有nil分隔符才是正确的释放停止点</span></div><div class="line">            <span class="keyword">return</span> badPop(token);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 依次释放直到指定的标志位（分隔符nil）为止</span></div><div class="line">    page-&gt;releaseUntil(stop);</div><div class="line"></div><div class="line">    <span class="comment">// 删除空的子page对象，释放内存</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的实现经过简化。主要<strong>目的就是将push时得到的token地址作为标记，将token及其后面插入的autorelease对象依次释放</strong>。</p>
<p>其中，主要的实现有两点：</p>
<ol>
<li>根据token确定所处的AutoReleasePoolPage对象。</li>
<li>在此page对象中，倒序删除所有保存的数据，直到token地址为止（包括token位置的nil数据）。</li>
</ol>
<p>依次来看实现。</p>
<ol>
<li>根据插入的对象地址，获取所在的AutoReleasePoolPage对象。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> AutoreleasePoolPage *<span class="title">pageForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// void * 转换为了 uintptr_t 类型，可以进行按位操作</span></div><div class="line">    <span class="keyword">return</span> pageForPointer((<span class="keyword">uintptr_t</span>)p);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> AutoreleasePoolPage *<span class="title">pageForPointer</span><span class="params">(<span class="keyword">uintptr_t</span> p)</span> </span></div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage *result;</div><div class="line"></div><div class="line">    <span class="comment">// 通过取余运算，得到地址在一个page内存中的偏移量</span></div><div class="line">    <span class="keyword">uintptr_t</span> offset = p % SIZE;</div><div class="line"></div><div class="line">    assert(offset &gt;= <span class="keyword">sizeof</span>(AutoreleasePoolPage));</div><div class="line"></div><div class="line">    <span class="comment">// p - offset，即得到最近一个page对象的起始地址</span></div><div class="line">    result = (AutoreleasePoolPage *)(p - offset);</div><div class="line"></div><div class="line">    <span class="comment">// 验证page的有效性</span></div><div class="line">    result-&gt;fastcheck();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道，AutoReleasePoolPage对象可以看作为一个类似数组的容器，将p地址减去在一个page容器中的偏移量，即可得到此page对象的起始地址。</p>
<ol>
<li>在AutoReleasePoolPage对象中，倒序移除保存的数据指针。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseUntil</span><span class="params">(id *stop)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 直到释放到stop所在位置才可</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) &#123;        </div><div class="line">        <span class="comment">// 获取当前使用的page对象（防止此时再插入更多的autorelease对象【没有加锁，也不是同步操作】）</span></div><div class="line">        AutoreleasePoolPage *page = hotPage();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (page-&gt;empty()) &#123;</div><div class="line">            <span class="comment">// 当前page已空（且还没有到stop），向上继续查找</span></div><div class="line">            page = page-&gt;parent;</div><div class="line">            <span class="comment">// 设置为hotPage（下次从这开始查找）</span></div><div class="line">            setHotPage(page);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        page-&gt;unprotect(); <span class="comment">// 解锁读写权限</span></div><div class="line">        <span class="comment">// 减1后，获取指向的数据</span></div><div class="line">        id obj = *--page-&gt;next;</div><div class="line">        <span class="comment">// 将next的数据域设置为0xa3（由于指针是4字节，因此写入完成后是0xa3a3a3a3）</span></div><div class="line">        <span class="built_in">memset</span>((<span class="keyword">void</span>*)page-&gt;next, SCRIBBLE, <span class="keyword">sizeof</span>(*page-&gt;next));</div><div class="line">        page-&gt;protect(); <span class="comment">// 锁定page</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123;</div><div class="line">            <span class="comment">// 取出的数据不是分隔符，则是正常对象，执行release操作</span></div><div class="line">            objc_release(obj);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// obj是nil分隔符，则继续向上（因为次分隔符地址不是指定的那个）</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 重新将当前page设置为hotPage</span></div><div class="line">    setHotPage(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></div><div class="line">    <span class="comment">// 确保所有的子page都是空的</span></div><div class="line">    <span class="keyword">for</span> (AutoreleasePoolPage *page = child; page; page = page-&gt;child) &#123;</div><div class="line">        assert(page-&gt;empty());</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际的过程可以看做是在栈中将对象的地址进行出栈操作，然后对每个出栈的对象调用release方法，直到nil标志位出栈后停止。</p>
<blockquote>
<p>在后面检查移除page对象的空的子page中，kill函数也可以看一下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage *page = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 获取最后的子page对象</span></div><div class="line">    <span class="keyword">while</span> (page-&gt;child) page = page-&gt;child;</div><div class="line"></div><div class="line">    AutoreleasePoolPage *deathptr;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="comment">// 获取父page对象</span></div><div class="line">        deathptr = page;</div><div class="line">        page = page-&gt;parent;</div><div class="line">        <span class="keyword">if</span> (page) &#123;</div><div class="line">            page-&gt;unprotect();</div><div class="line">            page-&gt;child = nil; <span class="comment">// 将子page置为nil</span></div><div class="line">            page-&gt;protect();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">delete</span> deathptr; <span class="comment">// 删除子page指针</span></div><div class="line">    &#125; <span class="keyword">while</span> (deathptr != <span class="keyword">this</span>);</div><div class="line">    <span class="comment">// 直到删除到自身page</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于AutoReleasePoolPage组成的是双向链表，故</p>
<ol>
<li>首先根据child指针域依次找到最末尾的page对象。</li>
<li>然后从后往前，根据parent指针找到父page对象，将自身置为nil，断开连接。直到调用方最初的page对象为止。</li>
</ol>
<h4 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h4><ul>
<li><a href="http://blog.tracyone.com/2015/06/14/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAARC-%E4%B8%8A/" target="_blank" rel="external">深入浅出ARC(上)</a></li>
<li><a href="https://www.jianshu.com/p/f5305144ca42" target="_blank" rel="external">NONPOINTER_ISA和散列表</a></li>
<li><a href="https://www.jianshu.com/p/18c3e88dfbf1" target="_blank" rel="external">https://www.jianshu.com/p/18c3e88dfbf1</a></li>
<li><a href="https://www.jianshu.com/p/8577286af88e" target="_blank" rel="external">iOS管理对象内存的数据结构以及操作算法–SideTables、RefcountMap、weak_table_t-二</a></li>
<li><a href="https://www.jianshu.com/p/18c3e88dfbf1" target="_blank" rel="external">OC源码 —— retain和release</a></li>
<li><a href="http://blog.tracyone.com/2015/06/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAARC-%E4%B8%AD/" target="_blank" rel="external">深入浅出ARC(中)</a></li>
<li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a></li>
<li><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">Objective-C Autorelease Pool 的实现原理</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-对象与类&quot;&gt;&lt;a href=&quot;#1-对象与类&quot; class=&quot;headerlink&quot; title=&quot;1. 对象与类&quot;&gt;&lt;/a&gt;1. 对象与类&lt;/h4&gt;&lt;h5 id=&quot;1-1-对象&quot;&gt;&lt;a href=&quot;#1-1-对象&quot; class=&quot;headerlink&quot; title=&quot;1.1 对象&quot;&gt;&lt;/a&gt;1.1 对象&lt;/h5&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;objc_object&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;isa_t&lt;/span&gt; isa;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对象（Class或id）内部只有一个isa_t联合体指针。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>弱指针weak的实现学习</title>
    <link href="http://yoursite.com/2019/08/13/%E5%BC%B1%E6%8C%87%E9%92%88weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/08/13/弱指针weak的实现学习/</id>
    <published>2019-08-12T16:16:12.823Z</published>
    <updated>2019-08-13T06:11:30.189Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-weak对象的实现函数"><a href="#1-weak对象的实现函数" class="headerlink" title="1. weak对象的实现函数"></a>1. weak对象的实现函数</h4><p>首先，看个例子（<em>取自《Objective-C高级编程 iOS与OS X多线程和内存管理》的第一部分</em>）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> weakObj = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure>
<p>其模拟代码为</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj;</div><div class="line"></div><div class="line"><span class="comment">// 创建临时对象tmp</span></div><div class="line"><span class="keyword">id</span> tmp = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(tmp, <span class="keyword">@selector</span>(init));</div><div class="line"></div><div class="line"><span class="comment">// 使用tmp创建weak对象obj</span></div><div class="line">objc_initWeak(&amp;obj, tmp);</div><div class="line"></div><div class="line"><span class="comment">// 作用域结束，tmp释放</span></div><div class="line">objc_release(tmp);</div><div class="line"></div><div class="line"><span class="comment">// 释放weak对象obj</span></div><div class="line">objc_destroyWeak(&amp;obj);</div></pre></td></tr></table></figure>
<p>通过代码可以看到，<strong>weak指针（weak对象）的创建及释放，实际上是通过<em>objc_initWeak()</em> 和 <em>objc_destroyWeak()</em> 函数实现的</strong>。现在，就需要查看一下iOS的运行时系统是如何实现weak的功能的。</p>
<blockquote>
<p>注：源代码采用objc.723版本</p>
</blockquote>
<p>objc_initWeak的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span></div><div class="line">objc_initWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!newObj) &#123;</div><div class="line">        *location = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</div><div class="line">        (location, (objc_object*)newObj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>objc_destroyWeak的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span></div><div class="line">objc_destroyWeak(<span class="keyword">id</span> *location)</div><div class="line">&#123;</div><div class="line">    (<span class="keyword">void</span>)storeWeak&lt;DoHaveOld, DontHaveNew, DontCrashIfDeallocating&gt;</div><div class="line">        (location, <span class="literal">nil</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>补充一下，修改weak对象的函数objc_storeWeak的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span></div><div class="line">objc_storeWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> storeWeak&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</div><div class="line">        (location, (objc_object *)newObj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，<strong>weak的相关功能，都是通过<em>storeWeak</em>函数进行实现的。通过不同的参数及条件设置实现weak对象的创建、修改和删除的</strong>。</p>
<h4 id="2-storeWeak的实现"><a href="#2-storeWeak的实现" class="headerlink" title="2. storeWeak的实现"></a>2. storeWeak的实现</h4><p>还是不废话，直接贴出实现源码（删除了部分无关代码）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> 更新weak变量。</div><div class="line"> </div><div class="line"> HaveOld为true时，即weak变量本身已经指向一个即将被清空的对象。这个值可以是nil。</div><div class="line"> HaveNew为true时，即有个新对象需要赋值给weak指针。这个值可以为nil。</div><div class="line"> CrashIfDeallocating为true时，如果newObj正在释放、或者newObj所属的类不支持弱引用，则进程就要中断（崩溃）；如果CrashIfDeallocating为false，则意味着将nil存储到变量中。</div><div class="line"> </div><div class="line"> @param location __weak指针地址</div><div class="line"> @param newObj  真正指向的对象</div><div class="line"> */</div><div class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</div><div class="line">          CrashIfDeallocating crashIfDeallocating&gt;</div><div class="line"><span class="keyword">static</span> <span class="keyword">id</span> </div><div class="line">storeWeak(<span class="keyword">id</span> *location, objc_object *newObj)</div><div class="line">&#123;</div><div class="line">    assert(haveOld  ||  haveNew); <span class="comment">// 至少一个为true</span></div><div class="line">    <span class="keyword">if</span> (!haveNew) assert(newObj == <span class="literal">nil</span>); <span class="comment">// 无新值时，newObj必须为nil</span></div><div class="line"></div><div class="line">    <span class="keyword">id</span> oldObj;</div><div class="line">    <span class="comment">// SideTable即为内存管理的数据结构。内部包含：引用计数表、弱引用表、自旋锁及相关方法。</span></div><div class="line">    SideTable *oldTable; <span class="comment">// 旧表（SideTable结构体指针）</span></div><div class="line">    SideTable *newTable; <span class="comment">// 新表（SideTable结构体指针）</span></div><div class="line"></div><div class="line">    <span class="comment">// Acquire locks for old and new values.</span></div><div class="line">    <span class="comment">// Order by lock address to prevent lock ordering problems. </span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (haveOld) &#123;</div><div class="line">        <span class="comment">// 若存在旧值</span></div><div class="line">        </div><div class="line">        <span class="comment">// 从weak地址中取出旧对象</span></div><div class="line">        oldObj = *location;</div><div class="line">        <span class="comment">// 使用旧对象获取到旧表实例</span></div><div class="line">        oldTable = &amp;SideTables()[oldObj];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 若不存在旧值</span></div><div class="line">        </div><div class="line">        <span class="comment">// 旧表直接置为nil</span></div><div class="line">        oldTable = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (haveNew) &#123;</div><div class="line">        <span class="comment">// 若存在新值</span></div><div class="line">        </div><div class="line">        <span class="comment">// 使用新值初始化得到新表实例</span></div><div class="line">        newTable = &amp;SideTables()[newObj];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 若不存在新值</span></div><div class="line">        </div><div class="line">        <span class="comment">// 新表直接置为nil</span></div><div class="line">        newTable = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据haveOld和haveNew状态，给两张SideTable表进行对应加锁（自旋锁）</span></div><div class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// Clean up old value, if any.</span></div><div class="line">    <span class="keyword">if</span> (haveOld) &#123;</div><div class="line">        <span class="comment">// 若存在旧值</span></div><div class="line">        </div><div class="line">        <span class="comment">// 在旧表中的weak表中清除相关信息（旧对象和weak指针的关联）</span></div><div class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Assign new value, if any.</span></div><div class="line">    <span class="keyword">if</span> (haveNew) &#123;</div><div class="line">        <span class="comment">// 若存在新值</span></div><div class="line">        </div><div class="line">        <span class="comment">// 在新表的weak表中存储相关信息（使用newObj的地址作为key，location地址，即weak指针作为value）</span></div><div class="line">        newObj = (objc_object *)</div><div class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (<span class="keyword">id</span>)newObj, location, </div><div class="line">                                  crashIfDeallocating);</div><div class="line">        <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></div><div class="line">        <span class="comment">// 如果被打断（如此时正在释放对象），则newObj就为nil了【注：crash的已经在上一步中进行处理了，这里是不crash的情况】</span></div><div class="line"></div><div class="line">        <span class="comment">// Set is-weakly-referenced bit in refcount table.</span></div><div class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</div><div class="line">            <span class="comment">// 若已经绑定成功，且newObj不是taggedPointer</span></div><div class="line">            </div><div class="line">            <span class="comment">// 将newObj的对应位标记为weak</span></div><div class="line">            newObj-&gt;setWeaklyReferenced_nolock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span></div><div class="line">        <span class="comment">// 确保weak指针指向newObj</span></div><div class="line">        *location = (<span class="keyword">id</span>)newObj;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// No new value. The storage is not changed.</span></div><div class="line">        <span class="comment">// 若没有新值，原存储信息不变</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 解锁相关表</span></div><div class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</div><div class="line"></div><div class="line">    <span class="comment">// 返回newObj对象</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)newObj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在以上代码中可以看到，我们所有的操作（注册weak、移除weak等）都是发生在<strong>SideTable</strong>实例中的。且在操作时需要在有锁的条件下执行。我们看一下SideTable到底是何方神圣：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> SideTable &#123;</div><div class="line">    <span class="comment">/** 自旋锁 */</span></div><div class="line">    spinlock_t slock;</div><div class="line">    <span class="comment">/** 引用计数表（散列表） */</span></div><div class="line">    RefcountMap refcnts;</div><div class="line">    <span class="comment">/** weak表（内部使用数组或二级表实现） */</span></div><div class="line">    weak_table_t weak_table;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，SideTable即为内存管理的精髓。其内部<strong>包含的就是引用计数表和weak弱引用表</strong>。</p>
<p>SideTable是全局对象（不支持析构，会crash），是由分离锁进行管理的StripedMap对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取oldTable对象（根据oldObj对象）</span></div><div class="line">oldTable = &amp;SideTables()[oldObj];</div></pre></td></tr></table></figure>
<p>其中，SideTables函数的实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在StripedMap模板类中，我们可以找到获取SideTable的相关实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StripedMap</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="keyword">enum</span> &#123; CacheLineSize = <span class="number">64</span> &#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_EMBEDDED</span></div><div class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PaddedT</span> &#123;</span></div><div class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    PaddedT <span class="built_in">array</span>[StripeCount];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span>&#123;</div><div class="line">        <span class="keyword">uintptr_t</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(p);</div><div class="line">        </div><div class="line">        <span class="comment">// hash算法（64位系统下得到的是0~63）</span></div><div class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % Stripe Count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) &#123; </div><div class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[indexForPointer(p)].value; </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，public方法中的实现即说明了一切：通过对象地址得到的hash值，取出数组中保存的值（这里即为SideTable对象）。且通过hash算法还可知道，一个StripedMap对象在64位系统下包含64个子单元。可以理解为一个分离锁管理着64个对象的SideTable对象。</p>
<p>由于本篇学习的是weak的实现，故我们暂时只讨论<em>weak_table_t</em>这个结构（这个还凑合，引用计数还根本不懂…）。</p>
<h4 id="3-weak弱引用表"><a href="#3-weak弱引用表" class="headerlink" title="3. weak弱引用表"></a>3. weak弱引用表</h4><p>首先看一下<em>weak_table_t</em>的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 全局弱引用表。</div><div class="line"> * weak_entry_t内部使用原始对象作为key，</div><div class="line"> * weak指针的地址的数组作为value</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_table_t</span> &#123;</span></div><div class="line">    <span class="comment">/** 弱引用键值数据数组的起始地址 */</span></div><div class="line">    <span class="keyword">weak_entry_t</span> *weak_entries;</div><div class="line">    <span class="comment">/** weak_entry_t数组的元素个数 */</span></div><div class="line">    <span class="keyword">size_t</span>    num_entries;</div><div class="line">    <span class="comment">/** weak_entry_t数组的大小 */</span></div><div class="line">    <span class="keyword">uintptr_t</span> mask;</div><div class="line">    <span class="comment">/** hash查找最大偏移量 */</span></div><div class="line">    <span class="keyword">uintptr_t</span> max_hash_displacement;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>weak_table_t内部保存着由week_entry_t实例组成的数组</strong>。</p>
<p>内部的<strong>weak_entry_t即为真正的键值对：key为引用的对象，value为weak指针组成的数组</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义的结构体内部对于weak指针个数的储存上线</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WEAK_INLINE_COUNT 4</span></div><div class="line"></div><div class="line"><span class="comment">// out_of_line_ness成员占用了inline_referrers数组index为1空间中的低2位。</span></div><div class="line"><span class="comment">// inline_referrers[1]是一个指针对齐的DisguisedPtr的对象。</span></div><div class="line"><span class="comment">// 一个指针对齐的DisguisedPtr的最低两位永远是0b00。</span></div><div class="line"><span class="comment">// 因此，在out_of_line_ness == 0b10，就被用于标记out-of-line动态数组的状态。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REFERRERS_OUT_OF_LINE 2</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_entry_t</span> &#123;</span></div><div class="line">    <span class="comment">/** 指向的对象 */</span></div><div class="line">    DisguisedPtr&lt;objc_object&gt; referent;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">            <span class="comment">/** 存储weak指针的动态数组的起始地址 */</span></div><div class="line">            <span class="keyword">weak_referrer_t</span> *referrers;</div><div class="line">            <span class="comment">/** 标识是否使用了动态数组：占2位 */</span></div><div class="line">            <span class="keyword">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>;</div><div class="line">            <span class="comment">/** 已存的weak指针个数：占62位 */</span></div><div class="line">            <span class="keyword">uintptr_t</span>        num_refs : PTR_MINUS_2;</div><div class="line">            <span class="comment">/** 动态数组的总大小 */</span></div><div class="line">            <span class="keyword">uintptr_t</span>        mask;</div><div class="line">            <span class="comment">/** hash查找最大偏移量 */</span></div><div class="line">            <span class="keyword">uintptr_t</span>        max_hash_displacement;</div><div class="line">        &#125;; <span class="comment">// 五个成员，共32字节</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">            <span class="comment">// 结构体中自带的可以存储4个weak指针的静态数组</span></div><div class="line">            <span class="comment">// 注：out_of_line_ness域使用了索引为1的位置的最低2位</span></div><div class="line">            <span class="keyword">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];</div><div class="line">        &#125;; <span class="comment">// 32字节</span></div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="comment">/** 判定是否使用了动态数组存储weak指针 */</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">out_of_line</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">weak_entry_t</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">weak_entry_t</span>&amp; other) &#123;</div><div class="line">        <span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;other, <span class="keyword">sizeof</span>(other));</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** 创建新的weak键值对实例（以前没有） */</span></div><div class="line">    <span class="keyword">weak_entry_t</span>(objc_object *newReferent, objc_object **newReferrer)</div><div class="line">        : referent(newReferent)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 使用静态数组存储weak指针</span></div><div class="line">        inline_referrers[<span class="number">0</span>] = newReferrer;</div><div class="line">        <span class="comment">// 将数组的其他位置数据置为nil</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</div><div class="line">            inline_referrers[i] = nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>weak_entry_t结构体固定为40字节大小。<br>其中，为了快速访问weak指针，weak_entry_t中直接设置了一个包含4个元素的静态数组。当指向对象的weak指针超过上限时，就使用动态数组进行存储（将静态数组中的weak指针copy到动态数组中，之后再存入新的weak指针）。<br>weak_entry_t提供给外部用于识别自身正在使用哪种存储数组的函数。</p>
<p>有了以上这些知识，我们就可以解释SideTable中的weak表是如何注册weak对象并如何清除weak对象的过程了。</p>
<h4 id="4-在weak引用表中注册weak对象"><a href="#4-在weak引用表中注册weak对象" class="headerlink" title="4. 在weak引用表中注册weak对象"></a>4. 在weak引用表中注册weak对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 如果不存在，注册一个新的（对象，弱指针）键值对（entry对象）。</div><div class="line"> * </div><div class="line"> * @param weak_table 全局弱引用表</div><div class="line"> * @param referent 弱指针要指向的对象</div><div class="line"> * @param referrer 弱指针的地址</div><div class="line"> */</div><div class="line"><span class="keyword">id</span> </div><div class="line">weak_register_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id, </div><div class="line">                      <span class="keyword">id</span> *referrer_id, <span class="keyword">bool</span> crashIfDeallocating)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 指向的原对象</span></div><div class="line">    objc_object *referent = (objc_object *)referent_id;</div><div class="line">    <span class="comment">// weak指针</span></div><div class="line">    objc_object **referrer = (objc_object **)referrer_id;</div><div class="line"></div><div class="line">    <span class="comment">// 原对象为nil，或者原对象是taggedPointer，直接返回原对象</span></div><div class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</div><div class="line"></div><div class="line">    <span class="comment">// ensure that the referenced object is viable</span></div><div class="line">    <span class="keyword">bool</span> deallocating;</div><div class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</div><div class="line">        <span class="comment">// 若原始对象的类，没有实现内存管理的相关方法</span></div><div class="line">        </div><div class="line">        <span class="comment">// 直接以SideTable的释放状态作为标识</span></div><div class="line">        deallocating = referent-&gt;rootIsDeallocating();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 若原始对象的类，实现了内存管理的相关方法</span></div><div class="line"></div><div class="line">        </div><div class="line">        <span class="built_in">BOOL</span> (*allowsWeakReference)(objc_object *, SEL) = </div><div class="line">            (<span class="built_in">BOOL</span>(*)(objc_object *, SEL))</div><div class="line">            object_getMethodImplementation((<span class="keyword">id</span>)referent, </div><div class="line">                                           SEL_allowsWeakReference);</div><div class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</div><div class="line">            <span class="comment">// 若allowsWeakReference的实现为消息转发函数，则证明调研对象不支持weak，直接返回nil</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 若allowsWeakReference的实现正常，执行此IMP，返回值取反作为释放的标识（即：自定义为不支持weak，则认为正在释放）</span></div><div class="line">        deallocating =</div><div class="line">            ! (*allowsWeakReference)(referent, SEL_allowsWeakReference);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (deallocating) &#123;</div><div class="line">        <span class="comment">// 根据释放标识，进行处理</span></div><div class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</div><div class="line">            <span class="comment">// crash</span></div><div class="line">            _objc_fatal(<span class="string">"Cannot form weak reference to instance (%p) of "</span></div><div class="line">                        <span class="string">"class %s. It is possible that this object was "</span></div><div class="line">                        <span class="string">"over-released, or is in the process of deallocation."</span>,</div><div class="line">                        (<span class="keyword">void</span>*)referent, object_getClassName((<span class="keyword">id</span>)referent));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 返回nil</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// now remember it and where it is being stored</span></div><div class="line">    weak_entry_t *entry;</div><div class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</div><div class="line">        <span class="comment">// 在weak表中，使用原始对象获取生成入口信息，若存在（证明原始对象子表中已经存储了其他weak指针了）</span></div><div class="line">        </div><div class="line">        <span class="comment">// 将weak指针插入到子表中</span></div><div class="line">        append_referrer(entry, referrer);</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 没有entry对象</span></div><div class="line">        </div><div class="line">        <span class="comment">// 使用原始对象创建新的entry对象（绑定好key和value）</span></div><div class="line">        weak_entry_t new_entry(referent, referrer);</div><div class="line">        </div><div class="line">        <span class="comment">// 检查是否需要扩充weak表（扩充后，原始数据均插入了新weak表中）</span></div><div class="line">        weak_grow_maybe(weak_table);</div><div class="line">        </div><div class="line">        <span class="comment">// 将新的入口信息插入到weak表中</span></div><div class="line">        weak_entry_insert(weak_table, &amp;new_entry);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 这里不要修改referrer的指向（也就是weak指针的指向不能变）</span></div><div class="line"></div><div class="line">    <span class="comment">// 返回原对象</span></div><div class="line">    <span class="keyword">return</span> referent_id;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，通过原始对象，在weak表中查找对应entry的过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 根据给定的对象，返回弱引用表中对应的entry。</div><div class="line"> * 如果没有对应的entry，返回NULL。</div><div class="line"> * 执行了一次循环查找。</div><div class="line"> *</div><div class="line"> * @param weak_table </div><div class="line"> * @param referent The object. Must not be nil.</div><div class="line"> * </div><div class="line"> * @return The table of weak referrers to this object. </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> weak_entry_t *</span></div><div class="line"><span class="title">weak_entry_for_referent</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, objc_object *referent)</span></div><div class="line">&#123;</div><div class="line">    assert(referent);</div><div class="line"></div><div class="line">    <span class="comment">// 从表中取出weak_entry_t指针（weak数据表的起始地址）</span></div><div class="line">    <span class="keyword">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!weak_entries) <span class="keyword">return</span> nil;</div><div class="line"></div><div class="line">    <span class="comment">// 根据对象地址的hash与weak表的mask与运算得到遍历的起始index</span></div><div class="line">    <span class="keyword">size_t</span> begin = hash_pointer(referent) &amp; weak_table-&gt;mask;</div><div class="line">    <span class="keyword">size_t</span> index = begin;</div><div class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 依次查看weak_entry_t对象中的referent是否为指向的对象</span></div><div class="line">    <span class="keyword">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;</div><div class="line">        <span class="comment">// 不是，索引后移</span></div><div class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</div><div class="line">        </div><div class="line">        <span class="comment">// 索引又变为begin了，直接crash（hash冲突且没有空余位置了）</span></div><div class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(weak_table-&gt;weak_entries);</div><div class="line">        hash_displacement++;</div><div class="line">        <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</div><div class="line">            <span class="comment">// 超出最大偏移范围，返回</span></div><div class="line">            <span class="keyword">return</span> nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 此时，通过index取到weak_entry_t对象，返回地址</span></div><div class="line">    <span class="keyword">return</span> &amp;weak_table-&gt;weak_entries[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注</strong>：</p>
<p>在查找遍历索引begin时，系统使用的方式是<strong>通过对象的hash值和weak_table的mask值进行<em>按位与</em>运算</strong>。<br>其中mask是num_entries-1，即如果此弱引用表的weak_entries个数是4，mask即为3，也就是0b11。<br>对象地址hash之后，通过mask进行<em>按位与</em>运算得到的，就只有mask值对应的范围，即0b00~0b11，故index取值范围是0~3。系统巧妙地将对象地址转化为索引，在数组中查找对应位置的数据。<br>后面使用while循环的原因是，<strong>由于hash值可能会重复，得到的index位置可能已经存在其他数据，故对index进行偏移处理，待新位置的元素符合要求，再进行操作</strong>。其中hash_displacement就是标记偏移量的。如果超过最大偏移量max_hash_displacement，则数组中没有符合要求的位置索引。</p>
</blockquote>
<p>向已经存在的weak_entry_t中插入新的weak指针，操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">append_referrer</span><span class="params">(<span class="keyword">weak_entry_t</span> *entry, objc_object **new_referrer)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</div><div class="line">        <span class="comment">// 若使用的内部数组存储weak指针，则直接遍历，将空的赋值为weak指针地址</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == nil) &#123;</div><div class="line">                entry-&gt;inline_referrers[i] = new_referrer;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 内部数组已满，此时需要使用动态数组存储（先初始化4个地址空间）</span></div><div class="line">        <span class="keyword">weak_referrer_t</span> *new_referrers = (<span class="keyword">weak_referrer_t</span> *)</div><div class="line">            <span class="built_in">calloc</span>(WEAK_INLINE_COUNT, <span class="keyword">sizeof</span>(<span class="keyword">weak_referrer_t</span>));</div><div class="line">        <span class="comment">// 将内部数组的四个weak指针copy到动态数组中</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</div><div class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 更新相关信息，以后使用动态数组存储</span></div><div class="line">        entry-&gt;referrers = new_referrers;</div><div class="line">        entry-&gt;num_refs = WEAK_INLINE_COUNT;</div><div class="line">        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;</div><div class="line">        entry-&gt;mask = WEAK_INLINE_COUNT<span class="number">-1</span>;</div><div class="line">        entry-&gt;max_hash_displacement = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 本来就在使用动态数组存储的情况</span></div><div class="line">    assert(entry-&gt;out_of_line());</div><div class="line"></div><div class="line">    <span class="comment">// 占用空间超过 3/4，扩容并插入新weak指针</span></div><div class="line">    <span class="keyword">if</span> (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123;</div><div class="line">        <span class="keyword">return</span> grow_refs_and_insert(entry, new_referrer);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 空间正常，可以插入</span></div><div class="line">    <span class="keyword">size_t</span> begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);</div><div class="line">    <span class="keyword">size_t</span> index = begin;</div><div class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 遍历找到待插入的索引位置</span></div><div class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != nil) &#123;</div><div class="line">        hash_displacement++;</div><div class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</div><div class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</div><div class="line">        entry-&gt;max_hash_displacement = hash_displacement;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 取出数组对应位置的地址，赋值weak指针</span></div><div class="line">    <span class="keyword">weak_referrer_t</span> &amp;ref = entry-&gt;referrers[index];</div><div class="line">    ref = new_referrer;</div><div class="line">    <span class="comment">// 计数+1</span></div><div class="line">    entry-&gt;num_refs++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而对于weak_table_t弱引用表中，没有引用对象指向的weak_entry_t对象时，直接创建新entry，将weak指针写入后，直接将此entry加入到弱引用表中。此过程与查询entry的过程非常相似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weak_entry_insert</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, <span class="keyword">weak_entry_t</span> *new_entry)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</div><div class="line">    assert(weak_entries != nil);</div><div class="line"></div><div class="line">    <span class="keyword">size_t</span> begin = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);</div><div class="line">    <span class="keyword">size_t</span> index = begin;</div><div class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (weak_entries[index].referent != nil) &#123;</div><div class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</div><div class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(weak_entries);</div><div class="line">        hash_displacement++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    weak_entries[index] = *new_entry;</div><div class="line">    weak_table-&gt;num_entries++;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</div><div class="line">        weak_table-&gt;max_hash_displacement = hash_displacement;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-在weak弱引用表中移除weak对象"><a href="#5-在weak弱引用表中移除weak对象" class="headerlink" title="5. 在weak弱引用表中移除weak对象"></a>5. 在weak弱引用表中移除weak对象</h4><p>相对的，当指向的对象将要释放时，运行时系统会将注册到weak表中的原始对象相关的所有weak指针信息移除。也就实现了weak自动置为nil的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">weak_unregister_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent_id, </span></div><div class="line">                        id *referrer_id)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 指向的对象</span></div><div class="line">    objc_object *referent = (objc_object *)referent_id;</div><div class="line">    <span class="comment">// weak指针的地址</span></div><div class="line">    objc_object **referrer = (objc_object **)referrer_id;</div><div class="line"></div><div class="line">    <span class="keyword">weak_entry_t</span> *entry;</div><div class="line"></div><div class="line">    <span class="comment">// 指向对象不存在，直接返回（用指向对象的地址作为key进行保存）</span></div><div class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</div><div class="line">        <span class="comment">// 使用指向的对象在weak表中查找，获取entry，如果存在</span></div><div class="line">        </div><div class="line">        <span class="comment">// 在entry中移除weak指针的地址存储</span></div><div class="line">        remove_referrer(entry, referrer);</div><div class="line">        </div><div class="line">        <span class="comment">// 查看入口信息子表中是否还有其他weak指针存储</span></div><div class="line">        <span class="keyword">bool</span> empty = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 使用了动态数组存储weak指针，且num_refs不为0，证明还有</span></div><div class="line">            empty = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 内部数组存储，只要数组不为空，就还有</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</div><div class="line">                    empty = <span class="literal">false</span>; </div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (empty) &#123;</div><div class="line">            <span class="comment">// 若子表中没有其他的weak指针地址存储了</span></div><div class="line">            </div><div class="line">            <span class="comment">// 在weak表中移除entry信息</span></div><div class="line">            weak_entry_remove(weak_table, entry);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这里不要清除weak指针的地址，objc_storeWeak函数不允许他人更改</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整体过程与注册weak指针的流程非常相似。查询到weak_entry_t对象后，移除内部的weak指针，最后清除此entry对象即可。</p>
<p>移除entry中指定的weak指针的过程如下（与插入weak指针非常相似）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove_referrer</span><span class="params">(<span class="keyword">weak_entry_t</span> *entry, objc_object **old_referrer)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</div><div class="line">        <span class="comment">// 没有使用外部动态数组，即weak直接存储在内部静态数组中</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</div><div class="line">            <span class="comment">// 查找到weak指针所在的对象</span></div><div class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == old_referrer) &#123;</div><div class="line">                <span class="comment">// 置为nil，完成清除（weak指针自动置nil的功能）</span></div><div class="line">                entry-&gt;inline_referrers[i] = nil;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 未找到，出现内部错误</span></div><div class="line">        _objc_inform(<span class="string">"Attempted to unregister unknown __weak variable "</span></div><div class="line">                     <span class="string">"at %p. This is probably incorrect use of "</span></div><div class="line">                     <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></div><div class="line">                     <span class="string">"Break on objc_weak_error to debug.\n"</span>, </div><div class="line">                     old_referrer);</div><div class="line">        objc_weak_error();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// weak指针存储超过了4个，使用了外部的动态数组</span></div><div class="line">    </div><div class="line">    <span class="comment">// 得到遍历的起始索引</span></div><div class="line">    <span class="keyword">size_t</span> begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);</div><div class="line">    <span class="keyword">size_t</span> index = begin;</div><div class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 在动态数组中依次查看，直到找到weak指针存储的位置</span></div><div class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != old_referrer) &#123;</div><div class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</div><div class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry); <span class="comment">// 出错crash</span></div><div class="line">        hash_displacement++;</div><div class="line">        <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</div><div class="line">            _objc_inform(<span class="string">"Attempted to unregister unknown __weak variable "</span></div><div class="line">                         <span class="string">"at %p. This is probably incorrect use of "</span></div><div class="line">                         <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></div><div class="line">                         <span class="string">"Break on objc_weak_error to debug.\n"</span>, </div><div class="line">                         old_referrer);</div><div class="line">            objc_weak_error();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 此时index所在位置即为weak指针存储的位置，置为nil清除</span></div><div class="line">    entry-&gt;referrers[index] = nil;</div><div class="line">    <span class="comment">// 将索引个数-1</span></div><div class="line">    entry-&gt;num_refs--;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在weak_table_t中移除weak_entry_t对象就比较简单了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weak_entry_remove</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, <span class="keyword">weak_entry_t</span> *entry)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 使用了动态数组存储weak指针，则直接从起始地址进行释放即完成清除（动态数组通过calloc申请的连续地址空间）</span></div><div class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) <span class="built_in">free</span>(entry-&gt;referrers);</div><div class="line">    </div><div class="line">    <span class="comment">// 将entry的整个存储空间清零</span></div><div class="line">    bzero(entry, <span class="keyword">sizeof</span>(*entry));</div><div class="line"></div><div class="line">    <span class="comment">// 整体weak表的num_entries计数 - 1</span></div><div class="line">    weak_table-&gt;num_entries--;</div><div class="line"></div><div class="line">    <span class="comment">// 检查缩小weak表的容量</span></div><div class="line">    weak_compact_maybe(weak_table);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，weak_compact_maybe函数会检查weak表中entry的存储占用率，根据实际情况释放相应空间。</p>
<blockquote>
<p>不仅如此，weak_grow_maybe函数也如此，会根据占用率动态扩大存储空间。其内部实现都是通过<em>weak_resize</em>函数实现的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TABLE_SIZE(entry) (entry-&gt;mask ? entry-&gt;mask + 1 : 0)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weak_resize</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, <span class="keyword">size_t</span> new_size)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> old_size = TABLE_SIZE(weak_table);</div><div class="line"></div><div class="line">    <span class="keyword">weak_entry_t</span> *old_entries = weak_table-&gt;weak_entries;</div><div class="line">    </div><div class="line">    <span class="comment">// 分配内存，new_size * sizeof(weak_entry_t) 个字节（new_size * 40）</span></div><div class="line">    <span class="keyword">weak_entry_t</span> *new_entries = (<span class="keyword">weak_entry_t</span> *)</div><div class="line">        <span class="built_in">calloc</span>(new_size, <span class="keyword">sizeof</span>(<span class="keyword">weak_entry_t</span>));</div><div class="line"></div><div class="line">    weak_table-&gt;mask = new_size - <span class="number">1</span>; <span class="comment">// 记录下尺寸</span></div><div class="line">    weak_table-&gt;weak_entries = new_entries; <span class="comment">// 数组起始地址</span></div><div class="line">    weak_table-&gt;max_hash_displacement = <span class="number">0</span>;</div><div class="line">    weak_table-&gt;num_entries = <span class="number">0</span>;  <span class="comment">// restored by weak_entry_insert below</span></div><div class="line">    </div><div class="line">    <span class="comment">// 将原始数据copy到新weak表中</span></div><div class="line">    <span class="keyword">if</span> (old_entries) &#123;</div><div class="line">        <span class="keyword">weak_entry_t</span> *entry;</div><div class="line">        <span class="keyword">weak_entry_t</span> *end = old_entries + old_size;</div><div class="line">        <span class="keyword">for</span> (entry = old_entries; entry &lt; end; entry++) &#123;</div><div class="line">            <span class="keyword">if</span> (entry-&gt;referent) &#123;</div><div class="line">                <span class="comment">// 将原始数据插入到weak表中</span></div><div class="line">                weak_entry_insert(weak_table, entry);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">free</span>(old_entries);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，我们就知道了，weak_table_t中的weak_entries成员实际上是weak_entry_t组成的数组（calloc创建的连续内存空间）。</p>
<h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><p>至此，我们基本了解了创建和释放一个weak弱指针对象所需要做的主要工作。也明白了weak指针在原对象释放后自动置为nil的实现方式。</p>
<p>此外，我们还了解了：</p>
<ol>
<li>苹果对于将hash值转化为数组索引index的转换方式及冲突后的索引偏移的操作。</li>
<li>对于weak_entry_t数据结构中，存储weak指针的两种方式（快速量少用静态数组，量大使用动态数组的可伸缩方式）的分段式存储思想。</li>
</ol>
<h4 id="7-参考资料："><a href="#7-参考资料：" class="headerlink" title="7. 参考资料："></a>7. 参考资料：</h4><ul>
<li><a href="https://www.jianshu.com/p/ed43b17c8a72" target="_blank" rel="external">读读objc源码(二)：weak类型指针的实现</a></li>
<li><a href="https://www.jianshu.com/p/ef6d9bf8fe59" target="_blank" rel="external">iOS管理对象内存的数据结构以及操作算法–SideTables、RefcountMap、weak_table_t-一</a></li>
<li><a href="https://blog.csdn.net/iJason92/article/details/72808387" target="_blank" rel="external">ObjC Runtime 中 Weak 属性的实现 (上)</a></li>
<li><a href="https://blog.csdn.net/iJason92/article/details/72863699" target="_blank" rel="external">ObjC Runtime 中 Weak 属性的实现 (中)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-weak对象的实现函数&quot;&gt;&lt;a href=&quot;#1-weak对象的实现函数&quot; class=&quot;headerlink&quot; title=&quot;1. weak对象的实现函数&quot;&gt;&lt;/a&gt;1. weak对象的实现函数&lt;/h4&gt;&lt;p&gt;首先，看个例子（&lt;em&gt;取自《Objective
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>GCD的串行队列同步死锁问题</title>
    <link href="http://yoursite.com/2019/08/08/GCD%E7%9A%84%E4%B8%B2%E8%A1%8C%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/08/08/GCD的串行队列同步死锁问题/</id>
    <published>2019-08-08T03:38:49.480Z</published>
    <updated>2019-08-08T03:38:49.480Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>《Effective Objective-C 2.0》中“第46条：<em>不要使用dispatch_get_current_queue</em>”笔记</p>
</blockquote>
<p>我们都知道，<strong>在串行队列的同步任务中，再次向其中派发同步任务会造成死锁</strong>（向主队列派发同步任务的死锁就是这样）。但是，如果是下面这样呢？</p>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queueA = dispatch_queue_create(<span class="string">"com.jiji.serialQueueA"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="built_in">dispatch_queue_t</span> queueB = dispatch_queue_create(<span class="string">"com.jiji.serialQueueB"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_sync</span>(queueA, ^&#123;</div><div class="line">    <span class="comment">// 向queueB中派发同步任务</span></div><div class="line">    <span class="built_in">dispatch_sync</span>(queueB, ^&#123;</div><div class="line">        <span class="comment">// 向queueA中派发同步任务</span></div><div class="line">        <span class="built_in">dispatch_sync</span>(queueA, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"inner----"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"outer-=-=-=-=-=-="</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>结果<strong>同样死锁</strong>。这是因为最内部派发到queueA中的任务需要按队列的方式，等待先入队的最外层任务执行完成，但最外层任务被最内部的任务阻塞无法继续执行，故导致死锁。这在道理上与最简单的死锁没有区别。</p>
<p>但是，当我们想要使用<em>dispatch_get_current_queue</em>函数，对内部执行队列进行区分，防止死锁时，可以发现此方法早已被标记为了<em>deprecated</em>。也就是说，此函数返回的队列不能作为任务执行队列的判断依据。</p>
<p>故数组建议我们<strong>使用<em>dispatch_queue_set_specific</em>函数，对队列绑定相关数据。在派发的任务执行时，动态取出绑定数据来判定当前的执行队列</strong>。</p>
<p>直接看对比示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将queueB的目标队列设置为queueA，即queueB中的任务被派发到queueA中执行</span></div><div class="line">dispatch_set_target_queue(queueB, queueA);</div><div class="line"></div><div class="line"><span class="comment">// 给指定队列绑定相关数据（使用键值对的方式）</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> kQueueSpecific;</div><div class="line"><span class="built_in">CFStringRef</span> queueSpecificValue = <span class="built_in">CFSTR</span>(<span class="string">"queueA"</span>);</div><div class="line">dispatch_queue_set_specific(queueA,</div><div class="line">                            &amp;kQueueSpecific,</div><div class="line">                            (<span class="keyword">void</span> *)queueSpecificValue,</div><div class="line">                            (dispatch_function_t)<span class="built_in">CFRelease</span>);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_sync</span>(queueB, ^&#123;</div><div class="line">    dispatch_block_t block = ^ &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"hahahahaha~~"</span>);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_queue_t</span> currentQueue = dispatch_get_current_queue();</div><div class="line">    <span class="keyword">if</span> (currentQueue == queueA) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"currentQueue == queueA"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"currentQueue == queueB"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 在当前队列中取出绑定的相关数据</span></div><div class="line">    <span class="built_in">CFStringRef</span> retrievedValue = dispatch_get_specific(&amp;kQueueSpecific);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (retrievedValue) &#123;</div><div class="line">        <span class="comment">// 存在相关值，即当前就在绑定的队列中执行，不要再向那个队列派发同步任务，会死锁</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"in queueA"</span>);</div><div class="line">        block();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 不存在，证明执行不在指定的那个队列中，可以派发同步任务</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NOT in queueA"</span>);</div><div class="line">        <span class="built_in">dispatch_sync</span>(queueA, block);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"finish!!!!"</span>);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>LockTest[19151:825723] currentQueue == queueB<br>LockTest[19151:825723] in queueA<br>LockTest[19151:825723] hahahahaha~~<br>LockTest[19151:825723] finish!!!!</p>
</blockquote>
<p>可以看出，由于设置了目标队列，实际上是有queueA执行派发任务。但是<em>dispatch_get_current_queue</em>只能反映出原始派发任务的队列，而通过<em>dispatch_get_specific</em>函数取到的绑定数据却是根据真实执行任务的队列获取到。故<strong>在同步派发任务时，为了防止死锁，可以使用<em>dispatch_queue_set_specific</em>和<em>dispatch_get_specific</em>配对，来识别当前执行任务的队列</strong>。</p>
<p>这就是<strong>不要使用dispatch_get_current_queue</strong>的原因。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;《Effective Objective-C 2.0》中“第46条：&lt;em&gt;不要使用dispatch_get_current_queue&lt;/em&gt;”笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们都知道，&lt;strong&gt;在串行队列的同步任务中，再次向其中派发同步任务会造成死锁&lt;/strong&gt;（向主队列派发同步任务的死锁就是这样）。但是，如果是下面这样呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>相关对象（AssociateObject）实现学习</title>
    <link href="http://yoursite.com/2019/08/05/%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1%EF%BC%88AssociateObject%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/08/05/相关对象（AssociateObject）实现学习/</id>
    <published>2019-08-05T15:20:11.312Z</published>
    <updated>2019-08-05T15:20:11.312Z</updated>
    
    <content type="html"><![CDATA[<h4 id="源代码copy"><a href="#源代码copy" class="headerlink" title="源代码copy"></a>源代码copy</h4><p>不废话，直接附上实现的源代码：</p>
<blockquote>
<p>相关API声明在objc-runtime.mm中</p>
</blockquote>
<a id="more"></a>
<h5 id="1-设置相关对象的值"><a href="#1-设置相关对象的值" class="headerlink" title="1. 设置相关对象的值"></a>1. 设置相关对象的值</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 为类的实例对象设置相关对象 */</span></div><div class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy) &#123;</div><div class="line">    _object_set_associative_reference(object, (<span class="keyword">void</span> *)key, value, policy);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 实现</span></div><div class="line"><span class="keyword">void</span> _object_set_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, uintptr_t policy) &#123;</div><div class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></div><div class="line">    <span class="comment">// 初始化ObjcAssociation结构实例</span></div><div class="line">    ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>);</div><div class="line">    <span class="comment">// 对传入的新值value根据policy进行内存处理，并返回对象地址</span></div><div class="line">    <span class="keyword">id</span> new_value = value ? acquireValue(value, policy) : <span class="literal">nil</span>;</div><div class="line">    &#123;</div><div class="line">        AssociationsManager manager;</div><div class="line">        <span class="comment">// 获取全局相关对象hashmap的起始地址</span></div><div class="line">        AssociationsHashMap &amp;associations(manager.associations());</div><div class="line">        <span class="comment">// object地址转换为查询地址</span></div><div class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</div><div class="line">        <span class="keyword">if</span> (new_value) &#123;</div><div class="line">            <span class="comment">// break any existing association.</span></div><div class="line">            <span class="comment">// 查询全局哈希表中是否存在object的相关对象信息的容器</span></div><div class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;</div><div class="line">                <span class="comment">// secondary table exists</span></div><div class="line">                <span class="comment">// 存在object的相关对象信息容器（也是一张子哈希表）</span></div><div class="line">                </div><div class="line">                <span class="comment">// 获取字表的起始地址</span></div><div class="line">                ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">                </div><div class="line">                <span class="comment">// 查找是否存在key（即新加的属性）的相关信息</span></div><div class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</div><div class="line">                    <span class="comment">// 存在相同的相关信息（以前存储过了），直接修改</span></div><div class="line">                    </div><div class="line">                    <span class="comment">// 将以前的值缓存给old_assosiation</span></div><div class="line">                    old_association = j-&gt;second;</div><div class="line">                    </div><div class="line">                    <span class="comment">// 在原地址中存入新值（ObjcAssociation结构体实例，成员为policy和new_value）</span></div><div class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 在该object中没有此属性key的相关信息保存，创建新的，直接存储</span></div><div class="line">                    </div><div class="line">                    <span class="comment">// 在该地址下，存入键值对：键名为属性名key，值为ObjcAssociation结构体实例</span></div><div class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// create the new association (first time).</span></div><div class="line">                <span class="comment">// 全局哈希表中没有存储object的相关对象容器，创建新的容器（ObjectAssociationMap对象，也是个哈希表）</span></div><div class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</div><div class="line">                </div><div class="line">                <span class="comment">// 将新创建的容器指针存储到全局哈希表中，键名为object的地址</span></div><div class="line">                associations[disguised_object] = refs;</div><div class="line">                </div><div class="line">                <span class="comment">// 在容器中存入相关对象值（ObjcAssociation结构体实例），键名为属性名key</span></div><div class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class="line">                </div><div class="line">                <span class="comment">// 标记object为存在相关对象信息（修改isa联合体实例中的相关位的值）</span></div><div class="line">                object-&gt;setHasAssociatedObjects();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// setting the association to nil breaks the association.</span></div><div class="line">            <span class="comment">// 传入的相关值是nil，则清除该相关对象的信息（清除属性的值）</span></div><div class="line">            </div><div class="line">            <span class="comment">// 使用object地址再全局哈希表中查找，试图找到object的相关对象容器</span></div><div class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</div><div class="line">                <span class="comment">// 已找到此容器（子哈希表，ObjectAssociationMap对象）</span></div><div class="line">                ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">                </div><div class="line">                <span class="comment">// 查找此属性名key存储的信息</span></div><div class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">// 查找到相关对象信息，缓存给old_association</span></div><div class="line">                    old_association = j-&gt;second;</div><div class="line">                    </div><div class="line">                    <span class="comment">// 清除此ObjectAssociationMap对象（相关对象实例）</span></div><div class="line">                    refs-&gt;erase(j);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// release the old value (outside of the lock).</span></div><div class="line">    <span class="comment">// 缓存的old_association中存在值，释放内存，清除缓存</span></div><div class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出，<strong>所有的相关对象信息实际上是保存在全局的一个哈希表中</strong>。其中，<strong>以实例对象的地址（ <em>DISGUISE(object)</em> ）为键名，对应的值为另一张哈希表。此子哈希表中，以设置的属性名为键名，对应的值为相关值value和内存管理方式policy组成的结构体实例</strong>。</p>
<p>而保存相关对象的值的操作中，系统：</p>
<blockquote>
<ol>
<li>首先查看是否已经存储过此object对应的子哈希表，不存在则创建；</li>
<li>查看子哈希表中，是否已经存储过此属性名key对应的结构体信息，存在即修改为新值，不存在则创建新的保存；</li>
<li>对与传入的value为nil时，清除子哈希表中属性名key对应的结构体信息，以达到清除相关值的目的（<em>系统没有提供单独清空相关值属性的API</em> ）。</li>
<li>替换下来的相关值信息，抹掉并释放内存。</li>
</ol>
</blockquote>
<h5 id="2-获取相关对象的值"><a href="#2-获取相关对象的值" class="headerlink" title="2. 获取相关对象的值"></a>2. 获取相关对象的值</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 为类的实例对象获取相关对象的值 */</span></div><div class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key) &#123;</div><div class="line">    <span class="keyword">return</span> _object_get_associative_reference(object, (<span class="keyword">void</span> *)key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 实现</span></div><div class="line"><span class="keyword">id</span> _object_get_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key) &#123;</div><div class="line">    <span class="keyword">id</span> value = <span class="literal">nil</span>;</div><div class="line">    <span class="comment">// 声明内存管理方式指针变量（默认为assign）</span></div><div class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</div><div class="line">    </div><div class="line">    &#123;</div><div class="line">        AssociationsManager manager;</div><div class="line">        <span class="comment">// 获取全局相关对象哈希表（起始地址）【由于associations得到的是指向AssociationsHashMap的指针，故使用取地址符返回AssociationsHashMap的起始地址】</span></div><div class="line">        AssociationsHashMap &amp;associations(manager.associations());</div><div class="line">    </div><div class="line">        <span class="comment">// 将object地址转换为查询地址（保存地址）</span></div><div class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</div><div class="line">    </div><div class="line">        <span class="comment">// 视图查找到object对应的相关对象信息容器（AssociationsHashMap对象）</span></div><div class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</div><div class="line">            <span class="comment">// 已找到，获取入口地址（ObjectAssociationMap对象地址）</span></div><div class="line">            ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">            </div><div class="line">            <span class="comment">// 查找ObjectAssociationMap中，是否存在属性名key对应的相关信息实例</span></div><div class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</div><div class="line">                <span class="comment">// 已找到，记录入口地址（ObjcAssociation结构体实例的指针）</span></div><div class="line">                ObjcAssociation &amp;entry = j-&gt;second;</div><div class="line">                <span class="comment">// 取出对应的值和内存管理方式</span></div><div class="line">                value = entry.value();</div><div class="line">                policy = entry.policy();</div><div class="line">                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;</div><div class="line">                    <span class="comment">// 通过按位与运算，对需要retain的值，进行retain操作</span></div><div class="line">                    objc_retain(value);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</div><div class="line">        <span class="comment">// 存在相关值，且内存管理方式为autorelease，进行autorelease操作</span></div><div class="line">        objc_autorelease(value);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 返回相关值</span></div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-为实例对象清除所有的相关对象"><a href="#3-为实例对象清除所有的相关对象" class="headerlink" title="3. 为实例对象清除所有的相关对象"></a>3. 为实例对象清除所有的相关对象</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 清除类的实例对象的所有相关对象 */</span></div><div class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object) </div><div class="line">&#123;</div><div class="line">    <span class="comment">// 查看对象isa联合体中has_assoc位的值来确定是否存在相关对象</span></div><div class="line">    <span class="keyword">if</span> (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;</div><div class="line">        _object_remove_assocations(object);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 实现</span></div><div class="line"><span class="keyword">void</span> _object_remove_assocations(<span class="keyword">id</span> object) &#123;</div><div class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</div><div class="line">    </div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 获取全局相关对象的整体哈希表</span></div><div class="line">        AssociationsManager manager;</div><div class="line">        AssociationsHashMap &amp;associations(manager.associations());</div><div class="line">    </div><div class="line">        <span class="comment">// 本身没有存储任何信息，直接返回</span></div><div class="line">        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">        <span class="comment">// 将object指针转换为查询的指针</span></div><div class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</div><div class="line">        <span class="comment">// 试图查询是否存在object的相关对象容器信息</span></div><div class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</div><div class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></div><div class="line">            <span class="comment">// 已查到，获取入口地址</span></div><div class="line">            ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">            </div><div class="line">            <span class="comment">// 依次遍历子哈希表（ObjectAssociationMap对象的键值对信息）</span></div><div class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</div><div class="line">                <span class="comment">// 头插法插入到向量对象中</span></div><div class="line">                elements.push_back(j-&gt;second);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// remove the secondary table.</span></div><div class="line">            <span class="comment">// 删除入口地址信息</span></div><div class="line">            delete refs;</div><div class="line">            <span class="comment">// 清除子表（object容器中存储的所有信息，即ObjectAssociationMap对象）</span></div><div class="line">            associations.erase(i);</div><div class="line">            <span class="comment">// 清除之后，object便没有任何相关对象保存</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></div><div class="line">    <span class="comment">// 对向量中存储的所有相关对象信息，依次释放内存</span></div><div class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><h5 id="1-在Category中添加的property属性，系统为什么不会自动合成setter和getter？"><a href="#1-在Category中添加的property属性，系统为什么不会自动合成setter和getter？" class="headerlink" title="1. 在Category中添加的property属性，系统为什么不会自动合成setter和getter？"></a>1. 在Category中添加的property属性，系统为什么不会自动合成setter和getter？</h5><ol>
<li>在编译期，类的内存布局已经确定，在Class的结构中，并没有专门存储Category相关信息的位置。</li>
<li>Category是在APP启动时，在运行期才进行加载的，且是在对应的类加载完毕后才进行。最重要的，加载Category时，系统只是将内部声明的方法附加到Class的对应方法列表中，并不会对类的ivar列表进行操作。</li>
<li>最重要的，objc_category_t结构体中，根本没有变量成员，故自身也不能存储任何变量的值。</li>
</ol>
<h5 id="2-相关对象是针对类的还是实例对象的？"><a href="#2-相关对象是针对类的还是实例对象的？" class="headerlink" title="2. 相关对象是针对类的还是实例对象的？"></a>2. 相关对象是针对类的还是实例对象的？</h5><p>显而易见，由API的实现，可以看到，所有的相关对象是与object参数，即类的实例对象进行绑定关联，并存储到全局哈希表中的。故<strong>设置的相关对象只对当前的调用者对象有效</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;源代码copy&quot;&gt;&lt;a href=&quot;#源代码copy&quot; class=&quot;headerlink&quot; title=&quot;源代码copy&quot;&gt;&lt;/a&gt;源代码copy&lt;/h4&gt;&lt;p&gt;不废话，直接附上实现的源代码：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相关API声明在objc-runtime.mm中&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>union 联合体</title>
    <link href="http://yoursite.com/2019/08/02/union%20%E8%81%94%E5%90%88%E4%BD%93/"/>
    <id>http://yoursite.com/2019/08/02/union 联合体/</id>
    <published>2019-08-02T06:25:30.791Z</published>
    <updated>2019-08-02T06:25:49.841Z</updated>
    
    <content type="html"><![CDATA[<p>基本声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明联合体并创建testUnion实例</span></div><div class="line"><span class="keyword">union</span> U &#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">double</span> d;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line">    <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">9</span>];</div><div class="line">&#125; testUnion;</div></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>union是所有内部成员共用同一块内存，所有成员的内存地址相同，与union的起始地址相同。故修改任意成员，会导致其他成员的值都会变化（共享同一块内存）。<br>union的大小（sizeOf）需要可以装下最大尺寸的成员。且由于内存对齐，大小是所有成员尺寸的整数倍。</p>
</blockquote>
<p>故testUnion的大小为：<br>i = 4; d = 8; c = 1; array = 9 <em> 1;<br>sizeOf(testUnion) = 16; （最大是double成员的8字节，由于array总共9字节，故需要扩展为2倍，8 </em> 2 = 16字节）。</p>
<blockquote>
<p>union与struct的区别：</p>
<ol>
<li>struct的大小是所有成员尺寸之和，union是不小于最大成员尺寸。因此union内存使用更加灵活。</li>
<li>union同时只能保存一个成员的值，struct每个成员的值独立（有独立的内存地址）。</li>
</ol>
</blockquote>
<p>union可以用于数据类型转换（如union实例包含int和array，传入array可以得到int数据）。</p>
<hr>
<blockquote>
<p>相关资料：</p>
<ul>
<li><a href="https://www.jianshu.com/p/ac81470365ef" target="_blank" rel="external">union联合体与内存对齐</a></li>
<li><a href="https://www.jianshu.com/p/0355f83ff557" target="_blank" rel="external">内存对齐，大端字节 序小端字节序验证</a></li>
<li><a href="https://blog.csdn.net/microsues/article/details/6140329" target="_blank" rel="external">struct/class/union内存对齐原则</a></li>
<li><a href="https://www.jianshu.com/p/3366f8d7cb2b" target="_blank" rel="external">2018-08-27 C语言union 联合体 复习</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本声明：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 声明联合体并创建testUnion实例&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt; U &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; d;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; c;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; testUnion;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的锁 笔记</title>
    <link href="http://yoursite.com/2019/08/02/iOS%E4%B8%AD%E7%9A%84%E9%94%81%20%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/08/02/iOS中的锁 笔记/</id>
    <published>2019-08-02T03:17:16.608Z</published>
    <updated>2019-08-02T03:17:28.411Z</updated>
    
    <content type="html"><![CDATA[<p><strong><u>会阻塞线程的锁，都属于互斥锁</u></strong></p>
<a id="more"></a>
<h4 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h4><p>NSLock的<em>lock</em>方法和<em>lockBeforeDate:</em> 方法会阻塞线程；<em>tryLock</em>方法不会阻塞线程。<br>多个线程同时加锁时，其他请求锁的线程按照先进先出执行。</p>
<h4 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h4><p>NSConditionLock与NSLock行为相似，只不过可以设置条件（condition整数），可以设置为在满足condition时才进行<em>lockWithCondition:</em>、<em>unlockWithCondition:</em>、<em>tryLockWithCondition:</em> 等操作（当然也可以不设置条件）。</p>
<p>故<strong>可以使用NSConditionLock设置线程（任务）间的依赖关系，用GCD可以结合着使用进行实现</strong>。</p>
<h4 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a>NSRecursiveLock</h4><p>递归锁。可以在单个线程中返回加锁或解锁，其自身会记录加锁和解锁的次数，只有次数匹配时，才会真正的解锁，其他线程才可以加锁成功。</p>
<blockquote>
<p>NSLock、NSConditionLock和NSRecursiveLock是先轮询，之后再进入waiting状态。</p>
</blockquote>
<h4 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h4><p>NSCondition由 一个锁 + 条件检查器 组成。在每个线程中，都可以对condition对象单独进行<em>lock</em>和<em>unlock</em>，不影响其他线程再次加锁或解锁。</p>
<p>condition对象调用<em>wait</em>后，直接进入waiting状态，阻塞当前线程执行。等待其他线程对condition调用<em>signal</em> 或 <em>broadcast</em> 后，唤醒1个或所有的waiting线程，继续向下执行。</p>
<blockquote>
<p>以上四种锁都是遵循<em>NSLocking</em>协议。</p>
</blockquote>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h4><p>@synchronized同步锁会将指定的参数对象进行加锁。只有对相同对象进行加锁时，后加锁的线程才会被阻塞。否则无效。</p>
<h4 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h4><p>信号量是GCD进行同步的一种方式。<br>通过<em>dispatch_semaphore_create</em>创建信号量（指定信号值，即同时执行的任务数）。<em>dispatch_semaphore_wait</em>函数会对信号值进行检测：当信号值大于1时，信号值减1，继续向下执行任务，在信号值是1的信号量中，相当于加锁操作；当信号值为0时，调用线程被阻塞。只有当其他线程调用<em>dispatch_semaphpre_signal</em>进行信号恢复后（保证信号值重新大于0），被阻塞的线程继续向下执行。</p>
<blockquote>
<p>**dispatch_semaphore与NSCondition都是基于信号的锁，区别是信号量会保存发送的信号，NSCondition则不可以（只能signal）。</p>
</blockquote>
<h4 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h4><p>自旋锁现在已经不建议使用了，具体原因见上面（优先级反转造成死锁）。<br>苹果推荐使用<os lock.h="">中的<em>os_unfair_lock()</em> 锁替代。</os></p>
<blockquote>
<p>自旋锁与互斥锁都是抢占式，任何时候都只能有一个保持者。区别是：互斥锁中，调用者在别的运算单元抢占锁后进入睡眠，等待结束后被唤醒进行抢占；自旋锁，调用者在被运算单元抢占锁后不睡眠，循环查看自旋锁是否被释放。<br>故自旋锁适合保持锁时间较短的情况，这种情况下其效率远高于互斥锁。</p>
</blockquote>
<p>缺点：需要获取锁的线程优先级相同。如果低优先级的线程获得锁后，高优先级线程会处于busy-wait状态，占用大量CPU。而低优先级线程无法获取CPU时间，导致任务无法完成，也就无法释放锁。造成死锁（优先级反转）。</p>
<blockquote>
<p>参考资料：</p>
<ul>
<li><a href="https://www.jianshu.com/p/ddbe44064ca4" target="_blank" rel="external">iOS 常见知识点（三）：Lock</a></li>
<li><a href="https://www.jianshu.com/p/a321377c5639" target="_blank" rel="external">线程安全: 互斥锁和自旋锁(10种)</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;u&gt;会阻塞线程的锁，都属于互斥锁&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Aspects源码学习笔记</title>
    <link href="http://yoursite.com/2019/07/30/Aspects%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/07/30/Aspects源码学习笔记/</id>
    <published>2019-07-30T09:33:09.262Z</published>
    <updated>2019-08-02T03:16:17.202Z</updated>
    
    <content type="html"><![CDATA[<p>Aspects是一个可以动态hook指定方法的轻量级的库，AOP思想非常棒的体现。</p>
<a id="more"></a>
<h4 id="1-相关结构说明"><a href="#1-相关结构说明" class="headerlink" title="1. 相关结构说明"></a>1. 相关结构说明</h4><blockquote>
<p>Aspects.h</p>
</blockquote>
<h5 id="AspectOptions"><a href="#AspectOptions" class="headerlink" title="AspectOptions"></a>AspectOptions</h5><p>切片位置，用于指定hook后自定义block执行的时机。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>AspectPositionAfter</td>
<td>原始IMP执行之后执行</td>
</tr>
<tr>
<td>AspectPositionInstead</td>
<td>替换原始IMP</td>
</tr>
<tr>
<td>AspectPositionBefore</td>
<td>原始IMP执行之前执行</td>
</tr>
<tr>
<td>AspectOptionAutomaticRemoval</td>
<td>执行一次后直接移除</td>
</tr>
</tbody>
</table>
<h5 id="AspectToken协议"><a href="#AspectToken协议" class="headerlink" title="AspectToken协议"></a>AspectToken协议</h5><p>用于注销hook使用。使用其中的<em>remove</em>方法进行注销。</p>
<h5 id="AspectInfo协议"><a href="#AspectInfo协议" class="headerlink" title="AspectInfo协议"></a>AspectInfo协议</h5><p>作为插入的block的第一个参数出现。<br>对外公开为协议，内部则使用类实现。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>instance</td>
<td>被hook的实例对象</td>
</tr>
<tr>
<td>originalInvocation</td>
<td>原始的NSInvocation对象</td>
</tr>
<tr>
<td>arguments</td>
<td>原始参数数组</td>
</tr>
</tbody>
</table>
<h5 id="Aspects，NSObject的分类"><a href="#Aspects，NSObject的分类" class="headerlink" title="Aspects，NSObject的分类"></a>Aspects，NSObject的分类</h5><p>Aspects的公开API核心。<br>分为两个版本：实例方法版本和类方法版本。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</div><div class="line">                      withOptions:(AspectOptions)options</div><div class="line">                       usingBlock:(<span class="keyword">id</span>)block</div><div class="line">                            error:(<span class="built_in">NSError</span> **)error;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>调用者为类对象</strong>，对指定类的<em>selector</em>进行hook，执行时机为<em>options</em>，插入的执行任务为<em>block</em>。可以监控错误，返回值为遵循<em>AspectToken</em>的对象，用它可以实现注销hook操作。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</div><div class="line">                      withOptions:(AspectOptions)options</div><div class="line">                       usingBlock:(<span class="keyword">id</span>)block</div><div class="line">                            error:(<span class="built_in">NSError</span> **)error;</div></pre></td></tr></table></figure>
<blockquote>
<p>作用与类方法版本相同，但<strong>调用者为类的实例对象</strong>，即hook的方法只对本实例有效，其他实例无效。</p>
</blockquote>
<h5 id="AspectErrorCode"><a href="#AspectErrorCode" class="headerlink" title="AspectErrorCode"></a>AspectErrorCode</h5><p>错误信息说明。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>AspectErrorSelectorBlacklisted</td>
<td>黑名单（不允许hook的情况）</td>
</tr>
<tr>
<td>AspectErrorDoesNotRespondToSelector</td>
<td>找不到SEL的实现</td>
</tr>
<tr>
<td>AspectErrorSelectorDeallocPosition</td>
<td>hook到delloc方法的时机错误（只允许before情况）</td>
</tr>
<tr>
<td>AspectErrorSelectorAlreadyHookedInClassHierarchy</td>
<td>类继承体系中已经hook过该方法</td>
</tr>
<tr>
<td>AspectErrorFailedToAllocateClassPair</td>
<td>创建类失败（实例对象hook时可能发生）</td>
</tr>
<tr>
<td>AspectErrorMissingBlockSignature</td>
<td>block的签名错误（编译期签名无效，无法读取使用）</td>
</tr>
<tr>
<td>AspectErrorIncompatibleBlockSignature</td>
<td>block签名与原始方法签名不匹配</td>
</tr>
<tr>
<td>AspectErrorRemoveObjectAlreadyDeallocated</td>
<td>重复移除hook对象</td>
</tr>
</tbody>
</table>
<hr>
<blockquote>
<p>Aspect.m</p>
</blockquote>
<h5 id="AspectBlockFlags"><a href="#AspectBlockFlags" class="headerlink" title="AspectBlockFlags"></a>AspectBlockFlags</h5><p>切片block结构体中的位标识</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>AspectBlockFlagsHasCopyDisposeHelpers</td>
<td>标识copy函数位（第25位）</td>
</tr>
<tr>
<td>AspectBlockFlagsHasSignature</td>
<td>标识签名位（第30位）</td>
</tr>
</tbody>
</table>
<h5 id="AspectBlockRef"><a href="#AspectBlockRef" class="headerlink" title="AspectBlockRef"></a>AspectBlockRef</h5><p>_AspectBlock结构体指针，结构与block结构体相似。</p>
<h5 id="AspectInfo"><a href="#AspectInfo" class="headerlink" title="AspectInfo"></a>AspectInfo</h5><p><strong>主要用于包装NSInvocation对象</strong>。</p>
<p>遵循了<em>AspectInfo</em>协议，作为内部实现（外部只公开为协议，隐藏真正的类）。</p>
<p>将协议方法实现为三个只读属性，使用指定方法进行初始化：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithInstance:(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>)instance invocation:(<span class="built_in">NSInvocation</span> *)invocation;</div></pre></td></tr></table></figure>
<h5 id="AspectIdentifier"><a href="#AspectIdentifier" class="headerlink" title="AspectIdentifier"></a>AspectIdentifier</h5><p><strong>保存切片的相关信息（如receiver、selector、block和error信息）</strong>。作为数据模型类。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 初始化方法，传入配置信息</span></div><div class="line">+ (<span class="keyword">instancetype</span>)identifierWithSelector:(SEL)selector object:(<span class="keyword">id</span>)object options:(AspectOptions)options block:(<span class="keyword">id</span>)block error:(<span class="built_in">NSError</span> **)error;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用AspectInfo对象（NSInvocation封装类）执行方法，执行block任务</span></div><div class="line">- (<span class="built_in">BOOL</span>)invokeWithInfo:(<span class="keyword">id</span>&lt;AspectInfo&gt;)info;</div></pre></td></tr></table></figure>
<h5 id="AspectsContainer"><a href="#AspectsContainer" class="headerlink" title="AspectsContainer"></a>AspectsContainer</h5><p><strong>作为AspectIdentifier的容器，负责管理内部的AspectIdentifier对象</strong>。提供添加、删除、检查等功能。<br>根据options将AspectIdentifier对象分别存储在不同的类别数组中。</p>
<p>在Aspects中，根据调用者（实例对象或类对象）实现了两个container。</p>
<h5 id="AspectTracker"><a href="#AspectTracker" class="headerlink" title="AspectTracker"></a>AspectTracker</h5><p>切片追踪者，<strong>保存着追踪的相关信息</strong>，方便查询。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>trackedClass</td>
<td>追踪的类</td>
</tr>
<tr>
<td>selectorNames</td>
<td>集合，保存着追踪的选择器名</td>
</tr>
<tr>
<td>parentEntry</td>
<td>自身实例的指针，根据类继承体系指向子类对象</td>
</tr>
</tbody>
</table>
<h5 id="NSInvocation-Aspects"><a href="#NSInvocation-Aspects" class="headerlink" title="NSInvocation + Aspects"></a>NSInvocation + Aspects</h5><p>NSInvocation的分类，提供了方法：直接返回切片的所有参数。</p>
<hr>
<h4 id="2-实现源代码学习"><a href="#2-实现源代码学习" class="headerlink" title="2. 实现源代码学习"></a>2. 实现源代码学习</h4><h5 id="Aspects是线程安全的"><a href="#Aspects是线程安全的" class="headerlink" title="Aspects是线程安全的"></a><u>Aspects是线程安全的</u></h5><p>可以在三个方面验证此结论：</p>
<h6 id="1-使用自旋锁进行整体hook"><a href="#1-使用自旋锁进行整体hook" class="headerlink" title="1. 使用自旋锁进行整体hook"></a>1. 使用自旋锁进行整体hook</h6><p>我们知道，在公共API中，实现都是通过调用c函数<em>aspect_add</em>来完成的，而其中的执行环境是通过锁机制来保证线程安全的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_performLocked(dispatch_block_t block) &#123;</div><div class="line">    <span class="comment">// 创建自旋锁</span></div><div class="line">    <span class="keyword">static</span> OSSpinLock aspect_lock = OS_SPINLOCK_INIT;</div><div class="line">    OSSpinLockLock(&amp;aspect_lock);</div><div class="line">    block();</div><div class="line">    OSSpinLockUnlock(&amp;aspect_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用自旋锁可以保证同时只执行一个运算任务，且其他运算单元不会因锁被他人保持而进入睡眠状态。自旋锁适合运算量不大的任务。在这种情况下，其效率要明显高于同步锁 <em>@synchronized</em>。</p>
<h6 id="2-AspectContainer中使用原子性数组"><a href="#2-AspectContainer中使用原子性数组" class="headerlink" title="2. AspectContainer中使用原子性数组"></a>2. AspectContainer中使用原子性数组</h6><p>在类AspectContainer中，保存AspectIdentifier实例的数组属性（<em>beforeAspects</em>、<em>insteadAspects</em>、<em>afterAspects</em>）的特性为atomic，保证在多线程环境下，访问该容器是安全的。</p>
<h6 id="3-使用dispatch-once来保证共享数据只有一份"><a href="#3-使用dispatch-once来保证共享数据只有一份" class="headerlink" title="3. 使用dispatch_once来保证共享数据只有一份"></a>3. 使用<em>dispatch_once</em>来保证共享数据只有一份</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 获取修改的类的集合（线程安全） */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _aspect_modifySwizzledClasses(<span class="keyword">void</span> (^block)(<span class="built_in">NSMutableSet</span> *swizzledClasses)) &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSMutableSet</span> *swizzledClasses;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</div><div class="line">        swizzledClasses = [<span class="built_in">NSMutableSet</span> new];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">@synchronized</span>(swizzledClasses) &#123;</div><div class="line">        block(swizzledClasses);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用<em>dispatch_once</em>保证集合创建为线程安全且只有一份。同时，执行block时也通过同步锁保证线程安全。</p>
<h5 id="Aspects的hook方法不可高频次调用"><a href="#Aspects的hook方法不可高频次调用" class="headerlink" title="Aspects的hook方法不可高频次调用"></a><u>Aspects的hook方法不可高频次调用</u></h5><p>作者说，hook的方法一般只可以是view或ViewController等方法，调用频次不要超过每秒1000次。<strong>这是由于Aspects的hook方法调用实际是在方法转发流程中进行的</strong>。</p>
<p>Aspects中所有的真正方法调用都是通过NSInvocation对象进行的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)invoke;</div><div class="line">- (<span class="keyword">void</span>)invokeWithTarget:(<span class="keyword">id</span>)target;</div></pre></td></tr></table></figure>
<p>我们知道，完整的消息转发流程是在方法调用的最后一步才进行，苹果明确说明这是比较耗费性能的（需要通过获取方法签名NSMethodSignature对象，封装生成NSInvocation对象，然后在forwardInvocation:方法中执行invoke方法）。故作者添加了此说明。</p>
<h5 id="Aspects对实例hook方法和类hook方法使用不同实现方案"><a href="#Aspects对实例hook方法和类hook方法使用不同实现方案" class="headerlink" title="Aspects对实例hook方法和类hook方法使用不同实现方案"></a><u>Aspects对实例hook方法和类hook方法使用不同实现方案</u></h5><blockquote>
<p>对于类的实例来说，使用Aspects对某方法进行hook只是对本实例有效；<br>而对于类对象来说，对某方法进行hook，即对本类的所有实例都有效。</p>
</blockquote>
<p>我们在<em>aspect_hookClass</em>的实现中，可以一探究竟</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Class aspect_hookClass(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</div><div class="line">	Class statedClass = <span class="keyword">self</span>.class; <span class="comment">// 得到self所属的类（实例返回class，类对象返回自身）</span></div><div class="line">	Class baseClass = object_getClass(<span class="keyword">self</span>); <span class="comment">// 获取self的class（获取isa：实例返回class对象，类对象返回metaClass）</span></div><div class="line">	<span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(baseClass);</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们看一下，对于<em>class</em>方法和<em>objc_getClass</em>函数的区别：</p>
<blockquote>
<p><u><em>class方法</em></u>： 对于类，返回自身；对于实例对象，返回所属Class<br><u><em>objc_getClass函数</em></u>： 其实现都是返回调用者的isa。也就是说，对于实例对象，得到的是所属Class；对于类，得到的是metaClass。</p>
</blockquote>
<h6 id="1-类实例hook的实现"><a href="#1-类实例hook的实现" class="headerlink" title="1. 类实例hook的实现"></a>1. 类实例hook的实现</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Class aspect_hookClass(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">// Already subclassed</span></div><div class="line">	<span class="keyword">if</span> ([className hasSuffix:AspectsSubclassSuffix]) &#123;</div><div class="line">		<span class="keyword">return</span> baseClass; <span class="comment">// 包含后缀，即hook过，直接返回class</span></div><div class="line">	&#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// self是类的实例对象，正常情况</span></div><div class="line">    <span class="comment">// 动态创建一个类（添加后缀作为类名）</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;</div><div class="line">    </div><div class="line">    <span class="comment">// 懒加载方式创建</span></div><div class="line">	Class subclass = objc_getClass(subclassName);</div><div class="line">	<span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="comment">// 新类作为原类的子类</span></div><div class="line">		subclass = objc_allocateClassPair(baseClass, subclassName, <span class="number">0</span>);</div><div class="line">		<span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="built_in">NSString</span> *errrorDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"objc_allocateClassPair failed to allocate class %s."</span>, subclassName];</div><div class="line">            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">		aspect_swizzleForwardInvocation(subclass); <span class="comment">// 给这个新类交换forwardInvocation方法</span></div><div class="line">		aspect_hookedGetClass(subclass, statedClass); <span class="comment">// 新类的class方法，返回的是原class（瞒天过海，自己的类名还是原来的类）</span></div><div class="line">		aspect_hookedGetClass(object_getClass(subclass), statedClass); <span class="comment">// metaClass的class也指向原来的类</span></div><div class="line">        <span class="comment">// 注册此类</span></div><div class="line">		objc_registerClassPair(subclass);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将self实例设置为此动态子类的实例</span></div><div class="line">	object_setClass(<span class="keyword">self</span>, subclass);</div><div class="line">	<span class="keyword">return</span> subclass;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里我们可以看到，对于实例hook，Aspects使用动态类的方式进行实现：<strong>创建一个继承于原类的子类，对该子类的NSInvocation进行hook，然后通过<em>object_setClass</em>将调用者的类指定为新子类</strong>。</p>
<p>下面我们依次查看方法实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> AspectsForwardInvocationSelectorName = <span class="string">@"__aspects_forwardInvocation:"</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_swizzleForwardInvocation(Class klass) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(klass);</div><div class="line">    <span class="comment">// 替换原始类的forwardInvocation方法IMP（kclass没实现则自动添加），返回值是原IMP</span></div><div class="line">    IMP originalImplementation = class_replaceMethod(klass, <span class="keyword">@selector</span>(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, <span class="string">"v@:@"</span>);</div><div class="line">    <span class="keyword">if</span> (originalImplementation) &#123;</div><div class="line">        <span class="comment">// 存在原IMP（即klass自己实现了forwardInvocation方法），则新SEL(hook版本的forwardInvocation)的IMP为原始IMP（即存储了原IMP）</span></div><div class="line">        class_addMethod(klass, <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName), originalImplementation, <span class="string">"v@:@"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 完成了klass</span></div><div class="line">    AspectLog(<span class="string">@"Aspects: %@ is now aspect aware."</span>, <span class="built_in">NSStringFromClass</span>(klass));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<em>class_replaceMethod</em>，替换了klass的<em>fowardInvocation:</em> 方法实现（替换IMP为 <em><strong>ASPECTS_ARE_BEING_CALLED</strong></em>），klass没有实现此方法，则直接将此方法及实现添加到类中。<br>当klass实现了原方法，则Aspects将原IMP保存到klass的<em>AspectsForwardInvocationSelectorName</em>方法中，相当于完成了<em>forwardInvocation:</em> 的方法交换。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_hookedGetClass(Class <span class="keyword">class</span>, Class statedClass) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">class</span>);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(statedClass);</div><div class="line">	Method method = class_getInstanceMethod(<span class="keyword">class</span>, <span class="keyword">@selector</span>(<span class="keyword">class</span>));</div><div class="line">	IMP newIMP = imp_implementationWithBlock(^(<span class="keyword">id</span> <span class="keyword">self</span>) &#123;</div><div class="line">		<span class="keyword">return</span> statedClass;</div><div class="line">	&#125;);</div><div class="line">    <span class="comment">// 将class的class实例方法的IMP替换为IMP的block实现（返回的是statedClass）</span></div><div class="line">	class_replaceMethod(<span class="keyword">class</span>, <span class="keyword">@selector</span>(<span class="keyword">class</span>), newIMP, method_getTypeEncoding(method));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理，此方法是将Class的<em>class</em>实例方法IMP进行替换，改为了statedClass。在调用时，即将新子类的Class及MetaClass均指向原类。这样原实例则根本不知道自己的实例已经被“偷梁换柱”了。</p>
<h6 id="2-类对象hook的实现"><a href="#2-类对象hook的实现" class="headerlink" title="2. 类对象hook的实现"></a>2. 类对象hook的实现</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Class aspect_hookClass(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (class_isMetaClass(baseClass)) &#123;</div><div class="line">        <span class="comment">// 是metaClass，即self是class。需要swizzle这个class对象（Class）</span></div><div class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace((Class)<span class="keyword">self</span>);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (statedClass != baseClass) &#123;</div><div class="line">        <span class="comment">// statedClass与baseClass不同，即self也是class，若self是一个KVO的类，也需要swizzle这个class对象（metaClass：baseClass即KVO之前的原始类，防止KVO使用完毕后，Class释放导致hook失效）</span></div><div class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace(baseClass);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>class_isMetaClass</em>判断当前类是否为metaClass，通过这种情况，可以判定调用Aspects的hook方法的是类对象。所以调用者的目的是将所有的类实例的指定方法都进行hook。故Aspects直接对该类进行操作。</p>
<blockquote>
<p><strong>注意</strong>：<br>由于KVO也是通过创建动态类的方式实现（创建子类后修改isa指向），故hook的应当是KVO之前的原始类。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Class aspect_swizzleClassInPlace(Class klass) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(klass);</div><div class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(klass);</div><div class="line"></div><div class="line">    _aspect_modifySwizzledClasses(^(<span class="built_in">NSMutableSet</span> *swizzledClasses) &#123;</div><div class="line">        <span class="comment">// 在线程安全的情况下，将class加入到修改的类列表中</span></div><div class="line">        <span class="keyword">if</span> (![swizzledClasses containsObject:className]) &#123;</div><div class="line">            <span class="comment">// 交换forwardInvocation方法</span></div><div class="line">            aspect_swizzleForwardInvocation(klass);</div><div class="line">            [swizzledClasses addObject:className];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> klass;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里直接对klass的<em>forwardInvocation:</em> 方法进行了替换，只不过需要在线程安全的前提下进行，且swizzledClasses是全局共享的。</p>
<h5 id="Aspects对指定selector的替换过程"><a href="#Aspects对指定selector的替换过程" class="headerlink" title="Aspects对指定selector的替换过程"></a><u>Aspects对指定selector的替换过程</u></h5><p>对于selector的处理过程，实例对象和类对象的处理方法是一致的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_prepareClassAndHookSelector(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</div><div class="line">    Class klass = aspect_hookClass(<span class="keyword">self</span>, error); <span class="comment">// 已经hook过forwardInvocation方法的类</span></div><div class="line">    </div><div class="line">    <span class="comment">// 准备检查hook对应的SEL</span></div><div class="line">    Method targetMethod = class_getInstanceMethod(klass, selector); <span class="comment">// 取出待hook的method</span></div><div class="line">    IMP targetMethodIMP = method_getImplementation(targetMethod);</div><div class="line">    <span class="comment">// 查看SEL的IMP是否是已替换的</span></div><div class="line">    <span class="keyword">if</span> (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;</div><div class="line">        <span class="comment">// 创建Hook版本的SEL名称及类型编码</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *typeEncoding = method_getTypeEncoding(targetMethod);</div><div class="line">        SEL aliasSelector = aspect_aliasForSelector(selector);</div><div class="line">        <span class="keyword">if</span> (![klass instancesRespondToSelector:aliasSelector]) &#123;</div><div class="line">            <span class="comment">// 类没有实现此hook的方法，则添加上（使用原始IMP）</span></div><div class="line">            __unused <span class="built_in">BOOL</span> addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);</div><div class="line">            <span class="built_in">NSCAssert</span>(addedAlias, <span class="string">@"Original implementation for %@ is already copied to %@ on %@"</span>, <span class="built_in">NSStringFromSelector</span>(selector), <span class="built_in">NSStringFromSelector</span>(aliasSelector), klass);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 给原SEL的实现修改为objc_msgForward函数</span></div><div class="line">        <span class="comment">// We use forwardInvocation to hook in.</span></div><div class="line">        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(<span class="keyword">self</span>, selector), typeEncoding);</div><div class="line">        AspectLog(<span class="string">@"Aspects: Installed hook for -[%@ %@]."</span>, klass, <span class="built_in">NSStringFromSelector</span>(selector));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于原始方法，Aspects将其实现IMP保存至aliasSelector中，而原始方法则直接指向 <em>_objc_msgForward</em>函数。</p>
<blockquote>
<p><em>_objc_msgForward</em> 是方法调用过程中的一步，在objc_msgSend流程中，当方法未找到IMP时，且未能动态添加方法IMP，<em>_objc_msgForward</em>则开始执行。也就是说 <em>_objc_msgForward</em>是消息转发的起点。</p>
</blockquote>
<p>交换成功后，调用者执行原方法时，则会直接进入消息转发阶段。</p>
<h5 id="Aspects对待hook的selector进行检测，符合要求才允许进行"><a href="#Aspects对待hook的selector进行检测，符合要求才允许进行" class="headerlink" title="Aspects对待hook的selector进行检测，符合要求才允许进行"></a><u>Aspects对待hook的selector进行检测，符合要求才允许进行</u></h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> aspect_isSelectorAllowedAndTrack(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSSet</span> *disallowedSelectorList;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</div><div class="line">        disallowedSelectorList = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"retain"</span>, <span class="string">@"release"</span>, <span class="string">@"autorelease"</span>, <span class="string">@"forwardInvocation:"</span>, <span class="literal">nil</span>];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// 黑名单不能被hook</span></div><div class="line">    <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(selector);</div><div class="line">    <span class="keyword">if</span> ([disallowedSelectorList containsObject:selectorName]) &#123;</div><div class="line">        <span class="built_in">NSString</span> *errorDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Selector %@ is blacklisted."</span>, selectorName];</div><div class="line">        AspectError(AspectErrorSelectorBlacklisted, errorDescription);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// dealloc 只能在before时hook</span></div><div class="line">    AspectOptions position = options&amp;AspectPositionFilter;</div><div class="line">    <span class="keyword">if</span> ([selectorName isEqualToString:<span class="string">@"dealloc"</span>] &amp;&amp; position != AspectPositionBefore) &#123;</div><div class="line">        <span class="built_in">NSString</span> *errorDesc = <span class="string">@"AspectPositionBefore is the only valid position when hooking dealloc."</span>;</div><div class="line">        AspectError(AspectErrorSelectorDeallocPosition, errorDesc);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 没有原始实现也不行</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> respondsToSelector:selector] &amp;&amp; ![<span class="keyword">self</span>.class instancesRespondToSelector:selector]) &#123;</div><div class="line">        <span class="built_in">NSString</span> *errorDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Unable to find selector -[%@ %@]."</span>, <span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>.class), selectorName];</div><div class="line">        AspectError(AspectErrorDoesNotRespondToSelector, errorDesc);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 类对象处理</span></div><div class="line">    <span class="keyword">if</span> (class_isMetaClass(object_getClass(<span class="keyword">self</span>))) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 实例对象，直接允许</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于实例对象，只要待hook的selector符合上述要求，即可准备进行hook。<br>而对于类而言，由于类存在继承体系，需要对hook的唯一性进行检测：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> aspect_isSelectorAllowedAndTrack(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// 类对象</span></div><div class="line">    <span class="keyword">if</span> (class_isMetaClass(object_getClass(<span class="keyword">self</span>))) &#123;</div><div class="line">        Class klass = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">        <span class="comment">// 获取交换class的字典</span></div><div class="line">        <span class="built_in">NSMutableDictionary</span> *swizzledClassesDict = aspect_getSwizzledClassesDict();</div><div class="line">        Class currentClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="comment">// 获取当前类的追踪者对象</span></div><div class="line">            AspectTracker *tracker = swizzledClassesDict[currentClass];</div><div class="line">            <span class="comment">// 查看追踪者的SEL列表中是否存在当前SEL</span></div><div class="line">            <span class="keyword">if</span> ([tracker.selectorNames containsObject:selectorName]) &#123;</div><div class="line">                </div><div class="line">                <span class="comment">// 已经追踪过当前SEL，查看追踪者的子类追踪者中，是否追踪过当前SEL</span></div><div class="line">                <span class="comment">// Find the topmost class for the log.</span></div><div class="line">                <span class="keyword">if</span> (tracker.parentEntry) &#123;</div><div class="line">                    <span class="comment">// 追踪过当前SEL，报错（即父类要hook的SEL在子类中已经hook过了）</span></div><div class="line">                    AspectTracker *topmostEntry = tracker.parentEntry;</div><div class="line">                    <span class="keyword">while</span> (topmostEntry.parentEntry) &#123;</div><div class="line">                        topmostEntry = topmostEntry.parentEntry;</div><div class="line">                    &#125;</div><div class="line">                    <span class="built_in">NSString</span> *errorDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Error: %@ already hooked in %@. A method can only be hooked once per class hierarchy."</span>, selectorName, <span class="built_in">NSStringFromClass</span>(topmostEntry.trackedClass)];</div><div class="line">                    AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription);</div><div class="line">                    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (klass == currentClass) &#123;</div><div class="line">                    <span class="comment">// 只是自己的类追踪过，才可以</span></div><div class="line">                    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">while</span> ((currentClass = class_getSuperclass(currentClass)));</div><div class="line"></div><div class="line">        <span class="comment">// 没有追踪过该类，则只设置从当前类开始hook</span></div><div class="line">        currentClass = klass;</div><div class="line">        AspectTracker *parentTracker = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="comment">// 只要子类hook该SEL，就将所有的父类也标识上（即从根类到当前类这个继承链都标记了hook当前SEL）</span></div><div class="line">            <span class="comment">// 懒加载追踪者对象，将SEL加入到追踪SEL列表中进行标记</span></div><div class="line">            AspectTracker *tracker = swizzledClassesDict[currentClass];</div><div class="line">            <span class="keyword">if</span> (!tracker) &#123;</div><div class="line">                tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass parent:parentTracker];</div><div class="line">                swizzledClassesDict[(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)currentClass] = tracker;</div><div class="line">            &#125;</div><div class="line">            [tracker.selectorNames addObject:selectorName];</div><div class="line">            parentTracker = tracker;</div><div class="line">        &#125;<span class="keyword">while</span> ((currentClass = class_getSuperclass(currentClass)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于类对象来说，当类的指定selector准备hook之前，先要检测其继承体系中是否已经hook过此selector。<br>其方法是：<br>通过AspectTracker对象，对其内部的selectorNames数组进行检测，依照parentEntry向下依次查找（parentEntry存储的是子类对象），<br>如果存在parentEntry的selectorNames已经包含selector，且该parentEntry类不是当前类，则证明selector已经在继承体系中（确切地说是子类中）已经hook过，不可以重复hook。</p>
<h5 id="AspectIdentifier，切面信息的生成"><a href="#AspectIdentifier，切面信息的生成" class="headerlink" title="AspectIdentifier，切面信息的生成"></a><u>AspectIdentifier，切面信息的生成</u></h5><p>我们回到最初，在aspect_add方法中可以看到，切面信息AspectIdentifier对象，是在开始hook操作之前，便生成添加到AspectsContainer容器中的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">id</span> aspect_add(<span class="keyword">id</span> <span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="keyword">id</span> block, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(block);</div><div class="line"></div><div class="line">    __block AspectIdentifier *identifier = <span class="literal">nil</span>;</div><div class="line">    <span class="comment">// 自旋锁的方式进行（安全）</span></div><div class="line">    aspect_performLocked(^&#123;</div><div class="line">        <span class="comment">// SEL是否允许hook</span></div><div class="line">        <span class="keyword">if</span> (aspect_isSelectorAllowedAndTrack(<span class="keyword">self</span>, selector, options, error)) &#123;</div><div class="line">            <span class="comment">// 获取容器对象</span></div><div class="line">            AspectsContainer *aspectContainer = aspect_getContainerForObject(<span class="keyword">self</span>, selector);</div><div class="line">            <span class="comment">// 生成得到AspectIdentifier对象</span></div><div class="line">            identifier = [AspectIdentifier identifierWithSelector:selector object:<span class="keyword">self</span> options:options block:block error:error];</div><div class="line">            <span class="keyword">if</span> (identifier) &#123;</div><div class="line">                <span class="comment">// 存在，即加入到容器中</span></div><div class="line">                [aspectContainer addAspect:identifier withOptions:options];</div><div class="line"></div><div class="line">                <span class="comment">// 将self所属的class配置为，运行hook的版本</span></div><div class="line">                <span class="comment">// （实例为创建动态类，交换消息转发实现；类为直接修改该lmetaClass，交换消息转发实现）</span></div><div class="line">                <span class="comment">// Modify the class to allow message interception.</span></div><div class="line">                aspect_prepareClassAndHookSelector(<span class="keyword">self</span>, selector, error);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> identifier;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，我们看一下如何得到保存AspectIdentifier对象的容器对象AspectContainer：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取SEL对应self所在的容器对象（内部加入的是带有前缀的SEL）</span></div><div class="line"><span class="keyword">static</span> AspectsContainer *aspect_getContainerForObject(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</div><div class="line">    <span class="comment">// 获取别名SEL（用于hook原SEL）</span></div><div class="line">    SEL aliasSelector = aspect_aliasForSelector(selector);</div><div class="line">    <span class="comment">// 获取self存储的切片容器对象【注意：由于self可以为实例对象或类对象，故NSObject中包含了两种AspectContainer属性：一个保存hook的实例方法identifier，一个保存hook的类方法identifier】</span></div><div class="line">    AspectsContainer *aspectContainer = objc_getAssociatedObject(<span class="keyword">self</span>, aliasSelector);</div><div class="line">    <span class="keyword">if</span> (!aspectContainer) &#123;</div><div class="line">        aspectContainer = [AspectsContainer new];</div><div class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, aliasSelector, aspectContainer, OBJC_ASSOCIATION_RETAIN);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> aspectContainer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码可以看出，AspectsContainer对象是通过关联对象的方式存储到<em>NSObject+Aspects</em>分类中的，其属性名称是使用hook版本的selector名称动态确定的。即每当我们hook一个selector后，NSObject类中即增加了一个名为“aspects_xxx”的属性，其类型为AspectsContainer。 对于加入其内部的AspectIdentifier对象，则根据options保存到不同的内部数组中。</p>
<p>对于AspectIdentifier的生成过程，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 根据信息生成切面识别对象 */</span></div><div class="line">+ (<span class="keyword">instancetype</span>)identifierWithSelector:(SEL)selector object:(<span class="keyword">id</span>)object options:(AspectOptions)options block:(<span class="keyword">id</span>)block error:(<span class="built_in">NSError</span> **)error &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(block);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</div><div class="line">    <span class="comment">// 获取block的签名对象</span></div><div class="line">    <span class="built_in">NSMethodSignature</span> *blockSignature = aspect_blockMethodSignature(block, error);</div><div class="line">    <span class="comment">// 检查得到的签名对象是否符合要求</span></div><div class="line">    <span class="keyword">if</span> (!aspect_isCompatibleBlockSignature(blockSignature, object, selector, error)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 使用block签名的对象信息创建AspectIdentifier对象</span></div><div class="line">    AspectIdentifier *identifier = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> (blockSignature) &#123;</div><div class="line">        identifier = [AspectIdentifier new];</div><div class="line">        identifier.selector = selector;</div><div class="line">        identifier.block = block;</div><div class="line">        identifier.blockSignature = blockSignature;</div><div class="line">        identifier.options = options;</div><div class="line">        identifier.object = object; <span class="comment">// weak</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> identifier;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即只有当block对象包含完整的签名时，才可以生成AspectIdentifier对象。<br>结合<em>AspectBlockRef</em>的结构数据，其生成过程如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Block内部定义的flag值.</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="keyword">int</span>, AspectBlockFlags) &#123;</div><div class="line">	AspectBlockFlagsHasCopyDisposeHelpers = (<span class="number">1</span> &lt;&lt; <span class="number">25</span>),</div><div class="line">	AspectBlockFlagsHasSignature          = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// AspectBlockRef数据结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _AspectBlock &#123;</div><div class="line">	__unused Class isa;</div><div class="line">	AspectBlockFlags flags;</div><div class="line">	__unused <span class="keyword">int</span> reserved;</div><div class="line">	<span class="keyword">void</span> (__unused *invoke)(<span class="keyword">struct</span> _AspectBlock *block, ...);</div><div class="line">	<span class="keyword">struct</span> &#123;</div><div class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</div><div class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</div><div class="line">		<span class="comment">// requires AspectBlockFlagsHasCopyDisposeHelpers</span></div><div class="line">		<span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src);</div><div class="line">		<span class="keyword">void</span> (*dispose)(<span class="keyword">const</span> <span class="keyword">void</span> *);</div><div class="line">		<span class="comment">// requires AspectBlockFlagsHasSignature</span></div><div class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *signature;</div><div class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *layout;</div><div class="line">	&#125; *descriptor;</div><div class="line">	<span class="comment">// imported variables</span></div><div class="line">&#125; *AspectBlockRef;</div><div class="line"></div><div class="line"><span class="comment">// 获取方法签名对象</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSMethodSignature</span> *aspect_blockMethodSignature(<span class="keyword">id</span> block, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    <span class="comment">// 转换为AspectBlockRef类型</span></div><div class="line">    AspectBlockRef layout = (__bridge <span class="keyword">void</span> *)block;</div><div class="line">    </div><div class="line">    <span class="comment">// flags的值不是AspectBlockFlagsHasSignature，直接报错</span></div><div class="line">	<span class="keyword">if</span> (!(layout-&gt;flags &amp; AspectBlockFlagsHasSignature)) &#123;</div><div class="line">        <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"The block %@ doesn't contain a type signature."</span>, block];</div><div class="line">        AspectError(AspectErrorMissingBlockSignature, description);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 在descriptor结构数据中</span></div><div class="line">	<span class="keyword">void</span> *desc = layout-&gt;descriptor;</div><div class="line">    </div><div class="line">    <span class="comment">// 跳过reserved和size</span></div><div class="line">	desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>);</div><div class="line">    <span class="comment">// 存在copy和dispose指针，跳过</span></div><div class="line">	<span class="keyword">if</span> (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) &#123;</div><div class="line">		desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 此时desc直接指向signature，没有值则认为没有签名</span></div><div class="line">	<span class="keyword">if</span> (!desc) &#123;</div><div class="line">        <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"The block %@ doesn't has a type signature."</span>, block];</div><div class="line">        AspectError(AspectErrorMissingBlockSignature, description);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 取出signature的值，转换生成NSMethodSignature对象</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *signature = (*(<span class="keyword">const</span> <span class="keyword">char</span> **)desc);</div><div class="line">	<span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:signature];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检查生成的block的签名对象是否正确的方法，就是与原始selector的签名对象进行直接比较（比较每个参数是否相同）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> aspect_isCompatibleBlockSignature(<span class="built_in">NSMethodSignature</span> *blockSignature, <span class="keyword">id</span> object, SEL selector, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(blockSignature);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(object);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</div><div class="line"></div><div class="line">    <span class="built_in">BOOL</span> signaturesMatch = <span class="literal">YES</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 通过selector和object得到原始的方法签名</span></div><div class="line">    <span class="built_in">NSMethodSignature</span> *methodSignature = [[object <span class="keyword">class</span>] instanceMethodSignatureForSelector:selector];</div><div class="line">    </div><div class="line">    <span class="comment">// 与生成block签名比较参数个数</span></div><div class="line">    <span class="keyword">if</span> (blockSignature.numberOfArguments &gt; methodSignature.numberOfArguments) &#123;</div><div class="line">        <span class="comment">// block签名参数更多，错误</span></div><div class="line">        signaturesMatch = <span class="literal">NO</span>;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// block签名参数大于1时，查看第二个参数是否为对象（实质是AspectInfo实例）</span></div><div class="line">        <span class="keyword">if</span> (blockSignature.numberOfArguments &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *blockType = [blockSignature getArgumentTypeAtIndex:<span class="number">1</span>];</div><div class="line">            <span class="keyword">if</span> (blockType[<span class="number">0</span>] != <span class="string">'@'</span>) &#123;</div><div class="line">                <span class="comment">// 不是，错误</span></div><div class="line">                signaturesMatch = <span class="literal">NO</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 由于标准方法签名的前两个参数为id和SEL，blockSignature对象的前两个参数为self和AspectInfo对象（执行时候是，现在只是id），故从第三个开始比较</span></div><div class="line">        <span class="keyword">if</span> (signaturesMatch) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> idx = <span class="number">2</span>; idx &lt; blockSignature.numberOfArguments; idx++) &#123;</div><div class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *methodType = [methodSignature getArgumentTypeAtIndex:idx];</div><div class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *blockType = [blockSignature getArgumentTypeAtIndex:idx];</div><div class="line">                <span class="comment">// Only compare parameter, not the optional type data.</span></div><div class="line">                <span class="keyword">if</span> (!methodType || !blockType || methodType[<span class="number">0</span>] != blockType[<span class="number">0</span>]) &#123;</div><div class="line">                    signaturesMatch = <span class="literal">NO</span>; <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!signaturesMatch) &#123;</div><div class="line">        <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Blog signature %@ doesn't match %@."</span>, blockSignature, methodSignature];</div><div class="line">        AspectError(AspectErrorIncompatibleBlockSignature, description);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Aspects中hook完成后，方法的执行过程"><a href="#Aspects中hook完成后，方法的执行过程" class="headerlink" title="Aspects中hook完成后，方法的执行过程"></a><u>Aspects中hook完成后，方法的执行过程</u></h5><p>方法的执行过程，即hook版本的<em>forwardInvocation:</em> 方法的执行过程，也就是 <em><strong>ASPECTS_ARE_BEING_CALLED</strong></em> 的实现过程：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** swizzled的forwardInvocation:方法 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ASPECTS_ARE_BEING_CALLED__(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSInvocation</span> *invocation) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(invocation);</div><div class="line">    SEL originalSelector = invocation.selector;</div><div class="line">	SEL aliasSelector = aspect_aliasForSelector(invocation.selector);</div><div class="line">    invocation.selector = aliasSelector; <span class="comment">// 将invocation的selector替换为hook的版本</span></div><div class="line">    AspectsContainer *objectContainer = objc_getAssociatedObject(<span class="keyword">self</span>, aliasSelector); <span class="comment">// 实例的切片信息容器</span></div><div class="line">    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(<span class="keyword">self</span>), aliasSelector); <span class="comment">// 类的切片信息容器</span></div><div class="line">    AspectInfo *info = [[AspectInfo alloc] initWithInstance:<span class="keyword">self</span> invocation:invocation]; <span class="comment">// 将invocation封装为AspectInfo对象</span></div><div class="line">    <span class="built_in">NSArray</span> *aspectsToRemove = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Before hooks.</span></div><div class="line">    <span class="comment">// 依次使用类切片信息容器内的切片信息对象（AspectIdentifier）执行方法，传入info对象</span></div><div class="line">    aspect_invoke(classContainer.beforeAspects, info);</div><div class="line">    <span class="comment">// 依次使用实例切片信息容器内的切片信息对象（AspectIdentifier）执行方法，传入info对象</span></div><div class="line">    aspect_invoke(objectContainer.beforeAspects, info);</div><div class="line"></div><div class="line">    <span class="comment">// Instead hooks.</span></div><div class="line">    <span class="built_in">BOOL</span> respondsToAlias = <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">if</span> (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123;</div><div class="line">        <span class="comment">// 使用替换的AspectIdentifier执行</span></div><div class="line">        aspect_invoke(classContainer.insteadAspects, info);</div><div class="line">        aspect_invoke(objectContainer.insteadAspects, info);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 原始调用者的类</span></div><div class="line">        Class klass = object_getClass(invocation.target);</div><div class="line">        <span class="comment">// 找到可以执行hook版本的SEL的类，然后执行</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="keyword">if</span> ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123;</div><div class="line">                [invocation invoke]; <span class="comment">// 直接执行，aliasSelector对应的IMP原始IMP，也就是原始方法执行</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">while</span> (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// After hooks.</span></div><div class="line">    aspect_invoke(classContainer.afterAspects, info);</div><div class="line">    aspect_invoke(objectContainer.afterAspects, info);</div><div class="line"></div><div class="line">    <span class="comment">// If no hooks are installed, call original implementation (usually to throw an exception)</span></div><div class="line">    <span class="comment">// 没有找到类实现了hook的SEL</span></div><div class="line">    <span class="keyword">if</span> (!respondsToAlias) &#123;</div><div class="line">        <span class="comment">// 将invocation恢复为原始SEL</span></div><div class="line">        invocation.selector = originalSelector;</div><div class="line">        <span class="comment">// 获取原始forwardInvocation方法SEL（本来已经交换了）</span></div><div class="line">        SEL originalForwardInvocationSEL = <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName);</div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:originalForwardInvocationSEL]) &#123;</div><div class="line">            <span class="comment">// 原始实例可以响应（实现过forwardInvocation方法），则指向原始的消息转发流程</span></div><div class="line">            ((<span class="keyword">void</span>( *)(<span class="keyword">id</span>, SEL, <span class="built_in">NSInvocation</span> *))objc_msgSend)(<span class="keyword">self</span>, originalForwardInvocationSEL, invocation);</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 不能响应，则直接抛异常</span></div><div class="line">            [<span class="keyword">self</span> doesNotRecognizeSelector:invocation.selector];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 让需要移除的AspectIdentifier对象，依次执行remove方法，清除对应方法的hook状态</span></div><div class="line">    [aspectsToRemove makeObjectsPerformSelector:<span class="keyword">@selector</span>(remove)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个流程主要是：</p>
<ol>
<li>beforeBlock执行（如果有） -&gt; 原始方法执行 -&gt; afterBlock执行（如果有） -&gt; 清除方法的hook状态（如果有）</li>
<li>原始方法实现如果不存在：如果原始类实现了<em>forwardInvocation:</em> 方法，则直接执行，走原始的消息转发流程了；如果没有实现，则直接抛异常（因为Aspects的流程已经走完）。其实整体来看，也是遵循原始类的方法调用过程。</li>
</ol>
<p>这里，需要看一下<em>aspect_invoke</em>函数的执行过程：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义成宏是为了可以得到调用栈的说明</span></div><div class="line"><span class="meta">#define aspect_invoke(aspects, info) \</span></div><div class="line"><span class="keyword">for</span> (AspectIdentifier *aspect <span class="keyword">in</span> aspects) &#123;\</div><div class="line">    [aspect invokeWithInfo:info];\</div><div class="line">    <span class="keyword">if</span> (aspect.options &amp; AspectOptionAutomaticRemoval) &#123; \</div><div class="line">        aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \</div><div class="line">    &#125; \</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此函数的作用是：</p>
<ol>
<li>依次使用AspectIdentifier对象进行block调用，传入AspectInfo信息。</li>
<li>如果执行后需要移除此AspectIdentifier对象（清除hook状态），直接插入到数组中，最后统一清理。</li>
</ol>
<p>最后我们看一下，AspectIdentifier的<em>invokeWithInfo</em>方法是如何执行的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)invokeWithInfo:(<span class="keyword">id</span>&lt;AspectInfo&gt;)info &#123;</div><div class="line">    <span class="comment">// 使用block签名对象生成NSInvocation对象</span></div><div class="line">    <span class="built_in">NSInvocation</span> *blockInvocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:<span class="keyword">self</span>.blockSignature];</div><div class="line">    <span class="comment">// 取出AspectInfo中原始类的invocation</span></div><div class="line">    <span class="built_in">NSInvocation</span> *originalInvocation = info.originalInvocation;</div><div class="line">    </div><div class="line">    <span class="comment">// block签名中的参数个数</span></div><div class="line">    <span class="built_in">NSUInteger</span> numberOfArguments = <span class="keyword">self</span>.blockSignature.numberOfArguments;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123;</div><div class="line">        <span class="comment">// 参数个数不匹配（block中的参数过多）</span></div><div class="line">        AspectLogError(<span class="string">@"Block has too many arguments. Not calling %@"</span>, info);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (numberOfArguments &gt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// block签名的参数个数大于1时，将AspectInfo对象设置在index为1的位置（这样block中的第一个参数即为AspectInfo对象）</span></div><div class="line">        [blockInvocation setArgument:&amp;info atIndex:<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 将原始invocation中的其他参数（除去原始的self和_cmd两个参数外的）copy到block的invocation中</span></div><div class="line">	<span class="keyword">void</span> *argBuf = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> idx = <span class="number">2</span>; idx &lt; numberOfArguments; idx++) &#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];</div><div class="line">		<span class="built_in">NSUInteger</span> argSize;</div><div class="line">		<span class="built_in">NSGetSizeAndAlignment</span>(type, &amp;argSize, <span class="literal">NULL</span>);</div><div class="line">        </div><div class="line">		<span class="keyword">if</span> (!(argBuf = reallocf(argBuf, argSize))) &#123;</div><div class="line">            AspectLogError(<span class="string">@"Failed to allocate memory for block invocation."</span>);</div><div class="line">			<span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">		&#125;</div><div class="line">        </div><div class="line">		[originalInvocation getArgument:argBuf atIndex:idx];</div><div class="line">		[blockInvocation setArgument:argBuf atIndex:idx];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// blockInvocation执行（block执行）</span></div><div class="line">    [blockInvocation invokeWithTarget:<span class="keyword">self</span>.block];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (argBuf != <span class="literal">NULL</span>) &#123;</div><div class="line">        free(argBuf);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Aspects清除方法的hook状态，恢复原始实例-类"><a href="#Aspects清除方法的hook状态，恢复原始实例-类" class="headerlink" title="Aspects清除方法的hook状态，恢复原始实例/类"></a><u>Aspects清除方法的hook状态，恢复原始实例/类</u></h5><p>在外部，调用Aspects的API，hook完成相关方法后，得到的返回值为遵循AspectToken协议的对象。在内部，实际上是AspectIdentifier作为此协议的代理进行实现。故清除hook状态的实现即为AspectIdentifier的remove实现，也就是<em>aspect_remove</em>函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> aspect_remove(AspectIdentifier *aspect, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    <span class="built_in">NSCAssert</span>([aspect isKindOfClass:AspectIdentifier.class], <span class="string">@"Must have correct type."</span>);</div><div class="line"></div><div class="line">    __block <span class="built_in">BOOL</span> success = <span class="literal">NO</span>;</div><div class="line">    aspect_performLocked(^&#123;</div><div class="line">        <span class="keyword">id</span> <span class="keyword">self</span> = aspect.object; <span class="comment">// 强引用，防止释放过程中object被释放</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">            <span class="comment">// 从容器中移除AspectIdentifier对象</span></div><div class="line">            AspectsContainer *aspectContainer = aspect_getContainerForObject(<span class="keyword">self</span>, aspect.selector);</div><div class="line">            success = [aspectContainer removeAspect:aspect];</div><div class="line">            </div><div class="line">            <span class="comment">// 清除调用者的hook状态，恢复selector和forwardInvocation的原始实现</span></div><div class="line">            aspect_cleanupHookedClassAndSelector(<span class="keyword">self</span>, aspect.selector);</div><div class="line">            </div><div class="line">            <span class="comment">// 清理信息</span></div><div class="line">            aspect.object = <span class="literal">nil</span>;</div><div class="line">            aspect.block = <span class="literal">nil</span>;</div><div class="line">            aspect.selector = <span class="literal">NULL</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSString</span> *errrorDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Unable to deregister hook. Object already deallocated: %@"</span>, aspect];</div><div class="line">            AspectError(AspectErrorRemoveObjectAlreadyDeallocated, errrorDesc);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> success;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，从hook状态恢复过程如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_cleanupHookedClassAndSelector(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</div><div class="line"></div><div class="line">	Class klass = object_getClass(<span class="keyword">self</span>); <span class="comment">// 调用者的类（instance-&gt;Class；Class-&gt;MetaClass）</span></div><div class="line">    <span class="built_in">BOOL</span> isMetaClass = class_isMetaClass(klass); <span class="comment">// 判定是否为MetaClass</span></div><div class="line">    <span class="keyword">if</span> (isMetaClass) &#123;</div><div class="line">        <span class="comment">// 即调用者为Class，klass设置为Class自身，以便统一处理，恢复selector（从这里可以看出，Aspects并不支持静态方法的hook，因为都是在Class上进行的事务）</span></div><div class="line">        klass = (Class)<span class="keyword">self</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Method targetMethod = class_getInstanceMethod(klass, selector);</div><div class="line">    IMP targetMethodIMP = method_getImplementation(targetMethod);</div><div class="line">    <span class="keyword">if</span> (aspect_isMsgForwardIMP(targetMethodIMP)) &#123;</div><div class="line">        <span class="comment">// IMP是_objc_msgForward函数，证明hook过，需要恢复</span></div><div class="line">        </div><div class="line">        <span class="comment">// 得到hook版本selector（其对应的IMP为原始IMP）</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *typeEncoding = method_getTypeEncoding(targetMethod);</div><div class="line">        SEL aliasSelector = aspect_aliasForSelector(selector);</div><div class="line">        Method originalMethod = class_getInstanceMethod(klass, aliasSelector);</div><div class="line">        <span class="comment">// 取出原始IMP</span></div><div class="line">        IMP originalIMP = method_getImplementation(originalMethod);</div><div class="line">        <span class="built_in">NSCAssert</span>(originalMethod, <span class="string">@"Original implementation for %@ not found %@ on %@"</span>, <span class="built_in">NSStringFromSelector</span>(selector), <span class="built_in">NSStringFromSelector</span>(aliasSelector), klass);</div><div class="line">        </div><div class="line">        <span class="comment">// 替换回原始IMP</span></div><div class="line">        class_replaceMethod(klass, selector, originalIMP, typeEncoding);</div><div class="line">        AspectLog(<span class="string">@"Aspects: Removed hook for -[%@ %@]."</span>, klass, <span class="built_in">NSStringFromSelector</span>(selector));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 从全局追踪字典中移除本类（只对Class调用者有效）</span></div><div class="line">    aspect_deregisterTrackedSelector(<span class="keyword">self</span>, selector);</div><div class="line"></div><div class="line">    <span class="comment">// 查看AspectIdentifier的容器中是否还有其他对象</span></div><div class="line">    AspectsContainer *container = aspect_getContainerForObject(<span class="keyword">self</span>, selector);</div><div class="line">    <span class="keyword">if</span> (!container.hasAspects) &#123;</div><div class="line">        <span class="comment">// AspectIdentifier容器空了（没有任何hook信息保存）</span></div><div class="line">        </div><div class="line">        <span class="comment">// 清除此动态属性（间接删除了容器对象）</span></div><div class="line">        aspect_destroyContainerForObject(<span class="keyword">self</span>, selector);</div><div class="line"></div><div class="line">        <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(klass);</div><div class="line">        <span class="keyword">if</span> ([className hasSuffix:AspectsSubclassSuffix]) &#123;</div><div class="line">            <span class="comment">// 包含子类后缀，证明调用者为实例，该类为动态创建的子类</span></div><div class="line">            Class originalClass = <span class="built_in">NSClassFromString</span>([className stringByReplacingOccurrencesOfString:AspectsSubclassSuffix withString:<span class="string">@""</span>]); <span class="comment">// 得到原始类名</span></div><div class="line">            <span class="built_in">NSCAssert</span>(originalClass != <span class="literal">nil</span>, <span class="string">@"Original class must exist"</span>);</div><div class="line">            object_setClass(<span class="keyword">self</span>, originalClass); <span class="comment">// 将调用者的类重新设置为原始类</span></div><div class="line">            AspectLog(<span class="string">@"Aspects: %@ has been restored."</span>, <span class="built_in">NSStringFromClass</span>(originalClass));</div><div class="line">            </div><div class="line">            <span class="comment">// 这里并没有在runtime系统中移除该类</span></div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 调用者为类，将其复原（恢复forwardInvocation实现）</span></div><div class="line">            <span class="keyword">if</span> (isMetaClass) &#123;</div><div class="line">                aspect_undoSwizzleClassInPlace((Class)<span class="keyword">self</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，统一将selector的IMP替换回来。</p>
<p>对于instance调用者，清除hook状态，只要将其isa指回到原来的类即可。</p>
<p>对于Class调用者来说，则稍微麻烦一些：<br>首先需要移除全局标记的方法信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_deregisterTrackedSelector(<span class="keyword">id</span> <span class="keyword">self</span>, SEL selector) &#123;</div><div class="line">    <span class="comment">// 只对类调用者有效</span></div><div class="line">    <span class="keyword">if</span> (!class_isMetaClass(object_getClass(<span class="keyword">self</span>))) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 取出全局swizzled的类字典</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span> *swizzledClassesDict = aspect_getSwizzledClassesDict();</div><div class="line">    <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(selector);</div><div class="line">    </div><div class="line">    <span class="comment">// 依次从当前向父类查询，移除追踪方法标记</span></div><div class="line">    Class currentClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        AspectTracker *tracker = swizzledClassesDict[currentClass];</div><div class="line">        <span class="keyword">if</span> (tracker) &#123;</div><div class="line">            [tracker.selectorNames removeObject:selectorName];</div><div class="line">            <span class="keyword">if</span> (tracker.selectorNames.count == <span class="number">0</span>) &#123;</div><div class="line">                [swizzledClassesDict removeObjectForKey:tracker];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">while</span> ((currentClass = class_getSuperclass(currentClass)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于关联对象，这里正好有个知识点：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_destroyContainerForObject(<span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt; <span class="keyword">self</span>, SEL selector) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</div><div class="line">    SEL aliasSelector = aspect_aliasForSelector(selector);</div><div class="line">    <span class="comment">// 清除关联对象的值（给属性值清零）</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, aliasSelector, <span class="literal">nil</span>, OBJC_ASSOCIATION_RETAIN);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>由于关联对象并没有提供单独清除某一个属性的值的方法（只有全部清除），故Aspects使用设置相关对象值为nil的方式进行了清零</strong>。<br>顺便移除了AspectIdentifier的容器对象。</p>
<p>对于复原类hook的forwardInvocation方法，也比较直接：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_undoSwizzleClassInPlace(Class klass) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(klass);</div><div class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(klass);</div><div class="line"></div><div class="line">    _aspect_modifySwizzledClasses(^(<span class="built_in">NSMutableSet</span> *swizzledClasses) &#123;</div><div class="line">        <span class="comment">// 在线程安全的情况下，从修改的类列表中移除该类</span></div><div class="line">        <span class="keyword">if</span> ([swizzledClasses containsObject:className]) &#123;</div><div class="line">            <span class="comment">// 恢复原始forwardInvocation方法</span></div><div class="line">            aspect_undoSwizzleForwardInvocation(klass);</div><div class="line">            [swizzledClasses removeObject:className];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_undoSwizzleForwardInvocation(Class klass) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(klass);</div><div class="line">    </div><div class="line">    <span class="comment">// 得到hook版本的方法（对应的IMP即为备份的原始IMP）</span></div><div class="line">    Method originalMethod = class_getInstanceMethod(klass, <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName));</div><div class="line">    <span class="comment">// NSObject原版方法</span></div><div class="line">    Method objectMethod = class_getInstanceMethod(<span class="built_in">NSObject</span>.class, <span class="keyword">@selector</span>(forwardInvocation:));</div><div class="line"></div><div class="line">    <span class="comment">// 如果klass没有实现forwardInvocation，则直接用NSObject的默认实现代替</span></div><div class="line">    IMP originalImplementation = method_getImplementation(originalMethod ?: objectMethod);</div><div class="line">    </div><div class="line">    <span class="comment">// 替换回原始实现</span></div><div class="line">    class_replaceMethod(klass, <span class="keyword">@selector</span>(forwardInvocation:), originalImplementation, <span class="string">"v@:@"</span>);</div><div class="line"></div><div class="line">    AspectLog(<span class="string">@"Aspects: %@ has been restored."</span>, <span class="built_in">NSStringFromClass</span>(klass));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ul>
<li><a href="https://github.com/steipete/Aspects" target="_blank" rel="external">Aspects</a></li>
<li><a href="https://www.jianshu.com/p/2c93446d86bd?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends" target="_blank" rel="external">Aspects源码解析</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Aspects是一个可以动态hook指定方法的轻量级的库，AOP思想非常棒的体现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime编程指南之消息转发</title>
    <link href="http://yoursite.com/2019/07/18/Objective-C%20Runtime%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E4%B9%8B%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>http://yoursite.com/2019/07/18/Objective-C Runtime编程指南之消息转发/</id>
    <published>2019-07-18T03:28:28.431Z</published>
    <updated>2019-07-18T03:28:39.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html" target="_blank" rel="external">Message Forwarding</a></p>
</blockquote>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>给一个对象发送其不能处理的消息会产生错误。可是，在发生错误之前，运行时系统给接收对象一个二次机会来处理这个消息。</p>
<a id="more"></a>
<h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>如果你给一个对象发送其不能处理的消息时，在产生错误之前，运行时会发送给对象一个<em>forwardInvocation:</em> 消息，此消息包含一个<em>NSInvocation</em>对象作为唯一参数—-这个<em>NSInvocation</em>对象中包含了之前的原始消息和参数。</p>
<p>你可以实现<em>forwardInvocation:</em> 方法来提供一个默认消息响应，或者用某种其他方式来避免错误。就像名称所说那样，<em>forwardInvocation:</em> 一般用于将消息转发给其他对象。</p>
<p>要了解转发的适用范围和目的，设想下面的场景：首先，假设你正在设计一个对象，它可以响应一个叫<em>negotiate</em>的消息，并且你想要它的响应中包含其他种类对象的响应。你可以很容易地完成它：只需要在你的<em>negotiate</em>方法体中，给其他对象再发送一个<em>negotiate</em>消息。</p>
<p>再想深一点，设想你想要你的对象能够响应<em>negotiate</em>消息，但是其实现却其他类中。完成它的一种方法就是让你的类继承于其他类。可是，这种情况有可能做不到。也许有很多原因导致你的类和实现了<em>negotiate</em>方法的类在不同的继承体系中。</p>
<p>即使你的类不能继承到<em>negotiate</em>方法，你还可以通过”借“的方式来实现一个特别的版本，就是将这个消息直接传递给一个其他类的实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (id)negotiate</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ( [someOtherObject respondsTo:@selector(negotiate)] )</div><div class="line">        <span class="keyword">return</span> [someOtherObject negotiate];</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式可能有一点笨，特别是当你想把许多消息都赚给其他对象时。你必须把从其他类借到的方法依次实现。此外，有时候你不太可能处理到那些你不知道的情况，因为你只是写了那些你当时准备转发的消息代码。这一些消息可能取决于运行时，并且很有可能在未来变成一些新的方法和类。</p>
<p>通过<em>forwardInvocation:</em> 消息提供的第二次机会是一个不太特别的解决方案，而且是个动态方案。其工作过程如下：当一个对象不能响应一个消息时（因为它没有一个可以匹配消息中选择器的方法），运行时系统会给对象发送一个<em>forwardInvocation:</em> 消息。每一个对象都从<em>NSObject</em>类中继承了<em>forwardInvocation:</em> 方法。可是，<em>NSObject</em>的实现版本仅仅调用了<em>doesNotRecognizeSelector:</em> 方法。通过覆盖<em>NSObject</em>的版本并进行你自身的实现，你可以利用这次机会通过<em>forwardInvocation:</em> 将消息转发给其他对象。</p>
<p>要转发一个消息，所有的<em>forwardInvocation:</em> 方法需要按下面的方式去做：</p>
<ul>
<li>决定这个消息要去哪，并且</li>
<li>带着原始参数给它发送过去</li>
</ul>
<p>这个消息可以通过<em>invokeWithTarget:</em> 方法进行发送：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([someOtherObject respondsToSelector:</div><div class="line">            [anInvocation selector]])</div><div class="line">        [anInvocation invokeWithTarget:someOtherObject];</div><div class="line">    <span class="keyword">else</span></div><div class="line">        [super forwardInvocation:anInvocation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转发出的消息的返回值会被返回给原始的接收者。所有类型的返回值都可以被传递给接收者，包括id、结构体和双精度浮点数等。</p>
<p><em>forwardInvocation:</em> 方法对于不能识别的消息扮演着一个分发中心的角色，给这些消息打包发送给不同的接收者。或者它也可以当做一个中转站，发送所有消息到同一个目的地。它可以将一个消息转换为另一个，或者直接”吞掉“某些消息使其不产生响应或错误。一个<em>forwardInvocation:</em> 方法还可以将多个消息合并到一个响应中。<em>forwardInvocation:</em> 方法所做的事情都由实现者决定。可是，它提供的一种将对象链接到到转发链中的机会为程序设计提供了新的可能性。</p>
<blockquote>
<p>注意：</p>
<p><strong>只有当正常的接收者不能调用一个存在的方法时，<em>forwardInvocation:</em> 方法才会收到待处理消息</strong>。例如，如果你想要你的对象转发<em>negotiate</em>消息给另一个对象，那么它自己就不能包含<em>negotiate</em>方法。如果存在此方法，消息就绝不会到达<em>forwardInvocation:</em> 中。</p>
</blockquote>
<p>查看更多关于转发和调用的信息，请在Foundation框架参考中查看<em>NSInvocation</em>类的说明。</p>
<h4 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h4><p>转发模拟了继承，并且可以被用于在Objective-C程序中实现出一些多继承的效果。如<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-87317" target="_blank" rel="external">图表5-1</a>所示，通过转发来响应消息的对象就好像是从另一个类中”继承“了方法实现一样。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/forwarding.gif" alt="图表5-1"></p>
<p>在这个插图中，一个Warrior类的实例转发<em>negotiate</em>消息给了一个Diplomat类的实例。Warrior看起来就好像是一个Diplomat一样。就好像它响应了<em>negotiate</em>消息，并且从实际上看，它确实响应了（虽然是一个Diplomat完成的工作）。</p>
<p>转发消息的对象从而通过两个继承体系的分支中“继承”了方法—-它自己的分支和响应消息的那个对象的分支。在上面的例子中，和自己的父类一样，看起来就好像Warrior类也继承于Diplomat类。</p>
<p>转发提供了大多数的多继承特性。可是，在二者之间还是存在一点重要的不同：多继承将不同的能力合并在了一个对象中。而转发，却将不同的功能分配给了不同的对象。它将问题分解到小的对象中，却用一种对消息发送者透明的方式将这些对象联系起来。</p>
<h4 id="替代者对象"><a href="#替代者对象" class="headerlink" title="替代者对象"></a>替代者对象</h4><p>转发不仅模拟了多继承，它还使开发一个可以代表或者“隐藏”大量对象的轻量级对象成为可能。替代者替代了其他对象并且将消息过滤给它们。</p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163" target="_blank" rel="external">The Objective-C Programming Language</a>中的“Remote Messaging”中讨论的代理就是这样一个替代者。代理负责了将消息转发给远程接收者的所有管理细节，确保参数值通在连接中被拷贝和取回，等等。但是它并没有做更多工作；代理并没有复制远程对象的功能，只是简单地给远程对象一个本地地址，即一个可以从其他应用程序中接收消息的位置。</p>
<p>其他种类的替代者对象也可以做到这些。假设，你有一个可以操作许多数据的对象—-也许它创建了一个复杂的图片或者从磁盘上的文件中读取了内容。创建这个对象也许会非常耗时，所以你更想进行懒加载—-当真的需要时或者是系统资源空闲时。同时，你至少需要一个占位对象来保证应用程序中的其他对象可以正常工作。</p>
<p>在这种情况下，你并不需要创建一个完整的对象，而是一个轻量级的替代者。此对象可以做一些自己的事情，比如回答关于数据的问题，但多数情况下，它只是为那个大对象占用一个位置，当真的需要时，就转发消息给它。当替代者的<em>forwardInvocation:</em> 收到消息并指向其他对象时，它可以确保改对象存在或者当不存在时可以创建出来。大对象的所有消息都会通过替代者传送过来，因此，无论程序的其他部分如何关心，替代者和大对象都是相同的。</p>
<h4 id="转发和继承"><a href="#转发和继承" class="headerlink" title="转发和继承"></a>转发和继承</h4><p>虽然转发模拟了继承，但<em>NSObject</em>类从不会将二者弄混。<strong>像<em>respondsToSelector:</em> 和 <em>isKindOfClass:</em> 的这种方法只会在继承体系中查找，而绝不会在转发链中查找</strong>。例如，如果一个Warrior对象被询问是否可以响应<em>negotiate</em>消息时，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( [aWarrior respondsToSelector:@selector(negotiate)] )</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>答案是NO，尽管它可以接收<em>negotiate</em>消息，不发生错误并能够进行响应，在某种意义上，通过转发消息给Diplomat对象（见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-87317" target="_blank" rel="external">图表5-1</a>）。</p>
<p>在许多情况下，NO就是正确答案。但也可能不是。如果你通过转发来创建一个替代者对象或者扩展类的能力，转发机制应该和继承一样透明。如果你想让你的对象看起来就像真的继承于转发消息的对象，你就需要重新实现<em>respondsToSelector:</em> 和<em>isKindOfClass:</em> 方法，以便包含你的转发规则。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (BOOL)respondsToSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ( [super respondsToSelector:aSelector] )</div><div class="line">        <span class="keyword">return</span> YES;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* Here, test whether the aSelector message can     *</span></div><div class="line">         * be forwarded to another object and whether that  *</div><div class="line">         * object can respond to it. Return YES if it can.  */</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了<em>respondsToSelector:</em> 和<em>isKindOfClass:</em> 方法之外，<em>instancesRespondToSelector:</em> 方法也应该模拟转发规则。如果协议被使用了，<em>conformsToProtocol:</em> 方法也应该加到修改列表中。相似地，如果一个对象转发了任何它收到的远程消息，它应该包含一个<em>methodSignatureForSelector:</em> 方法的版本，它可以返回最终要响应的转发消息的准确描述。例如，如果一个对象正要转发消息给它的替代者，你可以向下面这样实现<em>methodSignatureForSelector:</em> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector</div><div class="line">&#123;</div><div class="line">    NSMethodSignature* signature = [super methodSignatureForSelector:selector];</div><div class="line">    <span class="keyword">if</span> (!signature) &#123;</div><div class="line">       signature = [surrogate methodSignatureForSelector:selector];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> signature;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你还可以考虑将转发规则放到一些私有代码中，并且让所有的待转发方法都调用它（包括<em>forwardInvocation:</em>）。</p>
<blockquote>
<p>注意：</p>
<p>这是一项高级技术，只适合那些没有其他解决方案时的场景。不能用它来代替继承。如果你必须使用此项技术，确保你完整地理解了使用转发的类和转发到的类的所有行为。</p>
</blockquote>
<p>在本节中提到的方法都在Foundation框架指南的<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/cl/NSObject" target="_blank" rel="external">NSObject</a>类的说明中都有描述。要查看<em>invokeWithTarget:</em> 的更多信息，请查看Foundation框架指南的<a href="https://developer.apple.com/documentation/foundation/nsinvocation" target="_blank" rel="external">NSInvocation</a>类的说明。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Message Forwarding&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;消息转发&quot;&gt;&lt;a href=&quot;#消息转发&quot; class=&quot;headerlink&quot; title=&quot;消息转发&quot;&gt;&lt;/a&gt;消息转发&lt;/h3&gt;&lt;p&gt;给一个对象发送其不能处理的消息会产生错误。可是，在发生错误之前，运行时系统给接收对象一个二次机会来处理这个消息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime编程指南之动态方法解析</title>
    <link href="http://yoursite.com/2019/07/18/Objective-C%20Runtime%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E4%B9%8B%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/07/18/Objective-C Runtime编程指南之动态方法解析/</id>
    <published>2019-07-18T03:27:44.799Z</published>
    <updated>2019-07-18T03:28:10.383Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html#//apple_ref/doc/uid/TP40008048-CH102-SW1" target="_blank" rel="external">Dynamic Method Resolution</a></p>
</blockquote>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>本章节描述了如何动态地为方法提供实现。</p>
<a id="more"></a>
<h4 id="动态方法解析-1"><a href="#动态方法解析-1" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>有一些情况下，你可能想要为方法动态地提供实现。比如，声明的Objective-C属性的特性（在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163" target="_blank" rel="external">The Objective-C Programming Language</a>中查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17" target="_blank" rel="external">Declared Properties</a>）中包含了 <em>@dynamic</em> 关键字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@dynamic propertyName;</div></pre></td></tr></table></figure>
<p>它告诉了编译器与属性相关的方法需要动态提供。</p>
<p>你分别可以通过实现<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418500-resolveinstancemethod" target="_blank" rel="external">resolveInstanceMethod:</a>和<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418889-resolveclassmethod" target="_blank" rel="external">resolveClassMethod:</a>方法为指定的实例方法或类方法的选择器动态地提供实现。</p>
<p>一个Objective-C方法就是一个至少包含了两个参数的C函数—-<em>self</em> 和 <em>_cmd</em> 。你可以通过使用<a href="https://developer.apple.com/documentation/objectivec/1418901-class_addmethod" target="_blank" rel="external">class_addMethod</a>函数给类添加一个函数。因此，给定了如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamicMethodIMP</span><span class="params">(id self, SEL _cmd)</span> </span>&#123;</div><div class="line">    <span class="comment">// implementation ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像下面这样，你可以使用<em>resolveInstanceMethod:</em> 方法来给类动态添加一个方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@implementation MyClass</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (aSEL == @selector(resolveThisMethodDynamically)) &#123;</div><div class="line">          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, <span class="string">"v@:"</span>);</div><div class="line">          <span class="keyword">return</span> YES;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [super resolveInstanceMethod:aSEL];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>转发方法（在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1" target="_blank" rel="external">Message Forwarding</a>中描述的那样）和动态方法解析是在对立面的。一个类在转发机制进入之前，有机会动态解析出一个方法。如果<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Protocols/NSObject/Description.html#//apple_ref/occ/intfm/NSObject/respondsToSelector:" target="_blank" rel="external">respondsToSelector:</a>或<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/clm/NSObject/instancesRespondToSelector:" target="_blank" rel="external">instancesRespondToSelector:</a>被调用，动态方法解析器就会首先给机会让选择器提供一个<em>IMP</em>。如果你实现了<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418500-resolveinstancemethod" target="_blank" rel="external">resolveInstanceMethod:</a>方法，但是想要指定选择器通过转发机制转发走，你可以在那些选择器中返回NO。</p>
<h4 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h4><p>一个Objective-C程序可以在运行的过程中加载和链接新的类和分类。新的代码被添加到程序中并且与在程序开始时加载的类和分类同等对待。</p>
<p>动态加载可以被用于做许多不同的事情。比如，在系统偏好设置程序中，各种模块都是动态加载的。</p>
<p>在Cocoa环境中，动态加载普遍用于允许程序的自定义上。第三方可以编写一些在运行时加载的模块—-就像Interface Builder加载自定义调色板或者是OS X系统偏好设置加载自定义设置模块一样。可加载的模块扩展了应用程序的功能。这个功能可以在你允许但是可能没有想到的方式上给应用程序提供帮助。你提供了框架，第三方可以提供代码。</p>
<p>虽然在Mach-O文件中，有一个运行时函数可以执行Objective-C模块的动态加载（<em>objc_loadModules</em>，定义在<em>objc/objc-load.h</em>文件中），Cocoa的<em>NSBundle</em>类提供了一个更加方便的接口用于动态加载—-一个面向对象的并且与相关服务结合到一起的接口。在Foundation框架参考中查看<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSBundle/Description.html#//apple_ref/occ/cl/NSBundle" target="_blank" rel="external">NSBundle</a>类的相关说明及使用方法。在OS X的ABI Mach-O文件格式参考中查看Mach-O文件的相关信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html#//apple_ref/doc/uid/TP40008048-CH102-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dynamic Method Resolution&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;动态方法解析&quot;&gt;&lt;a href=&quot;#动态方法解析&quot; class=&quot;headerlink&quot; title=&quot;动态方法解析&quot;&gt;&lt;/a&gt;动态方法解析&lt;/h3&gt;&lt;p&gt;本章节描述了如何动态地为方法提供实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime编程指南之发送消息</title>
    <link href="http://yoursite.com/2019/07/18/Objective-C%20Runtime%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E4%B9%8B%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2019/07/18/Objective-C Runtime编程指南之发送消息/</id>
    <published>2019-07-18T03:27:18.831Z</published>
    <updated>2019-07-18T03:27:18.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html" target="_blank" rel="external">Messaging</a></p>
</blockquote>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>本章描述了消息表达式如何被转化为<a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend" target="_blank" rel="external">objc_msgSend</a>函数调用，还有如何通过名字索引到方法。之后解释了你如何利用<em>objc_msgSend</em>，还有—-如果需要—-如何规避动态绑定过程。</p>
<a id="more"></a>
<h4 id="objc-msgSend函数"><a href="#objc-msgSend函数" class="headerlink" title="objc_msgSend函数"></a>objc_msgSend函数</h4><p>在Objective-C中，消息直到运行时才会被绑定到方法实现上。编译器将消息表达式进行转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[receiver message]</div></pre></td></tr></table></figure>
<p>转换为消息函数的调用，<a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend" target="_blank" rel="external">objc_msgSend</a>。此函数携带着消息中的<strong>接受者</strong>和<strong>方法名</strong>（即选择器）作为函数的两个必要参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector)</div></pre></td></tr></table></figure>
<p>消息中传入的其他参数也会被<em>objc_msgSend</em>进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure>
<p>这个消息函数为动态绑定做了所有必要的事情：</p>
<ul>
<li>首先，消息函数查找选择器指向的程序（即方法实现）。由于在不同的类中，相同的方法可以有不同的实现，因此确定的实现取决于查找的接收者的类。</li>
<li>之后要调用此实现程序，传入接收对象（其数据的指针），方法指定的其他参数也一同传入。</li>
<li>最后，消息函数将实现程序调用后的返回值传回来，就好像自己的返回值一样。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：</p>
<p>编译器会自动调用此消息函数。你一定不要在代码中直接调用它。</p>
</blockquote>
<p>发送消息的关键在于编译器为每个类和对象构建的结构体。每个类的结构体包含以下两个必要的元素：</p>
<ul>
<li><strong>一个指向父类的指针</strong></li>
<li><strong>一个类的<em>分发表</em>。此表包含一个入口，可以把方法选择器和指定类的方法地址连接在一起</strong>。<em>setOrigin::</em> 方法的选择器和 <em>setOrigin::</em> 的地址（实现程序）连接在了一起，<em>display</em> 方法的选择器和 <em>display</em> 的地址连接在了一起，等等。</li>
</ul>
<p>当一个新对象被创建出来时，其内存已经被分配好，其实例变量也已经初始化。此对象中的第一个变量是一个指向它所属类结构体的指针。这个指针，叫做<strong>isa</strong>，给予此对象访问其所属类的能力，并且通过这个类，还可以访问到所有其继承到的类。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<p>虽然不能严格算是编程语言的一部分，但对于一个对象来说，在与Objective-C运行时系统协同工作时，isa指针却是十分必要的。一个对象”等价于“一个包含了定义的所有字段的<strong>objc_object结构体</strong>（定义在<em>objc/objc.h</em>中）。可是，你几乎用不到自己来创建根对象，继承了NSObject和NSProxy类的对象早已自动包含了isa指针。</p>
</blockquote>
<p>这些类的元素和对象结构体如插图3-1中所示：</p>
<p><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt="发送消息框架"></p>
<p>当消息发送给某个对象时，发送消息函数会沿着对象的isa指针找到该类的结构体，在其中的分发表中查找方法的选择器。如果在这里找不到选择器，<em>objc_msgSend</em>会沿着其父类的指针继续，并试图在父类的分发表中查找该选择器。连续的失败会导致<em>objc_msgSend</em>会沿着类的层级一直向上爬，直到到达<em>NSObject</em>类。一旦锁定了选择器，此函数就会在分发表中进入此方法中进行调用，并且传入接收者对象的数据结构。</p>
<p>以上就是方法实现在运行时被查找的方式—-或者，用面向对象的行话来说，那个方法被动态绑定到了消息上。</p>
<p>为了加速消息发送过程，一旦被使用，运行时系统会缓存该方法的选择器和地址。在每个类中都包含一个独立的缓存区域，并且它同样可以包含继承来的方法选择器。在查找分发表之前，消息发送程序会首先检查接收者类中的缓存（理论上来说，一个方法只要被用过一次就极有可能再次被使用）。如果方法选择器在缓存中，消息发送过程就只会比直接的函数调用稍慢一些。一旦程序已经运行足够的时间来给缓存”热身“，几乎所有发送的消息就都可以找到对应的缓存方法。随着程序的运行，缓存会动态增长空间来缓存新保存的消息。</p>
<h4 id="使用隐藏参数"><a href="#使用隐藏参数" class="headerlink" title="使用隐藏参数"></a>使用隐藏参数</h4><p>当<a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend" target="_blank" rel="external">objc_msgSend</a>找到了方法的实现程序后，它便调用此程序且将消息中包含的所有参数传递进去。它还会传入两个隐藏参数：</p>
<ul>
<li>接收者对象</li>
<li>方法的选择器</li>
</ul>
<p>这些参数给每一个方法实现提供了代码调用时方法表达式中的两个明确信息。它们被叫做”隐藏“，是因为在定义的方法中没有声明二者。它们只在代码编译时被插入到实现中。</p>
<p>虽然这些参数没有明确声明，源码还是可以索引到它们（就像源码可以索引到接收者内部的实例变量一样）。<strong>一个方法把接收者对象称作<em>self</em>，把其自身的选择器称作 <em>_cmd</em></strong>。在下面的例子中，<em>_cmd</em>代表了<em>strange</em>方法的选择器，<em>self</em>则代表了接收<em>strange</em>消息的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- strange</div><div class="line">&#123;</div><div class="line">    id  target = getTheReceiver();</div><div class="line">    SEL method = getTheMethod();</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> ( target == self || method == _cmd )</div><div class="line">        <span class="keyword">return</span> nil;</div><div class="line">    <span class="keyword">return</span> [target performSelector:method];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这两个参数中，<em>self</em>更为有用。实际上，对于方法定义来说，<em>self</em>才是将接收者对象的实例变量变为可用的方式。</p>
<h4 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h4><p><strong>规避动态绑定过程的唯一方法，就是获取方法的地址，然后直接进行函数调用</strong>。这种情况也许非常罕见，也许只有当某个指定方法要连续执行许多次，并且你希望避免每次执行之前进行的消息发送过程。</p>
<p>有一个定义在NSObject类中的方法，名为<em>methodForSelector:</em>，你可以设置一个指向方法实现程序的指针，之后使用这个指针来调用程序。<em>methodForSelector:</em> 返回的指针必须被转换成合适的函数类型，返回值和参数类型都必须包含在类型转换中。</p>
<p>下面的例子展示了<em>setFilled:</em> 方法的实现程序如何是被调用的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (*setter)(id, SEL, BOOL);</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"> </div><div class="line">setter = (<span class="keyword">void</span> (*)(id, SEL, BOOL))[target</div><div class="line">    methodForSelector:@selector(setFilled:)];</div><div class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++ )</div><div class="line">    setter(targetList[i], @selector(setFilled:), YES);</div></pre></td></tr></table></figure>
<p>传入程序中的前两个参数是接收者对象（self）和方法选择器（_cmd）。这些参数被隐藏在方法的语法中，但在方法被作为函数调用时必须明确声明。</p>
<p>使用<em>methodForSelector:</em> 来规避动态绑定过程可以节约消息发送过程中的大部分时间。可是，这种时间节约只有在特定的消息被重复执行许多次时才有意义，就像上面的for循环一样。</p>
<p>注意，<em>methodForSelector:</em> 方法是由Cocoa的运行时系统提供；它并不是Objective-C语言本身的特性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Messaging&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;发送消息&quot;&gt;&lt;a href=&quot;#发送消息&quot; class=&quot;headerlink&quot; title=&quot;发送消息&quot;&gt;&lt;/a&gt;发送消息&lt;/h3&gt;&lt;p&gt;本章描述了消息表达式如何被转化为&lt;a href=&quot;https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;objc_msgSend&lt;/a&gt;函数调用，还有如何通过名字索引到方法。之后解释了你如何利用&lt;em&gt;objc_msgSend&lt;/em&gt;，还有—-如果需要—-如何规避动态绑定过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime编程指南之与运行时系统进行交互</title>
    <link href="http://yoursite.com/2019/07/18/Objective-C%20Runtime%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E4%B9%8B%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B3%BB%E7%BB%9F%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92/"/>
    <id>http://yoursite.com/2019/07/18/Objective-C Runtime编程指南之与运行时系统进行交互/</id>
    <published>2019-07-18T03:26:14.107Z</published>
    <updated>2019-07-18T03:26:37.012Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtInteracting.html" target="_blank" rel="external">Interacting with the Runtime
</a></p>
</blockquote>
<h3 id="与运行时系统进行交互"><a href="#与运行时系统进行交互" class="headerlink" title="与运行时系统进行交互"></a>与运行时系统进行交互</h3><p>Objective-C程序通过三种不同方式与运行时系统进行交互：通过Objective-C代码；通过<em>Foundation</em>框架中定义在<em>NSObject</em>类中的方法；还有通过直接调用运行时的函数。</p>
<a id="more"></a>
<h4 id="Objective-C代码"><a href="#Objective-C代码" class="headerlink" title="Objective-C代码"></a>Objective-C代码</h4><p>对于绝大多数场景下，运行时系统会自动在幕后工作。你需要做的仅仅是编写和编译Objective-C代码即可。</p>
<p>当你编译包含Objective-C类和方法的代码时，编译器会创建对应的数据结构和方法调用来体现语言的动态性。这些数据结构会捕获到类、分类和协议声明中的相关信息；它们包含着在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163" target="_blank" rel="external">The Objective-C Programming Language</a>中<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocDefiningClasses.html#//apple_ref/doc/uid/TP30001163-CH12" target="_blank" rel="external">Defining a Class</a>和<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15" target="_blank" rel="external">Protocols</a>描述的类和协议对象，还有方法选择器、实例变量模板，还有从源代码中提取的其他信息等。最重要的运行时函数就是那个可以发送消息的对象，就像<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html#//apple_ref/doc/uid/TP40008048-CH104-SW1" target="_blank" rel="external">Messaging</a>中描述的一样。它通过源代码消息表达式进行调用。</p>
<h4 id="NSObject的方法"><a href="#NSObject的方法" class="headerlink" title="NSObject的方法"></a>NSObject的方法</h4><p>大多数Cocoa中的对象都是NSObject类的子类，因此大多数对象都继承了其中的方法（例外的是<em>NSProxy</em>类；更多信息请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1" target="_blank" rel="external">Message Forwarding</a>）。因此它的方法会表现出继承的实例和类的默认行为。可是，在某些情况下，NSObject类仅仅是定义了某些事如何做的一个模板；它自身并没有提供所有必要的代码。</p>
<p>例如，NSObject类定义了<em>description</em>实例方法来返回描述类内容的字符串。这个主要用于调试过程—-GDB对象打印命令打印出此方法返回的字符串。NSObject中此方法的实现并不知道本类包含的内容，因此该方法只返回了包含对象名称和内存地址的字符串。NSObject的子类可以实现此方法来返回更多信息。比如，Foundation的<em>NSArray</em>类会返回其包含的所有对象的描述信息。</p>
<p>一些NSObject中的方法只是向运行时系统查询信息。这些方法允许对象来进行”自省“（即查看自身的某些信息）。比如这些方法中的<em>class</em>方法，它让对象来识别出自身的类；<em>isKindOfClass:</em>和<em>isMemberOfClass:</em>，可以检测对象在继承链中的位置；<em>respondsToSelector:</em> 可以判定某对象是否可以接收指定消息；<em>conformsToProtocol:</em> 判定某对象是否声明已经实现了指定协议中的方法（即该类是否遵循了协议）；<em>methodForSelector:</em> 提供了方法实现的地址。形如这些方法都给予了对象检查自身的能力。</p>
<h4 id="运行时的函数"><a href="#运行时的函数" class="headerlink" title="运行时的函数"></a>运行时的函数</h4><p>运行时系统是一个带有公共接口的动态共享库，其内部由一系列函数和数据结构组成，公共接口定义在 <em>/usr/include/objc</em> 目录的头文件中。这些函数中的许多都允许你使用纯C语言来做那些编译器为Objective-C代码所做的事。其他一些则输出形成了NSObject类的基本功能。这些函数使为运行时系统开发其他接口或者为增强开发环境制作工具成为了可能；因为它们无需使用Objective-C进行编码。可是，一小部分的运行时函数也会在编写Objective-C代码时非常有用。所有这些函数都被记录在了<a href="https://developer.apple.com/documentation/objectivec/objective_c_runtime" target="_blank" rel="external">Objective-C Runtime Reference</a>中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtInteracting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Interacting with the Runtime
&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;与运行时系统进行交互&quot;&gt;&lt;a href=&quot;#与运行时系统进行交互&quot; class=&quot;headerlink&quot; title=&quot;与运行时系统进行交互&quot;&gt;&lt;/a&gt;与运行时系统进行交互&lt;/h3&gt;&lt;p&gt;Objective-C程序通过三种不同方式与运行时系统进行交互：通过Objective-C代码；通过&lt;em&gt;Foundation&lt;/em&gt;框架中定义在&lt;em&gt;NSObject&lt;/em&gt;类中的方法；还有通过直接调用运行时的函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》之树</title>
    <link href="http://yoursite.com/2019/04/12/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E4%B9%8B%E6%A0%91/"/>
    <id>http://yoursite.com/2019/04/12/《大话数据结构》之树/</id>
    <published>2019-04-12T15:10:28.591Z</published>
    <updated>2019-04-12T15:10:28.591Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>与线性结构的“一对一”不同，<strong>树是“一对多”的数据结构</strong>。</p>
<blockquote>
<p><strong>树是有限个结点n（n &gt;= 0）的集合</strong>。</p>
<ul>
<li>n为0时称为空树；</li>
<li>不为0时，<strong>有且只有一个结点作为树的根结点</strong>。</li>
<li>n大于1时，除根结点外的其他结点可以分为m（m &gt; 0）个互不相交的有限集合T1…Tm，每个子集合又是一棵树，称为子树。</li>
</ul>
</blockquote>
<a id="more"></a>
<p>下图即为一棵树：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554708278-%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5.jpg" alt="树"></p>
<h4 id="1-1-树的“度”"><a href="#1-1-树的“度”" class="headerlink" title="1.1 树的“度”"></a>1.1 树的“度”</h4><p><strong>每个结点包含的子结点的个数称为结点的“度”（degree）</strong>。<br>度为0的结点为“<em>叶子结点</em>”或“<em>终端结点</em>”；度不为0的结点称为“<em>分支结点</em>”或“<em>非终端结点</em>”。</p>
<p>我们将一棵树中所有子结点的“度”中的最大值称作<strong>树的度</strong>。</p>
<p>示意图中树的度为3（结点D的度最大，是3）。</p>
<h4 id="1-2-结点间的关系"><a href="#1-2-结点间的关系" class="headerlink" title="1.2 结点间的关系"></a>1.2 结点间的关系</h4><p>结点的子树中的根结点叫做该结点的<strong>孩子（Child）结点</strong>；该结点称为孩子的<strong>双亲（Parent）结点</strong>；同一双亲结点的子结点互为<strong>兄弟（Sibling）结点</strong>。</p>
<p>例如，在示意图中，结点D是B的孩子结点，C是B的兄弟结点，A是B的双亲结点。</p>
<blockquote>
<p>注：以下将双亲结点简称为“父结点”，孩子结点称为“子结点”。</p>
</blockquote>
<h4 id="1-3-树的“深度”"><a href="#1-3-树的“深度”" class="headerlink" title="1.3 树的“深度”"></a>1.3 树的“深度”</h4><p>从根结点开始，作为树的第一<strong>层（Level）</strong>；其子结点作为第二层，以此类推。</p>
<p><strong>树的最大层数称为该树的“深度”（Depth）</strong>。</p>
<p>由于示意图中的树分为四层，故其深度为4。其中，同一层的结点互为<strong>堂兄弟结点</strong>。如第三层的D、E和F结点。</p>
<h4 id="1-4-其他概念"><a href="#1-4-其他概念" class="headerlink" title="1.4 其他概念"></a>1.4 其他概念</h4><ol>
<li>若树从左至右为有序，且各子结点的顺序不可调换，则此树可以称为“<strong>有序树</strong>”。</li>
<li><strong>森林</strong>（Forest）是m（m &gt;= 0）棵互不相交的树的集合。</li>
</ol>
<h4 id="1-5-结构对比"><a href="#1-5-结构对比" class="headerlink" title="1.5 结构对比"></a>1.5 结构对比</h4><p>与线性结构的对比如下：</p>
<blockquote>
<p>线性结构：</p>
<ul>
<li>头元素：无前驱结点</li>
<li>尾元素：无后继结点</li>
<li>中间元素：一个前驱结点，一个后继结点</li>
</ul>
<p>树结构：</p>
<ul>
<li>根结点：无父结点，唯一</li>
<li>叶子结点：无子结点，自身可以有多个</li>
<li>分支结点：有父结点，存在1个或多个子结点</li>
</ul>
</blockquote>
<h3 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2. 存储结构"></a>2. 存储结构</h3><p>利用顺序和链式存储方式，我们可以将树的存储方式简单介绍三种：</p>
<ol>
<li>双亲表示法</li>
<li>孩子表示法</li>
<li>孩子兄弟表示法（二叉树）</li>
</ol>
<h4 id="2-1-双亲表示法"><a href="#2-1-双亲表示法" class="headerlink" title="2.1 双亲表示法"></a>2.1 双亲表示法</h4><p>双亲表示法使用顺序存储结构，将所有结点依次存储在连续的空间中。<br>最简单的就是使用一个parent域来标明自身的父结点。其结构如下：</p>
<table>
<thead>
<tr>
<th>data</th>
<th>parent</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据域</td>
<td>父结点索引（数组下标）</td>
</tr>
</tbody>
</table>
<p>以示意图为例，使用双亲表示法可以表示为：</p>
<table>
<thead>
<tr>
<th>下标</th>
<th>data</th>
<th>parent</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>A</td>
<td>-1</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>3</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>3</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>根据此存储方式，可以直接<strong>查询出每个子结点的父结点，其时间复杂度固定为O(1)</strong>。</p>
<p>可以根据需要，对结点的数据结构进行扩展：如添加指向第一个孩子结点的索引域firstChild；添加指向兄弟结点的索引域rightSib等。这种方式可以适时通过扩展并添加存储空间来提高访问效率。</p>
<h4 id="2-2-孩子表示法"><a href="#2-2-孩子表示法" class="headerlink" title="2.2 孩子表示法"></a>2.2 孩子表示法</h4><p>由于每个结点的子结点个数不确定，可以通过链表来表示每个结点下的子树。且由于我们在需要时可以方便地遍历树中的所有结点，可以考虑将所有结点保存在顺序存储结构中。故<strong>孩子表示法的具体方法为：把每个结点的孩子结点排列起来，以单链表为存储结构，则n个结点有n个孩子链表，如果该结点是叶子结点，则此单链表为空表。然后，将n个头指针又组成一个线性表，以顺序存储结构存储在一个一维数组中</strong>。</p>
<p>故示意图中的树，使用孩子表示法可以表示为：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554713216-%E6%A0%91--%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg" alt="树--孩子表示法"></p>
<p>其中结点分为两种：</p>
<ul>
<li>孩子链表中的孩子结点：</li>
</ul>
<table>
<thead>
<tr>
<th>child</th>
<th>next</th>
</tr>
</thead>
<tbody>
<tr>
<td>结点索引（顺序数组的下标）</td>
<td>兄弟结点索引</td>
</tr>
</tbody>
</table>
<ul>
<li>表头数组的表头结点</li>
</ul>
<table>
<thead>
<tr>
<th>data</th>
<th>firstChild</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据域</td>
<td>头指针域（存储对应孩子链表的头指针）</td>
</tr>
</tbody>
</table>
<p>对于此存储结构，要查找某结点的孩子结点，或查找某结点的兄弟结点，只要查找对应的孩子结点单链表即可。</p>
<h4 id="2-3-孩子兄弟表示法"><a href="#2-3-孩子兄弟表示法" class="headerlink" title="2.3 孩子兄弟表示法"></a>2.3 孩子兄弟表示法</h4><p><strong>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的</strong>。因此此节点包括两个指针域，分别指向该结点的第一个孩子结点和此结点的右兄弟结点。</p>
<table>
<thead>
<tr>
<th>data</th>
<th>firstChild</th>
<th>rightSib</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据域</td>
<td>第一个孩子结点的存储地址</td>
<td>右兄弟结点的存储地址</td>
</tr>
</tbody>
</table>
<p>故示意图中的树，使用孩子兄弟表示法可以表示为：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554728801-%E6%A0%91--%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg" alt="树--孩子兄弟表示法"></p>
<p>使用此方式，可以很方便地查找某结点的第几个子结点：只要找到该结点的第一个孩子结点后，依次查找其兄弟结点即可。</p>
<p>通过此种表示方法，我们可以发现，标准的树被转换成了<em>二叉树</em>表示（每个结点最多只有两个子结点）。</p>
<h3 id="3-二叉树"><a href="#3-二叉树" class="headerlink" title="3. 二叉树"></a>3. 二叉树</h3><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h4><ul>
<li><strong>每个结点最多有两棵子树（子结点），故二叉树的度不超过2</strong>。</li>
<li><strong>左右子树有序，不能颠倒</strong>。</li>
<li><strong>结点若只有一棵子树，也要区分是左还是右子树</strong>。</li>
</ul>
<p>如下图，二者是两棵不同的二叉树：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554791292-%E6%A0%91--%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8C%BA%E5%88%86.jpg" alt="树--二叉树区分"></p>
<h4 id="3-2-存储结构"><a href="#3-2-存储结构" class="headerlink" title="3.2 存储结构"></a>3.2 存储结构</h4><h5 id="3-2-1-顺序存储结构"><a href="#3-2-1-顺序存储结构" class="headerlink" title="3.2.1 顺序存储结构"></a>3.2.1 顺序存储结构</h5><p><strong>二叉树的顺序存储结构一般只适用于<em>完全二叉树</em></strong>。</p>
<blockquote>
<p>完全二叉树：</p>
<ul>
<li>叶子结点只出现在二叉树的最后两层</li>
<li>最后一层的叶子结点都是左结点；倒数第二层的叶子结点都是右结点</li>
<li>满二叉树（只有最后一层存在，且全都是叶子结点的二叉树）属于完全二叉树</li>
</ul>
</blockquote>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554792962-%E6%A0%91--%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.jpg" alt="树--二叉树的顺序存储"></p>
<p>如图所示，用一维数组存储二叉树的所有结点，通过数组下标来提现二叉树中结点间的关系。<br>但是，当二叉树中有过多空余结点（如图中的黄色不存在结点）时会导致空间浪费，故一般只使用顺序结构存储完全二叉树。</p>
<h5 id="3-2-2-链式存储结构–二叉链表"><a href="#3-2-2-链式存储结构–二叉链表" class="headerlink" title="3.2.2 链式存储结构–二叉链表"></a>3.2.2 链式存储结构–二叉链表</h5><p>二叉链表：<strong>每个数据节点包含本身的数据域和两个指针域</strong>，分别指向两个可能的孩子结点，这种结点组成的链表称为二叉链表。</p>
<p>结点结构如下：</p>
<table>
<thead>
<tr>
<th>lchild</th>
<th>data</th>
<th>rchild</th>
</tr>
</thead>
<tbody>
<tr>
<td>左孩子结点的存储地址</td>
<td>数据域</td>
<td>右孩子结点的存储地址</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 二叉链表的结点结构体 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></div><div class="line">    TElemType data; <span class="comment">// 数据域</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>;</span> <span class="comment">// 左孩子结点指针</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">rchild</span>;</span> <span class="comment">// 右孩子结点指针</span></div><div class="line">&#125; BiTNode, *BiTree;</div></pre></td></tr></table></figure>
<p>下图为二叉链表的表述示意图：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554794334-%E6%A0%91--%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.jpg" alt="树--二叉链表"></p>
<h4 id="3-3-二叉树的遍历"><a href="#3-3-二叉树的遍历" class="headerlink" title="3.3 二叉树的遍历"></a>3.3 二叉树的遍历</h4><blockquote>
<p>二叉树的遍历（traversing binary tree）是指从根结点出发，<strong>按照某种次序依次访问</strong>二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。</p>
</blockquote>
<p>若以从左到右方向限定，主要的遍历方式分为以下四种：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历</li>
</ul>
<p>与定义<strong>二叉树</strong>的方式一样，其遍历也是以<strong>递归</strong>的方式进行。</p>
<h5 id="3-3-1-前序遍历"><a href="#3-3-1-前序遍历" class="headerlink" title="3.3.1 前序遍历"></a>3.3.1 前序遍历</h5><p>遍历方式：<strong>先访问根节点，然后前序遍历左子树，再前序遍历右子树</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 访问根节点</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</div><div class="line">    <span class="comment">// 遍历左子树</span></div><div class="line">    PreOrderTraverse(T-&gt;lchild);</div><div class="line">    <span class="comment">// 遍历右子树</span></div><div class="line">    PreOrderTraverse(T-&gt;rchild);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-3-2-中序遍历"><a href="#3-3-2-中序遍历" class="headerlink" title="3.3.2 中序遍历"></a>3.3.2 中序遍历</h5><p>遍历方式：<strong>先中序遍历根节点的左子树，然后是根节点，再中序遍历右子树</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 遍历左子树</span></div><div class="line">    InOrderTraverse(T-&gt;lchild);</div><div class="line">    <span class="comment">// 访问根节点</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</div><div class="line">    <span class="comment">// 遍历右子树</span></div><div class="line">    InOrderTraverse(T-&gt;rchild);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-3-3-后续遍历"><a href="#3-3-3-后续遍历" class="headerlink" title="3.3.3 后续遍历"></a>3.3.3 后续遍历</h5><p>遍历方式：<strong>从左到右，先叶子后结点，全部访问完左右子树后，最后访问根结点</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 遍历左子树</span></div><div class="line">    PostOrderTraverse(T-&gt;lchild);</div><div class="line">    <span class="comment">// 遍历右子树</span></div><div class="line">    PostOrderTraverse(T-&gt;rchild);</div><div class="line">    <span class="comment">// 访问根节点</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-4-二叉树的创建"><a href="#3-4-二叉树的创建" class="headerlink" title="3.4 二叉树的创建"></a>3.4 二叉树的创建</h4><p>这里以前序方式创建。与前序遍历相同，创建时按照前序遍历的方式依次递归输入结点数据即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 创建二叉树【前序遍历法创建：根--左--右】 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span> </span>&#123;</div><div class="line">    TElemType ch;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</div><div class="line">    <span class="keyword">if</span> (ch == <span class="string">'#'</span>) &#123;</div><div class="line">        *T = <span class="literal">NULL</span>; <span class="comment">// 代表此结点位置无数据（数据为空）</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 分配空间，创建新结点</span></div><div class="line">        *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</div><div class="line">        <span class="comment">// 内存分配失败，退出</span></div><div class="line">        <span class="keyword">if</span> (!*T) &#123;</div><div class="line">            <span class="built_in">exit</span>(OVERFLOW);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 前序遍历方式赋值</span></div><div class="line">        </div><div class="line">        <span class="comment">// 1. 赋值根节点</span></div><div class="line">        (*T)-&gt;data = ch;</div><div class="line">        <span class="comment">// 2. 左孩子结点递归</span></div><div class="line">        CreateBiTree(&amp;((*T)-&gt;lchild));</div><div class="line">        <span class="comment">// 3. 右孩子结点递归</span></div><div class="line">        CreateBiTree(&amp;((*T)-&gt;rchild));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下图所示，依照代码，先<strong>将给定的二叉树转化为<em>扩展二叉树</em></strong>。</p>
<blockquote>
<p>扩展二叉树：<br>将给定的二叉树的每个结点的空指针设置一个虚拟结点，并指定一个特殊值（这里定义为“#”）。</p>
</blockquote>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554827002-%E6%A0%91--%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA.jpg" alt="树--二叉树的创建"></p>
<blockquote>
<p>二叉树的创建与三种遍历方式，可查看此示例：<a href="https://github.com/Choujiji/PlayWithDataStructure-Code/tree/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="external">项目地址</a></p>
</blockquote>
<h4 id="3-5-线索二叉树"><a href="#3-5-线索二叉树" class="headerlink" title="3.5 线索二叉树"></a>3.5 线索二叉树</h4><h5 id="3-5-1-线索化过程"><a href="#3-5-1-线索化过程" class="headerlink" title="3.5.1 线索化过程"></a>3.5.1 线索化过程</h5><p>此二叉链表虽然功能强大，但弱点显而易见：就是<strong>每次只能通过指定方式的遍历，才可以确定每个结点的前趋结点和后缀结点</strong>。而且我们可以发现，在下面的二叉链表示意图中，有n+1（即2n个总lchild和rchild指针个数 与 n-1个连线 的差）个空余指针域（存储的是“^”），随着二叉树的增长，浪费的空间会越来越多。</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554794334-%E6%A0%91--%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.jpg" alt="树--二叉链表"></p>
<p>因此，<strong>我们可以使用这些空余空间来保存每个结点的前趋和后继结点的信息，以解决上述问题。而解决此问题的过程，叫做线索化，线索化后的二叉链表叫做线索链表，对应的树叫做线索二叉树</strong>。</p>
<p>具体做法是：<strong>在使用某种顺序遍历每个结点时，若没有左孩子结点，其lchild保存的是前趋结点的指针；若没有右孩子结点，其rchild保存的是后继结点的指针</strong>。</p>
<p>如上图中的二叉树，其中序遍历后的结果为HDIBJEAFCG，根据遍历结果对该二叉链表进行线索化的结果如下：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554880420-%E6%A0%91--%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%911.jpg" alt="树--线索二叉树1"></p>
<p>可以看到，通过线索化，不仅解决了空间浪费问题，还解决了前趋和后继结点的记录问题，提高了访问效率。</p>
<h5 id="3-5-2-区分结点类型"><a href="#3-5-2-区分结点类型" class="headerlink" title="3.5.2 区分结点类型"></a>3.5.2 区分结点类型</h5><p>此时线索二叉树还存在一个问题：我们<strong>无法区分lchild指向的结点是前趋结点还是左孩子节点</strong>，对于rchild也是如此。</p>
<p>此时，<strong>需要针对每个指针域分别设置一个布尔类型的数据域，在线索化的过程中，根据实际情况进行区分（是前趋或后继结点时为1，是孩子结点时为0）</strong>。</p>
<p>结点结构如下：</p>
<table>
<thead>
<tr>
<th>左孩子结点地址</th>
<th>左标识符</th>
<th>数据域</th>
<th>右标识符</th>
<th>右孩子结点地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>lchild</td>
<td>ltag</td>
<td>data</td>
<td>rtag</td>
<td>rchild</td>
</tr>
</tbody>
</table>
<p>对应实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 枚举变量，用于标识符赋值 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</div><div class="line">    <span class="comment">/** 是孩子结点 */</span></div><div class="line">    Link,</div><div class="line">    <span class="comment">/** 是前趋或后缀结点 */</span></div><div class="line">    Thread</div><div class="line">&#125; PointerTag;</div><div class="line"></div><div class="line"><span class="comment">/** 线索二叉树结点结构 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> &#123;</span></div><div class="line">    <span class="comment">/** 数据域 */</span></div><div class="line">    TElemType data;</div><div class="line">    <span class="comment">/** 左结点指针 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>;</span></div><div class="line">    <span class="comment">/** 左结点标识符 */</span></div><div class="line">    PointerTag LTag;</div><div class="line">    <span class="comment">/** 右结点指针 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">rchild</span>;</span></div><div class="line">    <span class="comment">/** 右结点标识符 */</span></div><div class="line">    PointerTag RTag;</div><div class="line">&#125; BiThrNode, *BiThrTree; <span class="comment">// 定义为线索二叉树结点及线索二叉树指针</span></div></pre></td></tr></table></figure>
<p>添加结点类型区分后的线索二叉树如下：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554886236-%E6%A0%91--%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%912.jpg" alt="树--线索二叉树2"></p>
<p>这样在访问指定节点时，根据ltag和rtag的值即可区分相邻结点是前趋后继结点或是孩子结点了。</p>
<p>线索化过程的代码如下（这里使用中序遍历方式）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 当前访问节点 */</span></div><div class="line">BiThrTree currentP = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="comment">/** 中序遍历线索化 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!p) &#123;</div><div class="line">        <span class="comment">// 结点不存在，返回</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!p-&gt;lchild &amp;&amp; !p-&gt;rchild) &#123;</div><div class="line">        <span class="comment">// 左右子结点均不存在，即是叶子结点【防止最后一个结点无修改RTag】</span></div><div class="line">        p-&gt;LTag = Thread;</div><div class="line">        p-&gt;RTag = Thread;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 递归线索化左结点</span></div><div class="line">    InThreading(p-&gt;lchild);</div><div class="line">    </div><div class="line">    <span class="comment">// 自身数据线索化（由于是中序遍历【左--中--右】，此时右结点还没有访问到，故只处理当前和前一个结点即可）</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!(p-&gt;lchild)) &#123;</div><div class="line">        <span class="comment">// 左结点为空，即没有左孩子，故当前指向前趋结点</span></div><div class="line">        p-&gt;LTag = Thread;</div><div class="line">        p-&gt;lchild = currentP;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 包含左孩子</span></div><div class="line">        p-&gt;LTag = Link;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (currentP) &#123;</div><div class="line">        <span class="keyword">if</span> (!(currentP-&gt;rchild)) &#123;</div><div class="line">            <span class="comment">// 前一个结点的右结点指针为空，即没有右孩子，故指向后继结点（当前结点）</span></div><div class="line">            currentP-&gt;RTag = Thread;</div><div class="line">            currentP-&gt;rchild = p;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 包含右孩子</span></div><div class="line">            currentP-&gt;RTag = Link;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 记录当前结点</span></div><div class="line">    currentP = p;</div><div class="line">    </div><div class="line">    <span class="comment">// 递归线索化右结点</span></div><div class="line">    InThreading(p-&gt;rchild);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由上图即可看出，如果在二叉树的根结点之前再插入一个头结点，此时的<strong>线索二叉树实际上就是一个双向链表结构</strong>。其结构示意图如下：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554973426-%E6%A0%91--%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%913.jpg" alt="树--线索二叉树3"></p>
<p>插入头结点的简单方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 向线索二叉树中插入头结点 */</span></div><div class="line"><span class="function">BiThrTree <span class="title">insertHeadNodeToBiThrTree</span><span class="params">(BiThrTree biTree)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (biTree == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建头节点</span></div><div class="line">    BiThrTree headNode = (BiThrTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode));</div><div class="line">    <span class="comment">// 左孩子指向线索二叉树的根结点</span></div><div class="line">    headNode-&gt;lchild = biTree;</div><div class="line">    headNode-&gt;LTag = Link;</div><div class="line">    <span class="comment">// 右孩子指向中序遍历的最后一个结点</span></div><div class="line">    BiThrTree inOrderTailNode = biTree;</div><div class="line">    <span class="keyword">while</span> (inOrderTailNode-&gt;RTag == Link) &#123;</div><div class="line">        inOrderTailNode = inOrderTailNode-&gt;rchild;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 此时inOrderTailNode即为最后一个结点</span></div><div class="line">    headNode-&gt;rchild = inOrderTailNode;</div><div class="line">    headNode-&gt;RTag = Thread; <span class="comment">// 并不是右孩子</span></div><div class="line">    </div><div class="line">    <span class="comment">// targetNode的后继结点指向头结点</span></div><div class="line">    inOrderTailNode-&gt;rchild = headNode;</div><div class="line">    </div><div class="line">    <span class="comment">// 中序遍历的第一个结点的前趋结点指向头结点</span></div><div class="line">    BiThrTree inOrderFirstNode = biTree;</div><div class="line">    <span class="keyword">while</span> (inOrderFirstNode-&gt;LTag == Link) &#123;</div><div class="line">        inOrderFirstNode = inOrderFirstNode-&gt;lchild;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 此时inOrderFirstNode即为第一个结点</span></div><div class="line">    inOrderFirstNode-&gt;lchild = headNode;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> headNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终，通过访问双向链表的方式，中序遍历输出此二叉树的方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 中序遍历【扫描二叉链表方式】 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span> </span>&#123;</div><div class="line">    <span class="comment">// 中序遍历，即从头结点开始扫描，</span></div><div class="line">    <span class="comment">// 1. 首先找到最左边的结点（没有左孩子的），</span></div><div class="line">    <span class="comment">// 2. 然后找其后继结点（子树的根），</span></div><div class="line">    <span class="comment">// 3. 最后是其右结点（右孩子或后继）</span></div><div class="line">    <span class="comment">// 直到扫描到的结点是头结点，结束</span></div><div class="line">    </div><div class="line">    <span class="comment">// 指向根结点（从根结点开始）</span></div><div class="line">    BiThrTree currentNode = T-&gt;lchild;</div><div class="line">    </div><div class="line">    <span class="comment">// 遍历结束时，指向头结点</span></div><div class="line">    <span class="keyword">while</span> (currentNode != T) &#123;</div><div class="line">        <span class="comment">// 1. 找到当前子树最左边的结点（没有左孩子的）</span></div><div class="line">        <span class="keyword">while</span> (currentNode-&gt;LTag == Link) &#123;</div><div class="line">            <span class="comment">// 有左孩子，继续查找</span></div><div class="line">            currentNode = currentNode-&gt;lchild;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 找到了最左边的结点，输出</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%hhd "</span>, currentNode-&gt;data);</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 一直向后找到所有后继结点（即对应子树的根）</span></div><div class="line">        <span class="keyword">while</span> (currentNode-&gt;RTag == Thread &amp;&amp; currentNode-&gt;rchild != T) &#123;</div><div class="line">            currentNode = currentNode-&gt;rchild;</div><div class="line">            <span class="comment">// 找到了后继结点，输出</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%hhd "</span>, currentNode-&gt;data);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 3. 指向右结点（下一个结点，不管结点类型，准备下次循环）</span></div><div class="line">        currentNode = currentNode-&gt;rchild;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>线索化及遍历的完整过程，可查看此示例：<a href="https://github.com/Choujiji/PlayWithDataStructure-Code/tree/master/%E6%A0%91/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/ThreadedBinaryTree" target="_blank" rel="external">项目地址</a></p>
</blockquote>
<h4 id="3-6-树、森林转换为二叉树"><a href="#3-6-树、森林转换为二叉树" class="headerlink" title="3.6 树、森林转换为二叉树"></a>3.6 树、森林转换为二叉树</h4><p>由于二叉树的结构稳定（每个结点只有左右两个孩子），其性质也容易研究，故在某些情况下，将普通的树甚至森林转换为二叉树即可对它们进行问题的研究（如遍历等）。</p>
<h5 id="3-6-1-树-gt-二叉树"><a href="#3-6-1-树-gt-二叉树" class="headerlink" title="3.6.1 树 =&gt; 二叉树"></a>3.6.1 树 =&gt; 二叉树</h5><p>转换规则：</p>
<ol>
<li><strong>在兄弟结点与其左方的结点之间添加连接线</strong>。</li>
<li><strong>在结点的所有子孩子中，除了左边第一个孩子结点外，其他所有兄弟孩子结点与父结点间的连线去除</strong>。</li>
<li><strong>调整层次，结点的第一个子孩子作为二叉的左孩子，兄弟孩子作为“前一个”结点的右孩子</strong>。</li>
</ol>
<p>示例：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555052420-%E6%A0%91--%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="树--树转换二叉树"></p>
<p>转换过程：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555052792-%E6%A0%91--%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%912.jpg" alt="树--树转换二叉树2"></p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555052889-%E6%A0%91--%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%913.jpg" alt="树--树转换二叉树3"></p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555053130-%E6%A0%91--%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%914.jpg" alt="树--树转换二叉树4"></p>
<h5 id="3-6-2-森林-gt-二叉树"><a href="#3-6-2-森林-gt-二叉树" class="headerlink" title="3.6.2 森林 =&gt; 二叉树"></a>3.6.2 森林 =&gt; 二叉树</h5><p>可以将森林中的每一棵树看做是兄弟，利用兄弟结点的合并方式（作为前一个结点的右孩子）进行合并，最终合成一棵二叉树：</p>
<ol>
<li><strong>把每一棵树转换为二叉树</strong>。</li>
<li><strong>依次将后一棵树的根结点作为前一棵树的根结点的右孩子。连线完成后，即可得到合成的二叉树</strong>。</li>
</ol>
<p>示例：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555054041-%E6%A0%91--%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="树--森林转二叉树"></p>
<p>转换过程：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555054266-%E6%A0%91--%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%912.jpg" alt="树--森林转二叉树2"></p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555054387-%E6%A0%91--%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%913.jpg" alt="树--森林转二叉树3"></p>
<h4 id="3-7-赫夫曼树及霍夫曼编码"><a href="#3-7-赫夫曼树及霍夫曼编码" class="headerlink" title="3.7 赫夫曼树及霍夫曼编码"></a>3.7 赫夫曼树及霍夫曼编码</h4><h5 id="3-7-1-概念介绍"><a href="#3-7-1-概念介绍" class="headerlink" title="3.7.1 概念介绍"></a>3.7.1 概念介绍</h5><p>赫夫曼树是在二叉树的基础上设计而来。赫夫曼树的每个叶子结点都包含对应的权值（Weight）。<em>两个结点之间经过的所有分支叫做路径，路径上分支的个数叫做路径长度</em>。<strong>树的路径长度就是从<em>根结点</em>到<em>每个叶子结点</em>的路径长度的总和</strong>。</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555056066-%E6%A0%91--%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91.jpg" alt="树--赫夫曼树"></p>
<p>图中的二叉树的路径长度为（以A-E的顺序）：3 + 3 + 2 + 2 + 2 = 12。</p>
<p>霍夫曼树需要引入权的概念，故我们得到了带权路径的算法：<br><strong>结点的带权路径 = 结点从根到自身的路径长度 * 自身权重</strong></p>
<p>因此<strong>树的带权路径长度即为所有叶子结点带权路径的总和</strong>，称作<strong>WPL</strong>。</p>
<p>图中二叉树的WPL为：3 <em> 5 + 3 </em> 15 + 2 <em> 40 + 2 </em> 30 + 2 * 10 = 220。</p>
<p><strong>在带有权重的一组叶子结点所组成的二叉树中，WPL最小的可称作霍夫曼树</strong>。</p>
<h5 id="3-7-2-生成方法"><a href="#3-7-2-生成方法" class="headerlink" title="3.7.2 生成方法"></a>3.7.2 生成方法</h5><ol>
<li>将所有结点按照权值升序排列，生成有序树集合（每棵树即为单独的叶子结点）。</li>
<li>取前两棵树（权值最小）作为左右子树，生成新二叉树，其根结点的权值为原两树权值之和。</li>
<li>在集合中使用新的二叉树替换原始的两棵树并重新排序。</li>
<li>重复步骤2和3，直到序列只剩下一棵树为止，此树即为霍夫曼树。</li>
</ol>
<p>示例：</p>
<table>
<thead>
<tr>
<th>结点</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>权值</td>
<td>5</td>
<td>15</td>
<td>40</td>
<td>30</td>
<td>10</td>
</tr>
</tbody>
</table>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555062192-%E6%A0%91--%E7%94%9F%E6%88%90%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91.jpg" alt="树--生成霍夫曼树"></p>
<h5 id="3-7-3-霍夫曼编码"><a href="#3-7-3-霍夫曼编码" class="headerlink" title="3.7.3 霍夫曼编码"></a>3.7.3 霍夫曼编码</h5><p><strong>将霍夫曼树中所有结点（包括合成结点）的权值改为0和1（左分支权值为0，右分支权值为1），这样从根结点到指定叶子结点所生成的0和1序列即为霍夫曼编码</strong>。</p>
<p>上面的霍夫曼树转换后的结果为：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555066450-%E6%A0%91--%E8%BD%AC%E5%8C%96%E5%90%8E%E7%9A%84%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91.jpg" alt="树--转化后的霍夫曼树"></p>
<p>因此，图中每个字符所生成的霍夫曼编码如下：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>霍夫曼编码</td>
<td>1000</td>
<td>101</td>
<td>0</td>
<td>11</td>
<td>1001</td>
</tr>
</tbody>
</table>
<p><strong>霍夫曼编码可以用来压缩数据，进而提高了传输效率</strong>。</p>
<p>假设传输”BADBEC“这个字符串，使用传统的等长编码，可能会使用如下方式：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>等长编码</td>
<td>100</td>
<td>101</td>
<td>010</td>
<td>011</td>
<td>110</td>
</tr>
</tbody>
</table>
<p>故在此方式下，编码后的数据为”101100011101110010“，长度为18位；而使用霍夫曼编码，编码后的数据为”1011000101101110“，长度仅为16位，故数据得到了压缩。且随着编码字符的增多，霍夫曼编码的数据优势会越来越大。</p>
<p>像霍夫曼编码这样<strong>长短不一的编码方式，由于容易混淆，故必须设计成任一字符的编码都不是其他字符编码的前缀（否则解码时无法区分），这种编码方式叫做前缀编码</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h3&gt;&lt;p&gt;与线性结构的“一对一”不同，&lt;strong&gt;树是“一对多”的数据结构&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;树是有限个结点n（n &amp;gt;= 0）的集合&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n为0时称为空树；&lt;/li&gt;
&lt;li&gt;不为0时，&lt;strong&gt;有且只有一个结点作为树的根结点&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;n大于1时，除根结点外的其他结点可以分为m（m &amp;gt; 0）个互不相交的有限集合T1…Tm，每个子集合又是一棵树，称为子树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>STMAssembleView源码学习</title>
    <link href="http://yoursite.com/2019/03/24/STMAssembleView%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/03/24/STMAssembleView源码学习/</id>
    <published>2019-03-24T05:33:40.517Z</published>
    <updated>2019-03-24T05:33:53.681Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目地址：<a href="https://github.com/ming1016/STMAssembleView" target="_blank" rel="external">STMAssembleView</a></p>
</blockquote>
<h4 id="1-结构设计简洁"><a href="#1-结构设计简洁" class="headerlink" title="1. 结构设计简洁"></a>1. 结构设计简洁</h4><ul>
<li><strong>只公开最外层的STMAssembleView类，调用者只需引入一个类即可使用</strong>。</li>
<li><strong>将业务与功能解耦，生成对应的类：“View”视图类（STMAssembleView、STMPartView）与“Maker”类（STMAssemvleMaker、STMPartMaker）</strong>。“Maker”类负责抽象出支持的功能属性，“View”类通过使用Maker，将子功能进行组合并实现最终业务功能（视图配置）。</li>
</ul>
<a id="more"></a>
<h4 id="2-代码设计巧妙"><a href="#2-代码设计巧妙" class="headerlink" title="2. 代码设计巧妙"></a>2. 代码设计巧妙</h4><ul>
<li>对于“Maker”类，属性用于提供给调用者进行配置调用（即只使用getter），而<strong>属性的setter则另提供配套的设置方法，且设置方法返回的是对应“Maker”类型的Block对象，以实现链式调用</strong>。例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// STMAssembleMaker.m</span></div><div class="line"></div><div class="line">- (STMAssembleMaker *(^)(STMAssembleAlignment))alignmentEqualTo &#123;</div><div class="line">    <span class="keyword">return</span> ^STMAssembleMaker *(STMAssembleAlignment alignment) &#123;</div><div class="line">        <span class="comment">// jiji - 设置对齐方式</span></div><div class="line">        self.alignment = alignment;</div><div class="line">        <span class="keyword">return</span> self;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// 调用时</span></div><div class="line">make.alignmentEqualTo(STMAssembleAlignmentCenter);</div></pre></td></tr></table></figure>
<blockquote>
<p>如代码所示：</p>
<p>由于方法<em>alignmentEqualTo</em>返回的是Block对象，调用方法时，通过添加()即直接隐含执行了Block。且由于Block执行后返回的仍然为make自身，可以在后面继续连续调用其他实例方法，实现了链式调用。</p>
</blockquote>
<ul>
<li><strong>使用__weak指针，防止Block对象导致的内存引用循环</strong>。如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// STMAssembleMaker.m</span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)fsAsync:(NSString *)<span class="built_in">string</span> objects:(NSDictionary *)objs completion:(ParsingFormatStringCompleteBlock)completeBlock&#123;</div><div class="line">    __weak __typeof(<span class="built_in">string</span>) weakString = <span class="built_in">string</span>; <span class="comment">// 弱指针，防止Block执行时对该对象强引用</span></div><div class="line">    __weak __typeof(objs) weakObjs = objs;</div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), ^&#123;</div><div class="line">        __strong __typeof(weakString) strongString = weakString; <span class="comment">// 声明临时的__strong指针并指向__weak指向的对象，可以保证在Block执行过程中该对象不被释放。</span></div><div class="line">        __strong __typeof(weakObjs) strongObjs = weakObjs;</div><div class="line">        <span class="keyword">if</span> (strongString) &#123;</div><div class="line">            [STMAssembleView createViewWithFormatString:strongString objects:strongObjs completion:completeBlock];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如代码所示：</p>
<p>使用<strong>weak和</strong>strong指针的情况在Block声明时具有统一性，可以很好地避免引用循环的产生，且能保证在Block执行时捕获对象的有效性。</p>
<p>注：在单独使用GCD时，由于dispatch_async的Block会在执行后进行release，理论上可以不必担心循环引用的问题。这里铭神这样做的目的是保证自身不会保留传入的对象，需要调用者自己负责参数的生命周期。</p>
</blockquote>
<h4 id="3-知识点："><a href="#3-知识点：" class="headerlink" title="3. 知识点："></a>3. 知识点：</h4><h5 id="3-1-字符串的扫描处理"><a href="#3-1-字符串的扫描处理" class="headerlink" title="3.1 字符串的扫描处理"></a>3.1 字符串的扫描处理</h5><p>使用了<em>NSScanner</em>类对字符串进行扫描，按需将扫描结果进行归类，完成描述字符串的解析（后面根据解析结果调用对应的“View”类进行处理，生成页面）。</p>
<h5 id="3-2-使用变参合成字符串"><a href="#3-2-使用变参合成字符串" class="headerlink" title="3.2 使用变参合成字符串"></a>3.2 使用变参合成字符串</h5><p>使用va_list指向变参列表的第一个参数地址，通过NSString合成出完整字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//宏</span></div><div class="line"><span class="function">NSString *<span class="title">ASS</span><span class="params">(NSString *format, ...)</span> </span>&#123;</div><div class="line">    <span class="comment">// jiji - 声明变参指针</span></div><div class="line">    va_list args;</div><div class="line">    <span class="keyword">if</span> (format) &#123;</div><div class="line">        <span class="comment">// jiji - 初始化变参指针（指向第一个参数的地址，如这里的format的地址）</span></div><div class="line">        va_start(args, format);</div><div class="line">        </div><div class="line">        <span class="comment">// jiji - NSString直接通过变参指针读取并生成字符串</span></div><div class="line">        NSString *str = [[NSString alloc] initWithFormat:format arguments:args];</div><div class="line">        </div><div class="line">        <span class="comment">// jiji - 清除变参指针对象</span></div><div class="line">        va_end(args);</div><div class="line">        <span class="keyword">return</span> str;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> @<span class="string">""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/ming1016/STMAssembleView&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;STMAssembleView&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-结构设计简洁&quot;&gt;&lt;a href=&quot;#1-结构设计简洁&quot; class=&quot;headerlink&quot; title=&quot;1. 结构设计简洁&quot;&gt;&lt;/a&gt;1. 结构设计简洁&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;只公开最外层的STMAssembleView类，调用者只需引入一个类即可使用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将业务与功能解耦，生成对应的类：“View”视图类（STMAssembleView、STMPartView）与“Maker”类（STMAssemvleMaker、STMPartMaker）&lt;/strong&gt;。“Maker”类负责抽象出支持的功能属性，“View”类通过使用Maker，将子功能进行组合并实现最终业务功能（视图配置）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>出现“ld：library not found for -lPods”的解决办法</title>
    <link href="http://yoursite.com/2019/03/20/%E5%B7%A5%E7%A8%8B%E5%AE%89%E8%A3%85CocoaPods%E5%90%8E%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/20/工程安装CocoaPods后错误的解决办法/</id>
    <published>2019-03-20T02:57:18.103Z</published>
    <updated>2019-03-20T03:01:20.946Z</updated>
    
    <content type="html"><![CDATA[<p>有的时候，下载的使用CocoaPods配置的工程时，使用“pod install”后，编译时会遇到“<strong>ld: library not found for -lPods</strong>”错误。可以按如下方式试着解决：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/450996-85fee0ff00dcf0b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ld- library not found for -lPods.jpg"></p>
<a id="more"></a>
<p>如图所示，在当前<strong>Target</strong>的<strong>Build Phrase</strong>选项视图中，编辑<strong>Link Binary With Libraries</strong>选项。<strong>移除其中的“libPods.a”</strong>，只保留对应Target打包出的.a文件（添加.a文件时，主工程目录中Frameworks下回自动引入libPods.a依赖，如下图所示）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/450996-24c7e3e8e4d6a410.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Frameworks目录.jpg"></p>
<p>再进行编译一般就会解决问题。</p>
<blockquote>
<p>注：<br>此问题一般来说是由于原工程使用的是老版本的CocoaPods，通过新版CocoaPods安装配置后出现的问题。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有的时候，下载的使用CocoaPods配置的工程时，使用“pod install”后，编译时会遇到“&lt;strong&gt;ld: library not found for -lPods&lt;/strong&gt;”错误。可以按如下方式试着解决：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/450996-85fee0ff00dcf0b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ld- library not found for -lPods.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
