<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭吉吉的瞎记空间</title>
  <subtitle>技术的，瞎说的，啥都有吧。。。希望。。。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-23T10:40:19.664Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>臭吉吉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MBProgressHUD源码学习2：实现方式简单分析</title>
    <link href="http://yoursite.com/2019/01/23/MBProgressHUD%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A02%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/01/23/MBProgressHUD源码学习2：实现方式简单分析/</id>
    <published>2019-01-23T10:40:09.240Z</published>
    <updated>2019-01-23T10:40:19.664Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>提要：</p>
<ol>
<li>“全能”实现方法；</li>
<li>“延后显示”和“最少显示时间”；</li>
<li>使用KVO更新UI；</li>
<li>使用通知方式处理自身视图的朝向变化；</li>
<li>总结<a id="more"></a>
<h3 id="1-“全能”实现方法"><a href="#1-“全能”实现方法" class="headerlink" title="1. “全能”实现方法"></a>1. “全能”实现方法</h3></li>
</ol>
</blockquote>
<p><strong>“全能”实现方法，即真正用于实现功能的方法</strong>。这一封装方式在MBProgressHUD.m中屡见不鲜。如“全能”初始化方法<em>initWithFrame</em>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 全能初始化方法 */</span></div><div class="line">- (id)initWithFrame:(CGRect)frame &#123;</div><div class="line">	self = [super initWithFrame:frame];</div><div class="line">	<span class="keyword">if</span> (self) &#123;</div><div class="line">		<span class="comment">// 各种属性初始值设置</span></div><div class="line">		...</div><div class="line">		</div><div class="line">        <span class="comment">// 初始化label</span></div><div class="line">		[self setupLabels];</div><div class="line">        <span class="comment">// 加载indicator</span></div><div class="line">		[self updateIndicators];</div><div class="line">        <span class="comment">// 注册KVO，将UI的属性修改绑定到一起</span></div><div class="line">		[self registerForKVO];</div><div class="line">        <span class="comment">// 注册屏幕朝向通知，自动旋转</span></div><div class="line">		[self registerForNotifications];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithView:(UIView *)view &#123;</div><div class="line">	NSAssert(view, @<span class="string">"View must not be nil."</span>);</div><div class="line">	<span class="keyword">return</span> [self initWithFrame:view.bounds];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithWindow:(UIWindow *)window &#123;</div><div class="line">	<span class="keyword">return</span> [self initWithView:window];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在以上代码中，可以看出，外部API使用的初始化最终都是通过调用<em>initWithFrame</em>方法完成的。该方法的主要功能如下：</p>
<ul>
<li>提供了主要属性的初始赋值；</li>
<li>对用于显示信息的的UILabel对象进行初始化，真正的布局在layoutSubView中进行处理；</li>
<li>根据mode属性，对不同类型的indicator视图对象进行初始化；</li>
<li>通过KVO，将用于更新UI的相关属性进行统一配置；</li>
<li>使用通知，监听系统屏幕转向消息，配置视图转向重绘方法。</li>
</ul>
<blockquote>
<p>类似的封装方式，在本类中还体现在：</p>
<ol>
<li>如线程block的任务配置api中，<em>showAnimated:whileExecutingBlock:onQueue:completionBlock:</em>方法作为真正的实现方法，其余均为本方法的不同调用版本。</li>
<li>显示和隐藏HUD方法，分别通过<em>showUsingAnimation:</em>和<em>hideUsingAnimation:</em>方法进行真正的功能实现。</li>
</ol>
<p>这种封装方式的好处是使实现代码集中，便于管理，且不易出错。</p>
</blockquote>
<h3 id="2-“延后显示”和“最少显示时间”"><a href="#2-“延后显示”和“最少显示时间”" class="headerlink" title="2. “延后显示”和“最少显示时间”"></a>2. “延后显示”和“最少显示时间”</h3><ol>
<li>MBProgressHUD中，存在<em>graceTime</em>这一属性，其意义为“延迟一定的时间显示HUD”。即当任务运行时间过短的情况下，防止“闪烁”情况发生（HUD刚刚显示就隐藏）。此值需要我们手动设置，默认为0。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 显示自身 */</span></div><div class="line">- (<span class="keyword">void</span>)show:(BOOL)animated &#123;</div><div class="line">	useAnimation = animated;</div><div class="line">	<span class="comment">// 设置了graceTime后，就会延时显示了</span></div><div class="line">	<span class="keyword">if</span> (self.graceTime &gt; <span class="number">0.0</span>) &#123;</div><div class="line">		self.graceTimer = [NSTimer scheduledTimerWithTimeInterval:self.graceTime target:self </div><div class="line">						   selector:@selector(handleGraceTimer:) userInfo:nil repeats:NO];</div><div class="line">	&#125; </div><div class="line">	<span class="comment">// 直接显示</span></div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		[self showUsingAnimation:useAnimation];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)handleGraceTimer:(NSTimer *)theTimer &#123;</div><div class="line">	<span class="comment">// 任务执行期间，才会显示；否则就不必显示HUD了</span></div><div class="line">	<span class="keyword">if</span> (taskInProgress) &#123;</div><div class="line">		[self showUsingAnimation:useAnimation];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>代码中还存在<em>minShowTime</em>这一属性，即“最小显示时长”。用于在HUD隐藏时，当少于指定显示时长时延迟消失时机，防止“闪烁”情况发生：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 隐藏自身 */</span></div><div class="line">- (<span class="keyword">void</span>)hide:(BOOL)animated &#123;</div><div class="line">	useAnimation = animated;</div><div class="line">    <span class="comment">// 存在最小显示时长，并且HUD已经在显示（showStarted中保存了显示时刻）</span></div><div class="line">	<span class="keyword">if</span> (self.minShowTime &gt; <span class="number">0.0</span> &amp;&amp; showStarted) &#123;</div><div class="line">        <span class="comment">// 计算已显示时长</span></div><div class="line">		NSTimeInterval interv = [[NSDate date] timeIntervalSinceDate:showStarted];</div><div class="line">		<span class="keyword">if</span> (interv &lt; self.minShowTime) &#123;</div><div class="line">            <span class="comment">// 小于最小显示时长，则补齐时长后，执行隐藏功能（防止过早隐藏，出现闪烁）</span></div><div class="line">			self.minShowTimer = [NSTimer scheduledTimerWithTimeInterval:(self.minShowTime - interv) target:self </div><div class="line">								selector:@selector(handleMinShowTimer:) userInfo:nil repeats:NO];</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125; </div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 直接隐藏</span></div><div class="line">	[self hideUsingAnimation:useAnimation];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)handleMinShowTimer:(NSTimer *)theTimer &#123;</div><div class="line">	[self hideUsingAnimation:useAnimation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-使用KVO更新UI"><a href="#3-使用KVO更新UI" class="headerlink" title="3. 使用KVO更新UI"></a>3. 使用KVO更新UI</h3><p>对于MBProgressHUD中过于繁杂的各种配置属性（如mode、progress、各种文字及样式颜色等），设置后都需要进行UI更新。为了进行统一管理，且降低代码复杂程度，源码中使用了KVO的方式进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)registerForKVO &#123;</div><div class="line">    <span class="comment">// 依次设置需要的实例变量为KVO</span></div><div class="line">	<span class="keyword">for</span> (NSString *keyPath in [self observableKeypaths]) &#123;</div><div class="line">		[self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:<span class="literal">NULL</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSArray *)observableKeypaths &#123;</div><div class="line">    <span class="comment">// 返回所有需要设置为KVO的实例变量</span></div><div class="line">	<span class="keyword">return</span> [NSArray arrayWithObjects:@<span class="string">"mode"</span>, @<span class="string">"customView"</span>, @<span class="string">"labelText"</span>, @<span class="string">"labelFont"</span>, @<span class="string">"labelColor"</span>,</div><div class="line">			@<span class="string">"detailsLabelText"</span>, @<span class="string">"detailsLabelFont"</span>, @<span class="string">"detailsLabelColor"</span>, @<span class="string">"progress"</span>, @<span class="string">"activityIndicatorColor"</span>, nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    <span class="comment">// 由于所有KVO监听的实例变量均为UI相关，确保在主线程设置</span></div><div class="line">	<span class="keyword">if</span> (![NSThread isMainThread]) &#123;</div><div class="line">		[self performSelectorOnMainThread:@selector(updateUIForKeypath:) withObject:keyPath waitUntilDone:NO];</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		[self updateUIForKeypath:keyPath];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)updateUIForKeypath:(NSString *)keyPath &#123;</div><div class="line">    <span class="comment">// 统一进行属性设置</span></div><div class="line">	<span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"mode"</span>] || [keyPath isEqualToString:@<span class="string">"customView"</span>] ||</div><div class="line">		[keyPath isEqualToString:@<span class="string">"activityIndicatorColor"</span>]) &#123;</div><div class="line">		[self updateIndicators];</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"labelText"</span>]) &#123;</div><div class="line">		label.text = self.labelText;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"labelFont"</span>]) &#123;</div><div class="line">		label.font = self.labelFont;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"labelColor"</span>]) &#123;</div><div class="line">		label.textColor = self.labelColor;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"detailsLabelText"</span>]) &#123;</div><div class="line">		detailsLabel.text = self.detailsLabelText;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"detailsLabelFont"</span>]) &#123;</div><div class="line">		detailsLabel.font = self.detailsLabelFont;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"detailsLabelColor"</span>]) &#123;</div><div class="line">		detailsLabel.textColor = self.detailsLabelColor;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"progress"</span>]) &#123;</div><div class="line">		<span class="keyword">if</span> ([indicator respondsToSelector:@selector(setProgress:)]) &#123;</div><div class="line">			[(id)indicator setValue:@(progress) forKey:@<span class="string">"progress"</span>];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">    <span class="comment">// 设置完成后，更新布局（label等）并重绘界面（progress等）</span></div><div class="line">	[self setNeedsLayout];</div><div class="line">	[self setNeedsDisplay];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>通过<em>updateUIForKeypath:</em>方法，统一对所有UI相关修改进行属性设置，并在最后统一绘制并刷新布局，完成UI更新。</p>
</blockquote>
<p>移除KVO监听时，使用同样的方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)unregisterFromKVO &#123;</div><div class="line">    <span class="comment">// 依次移除KVO监听</span></div><div class="line">	<span class="keyword">for</span> (NSString *keyPath in [self observableKeypaths]) &#123;</div><div class="line">		[self removeObserver:self forKeyPath:keyPath];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSArray *)observableKeypaths &#123;</div><div class="line">    <span class="comment">// 返回所有需要设置为KVO的实例变量</span></div><div class="line">	<span class="keyword">return</span> [NSArray arrayWithObjects:@<span class="string">"mode"</span>, @<span class="string">"customView"</span>, @<span class="string">"labelText"</span>, @<span class="string">"labelFont"</span>, @<span class="string">"labelColor"</span>,</div><div class="line">			@<span class="string">"detailsLabelText"</span>, @<span class="string">"detailsLabelFont"</span>, @<span class="string">"detailsLabelColor"</span>, @<span class="string">"progress"</span>, @<span class="string">"activityIndicatorColor"</span>, nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-使用通知方式处理自身视图的朝向变化"><a href="#4-使用通知方式处理自身视图的朝向变化" class="headerlink" title="4. 使用通知方式处理自身视图的朝向变化"></a>4. 使用通知方式处理自身视图的朝向变化</h3><p>在设备朝向发生改变时，通过监听系统通知事件（<em>UIApplicationDidChangeStatusBarOrientationNotification</em>），重绘自身，以适应视图转向：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)registerForNotifications &#123;</div><div class="line">	NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];</div><div class="line">    <span class="comment">// 监听屏幕旋转消息</span></div><div class="line">	[nc addObserver:self selector:@selector(statusBarOrientationDidChange:)</div><div class="line">			   name:UIApplicationDidChangeStatusBarOrientationNotification object:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)unregisterFromNotifications &#123;</div><div class="line">	NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];</div><div class="line">	[nc removeObserver:self name:UIApplicationDidChangeStatusBarOrientationNotification object:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)statusBarOrientationDidChange:(NSNotification *)notification &#123;</div><div class="line">	UIView *superview = self.superview;</div><div class="line">	<span class="keyword">if</span> (!superview) &#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 依附于父视图上，则进行自身更新</span></div><div class="line">		[self updateForCurrentOrientationAnimated:YES];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)updateForCurrentOrientationAnimated:(BOOL)animated &#123;</div><div class="line">    <span class="comment">// Stay in sync with the superview in any case</span></div><div class="line">    <span class="keyword">if</span> (self.superview) &#123;</div><div class="line">        <span class="comment">// 自身尺寸为转向后的父视图尺寸</span></div><div class="line">        self.bounds = self.superview.bounds;</div><div class="line">        <span class="comment">// 重绘自身，更新为新样式</span></div><div class="line">        [self setNeedsDisplay];</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ol>
<li><strong>高效统一的UI更新</strong>：由于源码中将视图组件（如UILabel和）的布局配置封装于<em>layoutSubView:</em>方法中；将HUD的背景图及progress进度条绘制置于<em>drawRect:</em>方法中，故可以在任意时机通过调用<em>setNeedsLayout</em>以及<em>setNeedsDisplay</em>统一更新UI。再通过KVO、通知等方式统一进行绑定，实现了高效率的UI更新及代码规范的封装方式。</li>
<li><strong>对于“全能”实现方法的二次封装</strong>：只将真正的实现代码封装在指定方法中，并提供详细的配置参数。其他相关API只是对改方法进行不同配置上的二次封装，使代码机制，易于管理，减少了出错概率。</li>
<li><strong>灵活使用KVO等方式进行变量的自动设置</strong>：KVO可以在运行期间自动完成对应变量的更新，这对于大量对象的频繁修改尤其有效，也是集中管理代码的良好方式。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;提要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;“全能”实现方法；&lt;/li&gt;
&lt;li&gt;“延后显示”和“最少显示时间”；&lt;/li&gt;
&lt;li&gt;使用KVO更新UI；&lt;/li&gt;
&lt;li&gt;使用通知方式处理自身视图的朝向变化；&lt;/li&gt;
&lt;li&gt;总结
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>MBProgressHUD源码学习1：公有API介绍</title>
    <link href="http://yoursite.com/2019/01/23/MBProgressHUD%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A01%EF%BC%9A%E5%85%AC%E6%9C%89API%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/01/23/MBProgressHUD源码学习1：公有API介绍/</id>
    <published>2019-01-23T10:39:06.662Z</published>
    <updated>2019-01-23T10:39:27.847Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>源代码基于0.91版本；</li>
<li>本篇只介绍相关公有API，同时简单说明实现方式</li>
</ul>
</blockquote>
<h3 id="1-用于快速调用HUD的类方法"><a href="#1-用于快速调用HUD的类方法" class="headerlink" title="1. 用于快速调用HUD的类方法"></a>1. 用于快速调用HUD的类方法</h3><h4 id="1-1-在指定视图上显示和移除HUD"><a href="#1-1-在指定视图上显示和移除HUD" class="headerlink" title="1.1 在指定视图上显示和移除HUD"></a>1.1 在指定视图上显示和移除HUD</h4><ul>
<li><p>在视图中显示HUD，进入等待状态</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (MB_INSTANCETYPE)showHUDAddedTo:(UIView *)view animated:(BOOL)animated;</div></pre></td></tr></table></figure>
</li>
<li><p>在视图上移除HUD，退出等待状态</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated;</div></pre></td></tr></table></figure>
<p>对于没有特别要求，只需要简单屏蔽用户交互时使用；二者一般成对使用。</p>
<ul>
<li>移除视图中的所有HUD，退出等待状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (NSUInteger)hideAllHUDsForView:(UIView *)view animated:(BOOL)animated;</div></pre></td></tr></table></figure>
<p>此方法会遍历查找视图层级中的所有HUD视图并移除。</p>
<blockquote>
<p>快速显示和隐藏HUD方法，自动管理HUD的生命周期，故在实现中设置为“隐藏后直接移除视图”，如：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 示例的显示HUD方法</span></div><div class="line">+ (MB_INSTANCETYPE)showHUDAddedTo:(UIView *)view animated:(BOOL)animated &#123;</div><div class="line">	MBProgressHUD *hud = [[self alloc] initWithView:view];</div><div class="line">    <span class="comment">// 类方法，只是用于快速显示或隐藏，不关心视图，故消失后直接移除</span></div><div class="line">	hud.removeFromSuperViewOnHide = YES;</div><div class="line">	[view addSubview:hud];</div><div class="line">	[hud show:animated];</div><div class="line">	<span class="keyword">return</span> MB_AUTORELEASE(hud);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-2-获取视图中存在的HUD对象"><a href="#1-2-获取视图中存在的HUD对象" class="headerlink" title="1.2 获取视图中存在的HUD对象"></a>1.2 获取视图中存在的HUD对象</h4><ul>
<li>获取视图中当前显示的HUD对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (MB_INSTANCETYPE)HUDForView:(UIView *)view;</div></pre></td></tr></table></figure>
<p>这里使用了逆序遍历view的子视图的方式，快速获取最上层的HUD对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (MB_INSTANCETYPE)HUDForView:(UIView *)view &#123;</div><div class="line">    <span class="comment">// 逆序迭代（符合视图层级）</span></div><div class="line">	NSEnumerator *subviewsEnum = [view.subviews reverseObjectEnumerator];</div><div class="line">	<span class="keyword">for</span> (UIView *subview in subviewsEnum) &#123;</div><div class="line">		<span class="keyword">if</span> ([subview isKindOfClass:self]) &#123;</div><div class="line">			<span class="keyword">return</span> (MBProgressHUD *)subview;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>获取视图中所有存在的HUD对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (NSArray *)allHUDsForView:(UIView *)view;</div></pre></td></tr></table></figure>
<h3 id="2-初始化HUD的实例方法"><a href="#2-初始化HUD的实例方法" class="headerlink" title="2 初始化HUD的实例方法"></a>2 初始化HUD的实例方法</h3><h4 id="2-1-使用UIWindow对象尺寸创建HUD"><a href="#2-1-使用UIWindow对象尺寸创建HUD" class="headerlink" title="2.1 使用UIWindow对象尺寸创建HUD"></a>2.1 使用UIWindow对象尺寸创建HUD</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)initWithWindow:(UIWindow *)window;</div></pre></td></tr></table></figure>
<h4 id="2-2-使用UIView对象尺寸创建HUD"><a href="#2-2-使用UIView对象尺寸创建HUD" class="headerlink" title="2.2 使用UIView对象尺寸创建HUD"></a>2.2 使用UIView对象尺寸创建HUD</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)initWithView:(UIView *)view;</div></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>二者都是通过调用<em>initWithFrame</em>方法进行实例化，只是参数类型不同；</li>
<li>需要创建方自主管理HUD的生存周期。</li>
</ul>
<p>注意：</p>
<ul>
<li><strong>以上初始化方法中的参数只是由于指定HUD视图自身尺寸，并非添加到视图上。</strong></li>
<li><strong>添加到的父视图需要手动指定。</strong></li>
</ul>
<h3 id="3-显示、隐藏HUD的相关实例方法"><a href="#3-显示、隐藏HUD的相关实例方法" class="headerlink" title="3 显示、隐藏HUD的相关实例方法"></a>3 显示、隐藏HUD的相关实例方法</h3><h4 id="3-1-显示HUD视图，进入等待状态"><a href="#3-1-显示HUD视图，进入等待状态" class="headerlink" title="3.1 显示HUD视图，进入等待状态"></a>3.1 显示HUD视图，进入等待状态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)show:(BOOL)animated;</div></pre></td></tr></table></figure>
<h4 id="3-2-隐藏HUD视图，退出等待状态"><a href="#3-2-隐藏HUD视图，退出等待状态" class="headerlink" title="3.2 隐藏HUD视图，退出等待状态"></a>3.2 隐藏HUD视图，退出等待状态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)hide:(BOOL)animated;</div></pre></td></tr></table></figure>
<h4 id="3-3-在指定时间后，隐藏HUD视图，退出等待状态"><a href="#3-3-在指定时间后，隐藏HUD视图，退出等待状态" class="headerlink" title="3.3 在指定时间后，隐藏HUD视图，退出等待状态"></a>3.3 在指定时间后，隐藏HUD视图，退出等待状态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)hide:(BOOL)animated afterDelay:(NSTimeInterval)delay;</div></pre></td></tr></table></figure>
<p>以上方法，都是在通过自己实例化HUD对象后（默认为隐藏状态），自主控制HUD视图的显示与隐藏。</p>
<h3 id="4-在指定任务执行时，自动显示和隐藏HUD的相关方法"><a href="#4-在指定任务执行时，自动显示和隐藏HUD的相关方法" class="headerlink" title="4 在指定任务执行时，自动显示和隐藏HUD的相关方法"></a>4 在指定任务执行时，自动显示和隐藏HUD的相关方法</h3><h4 id="4-1-使用“target-selector”方式执行后台任务"><a href="#4-1-使用“target-selector”方式执行后台任务" class="headerlink" title="4.1 使用“target - selector”方式执行后台任务"></a>4.1 使用“<em>target - selector</em>”方式执行后台任务</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)showWhileExecuting:(SEL)method onTarget:(id)target withObject:(id)object animated:(BOOL)animated;</div></pre></td></tr></table></figure>
<p>此方法的实现步骤：</p>
<ol>
<li>在后台自动创建新线程，在其中执行预定任务；</li>
<li>同时在主线程创建并显示HUD；</li>
<li>任务完成后，在主线程中清理缓存数据，同时移除HUD，结束等待状态。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)showWhileExecuting:(SEL)method onTarget:(id)target withObject:(id)object animated:(BOOL)animated &#123;</div><div class="line">    <span class="comment">// 保存需要执行的参数对象</span></div><div class="line">	methodForExecution = method;</div><div class="line">	targetForExecution = MB_RETAIN(target);</div><div class="line">	objectForExecution = MB_RETAIN(object);	</div><div class="line">    <span class="comment">// 这里由于是开辟新线程执行任务，故是异步执行</span></div><div class="line">	self.taskInProgress = YES;</div><div class="line">	[NSThread detachNewThreadSelector:@selector(launchExecution) toTarget:self withObject:nil];</div><div class="line">    <span class="comment">// 同时显示HUD视图，进入等待状态</span></div><div class="line">	[self show:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)launchExecution &#123;</div><div class="line">	@autoreleasepool &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></div><div class="line">        <span class="comment">// 1.这里由于没有使用返回值，故需要向编译器添加“忽略内存泄漏”要求</span></div><div class="line">        <span class="comment">// 2.此方法在支持完毕前，不会返回（卡住当前执行线程）</span></div><div class="line">		[targetForExecution performSelector:methodForExecution withObject:objectForExecution];</div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></div><div class="line">        <span class="comment">// 执行完毕后，执行主线程的任务</span></div><div class="line">		[self performSelectorOnMainThread:@selector(cleanUp) withObject:nil waitUntilDone:NO];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)cleanUp &#123;</div><div class="line">    <span class="comment">// 标识任务已结束</span></div><div class="line">	taskInProgress = NO;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__has_feature(objc_arc)</span></div><div class="line">	[targetForExecution release];</div><div class="line">	[objectForExecution release];</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="comment">// 清除保留的执行对象</span></div><div class="line">	targetForExecution = nil;</div><div class="line">	objectForExecution = nil;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">// 隐藏HUD视图，退出等待状态</span></div><div class="line">	[self hide:useAnimation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-2-使用“block”方式执行后台任务"><a href="#4-2-使用“block”方式执行后台任务" class="headerlink" title="4.2 使用“block”方式执行后台任务"></a>4.2 使用“<em>block</em>”方式执行后台任务</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)showAnimated:(BOOL)animated whileExecutingBlock:(<span class="keyword">dispatch_block_t</span>)block;</div></pre></td></tr></table></figure>
<h4 id="4-3-使用“block”方式执行后台任务，并在完成后执行指定任务"><a href="#4-3-使用“block”方式执行后台任务，并在完成后执行指定任务" class="headerlink" title="4.3 使用“block”方式执行后台任务，并在完成后执行指定任务"></a>4.3 使用“<em>block</em>”方式执行后台任务，并在完成后执行指定任务</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)showAnimated:(BOOL)animated whileExecutingBlock:(<span class="keyword">dispatch_block_t</span>)block completionBlock:(MBProgressHUDCompletionBlock)completion;</div></pre></td></tr></table></figure>
<h4 id="4-4-使用“block”方式执行后台任务，任务在指定的GCD队列中执行"><a href="#4-4-使用“block”方式执行后台任务，任务在指定的GCD队列中执行" class="headerlink" title="4.4 使用“block”方式执行后台任务，任务在指定的GCD队列中执行"></a>4.4 使用“<em>block</em>”方式执行后台任务，任务在指定的GCD队列中执行</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)showAnimated:(BOOL)animated whileExecutingBlock:(<span class="keyword">dispatch_block_t</span>)block onQueue:(<span class="keyword">dispatch_queue_t</span>)<span class="built_in">queue</span>;</div></pre></td></tr></table></figure>
<h4 id="4-5-使用“block”方式执行后台任务，任务在指定的GCD队列中执行，并在完成后执行指定任务"><a href="#4-5-使用“block”方式执行后台任务，任务在指定的GCD队列中执行，并在完成后执行指定任务" class="headerlink" title="4.5 使用“block”方式执行后台任务，任务在指定的GCD队列中执行，并在完成后执行指定任务"></a>4.5 使用“<em>block</em>”方式执行后台任务，任务在指定的GCD队列中执行，并在完成后执行指定任务</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)showAnimated:(BOOL)animated whileExecutingBlock:(<span class="keyword">dispatch_block_t</span>)block onQueue:(<span class="keyword">dispatch_queue_t</span>)<span class="built_in">queue</span></div><div class="line">		  completionBlock:(MBProgressHUDCompletionBlock)completion;</div></pre></td></tr></table></figure>
<p>以上通过block方式执行任务的API，都是<strong>通过GCD的方式，在并发队列中执行异步任务</strong>，简化了实现。如<em>1.4.5</em>的方法实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 真正的block版本的异步执行函数 */</span></div><div class="line">- (<span class="keyword">void</span>)showAnimated:(BOOL)animated whileExecutingBlock:(<span class="keyword">dispatch_block_t</span>)block onQueue:(<span class="keyword">dispatch_queue_t</span>)<span class="built_in">queue</span></div><div class="line">	 completionBlock:(MBProgressHUDCompletionBlock)completion &#123;</div><div class="line">    <span class="comment">// 标识任务已开始执行</span></div><div class="line">	self.taskInProgress = YES;</div><div class="line">    <span class="comment">// 将block保存到堆内存（由于completion为外部回调，不会捕获当前对象中的变量，防止是栈内存的block被释放，故需要拷贝到堆上）</span></div><div class="line">	self.completionBlock = completion;</div><div class="line">    <span class="comment">// 在队列中异步执行任务</span></div><div class="line">	dispatch_async(<span class="built_in">queue</span>, ^(<span class="keyword">void</span>) &#123;</div><div class="line">		block();</div><div class="line">        <span class="comment">// 完成后，主线程进行清理工作</span></div><div class="line">		dispatch_async(dispatch_get_main_queue(), ^(<span class="keyword">void</span>) &#123;</div><div class="line">			[self cleanUp];</div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">    <span class="comment">// 同时，在主线程显示HUD视图，进入等待状态</span></div><div class="line">	[self show:animated];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;源代码基于0.91版本；&lt;/li&gt;
&lt;li&gt;本篇只介绍相关公有API，同时简单说明实现方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-用于快速调用HUD的类方法&quot;&gt;&lt;a href=&quot;#1-用于快速调用HUD的类方法&quot; class=&quot;headerlink&quot; title=&quot;1. 用于快速调用HUD的类方法&quot;&gt;&lt;/a&gt;1. 用于快速调用HUD的类方法&lt;/h3&gt;&lt;h4 id=&quot;1-1-在指定视图上显示和移除HUD&quot;&gt;&lt;a href=&quot;#1-1-在指定视图上显示和移除HUD&quot; class=&quot;headerlink&quot; title=&quot;1.1 在指定视图上显示和移除HUD&quot;&gt;&lt;/a&gt;1.1 在指定视图上显示和移除HUD&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在视图中显示HUD，进入等待状态&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>objc-公共头文件（Public Headers）的基本内容（下）</title>
    <link href="http://yoursite.com/2019/01/21/objc-%E5%85%AC%E5%85%B1%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%88Public%20Headers%EF%BC%89%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2019/01/21/objc-公共头文件（Public Headers）的基本内容（下）/</id>
    <published>2019-01-21T09:20:35.940Z</published>
    <updated>2019-01-21T09:20:35.940Z</updated>
    
    <content type="html"><![CDATA[<h3 id="runtime-h"><a href="#runtime-h" class="headerlink" title="runtime.h"></a>runtime.h</h3><h4 id="1-数据类型定义"><a href="#1-数据类型定义" class="headerlink" title="1.数据类型定义"></a>1.数据类型定义</h4><h5 id="1-1-方法Method"><a href="#1-1-方法Method" class="headerlink" title="1.1 方法Method"></a>1.1 方法Method</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> *<span class="title">Method</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></div><div class="line">    SEL name;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;</div><div class="line">    IMP imp;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SortBySELAddress</span> :</span></div><div class="line">        <span class="keyword">public</span> <span class="built_in">std</span>::binary_function&lt;<span class="keyword">const</span> <span class="keyword">method_t</span>&amp;,</div><div class="line">                                    <span class="keyword">const</span> <span class="keyword">method_t</span>&amp;, <span class="keyword">bool</span>&gt;</div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">method_t</span>&amp; lhs,</span></span></div><div class="line">                         <span class="keyword">const</span> <span class="keyword">method_t</span>&amp; rhs)</div><div class="line">        &#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>如上所述，Method即为method_t的结构体实例指针，其组成包含<strong>SEL选择器、IMP函数指针和方法类型描述</strong>。</p>
<h5 id="1-2-变量Ivar"><a href="#1-2-变量Ivar" class="headerlink" title="1.2 变量Ivar"></a>1.2 变量Ivar</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> *<span class="title">Ivar</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></div><div class="line">    <span class="keyword">int32_t</span> *offset;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;</div><div class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></div><div class="line">    <span class="keyword">uint32_t</span> alignment_raw;</div><div class="line">    <span class="keyword">uint32_t</span> size;</div><div class="line"></div><div class="line">    <span class="keyword">uint32_t</span> alignment() <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span> (alignment_raw == ~(<span class="keyword">uint32_t</span>)<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1U</span> &lt;&lt; WORD_SHIFT;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; alignment_raw;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Ivar为ivar_t的结构体实例指针，组成主要包括<strong>变量名，变量类型和偏移量（用于内存布局）</strong>。</p>
<h5 id="1-3-分类Category"><a href="#1-3-分类Category" class="headerlink" title="1.3 分类Category"></a>1.3 分类Category</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> *<span class="title">Category</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">classref_t</span> cls;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></div><div class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></div><div class="line"></div><div class="line">    <span class="keyword">method_list_t</span> *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</div><div class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">property_list_t</span> *propertiesForMeta(<span class="keyword">bool</span> isMeta, struct header_info *hi);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Category为category_t的结构体实例指针，内部主要包括<em>**分类名、所属类、实例方法列表指针、类方法列表指针和协议列表指针</em>。</p>
<h5 id="1-4-属性objc-property-t"><a href="#1-4-属性objc-property-t" class="headerlink" title="1.4 属性objc_property_t"></a>1.4 属性objc_property_t</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> *<span class="title">objc_property_t</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>指向property_t结构体实例的指针，内部包含名称和支持的特性。</p>
<h5 id="1-5-类Class"><a href="#1-5-类Class" class="headerlink" title="1.5 类Class"></a>1.5 类Class</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></div><div class="line">    Class _Nonnull isa;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Class即为指向objc_class结构体实例的指针。Class内部包含Class类型的isa指针。</li>
<li>由于Class的结构与id一致，均只包含isa的Class指针，故<strong>Class也是对象</strong>（面向对象中一切皆为对象）。</li>
<li>Class中的isa指向的是metaclass。</li>
</ul>
<h4 id="2-方法定义"><a href="#2-方法定义" class="headerlink" title="2.方法定义"></a>2.方法定义</h4><h5 id="2-1-使用对象的相关方法"><a href="#2-1-使用对象的相关方法" class="headerlink" title="2.1 使用对象的相关方法"></a>2.1 使用对象的相关方法</h5><h6 id="2-1-1-获取对象所属类"><a href="#2-1-1-获取对象所属类" class="headerlink" title="2.1.1 获取对象所属类"></a>2.1.1 获取对象所属类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class _<span class="function">Nullable </span></div><div class="line"><span class="title">object_getClass</span><span class="params">(id _Nullable obj)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-1-2-给对象设置所属类"><a href="#2-1-2-给对象设置所属类" class="headerlink" title="2.1.2 给对象设置所属类"></a>2.1.2 给对象设置所属类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class _<span class="function">Nullable</span></div><div class="line"><span class="title">object_setClass</span><span class="params">(id _Nullable obj, Class _Nonnull cls)</span>;</div></pre></td></tr></table></figure>
<p>返回值为设置之前的类</p>
<h6 id="2-1-3-判断执行对象是否为类"><a href="#2-1-3-判断执行对象是否为类" class="headerlink" title="2.1.3 判断执行对象是否为类"></a>2.1.3 判断执行对象是否为类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">object_isClass</span><span class="params">(id _Nullable obj)</span>;</div></pre></td></tr></table></figure>
<p>返回YES，则传入对象为Class或metaclass（印证了Class也是对象）。</p>
<h6 id="2-1-4-获取对象的实例变量的值"><a href="#2-1-4-获取对象的实例变量的值" class="headerlink" title="2.1.4 获取对象的实例变量的值"></a>2.1.4 获取对象的实例变量的值</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id _<span class="function">Nullable</span></div><div class="line"><span class="title">object_getIvar</span><span class="params">(id _Nullable obj, Ivar _Nonnull ivar)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-1-5-向对象的实例变量设置值"><a href="#2-1-5-向对象的实例变量设置值" class="headerlink" title="2.1.5 向对象的实例变量设置值"></a>2.1.5 向对象的实例变量设置值</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">object_setIvar</span><span class="params">(id _Nullable obj, Ivar _Nonnull ivar, id _Nullable value)</span>;</div></pre></td></tr></table></figure>
<p>对于实例变量Ivar来说，</p>
<ul>
<li>若其内存管理方式已知（如在ARC环境下），就会直接按照其进行设置；</li>
<li>若未知，则按照__unsafe_unretained方式进行设置；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">object_setIvarWithStrongDefault</span><span class="params">(id _Nullable obj, Ivar _Nonnull ivar, id _Nullable value)</span>;</div></pre></td></tr></table></figure>
<p>对于实例变量Ivar来说，</p>
<ul>
<li>若其内存管理方式已知（如在ARC环境下），就会直接按照其进行设置；</li>
<li>若未知，则按照__strong方式进行设置；</li>
</ul>
<h5 id="2-2-获取类定义的相关方法"><a href="#2-2-获取类定义的相关方法" class="headerlink" title="2.2 获取类定义的相关方法"></a>2.2 获取类定义的相关方法</h5><h6 id="2-2-1-根据名字获取类"><a href="#2-2-1-根据名字获取类" class="headerlink" title="2.2.1 根据名字获取类"></a>2.2.1 根据名字获取类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 1. 一般方式</span></div><div class="line">Class _<span class="function">Nullable</span></div><div class="line"><span class="title">objc_getClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name)</span>;</div><div class="line"></div><div class="line"><span class="comment">// 2. 第二种方式</span></div><div class="line">Class _<span class="function">Nullable</span></div><div class="line"><span class="title">objc_lookUpClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name)</span>;</div><div class="line"></div><div class="line"><span class="comment">// 3. 自杀式</span></div><div class="line">Class _<span class="function">Nonnull</span></div><div class="line"><span class="title">objc_getRequiredClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<ul>
<li>所有方式，均可以查询到是否存在改类。</li>
<li>区别：当Class没有注册到运行时系统中时，<em>objc_getClass</em>方法会在类的处理回调执行后，再次查询该类是否已存在；<em>objc_lookUpClass</em>则不会；<em>objc_getRequiredClass</em>则会自动终止进程（只会查询编译时已确定的Class）。</li>
</ul>
<h6 id="2-2-2-获取类的原类"><a href="#2-2-2-获取类的原类" class="headerlink" title="2.2.2 获取类的原类"></a>2.2.2 获取类的原类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class _<span class="function">Nullable</span></div><div class="line"><span class="title">objc_getMetaClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<p>类方法都是保存在metaclass中的。</p>
<h6 id="2-2-3-获取所有的类定义"><a href="#2-2-3-获取所有的类定义" class="headerlink" title="2.2.3 获取所有的类定义"></a>2.2.3 获取所有的类定义</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">objc_getClassList</span><span class="params">(Class _Nonnull * _Nullable buffer, <span class="keyword">int</span> bufferCount)</span>;</div></pre></td></tr></table></figure>
<p>注意：</p>
<blockquote>
<p>不要假定返回的所有类都继承自NSObject，故对其中的类调用方法时需要提前检查该方法是否已经实现。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class _Nonnull * _<span class="function">Nullable</span></div><div class="line"><span class="title">objc_copyClassList</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span>;</div></pre></td></tr></table></figure>
<p>我们一般使用此版本，不过使用完的列表对象，需要手动释放内存。</p>
<h5 id="2-3-使用类的相关方法"><a href="#2-3-使用类的相关方法" class="headerlink" title="2.3 使用类的相关方法"></a>2.3 使用类的相关方法</h5><h6 id="2-3-1-获取类的名字"><a href="#2-3-1-获取类的名字" class="headerlink" title="2.3.1 获取类的名字"></a>2.3.1 获取类的名字</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nonnull</span></div><div class="line"><span class="title">class_getName</span><span class="params">(Class _Nullable cls)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-3-2-判断类是否为原类（metaclass）"><a href="#2-3-2-判断类是否为原类（metaclass）" class="headerlink" title="2.3.2 判断类是否为原类（metaclass）"></a>2.3.2 判断类是否为原类（metaclass）</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">class_isMetaClass</span><span class="params">(Class _Nullable cls)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-3-3-获取类的父类"><a href="#2-3-3-获取类的父类" class="headerlink" title="2.3.3 获取类的父类"></a>2.3.3 获取类的父类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getSuperclass</span><span class="params">(Class _Nullable cls)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-3-4-返回类的实例的大小（OC对象的大小）"><a href="#2-3-4-返回类的实例的大小（OC对象的大小）" class="headerlink" title="2.3.4 返回类的实例的大小（OC对象的大小）"></a>2.3.4 返回类的实例的大小（OC对象的大小）</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span></div><div class="line">class_getInstanceSize(Class _Nullable cls);</div></pre></td></tr></table></figure>
<h6 id="2-3-5-获取类中的实例变量"><a href="#2-3-5-获取类中的实例变量" class="headerlink" title="2.3.5 获取类中的实例变量"></a>2.3.5 获取类中的实例变量</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Ivar _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getInstanceVariable</span><span class="params">(Class _Nullable cls, <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<p>返回的是指定名字的实例变量对象（非属性对象），类型为Ivar，即ivar<em>返回的是指定名字的实例变量对象（非属性对象），类型为Ivar，即ivar</em>返回构体指针。</p>
<h6 id="2-3-6-获取类中的类变量"><a href="#2-3-6-获取类中的类变量" class="headerlink" title="2.3.6 获取类中的类变量"></a>2.3.6 获取类中的类变量</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Ivar _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getClassVariable</span><span class="params">(Class _Nullable cls, <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<p>一般来说，Class中并没有所谓的“类变量”。我们可以使用此方法来返回“isa”指针的对象。</p>
<h6 id="2-3-7-拷贝并返回类的实例变量列表"><a href="#2-3-7-拷贝并返回类的实例变量列表" class="headerlink" title="2.3.7 拷贝并返回类的实例变量列表"></a>2.3.7 拷贝并返回类的实例变量列表</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Ivar _Nonnull * _<span class="function">Nullable</span></div><div class="line"><span class="title">class_copyIvarList</span><span class="params">(Class _Nullable cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span>;</div></pre></td></tr></table></figure>
<ul>
<li>返回的是包含所有实例变量Ivar指针的数组，使用完毕后需要手动释放内存；</li>
<li>只有自身类的实例变量，不包括父类</li>
</ul>
<h6 id="2-3-8-获取指定类的实例方法对象"><a href="#2-3-8-获取指定类的实例方法对象" class="headerlink" title="2.3.8 获取指定类的实例方法对象"></a>2.3.8 获取指定类的实例方法对象</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Method _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getInstanceMethod</span><span class="params">(Class _Nullable cls, SEL _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<p>注意：此方法会查找父类中的实现。</p>
<h6 id="2-3-9-获取指定类的类方法对象"><a href="#2-3-9-获取指定类的类方法对象" class="headerlink" title="2.3.9 获取指定类的类方法对象"></a>2.3.9 获取指定类的类方法对象</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Method _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getClassMethod</span><span class="params">(Class _Nullable cls, SEL _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<p>注意：此方法会查找父类中的实现。</p>
<h6 id="2-3-10-获取指定类中的指定方法实现"><a href="#2-3-10-获取指定类中的指定方法实现" class="headerlink" title="2.3.10 获取指定类中的指定方法实现"></a>2.3.10 获取指定类中的指定方法实现</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IMP _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getMethodImplementation</span><span class="params">(Class _Nullable cls, SEL _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<p>注意，返回的IMP为运行时中的内部对象，并非真正的函数指针。当找不到方法实现时，返回的是消息转发机制中的函数指针。</p>
<h6 id="2-3-11-拷贝并返回类中的方法列表"><a href="#2-3-11-拷贝并返回类中的方法列表" class="headerlink" title="2.3.11 拷贝并返回类中的方法列表"></a>2.3.11 拷贝并返回类中的方法列表</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Method _Nonnull * _<span class="function">Nullable</span></div><div class="line"><span class="title">class_copyMethodList</span><span class="params">(Class _Nullable cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span>;</div></pre></td></tr></table></figure>
<ul>
<li>返回的是包含所有方法Method指针的数组，使用完毕后需要手动释放内存；</li>
<li>只有自身类的方法，不包括父类</li>
</ul>
<h6 id="2-3-12-拷贝并返回类遵循的协议列表"><a href="#2-3-12-拷贝并返回类遵循的协议列表" class="headerlink" title="2.3.12 拷贝并返回类遵循的协议列表"></a>2.3.12 拷贝并返回类遵循的协议列表</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Protocol * __unsafe_unretained _Nonnull * _<span class="function">Nullable </span></div><div class="line"><span class="title">class_copyProtocolList</span><span class="params">(Class _Nullable cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span>;</div></pre></td></tr></table></figure>
<p>这里的Protocol实质上是NSObject的子类。</p>
<h6 id="2-3-13-获取类的属性对象（property）"><a href="#2-3-13-获取类的属性对象（property）" class="headerlink" title="2.3.13 获取类的属性对象（property）"></a>2.3.13 获取类的属性对象（property）</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">objc_property_t</span> _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getProperty</span><span class="params">(Class _Nullable cls, <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-3-14-拷贝并返回类的属性列表"><a href="#2-3-14-拷贝并返回类的属性列表" class="headerlink" title="2.3.14 拷贝并返回类的属性列表"></a>2.3.14 拷贝并返回类的属性列表</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">objc_property_t</span> _Nonnull * _<span class="function">Nullable</span></div><div class="line"><span class="title">class_copyPropertyList</span><span class="params">(Class _Nullable cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span>;</div></pre></td></tr></table></figure>
<ul>
<li>返回的是包含所有属性objc_property_t指针的数组，使用完毕后需要手动释放内存；</li>
<li>只有自身类的属性，不包括父类</li>
</ul>
<h6 id="2-3-15-获取类的实例变量布局"><a href="#2-3-15-获取类的实例变量布局" class="headerlink" title="2.3.15 获取类的实例变量布局"></a>2.3.15 获取类的实例变量布局</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getIvarLayout</span><span class="params">(Class _Nullable cls)</span>;</div></pre></td></tr></table></figure>
<p>得到的是类的实例变量的布局描述，这里留下疑问？？？</p>
<h6 id="2-3-16-获取类的weak的实例变量布局"><a href="#2-3-16-获取类的weak的实例变量布局" class="headerlink" title="2.3.16 获取类的weak的实例变量布局"></a>2.3.16 获取类的weak的实例变量布局</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">class_getWeakIvarLayout</span><span class="params">(Class _Nullable cls)</span>;</div></pre></td></tr></table></figure>
<p>第二个疑问？？？</p>
<h6 id="2-3-17-给类添加新方法"><a href="#2-3-17-给类添加新方法" class="headerlink" title="2.3.17 给类添加新方法"></a>2.3.17 给类添加新方法</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">class_addMethod</span><span class="params">(</span></div><div class="line">    Class _Nullable cls, </div><div class="line">    SEL _Nonnull name, </div><div class="line">    IMP _Nonnull imp,</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nullable types</div><div class="line">);</div></pre></td></tr></table></figure>
<ul>
<li>可以向类中动态添加方法</li>
<li>可以覆盖父类的同名方法</li>
<li>不会替换本类中已存在方法的实现（修改方法实现，可使用<em>method_setImplementation</em>方法）</li>
</ul>
<h6 id="2-3-18-替换类中指定方法的实现"><a href="#2-3-18-替换类中指定方法的实现" class="headerlink" title="2.3.18 替换类中指定方法的实现"></a>2.3.18 替换类中指定方法的实现</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">IMP _<span class="function">Nullable</span></div><div class="line"><span class="title">class_replaceMethod</span><span class="params">(</span></div><div class="line">    Class _Nullable cls, </div><div class="line">    SEL _Nonnull name, </div><div class="line">    IMP _Nonnull imp, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nullable types</div><div class="line">);</div></pre></td></tr></table></figure>
<ul>
<li>若方法不存在，则向该类中自动添加方法；</li>
<li>方法已存在，则替换方法实现</li>
</ul>
<h6 id="2-3-19-向类中添加实例变量"><a href="#2-3-19-向类中添加实例变量" class="headerlink" title="2.3.19 向类中添加实例变量"></a>2.3.19 向类中添加实例变量</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">class_addIvar</span><span class="params">(</span></div><div class="line">    Class _Nullable cls, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name, </div><div class="line">    <span class="keyword">size_t</span> size, </div><div class="line">    <span class="keyword">uint8_t</span> alignment, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nullable types</div><div class="line">);</div></pre></td></tr></table></figure>
<ul>
<li>只能在<em>objc_allocateClassPair</em>之后（动态创建类）并在<em>objc_registerClassPair</em>（向运行时系统注册类）之前调用，将实例变量添加到类布局中；</li>
<li>只能添加到本类中，不能添加到metaclass中；</li>
<li>alignment对齐方式，最少为“1&lt;&lt;alignment”；对于指针类型变量，传入log2(sizeof(pointer_type))。</li>
</ul>
<h6 id="2-3-20-向类中新增遵循的协议"><a href="#2-3-20-向类中新增遵循的协议" class="headerlink" title="2.3.20 向类中新增遵循的协议"></a>2.3.20 向类中新增遵循的协议</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">class_addProtocol</span><span class="params">(Class _Nullable cls, Protocol * _Nonnull protocol)</span>;</div></pre></td></tr></table></figure>
<p>返回NO时，即该类已遵循该协议</p>
<h6 id="2-3-21-向类中新增属性"><a href="#2-3-21-向类中新增属性" class="headerlink" title="2.3.21 向类中新增属性"></a>2.3.21 向类中新增属性</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">class_addProperty</span><span class="params">(</span></div><div class="line">    Class _Nullable cls, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> * _Nullable attributes, </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount</div><div class="line">);</div></pre></td></tr></table></figure>
<h6 id="2-3-22-替换类中的指定属性"><a href="#2-3-22-替换类中的指定属性" class="headerlink" title="2.3.22 替换类中的指定属性"></a>2.3.22 替换类中的指定属性</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">class_replaceProperty</span><span class="params">(</span></div><div class="line">    Class _Nullable cls, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> * _Nullable attributes, </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount</div><div class="line">);</div></pre></td></tr></table></figure>
<h6 id="2-3-23-向类中设置实例变量布局"><a href="#2-3-23-向类中设置实例变量布局" class="headerlink" title="2.3.23 向类中设置实例变量布局"></a>2.3.23 向类中设置实例变量布局</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">class_setIvarLayout</span><span class="params">(Class _Nullable cls, <span class="keyword">const</span> <span class="keyword">uint8_t</span> * _Nullable layout)</span>;</div></pre></td></tr></table></figure>
<p>？？？</p>
<h6 id="2-3-24-向类中设置weak的实例变量布局"><a href="#2-3-24-向类中设置weak的实例变量布局" class="headerlink" title="2.3.24 向类中设置weak的实例变量布局"></a>2.3.24 向类中设置weak的实例变量布局</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">class_setWeakIvarLayout</span><span class="params">(Class _Nullable cls, <span class="keyword">const</span> <span class="keyword">uint8_t</span> * _Nullable layout)</span>;</div></pre></td></tr></table></figure>
<p>？？？</p>
<h5 id="2-4-类实例化的相关方法"><a href="#2-4-类实例化的相关方法" class="headerlink" title="2.4 类实例化的相关方法"></a>2.4 类实例化的相关方法</h5><h6 id="2-4-1-创建类的实例"><a href="#2-4-1-创建类的实例" class="headerlink" title="2.4.1 创建类的实例"></a>2.4.1 创建类的实例</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id _<span class="function">Nullable</span></div><div class="line"><span class="title">class_createInstance</span><span class="params">(Class _Nullable cls, <span class="keyword">size_t</span> extraBytes)</span></div><div class="line">    OBJC_RETURNS_RETAINED;</div></pre></td></tr></table></figure>
<h5 id="2-5-动态添加类的相关方法"><a href="#2-5-动态添加类的相关方法" class="headerlink" title="2.5 动态添加类的相关方法"></a>2.5 动态添加类的相关方法</h5><h6 id="2-5-1-创建类及对应的元类"><a href="#2-5-1-创建类及对应的元类" class="headerlink" title="2.5.1 创建类及对应的元类"></a>2.5.1 创建类及对应的元类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Class _<span class="function">Nullable</span></div><div class="line"><span class="title">objc_allocateClassPair</span><span class="params">(</span></div><div class="line">    Class _Nullable superclass, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name,  </div><div class="line">    <span class="keyword">size_t</span> extraBytes</div><div class="line">);</div></pre></td></tr></table></figure>
<p>在运行时向系统添加类，需要先调用此方法（默认创建了类及对应的元类），之后可以使用<em>class_addMethod</em>和<em>class_addIvar</em>等添加方法和实例变量；最后调用<em>objc_registerClassPair</em>将该类注册到runtime系统中（实例方法需添加到本类，类方法添加到对应的元类中）。</p>
<h6 id="2-5-2-注册新创建的类"><a href="#2-5-2-注册新创建的类" class="headerlink" title="2.5.2 注册新创建的类"></a>2.5.2 注册新创建的类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">objc_registerClassPair</span><span class="params">(Class _Nonnull cls)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-5-3-释放类及元类"><a href="#2-5-3-释放类及元类" class="headerlink" title="2.5.3 释放类及元类"></a>2.5.3 释放类及元类</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">objc_disposeClassPair</span><span class="params">(Class _Nonnull cls)</span>;</div></pre></td></tr></table></figure>
<p>注意：若存在本类的子类，不要调用此方法。</p>
<h5 id="2-6-使用方法（Method）的相关方法"><a href="#2-6-使用方法（Method）的相关方法" class="headerlink" title="2.6 使用方法（Method）的相关方法"></a>2.6 使用方法（Method）的相关方法</h5><h6 id="2-6-1-获取方法中的选择器SEL"><a href="#2-6-1-获取方法中的选择器SEL" class="headerlink" title="2.6.1 获取方法中的选择器SEL"></a>2.6.1 获取方法中的选择器SEL</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SEL _<span class="function">Nonnull</span></div><div class="line"><span class="title">method_getName</span><span class="params">(Method _Nonnull m)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-6-2-获取方法的实现IMP"><a href="#2-6-2-获取方法的实现IMP" class="headerlink" title="2.6.2 获取方法的实现IMP"></a>2.6.2 获取方法的实现IMP</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IMP _<span class="function">Nonnull</span></div><div class="line"><span class="title">method_getImplementation</span><span class="params">(Method _Nonnull m)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-6-3-获取方法的类型编码"><a href="#2-6-3-获取方法的类型编码" class="headerlink" title="2.6.3 获取方法的类型编码"></a>2.6.3 获取方法的类型编码</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">method_getTypeEncoding</span><span class="params">(Method _Nonnull m)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-6-4-获取方法的参数个数"><a href="#2-6-4-获取方法的参数个数" class="headerlink" title="2.6.4 获取方法的参数个数"></a>2.6.4 获取方法的参数个数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span></span></div><div class="line"><span class="title">method_getNumberOfArguments</span><span class="params">(Method _Nonnull m)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-6-5-拷贝并返回方法的返回类型"><a href="#2-6-5-拷贝并返回方法的返回类型" class="headerlink" title="2.6.5 拷贝并返回方法的返回类型"></a>2.6.5 拷贝并返回方法的返回类型</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> * _<span class="function">Nonnull</span></div><div class="line"><span class="title">method_copyReturnType</span><span class="params">(Method _Nonnull m)</span>;</div></pre></td></tr></table></figure>
<p>需要手动释放返回值。</p>
<h6 id="2-6-6-拷贝并返回方法的参数类型"><a href="#2-6-6-拷贝并返回方法的参数类型" class="headerlink" title="2.6.6 拷贝并返回方法的参数类型"></a>2.6.6 拷贝并返回方法的参数类型</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">method_copyArgumentType</span><span class="params">(Method _Nonnull m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span>;</div></pre></td></tr></table></figure>
<p>需要手动释放返回值。</p>
<h6 id="2-6-7-获取方法的描述结构体信息"><a href="#2-6-7-获取方法的描述结构体信息" class="headerlink" title="2.6.7 获取方法的描述结构体信息"></a>2.6.7 获取方法的描述结构体信息</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description</span> * _<span class="title">Nonnull</span></span></div><div class="line"><span class="title">method_getDescription</span>(<span class="title">Method</span> _<span class="title">Nonnull</span> <span class="title">m</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description</span> &#123;</span></div><div class="line">    SEL _Nullable name;               <span class="comment">/**&lt; The name of the method */</span></div><div class="line">    <span class="keyword">char</span> * _Nullable types;           <span class="comment">/**&lt; The types of the method arguments */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h6 id="2-6-8-设置方法实现"><a href="#2-6-8-设置方法实现" class="headerlink" title="2.6.8 设置方法实现"></a>2.6.8 设置方法实现</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IMP _<span class="function">Nonnull</span></div><div class="line"><span class="title">method_setImplementation</span><span class="params">(Method _Nonnull m, IMP _Nonnull imp)</span>;</div></pre></td></tr></table></figure>
<p>返回值为先前的实现。</p>
<h6 id="2-6-9-交换两个方法的实现"><a href="#2-6-9-交换两个方法的实现" class="headerlink" title="2.6.9 交换两个方法的实现"></a>2.6.9 交换两个方法的实现</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">method_exchangeImplementations</span><span class="params">(Method _Nonnull m1, Method _Nonnull m2)</span>;</div></pre></td></tr></table></figure>
<h5 id="2-7-使用实例变量的相关方法"><a href="#2-7-使用实例变量的相关方法" class="headerlink" title="2.7 使用实例变量的相关方法"></a>2.7 使用实例变量的相关方法</h5><h6 id="2-7-1-获取实例变量的名称"><a href="#2-7-1-获取实例变量的名称" class="headerlink" title="2.7.1 获取实例变量的名称"></a>2.7.1 获取实例变量的名称</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">ivar_getName</span><span class="params">(Ivar _Nonnull v)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-7-2-获取实例变量的类型编码"><a href="#2-7-2-获取实例变量的类型编码" class="headerlink" title="2.7.2 获取实例变量的类型编码"></a>2.7.2 获取实例变量的类型编码</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">ivar_getTypeEncoding</span><span class="params">(Ivar _Nonnull v)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-7-3-获取实例变量的偏移量"><a href="#2-7-3-获取实例变量的偏移量" class="headerlink" title="2.7.3 获取实例变量的偏移量"></a>2.7.3 获取实例变量的偏移量</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ptrdiff_t</span></div><div class="line">ivar_getOffset(Ivar _Nonnull v);</div></pre></td></tr></table></figure>
<h5 id="2-7-使用属性的相关方法"><a href="#2-7-使用属性的相关方法" class="headerlink" title="2.7 使用属性的相关方法"></a>2.7 使用属性的相关方法</h5><h6 id="2-7-1-获取属性名称"><a href="#2-7-1-获取属性名称" class="headerlink" title="2.7.1 获取属性名称"></a>2.7.1 获取属性名称</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nonnull</span></div><div class="line"><span class="title">property_getName</span><span class="params">(<span class="keyword">objc_property_t</span> _Nonnull property)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-7-2-获取属性特性描述"><a href="#2-7-2-获取属性特性描述" class="headerlink" title="2.7.2 获取属性特性描述"></a>2.7.2 获取属性特性描述</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">property_getAttributes</span><span class="params">(<span class="keyword">objc_property_t</span> _Nonnull property)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-7-3-拷贝并返回属性的特性列表"><a href="#2-7-3-拷贝并返回属性的特性列表" class="headerlink" title="2.7.3 拷贝并返回属性的特性列表"></a>2.7.3 拷贝并返回属性的特性列表</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">objc_property_attribute_t</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">property_copyAttributeList</span><span class="params">(</span></div><div class="line">    <span class="keyword">objc_property_t</span> _Nonnull property, </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount</div><div class="line">);</div></pre></td></tr></table></figure>
<p>返回的属性列表数组需要手动释放。</p>
<h6 id="2-7-4-拷贝并返回属性特性的值"><a href="#2-7-4-拷贝并返回属性特性的值" class="headerlink" title="2.7.4 拷贝并返回属性特性的值"></a>2.7.4 拷贝并返回属性特性的值</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> * _<span class="function">Nullable</span></div><div class="line"><span class="title">property_copyAttributeValue</span><span class="params">(</span></div><div class="line">    <span class="keyword">objc_property_t</span> _Nonnull property, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull attributeName</div><div class="line">);</div></pre></td></tr></table></figure>
<p>返回值需要手动释放。</p>
<h5 id="2-8-选择器相关方法"><a href="#2-8-选择器相关方法" class="headerlink" title="2.8 选择器相关方法"></a>2.8 选择器相关方法</h5><h6 id="2-8-1-获取选择器的名称"><a href="#2-8-1-获取选择器的名称" class="headerlink" title="2.8.1 获取选择器的名称"></a>2.8.1 获取选择器的名称</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nonnull</span></div><div class="line"><span class="title">sel_getName</span><span class="params">(SEL _Nonnull sel)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-8-2-向运行时系统注册选择器"><a href="#2-8-2-向运行时系统注册选择器" class="headerlink" title="2.8.2 向运行时系统注册选择器"></a>2.8.2 向运行时系统注册选择器</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SEL _<span class="function">Nonnull</span></div><div class="line"><span class="title">sel_registerName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull str)</span>;</div></pre></td></tr></table></figure>
<ul>
<li>在向类定义中添加方法前，需要保证方法对应的SEL已注册到运行时系统中；</li>
<li>若同名SEL已注册，则直接返回</li>
</ul>
<h6 id="2-8-3-判断两个SEL是否相同"><a href="#2-8-3-判断两个SEL是否相同" class="headerlink" title="2.8.3 判断两个SEL是否相同"></a>2.8.3 判断两个SEL是否相同</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL</span></div><div class="line"><span class="title">sel_isEqual</span><span class="params">(SEL _Nonnull lhs, SEL _Nonnull rhs)</span>;</div></pre></td></tr></table></figure>
<p>与“==”等价。</p>
<h5 id="2-9-关联对象相关"><a href="#2-9-关联对象相关" class="headerlink" title="2.9 关联对象相关"></a>2.9 关联对象相关</h5><h6 id="2-9-1-关联规则"><a href="#2-9-1-关联规则" class="headerlink" title="2.9.1 关联规则"></a>2.9.1 关联规则</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">OBJC_ENUM</span><span class="params">(<span class="keyword">uintptr_t</span>, objc_AssociationPolicy)</span> </span>&#123;</div><div class="line">    <span class="comment">/** 关联对象为weak弱引用 */</span></div><div class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,</div><div class="line">    <span class="comment">/** 关联对象为strong强引用，非原子性 */</span></div><div class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>,</div><div class="line">    <span class="comment">/** 关联对象为copy强引用，非原子性 */</span></div><div class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</div><div class="line">    <span class="comment">/** 关联对象为strong强引用，原子性 */</span></div><div class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,</div><div class="line">    <span class="comment">/** 关联对象为copy强引用，原子性 */</span></div><div class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h6 id="2-9-2-设置对象的关联对象"><a href="#2-9-2-设置对象的关联对象" class="headerlink" title="2.9.2 设置对象的关联对象"></a>2.9.2 设置对象的关联对象</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">objc_setAssociatedObject</span><span class="params">(</span></div><div class="line">    id _Nonnull object, </div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull key, </div><div class="line">    id _Nullable value, objc_AssociationPolicy policy</div><div class="line">);</div></pre></td></tr></table></figure>
<h6 id="2-9-3-获取对象的关联对象值"><a href="#2-9-3-获取对象的关联对象值" class="headerlink" title="2.9.3 获取对象的关联对象值"></a>2.9.3 获取对象的关联对象值</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id _<span class="function">Nullable</span></div><div class="line"><span class="title">objc_getAssociatedObject</span><span class="params">(id _Nonnull object, <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull key)</span>;</div></pre></td></tr></table></figure>
<h6 id="2-9-4-移除对象的所有关联对象"><a href="#2-9-4-移除对象的所有关联对象" class="headerlink" title="2.9.4 移除对象的所有关联对象"></a>2.9.4 移除对象的所有关联对象</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">objc_removeAssociatedObjects</span><span class="params">(id _Nonnull object)</span>;</div></pre></td></tr></table></figure>
<h4 id="3-类型编码的相关定义"><a href="#3-类型编码的相关定义" class="headerlink" title="3.类型编码的相关定义"></a>3.类型编码的相关定义</h4><h5 id="3-1-OC类型编码"><a href="#3-1-OC类型编码" class="headerlink" title="3.1 OC类型编码"></a>3.1 OC类型编码</h5><table>
<thead>
<tr>
<th>编码</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>char</td>
</tr>
<tr>
<td>i</td>
<td>int</td>
</tr>
<tr>
<td>s</td>
<td>short</td>
</tr>
<tr>
<td>l</td>
<td>long</td>
</tr>
<tr>
<td>q</td>
<td>long long</td>
</tr>
<tr>
<td>C</td>
<td>unsigned char</td>
</tr>
<tr>
<td>I</td>
<td>unsigned int</td>
</tr>
<tr>
<td>S</td>
<td>unsigned short</td>
</tr>
<tr>
<td>L</td>
<td>unsigned long</td>
</tr>
<tr>
<td>Q</td>
<td>unsigned long long</td>
</tr>
<tr>
<td>f</td>
<td>float</td>
</tr>
<tr>
<td>d</td>
<td>double</td>
</tr>
<tr>
<td>B</td>
<td>C++ bool 或 C99 _Bool</td>
</tr>
<tr>
<td>v</td>
<td>void</td>
</tr>
<tr>
<td>*</td>
<td>字符指针（C字符串）</td>
</tr>
<tr>
<td>@</td>
<td>id或OC类的对象</td>
</tr>
<tr>
<td>#</td>
<td>类对象（Class）</td>
</tr>
<tr>
<td>:</td>
<td>选择器（SEL）</td>
</tr>
<tr>
<td>[<em>array type</em>]</td>
<td>数组</td>
</tr>
<tr>
<td>{<em>name=type…</em>}</td>
<td>结构体</td>
</tr>
<tr>
<td>(<em>name=type…</em>)</td>
<td>联合体</td>
</tr>
<tr>
<td>^type</td>
<td>c指针</td>
</tr>
<tr>
<td>?</td>
<td>未知（可用于函数指针）</td>
</tr>
</tbody>
</table>
<h5 id="3-2-OC方法编码"><a href="#3-2-OC方法编码" class="headerlink" title="3.2 OC方法编码"></a>3.2 OC方法编码</h5><table>
<thead>
<tr>
<th>编码</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>const</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;runtime-h&quot;&gt;&lt;a href=&quot;#runtime-h&quot; class=&quot;headerlink&quot; title=&quot;runtime.h&quot;&gt;&lt;/a&gt;runtime.h&lt;/h3&gt;&lt;h4 id=&quot;1-数据类型定义&quot;&gt;&lt;a href=&quot;#1-数据类型定义&quot; class=&quot;headerlink&quot; title=&quot;1.数据类型定义&quot;&gt;&lt;/a&gt;1.数据类型定义&lt;/h4&gt;&lt;h5 id=&quot;1-1-方法Method&quot;&gt;&lt;a href=&quot;#1-1-方法Method&quot; class=&quot;headerlink&quot; title=&quot;1.1 方法Method&quot;&gt;&lt;/a&gt;1.1 方法Method&lt;/h5&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;method_t&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;Method&lt;/span&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;method_t&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    SEL name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *types;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    IMP imp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SortBySELAddress&lt;/span&gt; :&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::binary_function&amp;lt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;method_t&lt;/span&gt;&amp;amp;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;method_t&lt;/span&gt;&amp;amp;, &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;method_t&lt;/span&gt;&amp;amp; lhs,&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                         &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;method_t&lt;/span&gt;&amp;amp; rhs)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; lhs.name &amp;lt; rhs.name; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>objc-公共头文件（Public Headers）的基本内容（上）</title>
    <link href="http://yoursite.com/2019/01/21/objc-%E5%85%AC%E5%85%B1%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%88Public%20Headers%EF%BC%89%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2019/01/21/objc-公共头文件（Public Headers）的基本内容（上）/</id>
    <published>2019-01-21T09:19:35.705Z</published>
    <updated>2019-01-21T09:19:35.706Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-NSObject-h"><a href="#1-NSObject-h" class="headerlink" title="1. NSObject.h"></a>1. NSObject.h</h3><p>内部主要包含了<strong>NSObject协议</strong>和<strong>NSObject类</strong>。</p>
<ul>
<li><p>NSObject协议规定了主要几部分：</p>
<ul>
<li>class和self</li>
<li>执行方法api</li>
<li>判断所属类和遵循协议的方法</li>
<li>内存管理方法（ARC下禁止）</li>
<li>响应方法api</li>
</ul>
</li>
<li><p>NSObject类规定了主要几部分：</p>
<ul>
<li>内部结构：isa的Class指针</li>
<li>load和initialize类方法</li>
<li>init和dealloc等实例方法</li>
<li>声明并实现了消息转发的相关方法</li>
<li>声明了类方法版本的NSObject协议方法<a id="more"></a>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-message-h"><a href="#2-message-h" class="headerlink" title="2. message.h"></a>2. message.h</h3><h4 id="2-1-super关键字对应的objc-super结构体："><a href="#2-1-super关键字对应的objc-super结构体：" class="headerlink" title="2.1 super关键字对应的objc_super结构体："></a>2.1 super关键字对应的<strong>objc_super结构体</strong>：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span></div><div class="line">    <span class="comment">/** 接收者，当前类的实例，即使用super的self */</span></div><div class="line">    __unsafe_unretained _Nonnull id receiver;</div><div class="line">    <span class="comment">/** 父类的指针 */</span></div><div class="line">    __unsafe_unretained _Nonnull Class super_class;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-2-基本的消息原型"><a href="#2-2-基本的消息原型" class="headerlink" title="2.2 基本的消息原型"></a>2.2 基本的消息原型</h4><p>对象调用方法，即<strong>给对象发消息，调用objc_msgSend方法</strong>，而根据参数类型的不同，系统会自动调用对应的子版本；而<strong>通过对象，调用父类的方法，调用objc_msgSendSuper方法</strong>。</p>
<ul>
<li>objc_msgSend函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id _<span class="function">Nullable <span class="title">objc_msgSend</span><span class="params">(id _Nullable self, SEL _Nullable op, ...)</span></span></div></pre></td></tr></table></figure>
<p>说明：</p>
<blockquote>
<ul>
<li>self，对象，即为id（指向objc_object实例的指针）</li>
<li>op即为SEL，objc_selector的实例指针，运行时系统可以通过SEL找到方法实现IMP</li>
<li>后面为方法调用的参数</li>
</ul>
</blockquote>
<ul>
<li>objc_msgSendSuper函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">id _<span class="function">Nullable <span class="title">objc_msgSendSuper</span><span class="params">(</span></span></div><div class="line">    struct objc_super * _Nullable super, </div><div class="line">    SEL _Nullable op,</div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure>
<p>说明：</p>
<blockquote>
<ul>
<li>super，即为上述objc_super结构体实例的指针</li>
<li>op为SEL</li>
<li>后面传入调用参数</li>
</ul>
</blockquote>
<hr>
<h3 id="3-objc-h"><a href="#3-objc-h" class="headerlink" title="3. objc.h"></a>3. objc.h</h3><h4 id="3-1-Class"><a href="#3-1-Class" class="headerlink" title="3.1 Class"></a>3.1 Class</h4><p>Class，类对象，即objc_class的结构体实例指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></div></pre></td></tr></table></figure>
<h4 id="3-2-对象"><a href="#3-2-对象" class="headerlink" title="3.2 对象"></a>3.2 对象</h4><p>对象，指的是Class的实例，默认即为id类型的变量：</p>
<ul>
<li>id即objc_object结构体实例的指针：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></div></pre></td></tr></table></figure>
<ul>
<li>objc_object结构体，即<strong>对象真正的本质：包含类指针的结构体实例</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></div><div class="line">    Class _Nonnull isa;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-3-选择器及实现"><a href="#3-3-选择器及实现" class="headerlink" title="3.3 选择器及实现"></a>3.3 选择器及实现</h4><ul>
<li>选择器SEL：objc_selector结构体实例的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></div></pre></td></tr></table></figure>
<ul>
<li>方法实现IMP：c函数指针，参数为调用对象id、选择器SEL和参数列表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...)</div></pre></td></tr></table></figure>
<h4 id="3-4-主要方法API"><a href="#3-4-主要方法API" class="headerlink" title="3.4 主要方法API"></a>3.4 主要方法API</h4><ul>
<li>获取选择器对应的方法名：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nonnull <span class="title">sel_getName</span><span class="params">(SEL _Nonnull sel)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>根据指定的名称向运行时系统注册选择器：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SEL _<span class="function">Nonnull <span class="title">sel_registerName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull str)</span></span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>在将方法添加到类定义中之前，必须先注册SEL</p>
</blockquote>
<ul>
<li>返回对象所属类的名字：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * _<span class="function">Nonnull <span class="title">object_getClassName</span><span class="params">(id _Nullable obj)</span></span>;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-NSObject-h&quot;&gt;&lt;a href=&quot;#1-NSObject-h&quot; class=&quot;headerlink&quot; title=&quot;1. NSObject.h&quot;&gt;&lt;/a&gt;1. NSObject.h&lt;/h3&gt;&lt;p&gt;内部主要包含了&lt;strong&gt;NSObject协议&lt;/strong&gt;和&lt;strong&gt;NSObject类&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NSObject协议规定了主要几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;class和self&lt;/li&gt;
&lt;li&gt;执行方法api&lt;/li&gt;
&lt;li&gt;判断所属类和遵循协议的方法&lt;/li&gt;
&lt;li&gt;内存管理方法（ARC下禁止）&lt;/li&gt;
&lt;li&gt;响应方法api&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSObject类规定了主要几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部结构：isa的Class指针&lt;/li&gt;
&lt;li&gt;load和initialize类方法&lt;/li&gt;
&lt;li&gt;init和dealloc等实例方法&lt;/li&gt;
&lt;li&gt;声明并实现了消息转发的相关方法&lt;/li&gt;
&lt;li&gt;声明了类方法版本的NSObject协议方法
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》17</title>
    <link href="http://yoursite.com/2019/01/18/GCD%E7%AF%87%EF%BC%9A1.GCD%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A6%81%E7%82%B9/"/>
    <id>http://yoursite.com/2019/01/18/GCD篇：1.GCD的使用要点/</id>
    <published>2019-01-18T05:43:36.161Z</published>
    <updated>2019-01-18T05:46:22.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCD篇：1-GCD的使用要点"><a href="#GCD篇：1-GCD的使用要点" class="headerlink" title="GCD篇：1.GCD的使用要点"></a>GCD篇：1.GCD的使用要点</h2><h4 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h4><p>一个CPU执行的CPU命令列为<strong>一条无分叉路径</strong>，即为<em>线程</em>。而这种无分叉路径存在多条，即为<em>多线程</em>。</p>
<ul>
<li>在多线程中，一个CPU核执行多条不同路径上的不同命令。</li>
<li>在CPU中，使用寄存器将执行“路径”的状态保存到各自的专用的内存块中。在切换不同目标路径时，从对应的内存块中读取并在CPU中将执行信息复原，继续执行目标路径的命令列。这个过程称为“上下文切换”。</li>
<li>多线程中需要注意的主要问题：<ul>
<li>数据竞争：多个线程同时更新相同资源；</li>
<li>死锁：执行等待事件的多个线程互相持续等待；</li>
<li>线程过多导致内存占用过大</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h4 id="2-GCD的API要点"><a href="#2-GCD的API要点" class="headerlink" title="2.GCD的API要点"></a>2.GCD的API要点</h4><h5 id="2-1-串行和并发队列的使用建议"><a href="#2-1-串行和并发队列的使用建议" class="headerlink" title="2.1 串行和并发队列的使用建议"></a>2.1 串行和并发队列的使用建议</h5><ul>
<li>多个线程同时更新相同资源时，避免产生数据竞争，可以使用Serial Dispatch Queue；</li>
<li>并行处理无数据竞争的问题时，使用Concurrent Dispatch Queue</li>
</ul>
<h5 id="2-2-GCD的内存管理"><a href="#2-2-GCD的内存管理" class="headerlink" title="2.2 GCD的内存管理"></a>2.2 GCD的内存管理</h5><ul>
<li>GCD使用引用计数的内存管理方式；</li>
<li>dispatch_queue_t对象可以保证在内部派发的block执行期间不被释放的原因：block对象通过dispatch_retain的方式保留队列，block对象执行完成后再释放引用；</li>
<li>iOS6之后，ARC可以完全胜任GCD的内存管理，不可再调用dispatch_release等相关API；</li>
</ul>
<h5 id="2-3-队列的优先级"><a href="#2-3-队列的优先级" class="headerlink" title="2.3 队列的优先级"></a>2.3 队列的优先级</h5><ul>
<li>对Global Dispatch Queue设置优先级，CGD会将各自使用该队列的线程设置为对应的优先级</li>
<li>手动创建的队列，其优先级均为DISPATCH_QUEUE_PRIORITY_DEFAULT</li>
<li>通过<em>dispatch_set_target_queue(targetQueue, originQueue)</em>修改队列的优先级：<ul>
<li><em>targetQueue</em>为待修改优先级的队列，<em>originQueue</em>为参照优先级的队列</li>
<li>此API可以设置队列的执行阶层：如多个串行队列同时修改相同资源时，将所有队列的优先级设置为同一个串行队列，可以防止并发处理，避免数据竞争的情况发生。</li>
</ul>
</li>
<li>通过XNU管理，在GCD中使用的线程并不能保证实时性。</li>
</ul>
<h5 id="2-4-dispatch-after"><a href="#2-4-dispatch-after" class="headerlink" title="2.4 dispatch_after"></a>2.4 dispatch_after</h5><p>任务的延迟执行，是指<strong>在指定时间后或到达指定时间，将block对象派发到任务队列中</strong>。注意是“派发”而不是“执行”，故可能存在一定时间延迟，且根据执行线程的任务拥挤程度，执行时间也不确定（派发的任务是由NSRunLoop对象在一次运行循环中取出并执行）。</p>
<h5 id="2-5-提高数据库或文件的读写效率"><a href="#2-5-提高数据库或文件的读写效率" class="headerlink" title="2.5 提高数据库或文件的读写效率"></a>2.5 提高数据库或文件的读写效率</h5><p>通过<em>COncurrent Dispatch Queue</em>和<em>dispatch_barrier_async函数</em>组合使用，异步读取，栅栏操作写入，既可以保证读取的高效，还能保证写入的有效性和安全性。</p>
<h5 id="2-6-确保安全地使用dispatch-sync"><a href="#2-6-确保安全地使用dispatch-sync" class="headerlink" title="2.6 确保安全地使用dispatch_sync"></a>2.6 确保安全地使用dispatch_sync</h5><p>对于个人目前的认知来说，只有在保证真正实现“原子性”的property时，才有可能会使用这个东西。</p>
<h5 id="2-7-Dispatch-Semaphore可以保证更细颗粒度的排他操作"><a href="#2-7-Dispatch-Semaphore可以保证更细颗粒度的排他操作" class="headerlink" title="2.7 Dispatch Semaphore可以保证更细颗粒度的排他操作"></a>2.7 Dispatch Semaphore可以保证更细颗粒度的排他操作</h5><ul>
<li>Dispatch Semaphore根据初始化传入的计数值来保证同时执行任务的最大数量</li>
<li>每次dispatch_semaphore_wait时，会从可用任务数中试图减1：<ul>
<li>本身是0，则没有可用执行空间，等待</li>
<li>可用执行空间大于0，则减去1，并执行下面的任务</li>
</ul>
</li>
<li>dispatch_semaphore_signal会对任务计数加1，释放占用的任务空间。</li>
</ul>
<h5 id="2-8-dispatch-once"><a href="#2-8-dispatch-once" class="headerlink" title="2.8 dispatch_once"></a>2.8 dispatch_once</h5><ul>
<li>dispatch_once可以保证真正的多线程访问安全</li>
<li>一般用于单例对象的创建</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GCD篇：1-GCD的使用要点&quot;&gt;&lt;a href=&quot;#GCD篇：1-GCD的使用要点&quot; class=&quot;headerlink&quot; title=&quot;GCD篇：1.GCD的使用要点&quot;&gt;&lt;/a&gt;GCD篇：1.GCD的使用要点&lt;/h2&gt;&lt;h4 id=&quot;1-多线程&quot;&gt;&lt;a href=&quot;#1-多线程&quot; class=&quot;headerlink&quot; title=&quot;1.多线程&quot;&gt;&lt;/a&gt;1.多线程&lt;/h4&gt;&lt;p&gt;一个CPU执行的CPU命令列为&lt;strong&gt;一条无分叉路径&lt;/strong&gt;，即为&lt;em&gt;线程&lt;/em&gt;。而这种无分叉路径存在多条，即为&lt;em&gt;多线程&lt;/em&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在多线程中，一个CPU核执行多条不同路径上的不同命令。&lt;/li&gt;
&lt;li&gt;在CPU中，使用寄存器将执行“路径”的状态保存到各自的专用的内存块中。在切换不同目标路径时，从对应的内存块中读取并在CPU中将执行信息复原，继续执行目标路径的命令列。这个过程称为“上下文切换”。&lt;/li&gt;
&lt;li&gt;多线程中需要注意的主要问题：&lt;ul&gt;
&lt;li&gt;数据竞争：多个线程同时更新相同资源；&lt;/li&gt;
&lt;li&gt;死锁：执行等待事件的多个线程互相持续等待；&lt;/li&gt;
&lt;li&gt;线程过多导致内存占用过大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》16</title>
    <link href="http://yoursite.com/2019/01/15/Blocks%E7%AF%87%EF%BC%9A7.%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/15/Blocks篇：7.循环引用问题/</id>
    <published>2019-01-15T04:12:59.642Z</published>
    <updated>2019-01-15T04:12:59.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Blocks篇：7-循环引用问题"><a href="#Blocks篇：7-循环引用问题" class="headerlink" title="Blocks篇：7.循环引用问题"></a>Blocks篇：7.循环引用问题</h2><h4 id="1-ARC下的Block循环引用"><a href="#1-ARC下的Block循环引用" class="headerlink" title="1.ARC下的Block循环引用"></a>1.ARC下的Block循环引用</h4><h5 id="1-1-使用weak或unsafe-unretained避免循环引用"><a href="#1-1-使用weak或unsafe-unretained避免循环引用" class="headerlink" title="1.1 使用weak或unsafe_unretained避免循环引用"></a>1.1 使用<strong>weak或</strong>unsafe_unretained避免循环引用</h5><p>一般来说，最简单的这种情况即：<em>block对象作为OC对象的成员，而在block函数体内部直接或间接捕获了该OC对象，造成互相强引用</em>。举例来说：<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(^MyBlock)</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">@interface TestObject : NSObject &#123;</div><div class="line">    <span class="comment">// block成员</span></div><div class="line">    MyBlock myBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TestObject</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        <span class="comment">// 初始化block成员</span></div><div class="line">        myBlock = ^&#123;</div><div class="line">            NSLog(@<span class="string">"%@"</span>, self);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>产生循环引用的过程：</p>
<blockquote>
<ul>
<li>由于myBlock对象捕获了OC对象（self），myBlock被自动拷贝到堆上，并自动对self产生强引用；</li>
<li>myBlock是self的成员，当myBlock分配到堆内存后，self负责对其进行内存管理，自动对myBlock对象产生强引用；</li>
<li>互相保留，引用循环产生</li>
</ul>
</blockquote>
<p>不过这种情况，编译器可以直接识别并给出引用循环警告。我们可以通过所有权修饰符<strong>weak或</strong>unsafe_unretained，使myBlock对象通过保留弱引用或不安全的对象指针，来避免对self产生强引用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        <span class="comment">// 初始化block成员</span></div><div class="line">        </div><div class="line">        __weak TestObject *weakSelf = self;</div><div class="line"><span class="comment">//        __unsafe_unretained TestObject *unsafeSelf = self;</span></div><div class="line">        myBlock = ^&#123;</div><div class="line">            NSLog(@<span class="string">"%@"</span>, weakSelf);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于在init方法中不比担心self对象释放的问题，可以安心使用__unsafe_unretained修饰符。</p>
<h5 id="1-2-通过-block变量，并适时将其释放来解除循环引用"><a href="#1-2-通过-block变量，并适时将其释放来解除循环引用" class="headerlink" title="1.2 通过__block变量，并适时将其释放来解除循环引用"></a>1.2 通过__block变量，并适时将其释放来解除循环引用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@implementation TestObject</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        <span class="comment">// 初始化block成员</span></div><div class="line">        </div><div class="line">        __block TestObject *blockSelf = self;</div><div class="line">        myBlock = ^&#123;</div><div class="line">            NSLog(@<span class="string">"blockSelf - %@"</span>, blockSelf);</div><div class="line">            </div><div class="line">            <span class="comment">// 释放__block变量，其释放对self的强引用</span></div><div class="line">            blockSelf = nil;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">// 通过执行block对象，在内部解除循环引用</span></div><div class="line">        myBlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    NSLog(@<span class="string">"%@"</span>, NSStringFromSelector(_cmd));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>由于在ARC下，复制到堆内存中的<strong>block对象会对内部的OC对象进行强引用，故可以让block对象捕获</strong>block对象，并在需要时释放__block对象（一般都是执行block时），以间接解除对self的强引用。</strong></p>
<p>补充：</p>
<blockquote>
<p>调用block后，直接将block对象释放也可以解除循环引用。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>一般来说，<strong>必须执行block后，引用循环才可以被解除</strong>，容易出现遗漏的情况。</p>
</blockquote>
<h4 id="2-非ARC下的Block内存控制"><a href="#2-非ARC下的Block内存控制" class="headerlink" title="2.非ARC下的Block内存控制"></a>2.非ARC下的Block内存控制</h4><h5 id="2-1-非ARC下的Block引用循环"><a href="#2-1-非ARC下的Block引用循环" class="headerlink" title="2.1 非ARC下的Block引用循环"></a>2.1 非ARC下的Block引用循环</h5><p>由于<strong>非ARC环境下</strong>，无法使用所有权修饰符，故<strong>只能通过__block变量的方式来解决引用循环问题</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        <span class="comment">// 初始化block成员</span></div><div class="line">        </div><div class="line">        __block TestObject *blockSelf = self;</div><div class="line">        myBlock = ^&#123;</div><div class="line">            NSLog(@<span class="string">"blockSelf - %@"</span>, blockSelf);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上述代码中，直接使用__block对象即可，无需释放，即可避免生成引用循环。</p>
<p>原因：</p>
<blockquote>
<p><strong>非ARC环境下，__block变量被分配到堆内存时，不会对内部的OC对象进行强引用</strong>；<br>因此，在block对象函数内部，不会对OC对象发生强引用，相当于ARC下的<strong>weak和</strong>unsafe_unretained的情况。</p>
</blockquote>
<h5 id="2-2-非ARC环境下的Block内存使用规则补充"><a href="#2-2-非ARC环境下的Block内存使用规则补充" class="headerlink" title="2.2 非ARC环境下的Block内存使用规则补充"></a>2.2 非ARC环境下的Block内存使用规则补充</h5><ul>
<li>对不同内存区域的block执行retain和copy操作的结果：</li>
</ul>
<table>
<thead>
<tr>
<th>block对象所在的内存区域</th>
<th>执行操作</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>栈</td>
<td>retain</td>
<td>无效</td>
</tr>
<tr>
<td>栈</td>
<td>copy</td>
<td>复制到堆内存</td>
</tr>
<tr>
<td>堆</td>
<td>retain</td>
<td>产生强引用</td>
</tr>
<tr>
<td>堆</td>
<td>copy</td>
<td>产生强引用</td>
</tr>
</tbody>
</table>
<ul>
<li>在C语言环境下，可以使用Block_copy()和Block_release()对堆内存的block对象进行内存管理。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Blocks篇：7-循环引用问题&quot;&gt;&lt;a href=&quot;#Blocks篇：7-循环引用问题&quot; class=&quot;headerlink&quot; title=&quot;Blocks篇：7.循环引用问题&quot;&gt;&lt;/a&gt;Blocks篇：7.循环引用问题&lt;/h2&gt;&lt;h4 id=&quot;1-ARC下的Block循环引用&quot;&gt;&lt;a href=&quot;#1-ARC下的Block循环引用&quot; class=&quot;headerlink&quot; title=&quot;1.ARC下的Block循环引用&quot;&gt;&lt;/a&gt;1.ARC下的Block循环引用&lt;/h4&gt;&lt;h5 id=&quot;1-1-使用weak或unsafe-unretained避免循环引用&quot;&gt;&lt;a href=&quot;#1-1-使用weak或unsafe-unretained避免循环引用&quot; class=&quot;headerlink&quot; title=&quot;1.1 使用weak或unsafe_unretained避免循环引用&quot;&gt;&lt;/a&gt;1.1 使用&lt;strong&gt;weak或&lt;/strong&gt;unsafe_unretained避免循环引用&lt;/h5&gt;&lt;p&gt;一般来说，最简单的这种情况即：&lt;em&gt;block对象作为OC对象的成员，而在block函数体内部直接或间接捕获了该OC对象，造成互相强引用&lt;/em&gt;。举例来说：&lt;br&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》15</title>
    <link href="http://yoursite.com/2019/01/15/Blocks%E7%AF%87%EF%BC%9A6.Blocks%E6%8D%95%E8%8E%B7%E7%9A%84OC%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/01/15/Blocks篇：6.Blocks捕获的OC对象及其内存管理/</id>
    <published>2019-01-15T04:12:24.974Z</published>
    <updated>2019-01-15T04:12:24.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Blocks篇：6-Blocks捕获的OC对象及其内存管理"><a href="#Blocks篇：6-Blocks捕获的OC对象及其内存管理" class="headerlink" title="Blocks篇：6.Blocks捕获的OC对象及其内存管理"></a>Blocks篇：6.Blocks捕获的OC对象及其内存管理</h2><blockquote>
<p>之前所说的，都是Block对象捕获基本数据类型变量时的处理方式。现在我们看一下对于OC对象被Block捕获时的情况。<br><a id="more"></a></p>
<h4 id="1-Block对象捕获OC对象"><a href="#1-Block对象捕获OC对象" class="headerlink" title="1.Block对象捕获OC对象"></a>1.Block对象捕获OC对象</h4></blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(^MyBlock)</span><span class="params">(id obj)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        MyBlock myBlock;</div><div class="line">        </div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 声明数组作为被捕获变量</span></div><div class="line">            NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</div><div class="line">        </div><div class="line">            <span class="comment">// 声明block</span></div><div class="line">            myBlock = ^(id obj)&#123;</div><div class="line">                <span class="comment">// 向捕获的数组中添加对象</span></div><div class="line">                [<span class="built_in">array</span> addObject:obj];</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"个数：%ld\n"</span>, <span class="built_in">array</span>.count);</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 执行block</span></div><div class="line">        myBlock([NSObject <span class="keyword">new</span>]);</div><div class="line">        myBlock([NSObject <span class="keyword">new</span>]);</div><div class="line">        myBlock([NSObject <span class="keyword">new</span>]);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此代码运行正常无误。这也直接证明了<strong>Block对象对该数组对象进行了强引用，使被捕获对象的生存周期超过了原始作用域</strong>。究其原因，查看部分转换后的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"></div><div class="line"><span class="comment">/** Block的完整结构体 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    <span class="comment">// 声明捕获的OC对象（ARC下为__strong修饰，强引用）</span></div><div class="line">    NSMutableArray *<span class="built_in">array</span>;</div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, NSMutableArray *_array, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="built_in">array</span>(_array) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp;</div><div class="line">        Desc = desc;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/** Block的执行函数 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself, id obj) &#123;</div><div class="line">    NSMutableArray *<span class="built_in">array</span> = __cself-&gt;<span class="built_in">array</span>; <span class="comment">// bound by copy</span></div><div class="line">    </div><div class="line">    ((<span class="keyword">void</span> (*)(id, SEL, ObjectType _Nonnull))(<span class="keyword">void</span> *)objc_msgSend)((id)<span class="built_in">array</span>, sel_registerName(<span class="string">"addObject:"</span>), (id)obj);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"个数：%ld\n"</span>, ((NSUInteger (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)<span class="built_in">array</span>, sel_registerName(<span class="string">"count"</span>)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Block复制到堆时附带执行的函数 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</div><div class="line">    <span class="comment">// _Block_object_assign相当于retain；BLOCK_FIELD_IS_OBJECT标明捕获对象为OC对象</span></div><div class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="built_in">array</span>, (<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Block复制从堆中释放时附带执行的函数 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</div><div class="line">    <span class="comment">// _Block_object_dispose相当于release；BLOCK_FIELD_IS_OBJECT标明捕获对象为OC对象</span></div><div class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Block描述信息结构体 */</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></div><div class="line">  <span class="keyword">size_t</span> reserved;</div><div class="line">  <span class="keyword">size_t</span> Block_size;</div><div class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div></pre></td></tr></table></figure>
<p>在转换代码中显而易见，Block将捕获的OC对象以强引用的方式（ARC下隐含为__strong），作为结构体的成员变量。并在Block的描述信息对象中提供了copy和dispose方法，在适当时机调用以配合内存管理。</p>
<p>注意：</p>
<blockquote>
<ul>
<li><strong>由于编译器支持Block结构的类引用计数的内存管理方式，即ARC下，系统可以在适当时机分配和释放Block对象的内存。故在Block的相关结构体中可以直接存入带有所有权修饰符的OC对象。</strong></li>
<li><strong>由于OC对象本身分配在堆内存中，Block对象只需通过指针传递即可完成捕获</strong>。</li>
<li>由于捕获后，<strong>Block对象也参与了OC对象的内存管理，故需要提供保留和释放相关函数</strong>，以备系统在堆内存中创建（copy操作）和释放Block对象（dispose操作）时进行调用。这里则与__block变量时一样，使用了<em>_Block_object_assign</em>和<em>_Block_object_dispose</em>函数对OC对象进行保留和释放操作。</li>
</ul>
</blockquote>
<p>补充：</p>
<p>在<em>_Block_object_assign</em>以及<em>_Block_object_dispose</em>中，用于区分捕获变量类型的标识：</p>
<table>
<thead>
<tr>
<th>捕获的对象</th>
<th>标识值</th>
</tr>
</thead>
<tbody>
<tr>
<td>OC对象</td>
<td>BLOCK_FIELD_IS_OBJECT</td>
</tr>
<tr>
<td>__block修饰的变量或对象</td>
<td>BLOCK_FIELD_IS_BYREF</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="2-block修饰的OC对象"><a href="#2-block修饰的OC对象" class="headerlink" title="2.__block修饰的OC对象"></a>2.__block修饰的OC对象</h4><h5 id="2-1-block修饰的强引用对象（strong所有权）"><a href="#2-1-block修饰的强引用对象（strong所有权）" class="headerlink" title="2.1 block修饰的强引用对象（strong所有权）"></a>2.1 <strong>block修饰的强引用对象（</strong>strong所有权）</h5><p>还是先看实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        <span class="comment">// 声明__block修饰的OC对象</span></div><div class="line">        __block NSObject *myObj = [[NSObject alloc] init];</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">            <span class="comment">// 修改捕获对象</span></div><div class="line">            myObj = [[NSArray alloc] init];</div><div class="line">        &#125;;</div><div class="line">        </div><div class="line">        <span class="comment">// 执行Block</span></div><div class="line">        myBlock();</div><div class="line">        </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (__bridge <span class="keyword">void</span> *)myObj);</div><div class="line">        </div><div class="line">        <span class="comment">// 修改__block对象</span></div><div class="line">        myObj = [[NSObject alloc] init];</div><div class="line">        </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (__bridge <span class="keyword">void</span> *)myObj);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，当Block执行后，在外部读取捕获的OC对象，可以发现仍然指向同一地址。这与__block修饰基本变量的情况一致，也是需要通过生成特定捕获变量的结构体实例，在拷贝到堆内存后，最终访问均指向相同的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"></div><div class="line"><span class="comment">/** 捕获对象的结构体 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_myObj_0</span> &#123;</span></div><div class="line">    <span class="keyword">void</span> *__isa;</div><div class="line">    <span class="comment">/** 指向自身结构体实例的指针 */</span></div><div class="line">    __Block_byref_myObj_0 *__forwarding;</div><div class="line">    <span class="keyword">int</span> __flags;</div><div class="line">    <span class="keyword">int</span> __size;</div><div class="line">    <span class="comment">/** 分配到堆内存时的执行函数 */</span></div><div class="line">    <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</div><div class="line">    <span class="comment">/** 在堆内存中释放时的执行函数 */</span></div><div class="line">    <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</div><div class="line">    <span class="comment">/** 真正的值（OC对象），在ARC下默认为__strong修饰 */</span></div><div class="line">    NSObject *myObj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_copy_131(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src) &#123;</div><div class="line">    <span class="comment">// 赋值并保留对象</span></div><div class="line">    _Block_object_assign((<span class="keyword">char</span>*)dst + <span class="number">40</span>, *(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_dispose_131(<span class="keyword">void</span> *src) &#123;</div><div class="line">    <span class="comment">// 释放对象</span></div><div class="line">    _Block_object_dispose(*(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    <span class="comment">/** 捕获对象的结构体实例 */</span></div><div class="line">    __Block_byref_myObj_0 *myObj; <span class="comment">// by ref</span></div><div class="line">    <span class="comment">/** 构造函数，其中捕获变量传递的是__forwarding指向的对象 */</span></div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_myObj_0 *_myObj, <span class="keyword">int</span> flags=<span class="number">0</span>) : myObj(_myObj-&gt;__forwarding) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp;</div><div class="line">        Desc = desc;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    </div><div class="line">    __Block_byref_myObj_0 *myObj = __cself-&gt;myObj; <span class="comment">// bound by ref</span></div><div class="line">    </div><div class="line">    <span class="comment">// 对堆中的__block对象（__forwarding实例中的OC对象）进行修改</span></div><div class="line">    (myObj-&gt;__forwarding-&gt;myObj) = ((NSArray *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((NSArray *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSArray"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** 在堆内存上生成时的回调函数 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</div><div class="line">    <span class="comment">// 对捕获生成的__block对象进行赋值并保留</span></div><div class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;myObj, (<span class="keyword">void</span>*)src-&gt;myObj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</div><div class="line">    <span class="comment">// 对捕获生成的__block对象进行释放</span></div><div class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;myObj, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> reserved;</div><div class="line">    <span class="keyword">size_t</span> Block_size;</div><div class="line">    <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">    <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; </div><div class="line">    <span class="number">0</span>, </div><div class="line">    <span class="keyword">sizeof</span>(struct __main_block_impl_0), </div><div class="line">    __main_block_copy_0, </div><div class="line">    __main_block_dispose_0</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="comment">/* @autoreleasepool */</span> </div><div class="line">    &#123; </div><div class="line">        __AtAutoreleasePool __autoreleasepool; </div><div class="line">        </div><div class="line">        <span class="comment">// 生成__block修饰的对象</span></div><div class="line">        __attribute__((__blocks__(byref))) __Block_byref_myObj_0 myObj = &#123;</div><div class="line">            (<span class="keyword">void</span>*)<span class="number">0</span>,</div><div class="line">            (__Block_byref_myObj_0 *)&amp;myObj, </div><div class="line">            <span class="number">33554432</span>, </div><div class="line">            <span class="keyword">sizeof</span>(__Block_byref_myObj_0),</div><div class="line">            <span class="comment">// 赋值OC对象的内存保留函数</span></div><div class="line">            __Block_byref_id_object_copy_131, </div><div class="line">            <span class="comment">// 赋值OC对象的内存释放函数</span></div><div class="line">            __Block_byref_id_object_dispose_131, </div><div class="line">            <span class="comment">// 创建真正的OC对象</span></div><div class="line">            ((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>))</div><div class="line">        &#125;;</div><div class="line">        </div><div class="line">        <span class="comment">// 声明并创建Block对象</span></div><div class="line">        <span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_myObj_0 *)&amp;myObj, <span class="number">570425344</span>));</div><div class="line">        </div><div class="line">        <span class="comment">// 调用Block并传入本身指针</span></div><div class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">        </div><div class="line">        <span class="comment">// 访问栈上的__block对象</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (__bridge <span class="keyword">void</span> *)(myObj.__forwarding-&gt;myObj));</div><div class="line">        </div><div class="line">        <span class="comment">// 修改栈上的__block对象</span></div><div class="line">        (myObj.__forwarding-&gt;myObj) = ((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</div><div class="line">        </div><div class="line">        <span class="comment">// 访问栈上的__block对象</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, (__bridge <span class="keyword">void</span> *)(myObj.__forwarding-&gt;myObj));</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>注意，这里相比较普通的<strong>block变量时，**在</strong>block变量结构体中，新增了对于__block变量在堆内存中进行分配和释放时的函数指针成员**：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 分配到堆内存时的执行函数 */</span></div><div class="line"><span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</div><div class="line"><span class="comment">/** 在堆内存中释放时的执行函数 */</span></div><div class="line"><span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</div></pre></td></tr></table></figure>
<p>这是<strong>由于__block修饰的是OC对象，其结构体实例赋值此OC对象的内存管理，故需要提供保留和释放操作。</strong></p>
<ul>
<li>同样的，<strong>在栈中（声明<strong>block对象所在的地方）或是堆中（Block对象执行的函数体中），都可以通过</strong>forwarding指针访问到相同的OC对象</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取堆内存中的__block对象【栈__block对象的__forwarding依然指向的是堆中的__block对象】</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_myObj_0</span> __<span class="title">blockVar_onHeap</span> = <span class="title">myObj</span>.__<span class="title">forwarding</span>;</span></div><div class="line"><span class="comment">// 得到真正的OC对象</span></div><div class="line">NSObject realObj = __blockVar_onStack-&gt;myObj;</div></pre></td></tr></table></figure>
<h4 id="2-2-block修饰的其他OC对象"><a href="#2-2-block修饰的其他OC对象" class="headerlink" title="2.2 __block修饰的其他OC对象"></a>2.2 __block修饰的其他OC对象</h4><ul>
<li>当__block修饰的OC对象为弱对象时，我们以最开始的例子进行修改验证：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(^MyBlock)</span><span class="params">(id obj)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        MyBlock myBlock;</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 声明数组</span></div><div class="line">            NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</div><div class="line">            </div><div class="line">            <span class="comment">// 将待捕获对象声明为弱对象</span></div><div class="line">            __block __weak NSMutableArray *weakArray = <span class="built_in">array</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 声明block</span></div><div class="line">            myBlock = ^(id obj)&#123;</div><div class="line">                [weakArray addObject:obj];</div><div class="line"></div><div class="line">                <span class="built_in">printf</span>(<span class="string">"个数：%ld\n"</span>, weakArray.count);</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 执行block（向数组中添加对象）</span></div><div class="line">        myBlock([NSObject <span class="keyword">new</span>]);</div><div class="line">        myBlock([NSObject <span class="keyword">new</span>]);</div><div class="line">        myBlock([NSObject <span class="keyword">new</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行情况为：</p>
<blockquote>
<p>个数：0<br>个数：0<br>个数：0<br>Program ended with exit code: 0</p>
</blockquote>
<p><strong>在<strong>block对象中保留的是数组的弱引用，当原数组对象释放后，</strong>block对象中的OC对象自动置为nil，故结果为0。</strong></p>
<ul>
<li>当<strong>block修饰的OC对象为</strong>unsafe_unretained修饰的对象时，与弱引用情况相同，只是需要保证不要访问野指针。</li>
<li><strong>block修饰的OC对象不允许标记为</strong>autoreleasing。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Blocks篇：6-Blocks捕获的OC对象及其内存管理&quot;&gt;&lt;a href=&quot;#Blocks篇：6-Blocks捕获的OC对象及其内存管理&quot; class=&quot;headerlink&quot; title=&quot;Blocks篇：6.Blocks捕获的OC对象及其内存管理&quot;&gt;&lt;/a&gt;Blocks篇：6.Blocks捕获的OC对象及其内存管理&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;之前所说的，都是Block对象捕获基本数据类型变量时的处理方式。现在我们看一下对于OC对象被Block捕获时的情况。&lt;br&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》14</title>
    <link href="http://yoursite.com/2019/01/15/Blocks%E7%AF%87%EF%BC%9A5.Blocks%E4%BF%AE%E6%94%B9%E6%8D%95%E8%8E%B7%E5%88%B0%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%88__block%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%89/"/>
    <id>http://yoursite.com/2019/01/15/Blocks篇：5.Blocks修改捕获到的变量（__block修饰符）/</id>
    <published>2019-01-15T04:11:24.722Z</published>
    <updated>2019-01-15T04:11:24.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Blocks篇：5-Blocks修改捕获到的变量（-block修饰符）"><a href="#Blocks篇：5-Blocks修改捕获到的变量（-block修饰符）" class="headerlink" title="Blocks篇：5.Blocks修改捕获到的变量（__block修饰符）"></a>Blocks篇：5.Blocks修改捕获到的变量（__block修饰符）</h2><blockquote>
<p>我们知道，在Block中，修改捕获变量的方式：</p>
<ul>
<li>对于全局变量，由于实质上Block并未对其进行捕获，故可以直接在Block函数体内部进行变量修改；</li>
<li>对于局部的静态变量，由于Block捕获的是其指针，故可以通过指针对原变量进行修改；</li>
<li>对于普通的局部变量，由于在Block函数体内使用的版本已经不是之前的变量了（是Block结构体中保存的成员），故编译器不支持直接修改。这种情况下，只能通过“__block”修饰变量进行处理。<a id="more"></a>
<h4 id="1-block修饰符带来的变化"><a href="#1-block修饰符带来的变化" class="headerlink" title="1.__block修饰符带来的变化"></a>1.__block修饰符带来的变化</h4></li>
</ul>
</blockquote>
<p>由于需修改局部变量，我们将栗子变成这个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        <span class="comment">// 声明__block修饰的局部变量</span></div><div class="line">        __block <span class="keyword">int</span> val = <span class="number">2</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">            <span class="comment">// 捕获后修改变量的值</span></div><div class="line">            val = <span class="number">3</span>;</div><div class="line">        &#125;;</div><div class="line">        myBlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用clang转换后，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"></div><div class="line"><span class="comment">/** Block数据结构体（没变） */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></div><div class="line">    <span class="keyword">void</span> *isa;</div><div class="line">    <span class="keyword">int</span> Flags;</div><div class="line">    <span class="keyword">int</span> Reserved;</div><div class="line">    <span class="keyword">void</span> *FuncPtr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** __block修饰的变量对应的结构体 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_val_0</span> &#123;</span></div><div class="line">    <span class="comment">/** 类型 */</span></div><div class="line">    <span class="keyword">void</span> *__isa;</div><div class="line">    <span class="comment">/** 指向自身结构体实例的指针 */</span></div><div class="line">    __Block_byref_val_0 *__forwarding;</div><div class="line">    <span class="keyword">int</span> __flags;</div><div class="line">    <span class="keyword">int</span> __size;</div><div class="line">    <span class="comment">/** 变量真正的值 */</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** Block完整结构体 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="comment">/** Block数据实例 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="comment">/** Block描述信息实例的指针 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    <span class="comment">/** __Block_byref_val_0实例的指针 */</span></div><div class="line">    __Block_byref_val_0 *val; <span class="comment">// by ref</span></div><div class="line">    <span class="comment">// 构造函数</span></div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp;</div><div class="line">        Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** Block的函数体 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    <span class="comment">// 取出保存的实例</span></div><div class="line">    __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></div><div class="line">    <span class="comment">// 取出对应的变量真实值？？？</span></div><div class="line">    (val-&gt;__forwarding-&gt;val) = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** __block变量对应的copy函数（复制Block对象时调用） */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** __block变量对应的dispose函数（释放Block对象时调用） */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Block描述信息结构体实例 */</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> reserved;</div><div class="line">    <span class="keyword">size_t</span> Block_size;</div><div class="line">    <span class="comment">/** copy函数指针 */</span></div><div class="line">    <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">    <span class="comment">/** dispose函数指针 */</span></div><div class="line">    <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; </div><div class="line">    <span class="number">0</span>, </div><div class="line">    <span class="keyword">sizeof</span>(struct __main_block_impl_0), </div><div class="line">    __main_block_copy_0, <span class="comment">// 赋值函数</span></div><div class="line">    __main_block_dispose_0 <span class="comment">// 赋值函数</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// main函数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="comment">/* @autoreleasepool */</span> </div><div class="line">    &#123; </div><div class="line">        __AtAutoreleasePool __autoreleasepool; </div><div class="line">        </div><div class="line">        <span class="comment">// 创建__block变量对应的__Block_byref_val_0结构体实例</span></div><div class="line">        <span class="comment">// （__attribute__部分表示需要变量为栈上的变量？？？）</span></div><div class="line">        __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;</div><div class="line">            (<span class="keyword">void</span>*)<span class="number">0</span>,</div><div class="line">            (__Block_byref_val_0 *)&amp;val, <span class="comment">// 指向自身实例</span></div><div class="line">            <span class="number">0</span>, </div><div class="line">            <span class="keyword">sizeof</span>(__Block_byref_val_0), </div><div class="line">            <span class="number">2</span> <span class="comment">// 真正的值</span></div><div class="line">        &#125;;</div><div class="line">        </div><div class="line">        <span class="comment">// 创建Block对象，并使用函数指针指向它</span></div><div class="line">        <span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = (</div><div class="line">            (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0(</div><div class="line">                (<span class="keyword">void</span> *)__main_block_func_0, <span class="comment">// 函数指针</span></div><div class="line">                &amp;__main_block_desc_0_DATA, <span class="comment">// 描述信息实例指针</span></div><div class="line">                (__Block_byref_val_0 *)&amp;val, <span class="comment">// 变量实例指针</span></div><div class="line">                <span class="number">570425344</span></div><div class="line">            )</div><div class="line">        );</div><div class="line">        </div><div class="line">        <span class="comment">// 调用Block中的函数</span></div><div class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在代码中可以看到，</p>
<ol>
<li>使用__block修饰的变量，由基本变量转变成了结构体实例；</li>
<li>当Block使用时，Block需要在其结构中保存此结构体实例的指针；</li>
<li>提供了copy和dispose函数用于管理捕获的__block变量的内存。</li>
</ol>
<h4 id="2-block变量的存储规则"><a href="#2-block变量的存储规则" class="headerlink" title="2.__block变量的存储规则"></a>2.__block变量的存储规则</h4><p>我们知道，当Block对象捕获变量后，ARC会自动将其复制到堆内存中。此时，被捕获的__block变量又会如何变化呢？</p>
<table>
<thead>
<tr>
<th>__block变量本身的存储域</th>
<th>Block从栈复制到堆时的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>栈</td>
<td>复制到堆内存中</td>
</tr>
<tr>
<td>堆</td>
<td>被该Block持有</td>
</tr>
</tbody>
</table>
<p>由上表可得出结论：</p>
<blockquote>
<ol>
<li>在Block捕获了__block变量的情况下，当Block在堆内存中生成后，该变量也会被自动拷贝到堆内存中，并继续被Block对象所持有。</li>
<li>__block变量的内存管理非常类似于引用计数的管理方式：被_NSConcreteMallocBlock对象持有时，变量存在；当没有被任何Block持有后，被系统释放。</li>
</ol>
</blockquote>
<p>现在，我们就可以来解释一下之前的疑问：为何<strong>block变量内部存在指向自身结构实例的</strong>forwarding指针；且取值或修改时，需要通过此指针取出val的值？</p>
<h5 id="2-1-block变量可以在Block内或外部随意修改"><a href="#2-1-block变量可以在Block内或外部随意修改" class="headerlink" title="2.1 __block变量可以在Block内或外部随意修改"></a>2.1 __block变量可以在Block内或外部随意修改</h5><p>开门见山，直接给出原因：</p>
<blockquote>
<p><strong><strong>block变量通过</strong>forwarding可以从任意内存区域访问同一块内存。</strong></p>
</blockquote>
<p>我们先来回顾一下__block变量在栈中的大体结构：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1547444843-%E5%AD%98%E5%82%A8%E5%9C%A8%E6%A0%88%E4%B8%AD%E7%9A%84__block%E5%8F%98%E9%87%8F%E7%BB%93%E6%9E%84.jpg" alt="存储在栈中的__block变量结构.jpg"></p>
<ol>
<li>我们知道，在普通情况下，Block函数体中的捕获变量是通过值传递复制进去的，其执行时，原变量早已释放；若需要同时可以访问或修改，必然需要该变量为同一块内存。</li>
<li>故<strong>block变量能够同时修改的原因，必然是在栈和堆中同时存在相同的变量指针，指向同一块内存。所以，根据存储规则，**当栈</strong>block变量被复制到堆内存时，原变量的__forwarding指针必然需要指向堆变量**，以满足此目的。</li>
</ol>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1547445309-%E5%A4%8D%E5%88%B6%E5%88%B0%E5%A0%86%E5%90%8E__block%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84.jpg" alt="复制到堆后__block变量的结构.jpg"></p>
<p>此时，<strong>无论是从栈中或是堆中访问<strong>block变量，均可以通过</strong>forwarding指针来访问到真正的变量值</strong>。如之前的Block函数体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    <span class="comment">// 取出保存的实例</span></div><div class="line">    __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></div><div class="line">    <span class="comment">// 通过__forwarding获取真正的变量实例，并取值</span></div><div class="line">    (val-&gt;__forwarding-&gt;val) = <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Block函数体中，由于val已经是<strong>堆<strong>block变量，故其</strong>forwarding指针指向自身</strong>，可以成功取到变量值。</p>
<p>而在Block外，直接访问或修改val的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val += <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>其转换后的代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val-&gt;__forwarding-&gt;val += <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>此时，<strong>栈变量val的__forwarding指针指向堆变量val</strong>，故其val与在堆中直接访问相同，均指向同一个val的地址。</p>
<h4 id="3-Block对象对捕获到的-block变量进行内存管理"><a href="#3-Block对象对捕获到的-block变量进行内存管理" class="headerlink" title="3.Block对象对捕获到的__block变量进行内存管理"></a>3.Block对象对捕获到的__block变量进行内存管理</h4><p>在上述实例中，Block对象的描述结构指定了copy和dispose两个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** copy函数 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** dispose函数 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> reserved;</div><div class="line">    <span class="keyword">size_t</span> Block_size;</div><div class="line">    <span class="comment">/** copy指针 */</span></div><div class="line">    <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">    <span class="comment">/** dispose指针 */</span></div><div class="line">    <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; </div><div class="line">    <span class="number">0</span>, </div><div class="line">    <span class="keyword">sizeof</span>(struct __main_block_impl_0),</div><div class="line">    <span class="comment">/** copy指针 */</span></div><div class="line">    __main_block_copy_0, </div><div class="line">    <span class="comment">/** dispose指针 */</span></div><div class="line">    __main_block_dispose_0</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li><strong>copy方法即为由_NSConcreteStackBlock对象copy生成_NSConcreteMallocBlock对象过程中进行的函数调用</strong>。这里即对捕获的__block变量进行指针复制（传递引用）。</li>
<li><strong>dispose方法为堆_NSConcreteMallocBlock对象释放时进行调用</strong>，内部即对捕获的__block变量进行释放操作，不再保留。</li>
</ul>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1547446878-%E6%A0%88Block%E5%A4%8D%E5%88%B6%E4%B8%BA%E5%A0%86Block%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="栈Block复制为堆Block的过程.jpg"></p>
<p>因此，经过此过程，<strong>堆内存中的Block对象强引用着同样处于堆内存中的<strong>block变量；当自身释放时，被保留的</strong>block变量的强引用失效</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Blocks篇：5-Blocks修改捕获到的变量（-block修饰符）&quot;&gt;&lt;a href=&quot;#Blocks篇：5-Blocks修改捕获到的变量（-block修饰符）&quot; class=&quot;headerlink&quot; title=&quot;Blocks篇：5.Blocks修改捕获到的变量（__block修饰符）&quot;&gt;&lt;/a&gt;Blocks篇：5.Blocks修改捕获到的变量（__block修饰符）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们知道，在Block中，修改捕获变量的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于全局变量，由于实质上Block并未对其进行捕获，故可以直接在Block函数体内部进行变量修改；&lt;/li&gt;
&lt;li&gt;对于局部的静态变量，由于Block捕获的是其指针，故可以通过指针对原变量进行修改；&lt;/li&gt;
&lt;li&gt;对于普通的局部变量，由于在Block函数体内使用的版本已经不是之前的变量了（是Block结构体中保存的成员），故编译器不支持直接修改。这种情况下，只能通过“__block”修饰变量进行处理。
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》13</title>
    <link href="http://yoursite.com/2019/01/15/Blocks%E7%AF%87%EF%BC%9A4.Blocks%E7%9A%84%E5%AD%98%E5%82%A8%E5%9F%9F%EF%BC%88ARC%E4%B8%8B_NSConcreteBlock%E7%9A%84%E9%99%B7%E9%98%B1%EF%BC%89/"/>
    <id>http://yoursite.com/2019/01/15/Blocks篇：4.Blocks的存储域（ARC下_NSConcreteBlock的陷阱）/</id>
    <published>2019-01-15T04:10:25.966Z</published>
    <updated>2019-01-15T04:10:25.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Blocks篇：4-Blocks的存储域（ARC下-NSConcreteBlock的陷阱）"><a href="#Blocks篇：4-Blocks的存储域（ARC下-NSConcreteBlock的陷阱）" class="headerlink" title="Blocks篇：4.Blocks的存储域（ARC下_NSConcreteBlock的陷阱）"></a>Blocks篇：4.Blocks的存储域（ARC下_NSConcreteBlock的陷阱）</h2><blockquote>
<p>在上一节中我们知道，在Block捕获不同种类的变量时，生成的Block对象的类型(isa指针)分为三种：</p>
<ul>
<li>_NSConcreteStackBlock</li>
<li>_NSConcreteGlobalBlock</li>
<li>_NSConcreteMallocBlock</li>
</ul>
<p>此三种类型的Block对象分别存储在栈区、全局（数据区）和堆区<br><a id="more"></a><br>我们知道，<strong>由于Block对象的函数体定义在Block实例化的生命周期外部，故其执行时早已不在原作用域内</strong>。况且，由于在函数中，定义的Block对象也是局部变量，超出作用域也会被自动回收。所以，<strong>要保证Block超出原作用域仍然可以存在的方式，就是将其转化为全局Block，或者复制到堆内存中</strong>，这样才可以保证其内存可控并正确执行Block的函数。在ARC环境下，LLVM在编译期已经可以在绝大多数情况下正确处理这种情况。通过测试，编码时定义的局部Block变量（即_NSConcreteStackBlock对象），在运行时可以得到如下结果：</p>
</blockquote>
<table>
<thead>
<tr>
<th>捕获变量情况</th>
<th>运行期生成的Block对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>_NSConcreteGlobalBlock</td>
</tr>
<tr>
<td>全局或静态变量</td>
<td>_NSConcreteGlobalBlock</td>
</tr>
<tr>
<td>普通局部变量</td>
<td>_NSConcreteMallocBlock</td>
</tr>
</tbody>
</table>
<p>但是，发现在一种情况下，ARC不会自动处理，需要我们对Block对象进行手动转换。</p>
<h4 id="1-ARC下的Blocks陷阱"><a href="#1-ARC下的Blocks陷阱" class="headerlink" title="1.ARC下的Blocks陷阱"></a>1.ARC下的Blocks陷阱</h4><p>先看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(^VoidBlock)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/** 返回包含Block对象的集合的函数 */</span></div><div class="line"><span class="function">NSArray *<span class="title">getBlocksArray</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> myVal = <span class="number">2</span>;</div><div class="line">    <span class="comment">// 内部的Block对象均为__NSConcreteStackBlock对象</span></div><div class="line">    <span class="keyword">return</span> [[NSArray alloc] initWithObjects:</div><div class="line">            ^&#123;NSLog(@<span class="string">"block1~%d"</span>, myVal);&#125;,</div><div class="line">            ^&#123;NSLog(@<span class="string">"block2~%d"</span>, myVal);&#125;,</div><div class="line">            nil</div><div class="line">            ];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        <span class="comment">// 获取该数组</span></div><div class="line">        NSArray *blocksArray = getBlocksArray();</div><div class="line">        <span class="comment">// 取出Block对象</span></div><div class="line">        VoidBlock voidBlock = blocksArray[<span class="number">0</span>];</div><div class="line">        <span class="comment">// 执行</span></div><div class="line">        voidBlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行情况，我们可以直接得到个漂亮的“EXC_BAD_ACCESS”。</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1547286721-Block%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%9D%91.jpg" alt="Block在集合中的坑"></p>
<blockquote>
<p>在图中已经看出，这种情况下，编译器并没有将捕获有变量的Block拷贝至堆中。故在准备执行时，Block对象已经被释放（第一个被转成__NSConcreteMallocBlock的原因是由于NSArray的init方法会自动保留对象，进而发生了Block的copy操作）。当执行完毕后，由于数组对象的释放，在对其内部元素依次释放时访问了野指针，导致崩溃。</p>
</blockquote>
<p>所以，在集合中使用Block对象时，为了保证其安全性，我们可以有两种方式：</p>
<ol>
<li>手动将Block复制到堆中：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSArray *<span class="title">getBlocksArray</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> myVal = <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> [[NSArray alloc] initWithObjects:</div><div class="line">            [^&#123;NSLog(@<span class="string">"block1~%d"</span>, myVal);&#125; copy],</div><div class="line">            [^&#123;NSLog(@<span class="string">"block2~%d"</span>, myVal);&#125; copy],</div><div class="line">            nil</div><div class="line">            ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>由于Block是OC对象，故对其发送copy消息可以直接将其转换为__NSConcreteMallocBlock对象。</strong></p>
<ol>
<li>在初始化Block时，利用ARC的特性，<strong>对Block进行显式声明，以获取“<strong>strong”修饰的Block，自动生成</strong>NSConcreteMallocBlock对象</strong>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSArray *<span class="title">getBlocksArray</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> myVal = <span class="number">2</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 生成了强引用Block变量，自动分配到了堆内存中</span></div><div class="line">    VoidBlock block1 = ^&#123;NSLog(@<span class="string">"block1~%d"</span>, myVal);&#125;;</div><div class="line">    VoidBlock block2 = ^&#123;NSLog(@<span class="string">"block2~%d"</span>, myVal);&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [[NSArray alloc] initWithObjects:</div><div class="line">            block1,</div><div class="line">            block2,</div><div class="line">            nil</div><div class="line">            ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：例外情况</strong></p>
<blockquote>
<p>在系统带有Block参数的API中（如GCD或是Animation相关等等），无需手动对Block进行复制（其内部实现已经包含了复制操作）。</p>
</blockquote>
<h4 id="2-Blocks的保留操作"><a href="#2-Blocks的保留操作" class="headerlink" title="2.Blocks的保留操作"></a>2.Blocks的保留操作</h4><h5 id="2-1-Blocks的保留解析"><a href="#2-1-Blocks的保留解析" class="headerlink" title="2.1 Blocks的保留解析"></a>2.1 Blocks的保留解析</h5><p>我们知道，在生成__strong修饰的Block对象时，其实隐含的对生成的对象进行了retain操作。此操作实际为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">VoidBlock blockObj = ...;</div><div class="line"><span class="comment">// 对Block进行保留操作</span></div><div class="line">objc_retainBlock(blockObj);</div><div class="line">...</div></pre></td></tr></table></figure>
<p>在NSObject.mm中，我们找到了此方法的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSObject.mm</span></div><div class="line"></div><div class="line"><span class="function">id <span class="title">objc_retainBlock</span><span class="params">(id x)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (id)_Block_copy(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，<strong>对Block进行retain其实也就是进行了copy操作，进而在堆上生成了Block</strong>。</p>
<h5 id="2-2-Blocks的copy操作"><a href="#2-2-Blocks的copy操作" class="headerlink" title="2.2 Blocks的copy操作"></a>2.2 Blocks的copy操作</h5><p>现在，我们知道了对栈中的Block进行复制或保留操作，会在堆内存上生成对应的Block对象。但对于其他两者呢？</p>
<table>
<thead>
<tr>
<th>copy对应Block</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td>无作用</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>引用计数 + 1</td>
</tr>
</tbody>
</table>
<p>对于堆内存中的Block对象，其实是遵循了引用计数的内存管理方式。因此，在使用Block对象时，也要注意引用循环问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Blocks篇：4-Blocks的存储域（ARC下-NSConcreteBlock的陷阱）&quot;&gt;&lt;a href=&quot;#Blocks篇：4-Blocks的存储域（ARC下-NSConcreteBlock的陷阱）&quot; class=&quot;headerlink&quot; title=&quot;Blocks篇：4.Blocks的存储域（ARC下_NSConcreteBlock的陷阱）&quot;&gt;&lt;/a&gt;Blocks篇：4.Blocks的存储域（ARC下_NSConcreteBlock的陷阱）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在上一节中我们知道，在Block捕获不同种类的变量时，生成的Block对象的类型(isa指针)分为三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;_NSConcreteStackBlock&lt;/li&gt;
&lt;li&gt;_NSConcreteGlobalBlock&lt;/li&gt;
&lt;li&gt;_NSConcreteMallocBlock&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此三种类型的Block对象分别存储在栈区、全局（数据区）和堆区&lt;br&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》12</title>
    <link href="http://yoursite.com/2019/01/15/Blocks%E7%AF%87%EF%BC%9A3.Blocks%E4%BD%BF%E7%94%A8%E6%8D%95%E8%8E%B7%E5%88%B0%E7%9A%84%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2019/01/15/Blocks篇：3.Blocks使用捕获到的变量/</id>
    <published>2019-01-15T04:09:21.983Z</published>
    <updated>2019-01-15T04:09:33.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Blocks篇：3-Blocks使用捕获到的变量"><a href="#Blocks篇：3-Blocks使用捕获到的变量" class="headerlink" title="Blocks篇：3.Blocks使用捕获到的变量"></a>Blocks篇：3.Blocks使用捕获到的变量</h2><blockquote>
<p>所谓Blocks捕获变量，即在Block函数体内使用外部声明的变量。</p>
</blockquote>
<h4 id="1-捕获局部变量（自动变量）和静态局部变量"><a href="#1-捕获局部变量（自动变量）和静态局部变量" class="headerlink" title="1. 捕获局部变量（自动变量）和静态局部变量"></a>1. 捕获局部变量（自动变量）和静态局部变量</h4><a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        <span class="keyword">int</span> uselessVal = <span class="number">1</span>;</div><div class="line">        <span class="comment">// 局部变量</span></div><div class="line">        <span class="keyword">int</span> val = <span class="number">3</span>;</div><div class="line">        <span class="comment">// 静态局部变量</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">int</span> staticVal = <span class="number">4</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">            <span class="comment">// 捕获val和staticVal使用</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"val = %d\n"</span>, val);</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"staticVal = %d\n"</span>, staticVal);</div><div class="line">        &#125;;</div><div class="line">        myBlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转换后的C++代码部分如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"></div><div class="line"><span class="comment">/** Block的完整结构体声明 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    <span class="keyword">int</span> val; <span class="comment">// 内部捕获的局部变量</span></div><div class="line">    <span class="keyword">int</span> *staticVal; <span class="comment">// 内部捕获的静态局部变量</span></div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _val, <span class="keyword">int</span> *_staticVal, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val), staticVal(_staticVal) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock; <span class="comment">// 这里只按照MRC编译确定，ARC则不同</span></div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp;</div><div class="line">        Desc = desc;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** Block中函数体转换生成的C函数 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    <span class="comment">// 获取Block结构体实例中捕获的变量</span></div><div class="line">    <span class="keyword">int</span> val = __cself-&gt;val; <span class="comment">// bound by copy</span></div><div class="line">    <span class="keyword">int</span> *staticVal = __cself-&gt;staticVal; <span class="comment">// bound by copy</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"val = %d\n"</span>, val);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"staticVal = %d\n"</span>, (*staticVal));</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// main函数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line">        <span class="keyword">int</span> uselessVal = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> val = <span class="number">3</span>;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">int</span> staticVal = <span class="number">4</span>;</div><div class="line"></div><div class="line">        <span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, val, &amp;staticVal)); <span class="comment">// 初始化时赋值，将要捕获的变量传递进去</span></div><div class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上可以看出：</p>
<ol>
<li><strong>只有Block内部使用的变量才会被捕获；</strong></li>
<li><strong>普通的局部变量是通过值传递方式进行捕获，静态局部变量是通过指针传递方式进行的；</strong><ul>
<li>原因：<ol>
<li><em>由于C函数的声明和实现是在原局部变量的生命周期之外（这里是main函数外部），使用时原变量早已被释放，故需要直接将值保存到Block结构体实例中；</em></li>
<li><em>对于静态局部变量，由于静态变量是存储在专门的数据区（也就可以理解为全局），在C函数中也可以直接访问，故只需将其指针保存在Block结构体实例中即可。</em></li>
</ol>
</li>
</ul>
</li>
<li><strong>C函数内部使用时，通过传递进去的Block指针取出被捕获的变量值。</strong></li>
<li>补充：<strong>在ARC环境下，对于Block的类型（isa）</strong>，<ul>
<li><strong>捕获普通局部变量后，在运行时，系统会将Block拷贝到堆上，变为_NSConcreteMallocBlock</strong></li>
<li><strong>捕获静态局部变量，虽然使用，实际也只是记录该变量的指针，Block为_NSConcreteGlobalBlock</strong></li>
<li><strong>没有捕获任何变量的Block为_NSConcreteGlobalBlock类型</strong></li>
</ul>
</li>
</ol>
<h4 id="2-捕获全局变量和全局静态变量"><a href="#2-捕获全局变量和全局静态变量" class="headerlink" title="2. 捕获全局变量和全局静态变量"></a>2. 捕获全局变量和全局静态变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> globalVal = <span class="number">3</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> globalStaticVal = <span class="number">4</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        <span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"globalVal = %d\n"</span>, globalVal);</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"globalStaticVal = %d\n"</span>, globalStaticVal);</div><div class="line">        &#125;;</div><div class="line">        myBlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转换后的C++部分代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> globalVal = <span class="number">3</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> globalStaticVal = <span class="number">4</span>;</div><div class="line"></div><div class="line"><span class="comment">/** Block完整结构体声明 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="comment">// 没有保存全局变量</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp;</div><div class="line">        Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    <span class="comment">// 直接使用</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"globalVal = %d\n"</span>, globalVal);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"globalStaticVal = %d\n"</span>, globalStaticVal);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，</p>
<ol>
<li><strong>对于全局变量（包含静态全局变量），由于在Block的C函数中可以直接访问，故无需在Block结构中对其进行额外的保存工作</strong>。</li>
<li><strong>在ARC环境下，Block的类型（isa）为_NSConcreteGlobalBlock</strong></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Blocks篇：3-Blocks使用捕获到的变量&quot;&gt;&lt;a href=&quot;#Blocks篇：3-Blocks使用捕获到的变量&quot; class=&quot;headerlink&quot; title=&quot;Blocks篇：3.Blocks使用捕获到的变量&quot;&gt;&lt;/a&gt;Blocks篇：3.Blocks使用捕获到的变量&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;所谓Blocks捕获变量，即在Block函数体内使用外部声明的变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-捕获局部变量（自动变量）和静态局部变量&quot;&gt;&lt;a href=&quot;#1-捕获局部变量（自动变量）和静态局部变量&quot; class=&quot;headerlink&quot; title=&quot;1. 捕获局部变量（自动变量）和静态局部变量&quot;&gt;&lt;/a&gt;1. 捕获局部变量（自动变量）和静态局部变量&lt;/h4&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》11</title>
    <link href="http://yoursite.com/2019/01/15/Blocks%E7%AF%87%EF%BC%9A2.Blocks%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%85%B6%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%B4%A8/"/>
    <id>http://yoursite.com/2019/01/15/Blocks篇：2.Blocks的调用过程及其对象本质/</id>
    <published>2019-01-15T04:06:05.910Z</published>
    <updated>2019-01-15T04:06:17.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Blocks篇：2-Blocks的调用过程及其对象本质"><a href="#Blocks篇：2-Blocks的调用过程及其对象本质" class="headerlink" title="Blocks篇：2.Blocks的调用过程及其对象本质"></a>Blocks篇：2.Blocks的调用过程及其对象本质</h2><blockquote>
<ul>
<li>Blocks实际上是通过支持Block的编译器，将其转换为标准的C代码进行编译。</li>
<li>我们可以使用clang的“-rewrite-objc”命令，将包含Block的源代码转换为C++代码，帮助理解。<a id="more"></a>
<h4 id="1-Blocks的调用过程"><a href="#1-Blocks的调用过程" class="headerlink" title="1. Blocks的调用过程"></a>1. Blocks的调用过程</h4>多说无用，来个最简单的栗子说明吧：</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        <span class="comment">// 声明并赋值myBlock</span></div><div class="line">        <span class="keyword">void</span> (^myBlock)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Hello Block~\n"</span>);</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">// 调用myBlock</span></div><div class="line">        myBlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>使用”<em>clang -rewrite-objc main.m</em>“转换后的代码为：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.cpp</span></div><div class="line"></div><div class="line"><span class="comment">/** Block结构体 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></div><div class="line">  <span class="comment">/** 类型指针 */</span></div><div class="line">  <span class="keyword">void</span> *isa;</div><div class="line">  <span class="keyword">int</span> Flags;</div><div class="line">  <span class="keyword">int</span> Reserved;</div><div class="line">  <span class="comment">/** 函数指针 */</span></div><div class="line">  <span class="keyword">void</span> *FuncPtr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** Block变量完整结构体声明 */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></div><div class="line">    <span class="comment">/** Block结构体实例 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></div><div class="line">    <span class="comment">/** 描述信息对象指针 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></div><div class="line">    </div><div class="line">    <span class="comment">/** 本结构体的构造函数 */</span></div><div class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock; <span class="comment">// isa指针赋值，即证明了Block是“对象”（由于默认clang没有开启ARC，ARC下这里是__NSGlobalBlock__，即_NSConcreteGlobalBlock）</span></div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp; <span class="comment">// 函数指针赋值</span></div><div class="line">        Desc = desc; <span class="comment">// 描述信息指针赋值</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/** Block中真正的函数体 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello Block~\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Block描述结构体声明，并实例化 */</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> reserved;</div><div class="line">    <span class="keyword">size_t</span> Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 原main函数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="comment">/* @autoreleasepool */</span> </div><div class="line">    &#123; </div><div class="line">        __AtAutoreleasePool __autoreleasepool; </div><div class="line">        </div><div class="line">        <span class="comment">// 声明了myBlock的C函数指针</span></div><div class="line">        <span class="comment">// 指向了__main_block_impl_0的结构体实例</span></div><div class="line">        <span class="keyword">void</span> (*myBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">        </div><div class="line">        <span class="comment">// 使用__block_impl实例中的函数指针FuncPtr进行函数调用（传入__block_impl实例的指针作为参数）</span></div><div class="line">        <span class="comment">// 即为原 myBlock()</span></div><div class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>以上代码中，在main函数中，简化后的myBlock声明为：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建 __main_block_impl_0结构体实例</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> <span class="title">tmp</span> = __<span class="title">main_block_impl_0</span>(__<span class="title">main_block_func_0</span>, &amp;__<span class="title">main_block_desc_0_DATA</span>);</span></div><div class="line"><span class="comment">// 赋值给__main_block_impl_0结构体的指针</span></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> *<span class="title">myBlock</span> = &amp;<span class="title">tmp</span>;</span></div></pre></td></tr></table></figure>
<ol>
<li>简化后的myBlock调用为：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取结构体实例中的myImpl成员</span></div><div class="line"> __block_impl myImpl = (*myBlock).impl;</div><div class="line"> <span class="comment">// myImpl的FuncPtr成员即为真正的函数指针，直接进行调用并传参</span></div><div class="line"> (myImpl.FuncPtr)(*myBlock);</div></pre></td></tr></table></figure>
<p>由此，在编译期间，我们了解了<strong>Blocks的声明和整个调用过程</strong>：</p>
<blockquote>
<ol>
<li>系统在原声明Block的生命周期外，生成静态的相关Block结构体、描述信息结构体和执行函数等。</li>
<li>在原声明Block的生命周期内部，使用相关结构体创建并生成Block的实例。</li>
<li>根据生成的Block实例，找到其中的C函数指针，进行调用。</li>
</ol>
</blockquote>
<h4 id="2-Blocks是对象"><a href="#2-Blocks是对象" class="headerlink" title="2.Blocks是对象"></a>2.Blocks是对象</h4><p>对于Block变量的本质，上面代码中可以看出：</p>
<blockquote>
<ol>
<li>在Block的结构体__block_impl中，包含了isa成员变量，是（void *）类型；</li>
<li>isa变量在初始化Block时，赋值的是_NSConcreteStackBlock的地址；</li>
</ol>
</blockquote>
<h5 id="2-1-isa"><a href="#2-1-isa" class="headerlink" title="2.1 isa"></a>2.1 isa</h5><p>我们知道，isa标识的是OC对象的类型。在<em>objc-private.h</em>中可以找到声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// objc_object</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">isa_t</span> isa;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// isa_t</span></div><div class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">// 指向的是对应的Class</span></div><div class="line">    Class cls;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** id是objc_object结构体指针（id即为OC对象）*/</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></div><div class="line"></div><div class="line"><span class="comment">/** Class是objc_class结构体指针 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// objc_class</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</div><div class="line">    <span class="comment">// Class ISA;</span></div><div class="line">    Class superclass;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在以上代码中可以看到：</p>
<blockquote>
<ol>
<li>id（我们说的OC对象），即objc_object结构体指针，其类型的实质，就是isa联合体的cls成员，也就是指向的Class；</li>
<li>由于objc_class“继承”了objc_object结构体，故其中也包含了isa成员，即“类”也标识了自己所属的类（metaclass，说多了…）。</li>
</ol>
</blockquote>
<h4 id="2-2-NSConcreteStackBlock类型"><a href="#2-2-NSConcreteStackBlock类型" class="headerlink" title="2.2 _NSConcreteStackBlock类型"></a>2.2 _NSConcreteStackBlock类型</h4><ol>
<li>对于_NSConcreteStackBlock，我们可以在main.cpp中找到其声明：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Runtime copy/destroy helper functions (from Block_private.h)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __OBJC_EXPORT_BLOCKS</span></div><div class="line">...</div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllexport) <span class="keyword">void</span> *_NSConcreteGlobalBlock[<span class="number">32</span>];</div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllexport) <span class="keyword">void</span> *_NSConcreteStackBlock[<span class="number">32</span>];</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">...</div><div class="line">__OBJC_RW_DLLIMPORT <span class="keyword">void</span> *_NSConcreteGlobalBlock[<span class="number">32</span>];</div><div class="line">__OBJC_RW_DLLIMPORT <span class="keyword">void</span> *_NSConcreteStackBlock[<span class="number">32</span>];</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>可以看到，_NSConcreteStackBlock声明的是一个数组的指针。</p>
<ol>
<li>而在GNUStep的开源版本中，我们找到了直接支持”Block是对象“的证据：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> _<span class="title">NSConcreteGlobalBlock</span>;</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> _<span class="title">NSConcreteStackBlock</span>;</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> _<span class="title">NSConcreteMallocBlock</span>;</span></div></pre></td></tr></table></figure>
<p>故我们可以将Block看做是OC对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Blocks篇：2-Blocks的调用过程及其对象本质&quot;&gt;&lt;a href=&quot;#Blocks篇：2-Blocks的调用过程及其对象本质&quot; class=&quot;headerlink&quot; title=&quot;Blocks篇：2.Blocks的调用过程及其对象本质&quot;&gt;&lt;/a&gt;Blocks篇：2.Blocks的调用过程及其对象本质&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Blocks实际上是通过支持Block的编译器，将其转换为标准的C代码进行编译。&lt;/li&gt;
&lt;li&gt;我们可以使用clang的“-rewrite-objc”命令，将包含Block的源代码转换为C++代码，帮助理解。
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》10</title>
    <link href="http://yoursite.com/2019/01/15/Blocks%E7%AF%87%EF%BC%9A1.Blocks%E7%9A%84%E5%A3%B0%E6%98%8E/"/>
    <id>http://yoursite.com/2019/01/15/Blocks篇：1.Blocks的声明/</id>
    <published>2019-01-15T04:05:21.255Z</published>
    <updated>2019-01-15T04:05:21.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Blocks篇：1-Blocks的声明"><a href="#Blocks篇：1-Blocks的声明" class="headerlink" title="Blocks篇：1.Blocks的声明"></a>Blocks篇：1.Blocks的声明</h2><blockquote>
<p><strong>Blocks是带有自动变量值的匿名函数。</strong></p>
</blockquote>
<p>写法：</p>
<ul>
<li>Blocks变量声明：与C函数指针声明基本相似，将指针符号”*”替换为“^”。</li>
<li>Blocks主体声明：省略了名称的C函数，在原函数名前添加“^”。<ul>
<li>无参数Blocks，可以省略参数列表</li>
<li>无返回值Blocks，可以省略返回值</li>
</ul>
</li>
</ul>
<a id="more"></a>
<p>举例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 完整声明</span></div><div class="line"><span class="keyword">void</span> (^myBlock)(<span class="keyword">int</span> a) = <span class="keyword">void</span> ^(<span class="keyword">int</span> a) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 无参数，无返回值</span></div><div class="line"><span class="keyword">void</span> (^myBlock2)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Blocks篇：1-Blocks的声明&quot;&gt;&lt;a href=&quot;#Blocks篇：1-Blocks的声明&quot; class=&quot;headerlink&quot; title=&quot;Blocks篇：1.Blocks的声明&quot;&gt;&lt;/a&gt;Blocks篇：1.Blocks的声明&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Blocks是带有自动变量值的匿名函数。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;写法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Blocks变量声明：与C函数指针声明基本相似，将指针符号”*”替换为“^”。&lt;/li&gt;
&lt;li&gt;Blocks主体声明：省略了名称的C函数，在原函数名前添加“^”。&lt;ul&gt;
&lt;li&gt;无参数Blocks，可以省略参数列表&lt;/li&gt;
&lt;li&gt;无返回值Blocks，可以省略返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》9</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A9.ARC%E5%AE%9E%E7%8E%B0%E4%B9%8B__autoreleasing/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇：9.ARC实现之__autoreleasing/</id>
    <published>2019-01-06T07:54:34.109Z</published>
    <updated>2019-01-06T07:54:34.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：9-ARC实现之-autoreleasing"><a href="#内存管理篇：9-ARC实现之-autoreleasing" class="headerlink" title="内存管理篇：9.ARC实现之__autoreleasing"></a>内存管理篇：9.ARC实现之__autoreleasing</h2><ol>
<li>__autoreleasing修饰的变量与在非ARC环境下，对对象调用autorelease方法效果一致：</li>
</ol>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasePool &#123;</div><div class="line">    id __autoreleasing obj = [[NSObject alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转换后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建pool</span></div><div class="line">id pool = objc_autoreleasePoolPush();</div><div class="line"></div><div class="line"><span class="comment">// 创建对象</span></div><div class="line">id obj = objc_msgSend(NSObject, @selector(alloc));</div><div class="line">objc_msgSend(obj, @selector(init));</div><div class="line"></div><div class="line"><span class="comment">// 加入到pool中</span></div><div class="line">objc_autorelease(obj);</div><div class="line"></div><div class="line"><span class="comment">// 释放pool中的对象</span></div><div class="line">objc_autoreleasePoolPop(pool);</div></pre></td></tr></table></figure>
<ol>
<li>对于将非调用方创建的对象，加入到autoreleasePool中的情况，生成的代码如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasePool &#123;</div><div class="line">    id __autoreleasing obj = [NSMutableArray <span class="built_in">array</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转换后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建pool</span></div><div class="line">id pool = objc_autoreleasePoolPush();</div><div class="line"></div><div class="line"><span class="comment">// 创建对象</span></div><div class="line">id obj = objc_msgSend(NSMutableArray, @selector(<span class="built_in">array</span>));</div><div class="line"><span class="comment">// 保留返回的自动释放对象（autorelease优化）</span></div><div class="line">objc_retainAutoreleasedReturnValue(obj);</div><div class="line"></div><div class="line"><span class="comment">// 加入到pool中</span></div><div class="line">objc_autorelease(obj);</div><div class="line"></div><div class="line"><span class="comment">// 释放pool中的对象</span></div><div class="line">objc_autoreleasePoolPop(pool);</div></pre></td></tr></table></figure>
<p>这里在前面<strong>strong的情况中有说过，<strong>对于函数的返回值，ARC使用objc_autoreleaseReturnValue和objc_retainAutoreleasedReturnValue方法进行优化，避免了将生成的对象在pool中进行进入和取出操作</strong>。但是由于接收变量是使用</strong>autoreleasing修饰的，故直接将其加入到pool中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：9-ARC实现之-autoreleasing&quot;&gt;&lt;a href=&quot;#内存管理篇：9-ARC实现之-autoreleasing&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇：9.ARC实现之__autoreleasing&quot;&gt;&lt;/a&gt;内存管理篇：9.ARC实现之__autoreleasing&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;__autoreleasing修饰的变量与在非ARC环境下，对对象调用autorelease方法效果一致：&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》8</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A8.ARC%E5%AE%9E%E7%8E%B0%E4%B9%8B__weak/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇：8.ARC实现之__weak/</id>
    <published>2019-01-06T07:53:26.381Z</published>
    <updated>2019-01-06T07:53:34.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：8-ARC实现之-weak"><a href="#内存管理篇：8-ARC实现之-weak" class="headerlink" title="内存管理篇：8.ARC实现之__weak"></a>内存管理篇：8.ARC实现之__weak</h2><blockquote>
<p>我们知道，weak修饰的变量，其地址是被存储在一个专用的散列表中，此散列表的键值为原内存的散列值（即对象地址的hash值）。</p>
</blockquote>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546747255-weak%E8%A1%A8.jpg" alt="img"></p>
<p>__weak修饰的变量，其主要存在两大功能：</p>
<ol>
<li><strong>当其引用的对象被释放时，此变量自动被赋值为nil</strong>；</li>
<li><strong>使用__weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象</strong>。</li>
</ol>
<a id="more"></a>
<h4 id="当-weak变量引用的对象被释放时，其自动被赋值为nil"><a href="#当-weak变量引用的对象被释放时，其自动被赋值为nil" class="headerlink" title="当__weak变量引用的对象被释放时，其自动被赋值为nil"></a>当__weak变量引用的对象被释放时，其自动被赋值为nil</h4><p>先看示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// obj为强引用变量且已经被赋值</span></div><div class="line">    id __weak obj1 = obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id obj1;</div><div class="line">objc_initWeak(&amp;obj1, obj);</div><div class="line">objc_destroyWeak(&amp;obj1);</div></pre></td></tr></table></figure>
<p>objc_initWeak方法，即为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj1 = <span class="number">0</span>;</div><div class="line">objc_storeWeak(&amp;obj1, obj);</div></pre></td></tr></table></figure>
<p>objc_destroyWeak方法，即为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_storeWeak(&amp;obj1, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>由此可以看出，</p>
<ol>
<li><strong>对于初始化的weak变量：为变量赋值为0，并将其地址存储到weak表中，对象内存的散列值所在的地址中</strong>。</li>
<li><strong>释放weak变量时：则是在weak表中，将对象内存散列值所在地址存储的数据中，将存储的变量清空</strong>。</li>
</ol>
<blockquote>
<p>由于可以使用多个weak变量指向同一对象，所以在weak表中，一个键值的散列地址中可以存储多个weak变量地址。</p>
</blockquote>
<p><em>结论：<br>weak对象释放时，自动置为nil的原因</em>：</p>
<ul>
<li><strong>在系统调用dealloc释放对象时（最后的objc_clear_deallocating方法），ARC会根据对象的引用状态，去weak表中查询对应的weak变量，将变量地址赋值为nil，并将其记录删除。最后将此键值记录一并删除。</strong></li>
<li>注意：此过程需要消耗CPU资源，故不要滥用，需要时再使用（如避免delegate和block导致的引用循环）。</li>
</ul>
<h4 id="使用-weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象"><a href="#使用-weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象" class="headerlink" title="使用__weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象"></a>使用__weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象</h4><p>还是先看实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// obj为强引用变量，且已被赋值</span></div><div class="line">    id __weak obj1 = obj;</div><div class="line">    NSLog(@<span class="string">"%@"</span>, obj1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 初始化weak变量并赋值</span></div><div class="line">id obj1;</div><div class="line">objc_initWeak(&amp;obj1, obj);</div><div class="line"><span class="comment">// ？？？</span></div><div class="line">id tmp = objc_loadWeakRetained(&amp;obj1);</div><div class="line"><span class="comment">// ？？？</span></div><div class="line">objc_autorelease(tmp);</div><div class="line">NSLog(@<span class="string">"%@"</span>, tmp);</div><div class="line"><span class="comment">// 释放weak变量</span></div><div class="line">objc_destroyWeak(&amp;obj1);</div></pre></td></tr></table></figure>
<p>其中：</p>
<ol>
<li><strong>先通过objc_loadWeakRetained方法，将weak变量对应引用的对象取出，并进行retain操作。</strong></li>
<li><strong>使用objc_autorelease方法，将生成的临时对象加入到autoreleasePool中，即可保证对象的生存期，以便正常使用。</strong></li>
</ol>
<p>注意：</p>
<ul>
<li>大量使用weak变量，会在autoreleasePool中插入大量临时变量，增加内存开销，并对CPU进行过多无畏的损耗。</li>
<li>正确的使用方法，是使用strong变量指向weak变量后，再进行使用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">id __weak obj1 = obj;</div><div class="line">id tmp = obj1;</div><div class="line">NSLog(@<span class="string">"1.%@"</span>, tmp);</div><div class="line">NSLog(@<span class="string">"2.%@"</span>, tmp);</div><div class="line">NSLog(@<span class="string">"3.%@"</span>, tmp);</div><div class="line">NSLog(@<span class="string">"4.%@"</span>, tmp);</div><div class="line">NSLog(@<span class="string">"5.%@"</span>, tmp);</div><div class="line"><span class="comment">// 这样，autoreleasePool只会将obj1插入一次</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：8-ARC实现之-weak&quot;&gt;&lt;a href=&quot;#内存管理篇：8-ARC实现之-weak&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇：8.ARC实现之__weak&quot;&gt;&lt;/a&gt;内存管理篇：8.ARC实现之__weak&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们知道，weak修饰的变量，其地址是被存储在一个专用的散列表中，此散列表的键值为原内存的散列值（即对象地址的hash值）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546747255-weak%E8%A1%A8.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;__weak修饰的变量，其主要存在两大功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;当其引用的对象被释放时，此变量自动被赋值为nil&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用__weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》7</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A7.ARC%E5%AE%9E%E7%8E%B0%E4%B9%8B__strong%E5%8F%8Aautorelease%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇：7.ARC实现之__strong及autorelease优化/</id>
    <published>2019-01-06T07:52:21.263Z</published>
    <updated>2019-01-06T07:52:21.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：7-ARC实现之-strong及autorelease优化"><a href="#内存管理篇：7-ARC实现之-strong及autorelease优化" class="headerlink" title="内存管理篇：7.ARC实现之__strong及autorelease优化"></a>内存管理篇：7.ARC实现之__strong及autorelease优化</h2><blockquote>
<p>对于持有非自己创建的对象的情况，我们知道，这种情况是指对于非“alloc、new、copy和mutableCopy”开头的并返回对象实例的方法，接收方不负责内存管理。<br>ARC会在方法实现中将返回值加入到autoreleasePool中，待接收方从中取出使用，延迟释放时机。</p>
</blockquote>
<a id="more"></a>
<p>但是实际上，代码并不会都如我们想象的那样，因为会有更优化的执行。先看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    id __strong obj = [NSMutableArray <span class="built_in">array</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 发消息创建对象</span></div><div class="line">id obj = objc_msgSend(NSMutableArray, @selector(<span class="built_in">array</span>));</div><div class="line"><span class="comment">// ???</span></div><div class="line">objc_retainAutoreleasedReturnValue(obj);</div><div class="line"><span class="comment">// 正常释放对象</span></div><div class="line">objc_release(obj);</div></pre></td></tr></table></figure>
<p>而对于NSMutableArray的array方法，编译后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (id)<span class="built_in">array</span> &#123;</div><div class="line">    <span class="comment">// 正常的二段式创建</span></div><div class="line">    id obj = objc_msgSend(NSMutableArray, @selector(alloc));</div><div class="line">    objc_msgSend(obj, @selector(init));</div><div class="line">    <span class="comment">// ???</span></div><div class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在以上代码中可以看到，在这种情况下，ARC使用了<em>objc_autoreleaseReturnValue</em>替代了autorelease操作，而调用方则使用<em>objc_retainAutoreleasedReturnValue</em>替代了传统的retain操作。作用是什么呢？</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546692024-AutoRelease%E4%BC%98%E5%8C%96.jpg" alt="img"></p>
<blockquote>
<p>使用这对方法（创建对象的方法返回使用objc_autoreleaseReturnValue返回的对象，而接收方使用objc_retainAutoreleasedReturnValue接收返回的对象）时，编译器实际上并没有将生成的对象加入到autoreleasePool中，而是直接将对象传递给接收方。避免了频繁地将对象在autoreleasePool中进行加入、取出操作，以达到最优效率。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：7-ARC实现之-strong及autorelease优化&quot;&gt;&lt;a href=&quot;#内存管理篇：7-ARC实现之-strong及autorelease优化&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇：7.ARC实现之__strong及autorelease优化&quot;&gt;&lt;/a&gt;内存管理篇：7.ARC实现之__strong及autorelease优化&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;对于持有非自己创建的对象的情况，我们知道，这种情况是指对于非“alloc、new、copy和mutableCopy”开头的并返回对象实例的方法，接收方不负责内存管理。&lt;br&gt;ARC会在方法实现中将返回值加入到autoreleasePool中，待接收方从中取出使用，延迟释放时机。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》6</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A%206.%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%88%E9%9D%9EOC%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%EF%BC%89/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇： 6.不要使用静态和动态数组（非OC集合对象）/</id>
    <published>2019-01-06T07:51:20.446Z</published>
    <updated>2019-01-06T07:51:20.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：-6-不要使用静态和动态数组（非OC集合对象）"><a href="#内存管理篇：-6-不要使用静态和动态数组（非OC集合对象）" class="headerlink" title="内存管理篇： 6.不要使用静态和动态数组（非OC集合对象）"></a>内存管理篇： 6.不要使用静态和动态数组（非OC集合对象）</h2><h4 id="静态数组（类似于c数组，非OC的集合对象）："><a href="#静态数组（类似于c数组，非OC的集合对象）：" class="headerlink" title="静态数组（类似于c数组，非OC的集合对象）："></a>静态数组（类似于c数组，非OC的集合对象）：</h4><ul>
<li>使用<strong>strong、</strong>weak和__autoreleasing修饰的静态数组（如：id objs[10]），其初始值也会自动赋值为nil，且当其释放时，子元素也会自动被释放；</li>
</ul>
<a id="more"></a>
<h4 id="动态数组（对象指针实现）："><a href="#动态数组（对象指针实现）：" class="headerlink" title="动态数组（对象指针实现）："></a>动态数组（对象指针实现）：</h4><ol>
<li>声明：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明，指向id的指针：</span></div><div class="line">id __strong *<span class="built_in">array</span> = nil;</div><div class="line"><span class="comment">// 或 指向对象的指针</span></div><div class="line"><span class="comment">// NSObject * __strong *array = nil;</span></div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>动态数组用对象指针表示；</li>
<li>由于对象指针默认为“<strong>autoreleasing”修饰符，所以需要显示指定为“</strong>strong”；</li>
<li>对象指针不会被ARC自动置为nil，需要显示指定。</li>
</ul>
</blockquote>
<ol>
<li>初始化：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 初始化：</span></div><div class="line"><span class="built_in">array</span> = (id __strong *)<span class="built_in">calloc</span>(entries, <span class="keyword">sizeof</span>(id)); </div><div class="line"><span class="comment">// calloc方法会自动将内存空间写入0数据，比malloc配合memset更为安全且简洁</span></div><div class="line"></div><div class="line"><span class="comment">// 使用malloc和memset的错误方式</span></div><div class="line"><span class="built_in">array</span> = (id __strong *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(id) * entries);</div><div class="line"><span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; entries; ++i) &#123;</div><div class="line">    <span class="built_in">array</span>[i] = nil; <span class="comment">// 错误：在ARC下相当于直接释放</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>使用：(与静态数组一致，同样不能放入nil)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">array</span>[<span class="number">0</span>] = [[NSObject alloc] init];</div></pre></td></tr></table></figure>
<ol>
<li>释放：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.依次释放子元素</span></div><div class="line"><span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; entries; ++i) &#123;</div><div class="line">    <span class="built_in">array</span>[i] = nil; <span class="comment">// 在ARC下相当于直接释放对象</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 2.释放动态数组本身</span></div><div class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>原因：由于动态数组是在运行期确定，ARC无法在编译器对其进行内存管理，直接释放数组本身会让子元素发生内存泄漏。</p>
</blockquote>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><p>使用memcpy拷贝数组中的元素和realloc重新分配内存，都可能导致对象内存泄漏或过度释放，所以ARC下也被禁止使用。</p>
<hr>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><blockquote>
<p>直接使用Foundation的集合对象就好了，不要用这种东西。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：-6-不要使用静态和动态数组（非OC集合对象）&quot;&gt;&lt;a href=&quot;#内存管理篇：-6-不要使用静态和动态数组（非OC集合对象）&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇： 6.不要使用静态和动态数组（非OC集合对象）&quot;&gt;&lt;/a&gt;内存管理篇： 6.不要使用静态和动态数组（非OC集合对象）&lt;/h2&gt;&lt;h4 id=&quot;静态数组（类似于c数组，非OC的集合对象）：&quot;&gt;&lt;a href=&quot;#静态数组（类似于c数组，非OC的集合对象）：&quot; class=&quot;headerlink&quot; title=&quot;静态数组（类似于c数组，非OC的集合对象）：&quot;&gt;&lt;/a&gt;静态数组（类似于c数组，非OC的集合对象）：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用&lt;strong&gt;strong、&lt;/strong&gt;weak和__autoreleasing修饰的静态数组（如：id objs[10]），其初始值也会自动赋值为nil，且当其释放时，子元素也会自动被释放；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》5</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A%205.ARC%E7%9A%84%E8%A7%84%E5%88%99%E8%A1%A5%E5%85%85/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇： 5.ARC的规则补充/</id>
    <published>2019-01-06T07:49:49.390Z</published>
    <updated>2019-01-06T07:49:49.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：-5-ARC的规则补充"><a href="#内存管理篇：-5-ARC的规则补充" class="headerlink" title="内存管理篇： 5.ARC的规则补充"></a>内存管理篇： 5.ARC的规则补充</h2><ol>
<li>ARC的方法命名</li>
</ol>
<blockquote>
<p>我们都知道，在内存管理的思考方式中，当方法命名以“alloc、new、copy、mutableCopy”开头或直接命名时，返回对象（必须返回对象）的内存由接收方进行管理。这种方式在ARC中同样适用。</p>
</blockquote>
<p>在ARC环境下，以init或init开头的方法，也需要遵循此规则。且init的方法规定更为严格：</p>
<ul>
<li>必须返回id或类型的对象</li>
<li>必须是实例方法</li>
</ul>
<a id="more"></a>
<hr>
<ol>
<li><strong>OC对象（这里代指Foundation框架中类的对象）不能直接作为C数据结构的成员。</strong><blockquote>
<p>原因：ARC为OC语言编译器特性，不支持对C语言进行内存管理（最新的iOS 12中，好像已经支持此特性了，LLVM真强大。。。）</p>
</blockquote>
</li>
</ol>
<p>对于需要作为成员的OC对象，解决方法：</p>
<ul>
<li>使用“__unsafe_unretained”进行所有权修饰，显示声明并告知编译器不要对其进行内存管理；</li>
<li>通过“__bridge”将OC对象转换为（void *）指针。</li>
</ul>
<hr>
<ol>
<li>显示转换“id”与“void *”</li>
</ol>
<p>对象与C指针之间是通过“__bridge”关键字进行转换，主要分为三种方式：</p>
<blockquote>
<ul>
<li>__bridge</li>
<li>__bridge_retained</li>
<li>__bridge_transfer</li>
</ul>
</blockquote>
<ul>
<li>__bridge:</li>
</ul>
<p>直接转换，忽略ARC内存管理，与添加__unsafe_unretained效果类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">id obj = [[NSObject alloc] init];</div><div class="line"><span class="comment">// 转换为c指针</span></div><div class="line"><span class="keyword">void</span> *p = (__bridge <span class="keyword">void</span> *)obj;</div><div class="line"><span class="comment">// 转换为OC对象</span></div><div class="line">id obj2 = (__bridge id)p;</div></pre></td></tr></table></figure>
<ul>
<li>__bridge_retained:</li>
</ul>
<p>意为“转换后进行保留”，接收方对其自动强引用（同时掌握所有权），与__strong的retain效果类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *p = <span class="number">0</span>;</div><div class="line">&#123;</div><div class="line">    id obj = [[NSObject alloc] init];</div><div class="line">    <span class="comment">// 转换为c指针</span></div><div class="line">    p = (__bridge_retained <span class="keyword">void</span> *)obj;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 出作用域后，obj强引用消失</span></div><div class="line"><span class="comment">// 由于__bridge_retained，p同时也是强引用，对象得以继续生存</span></div><div class="line">NSLog(<span class="string">"%@"</span>, [(__bridge id)p class]);</div></pre></td></tr></table></figure>
<ul>
<li>__bridge_transfer:</li>
</ul>
<p>意为“转换后释放”，原创建方在转换后自动释放自身引用，只由接收方进行内存管理（转换了所有权），与release效果类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *p = xxx;</div><div class="line">id obj = (__bridge_transfer id)p;</div><div class="line"><span class="comment">// 转换后相当于p进行了release操作，只有obj持有对象</span></div></pre></td></tr></table></figure>
<p><strong>OC（Foundation）对象与CF（Core Foundation）对象间的转换</strong>：</p>
<ul>
<li>由于二者基本是等效框架（只是实现语言不同），对象间的转换无需消耗CPU资源，是“免费桥接”（“toll-free bridge”）。</li>
<li>一般转换规则：<ul>
<li>OC -&gt; CF，使用“__bridge_retained”或“CFBridgingRetain”</li>
<li>CF -&gt; OC，使用“__bridge_transfer”或“CFBridgingRelease”（因为一般转换为OC对象后，ARC可以自动介入，防止忘记使用CFRelease手动释放内存）</li>
</ul>
</li>
</ul>
<blockquote>
<p>总结：<strong>尽量不要直接使用__bridge进行转换</strong>，使用时需再三考虑内存管理情况。</p>
</blockquote>
<hr>
<ol>
<li>使用<strong>strong、</strong>weak和__autoreleasing修饰的变量，其初始值会自动赋值为nil</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：-5-ARC的规则补充&quot;&gt;&lt;a href=&quot;#内存管理篇：-5-ARC的规则补充&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇： 5.ARC的规则补充&quot;&gt;&lt;/a&gt;内存管理篇： 5.ARC的规则补充&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;ARC的方法命名&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我们都知道，在内存管理的思考方式中，当方法命名以“alloc、new、copy、mutableCopy”开头或直接命名时，返回对象（必须返回对象）的内存由接收方进行管理。这种方式在ARC中同样适用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在ARC环境下，以init或init开头的方法，也需要遵循此规则。且init的方法规定更为严格：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须返回id或类型的对象&lt;/li&gt;
&lt;li&gt;必须是实例方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》4</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A%204.ARC%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇： 4.ARC的所有权修饰符/</id>
    <published>2019-01-06T07:47:20.057Z</published>
    <updated>2019-01-06T07:48:00.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：-4-ARC的所有权修饰符"><a href="#内存管理篇：-4-ARC的所有权修饰符" class="headerlink" title="内存管理篇： 4.ARC的所有权修饰符"></a>内存管理篇： 4.ARC的所有权修饰符</h2><h3 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h3><blockquote>
<ul>
<li>在ARC下，对象必须通过所有权修饰符进行修饰，系统会根据不同的所有权修饰符对对象进行相应的内存管理。</li>
<li>所有权修饰符包括：<strong>strong、</strong>weak、<strong>unsafe_unretained、</strong>autoreleasing。</li>
</ul>
</blockquote>
<a id="more"></a>
<h4 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="__strong修饰符"></a>__strong修饰符</h4><blockquote>
<ul>
<li>__strong作为默认的所有权修饰符，使用时可以直接省略；</li>
<li>__strong将修饰对象的指针变量声明为强引用（对象的引用计数+1）</li>
</ul>
</blockquote>
<p>__strong修饰的对象，依然符合内存管理的4条思考方式：</p>
<ul>
<li>自己创建的对象，自己持有：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// 作用域内，object负责内存管理</span></div><div class="line">    id __strong object = [[NSObject alloc] init];</div><div class="line">&#125;   <span class="comment">// 出作用域，对象的强引用失效，内存释放</span></div></pre></td></tr></table></figure>
<ul>
<li>非自己创建的对象，自己也能持有：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    id __strong object1 = [[NSObject alloc] init];</div><div class="line">    <span class="comment">// 通过赋值方式，持有别人创建的对象</span></div><div class="line">    id __strong object2 = object1</div><div class="line">&#125;   </div><div class="line"><span class="comment">// 出作用域，object2强引用失效，对象收到release消息；object1强引用也失效，对象收到release消息；最终内存释放</span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// 持有非自己创建的对象</span></div><div class="line">    id __strong object = [NSMutableArray <span class="built_in">array</span>];</div><div class="line">&#125;   <span class="comment">// 出作用域，对象的强引用失效，内存释放</span></div></pre></td></tr></table></figure>
<ul>
<li>当不再需要时，可以释放自己创建的对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    id __strong object = [[NSObject alloc] init];</div><div class="line">    <span class="comment">// 不需要时，直接置为nil或指向其他对象时，原对象收到release消息</span></div><div class="line">    object = nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>无法释放非自己创建的对象<ul>
<li>由于无法调用release方法，无需担心释放问题。</li>
</ul>
</li>
</ul>
<h4 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="__weak修饰符"></a>__weak修饰符</h4><blockquote>
<ul>
<li>与<strong>strong相对，</strong>weak为弱引用，不持有对象；</li>
<li>出作用域后，修饰的指针变量自动置为nil，访问安全；</li>
<li><strong>解决“引用循环”问题；</strong></li>
<li>iOS5以上适用（自动置nil是在运行期实现，故ARC不全是编译器特性）</li>
</ul>
</blockquote>
<h4 id="unsafe-unretained修饰符"><a href="#unsafe-unretained修饰符" class="headerlink" title="__unsafe_unretained修饰符"></a>__unsafe_unretained修饰符</h4><blockquote>
<ul>
<li>作为iOS5以前“__weak”的版本，编译器不对其内存进行管理；</li>
<li>出作用域后，指针变量不会置为nil，访问极其危险</li>
</ul>
</blockquote>
<p><strong>不建议使用。</strong></p>
<h4 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h4><blockquote>
<p>在ARC下，NSAutoreleasePool类的创建使用需要使用@autoreleasepool块来代替，且不能手动调用autorelease方法。</p>
</blockquote>
<ul>
<li>非显示使用的情况（编译器自动将对象标记为__autoreleasing）：</li>
</ul>
<ol>
<li><strong>在@autoreleasepool块中直接使用：</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line">    id obj = [[NSObject alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong>作为函数返回值：</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">+ (MyClass *)myObject &#123;</div><div class="line">    <span class="keyword">return</span> [[MyClass alloc] init];</div><div class="line">    <span class="comment">/** </span></div><div class="line">    * 相当于</div><div class="line">    *   id obj = [[MyClass alloc] init];</div><div class="line">    *   return obj;</div><div class="line">    */</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">隐含创建的obj变量会被赋值__strong修饰符，出作用域后会被释放，但由于对象作为函数返回值，编译器会将其标记为__autoreleasing，加入到最近的autoreleasepool对象中。</div><div class="line">&gt; 注意：对于此种情况，方法命名时需要遵循内存管理规则：即不得使用“alloc、<span class="keyword">new</span>、copy和mutableCopy”作为方法名开头（会将返回对象标记为__strong）。</div><div class="line"></div><div class="line"><span class="number">3.</span> **指向id的指针或指向对象的指针：**</div><div class="line"></div><div class="line">``` c</div><div class="line"><span class="comment">// 指向id的指针</span></div><div class="line">id __autoreleasing *obj;</div><div class="line"><span class="comment">// 指向NSObject对象的指针</span></div><div class="line">NSObject * __autoreleasing *obj;</div></pre></td></tr></table></figure>
<p>举例，API中的error参数，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSError ** 等同于 NSError * __autoreleasing *</span></div><div class="line">- (BOOL)performTaskWithError:(NSError **)error &#123;</div><div class="line">    <span class="keyword">if</span> (出现错误) &#123;</div><div class="line">        &amp;error = [NSError errorWithxxx];</div><div class="line">        <span class="keyword">return</span> NO;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用时：</span></div><div class="line">NSError *error; <span class="comment">// 相当于NSError __strong *error，值为nil（由于对象指针赋值时，二者的所有权修饰符必须一致。实际上这里error在下面赋值时，隐含地生成了__autoreleasing修饰的临时变量）</span></div><div class="line">[obj performTaskWithError:&amp;error];</div></pre></td></tr></table></figure>
<blockquote>
<p>原因：<br>这里其实也遵循了内存管理法则所述的方法命名规范，由于方法名不是由“alloc、new、copy和mutableCopy”开头，error作为返回对象与函数的返回值一样，且接收方相当于持有非自己创建的对象。所以会被编译器自动加入到autoreleasepool中。<br>所以指向对象的指针，会被自动标记为“__autoreleasing”。</p>
</blockquote>
<ul>
<li><strong>对象指针赋值时，二者的所有权修饰符必须一致</strong>。如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSError *error = nil; <span class="comment">// 默认为__strong</span></div><div class="line"><span class="comment">// 由于默认指向对象的指针为__autoreleasing，所以这里需要显示指定为__strong</span></div><div class="line">NSError * __strong *pError = &amp;error;</div></pre></td></tr></table></figure>
<ul>
<li><strong>在访问使用__weak修饰符的变量时，实际上该对象必定会被加到autoreleasepool中</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id __weak obj1 = obj0;</div><div class="line">NSLog(@<span class="string">"class = %@"</span>, [obj1 class]);</div></pre></td></tr></table></figure>
<p>与以下代码等效：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id __weak obj1 = obj0;</div><div class="line">id __autoreleasing tmp = obj1;</div><div class="line">NSLog(@<span class="string">"class = %@"</span>, [tmp class]);</div></pre></td></tr></table></figure>
<blockquote>
<p>原因：<br><strong>weak修饰的变量只是弱引用，其指向的对象随时可能被释放而变为nil；<br>为了保证使用过程中对象的持续存在，ARC会将生成</strong>autorelease修饰的临时变量指向该对象，从而将其加入到autoreleasepool中。</p>
</blockquote>
<ul>
<li>注意：<strong>使用__autoreleasing修饰的变量，必须为自动变量（局部变量、函数或方法参数），不能是其他。</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：-4-ARC的所有权修饰符&quot;&gt;&lt;a href=&quot;#内存管理篇：-4-ARC的所有权修饰符&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇： 4.ARC的所有权修饰符&quot;&gt;&lt;/a&gt;内存管理篇： 4.ARC的所有权修饰符&lt;/h2&gt;&lt;h3 id=&quot;所有权修饰符&quot;&gt;&lt;a href=&quot;#所有权修饰符&quot; class=&quot;headerlink&quot; title=&quot;所有权修饰符&quot;&gt;&lt;/a&gt;所有权修饰符&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在ARC下，对象必须通过所有权修饰符进行修饰，系统会根据不同的所有权修饰符对对象进行相应的内存管理。&lt;/li&gt;
&lt;li&gt;所有权修饰符包括：&lt;strong&gt;strong、&lt;/strong&gt;weak、&lt;strong&gt;unsafe_unretained、&lt;/strong&gt;autoreleasing。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》3</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A%203.autorelease/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇： 3.autorelease/</id>
    <published>2019-01-06T07:43:19.318Z</published>
    <updated>2019-01-06T07:44:11.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：-3-autorelease"><a href="#内存管理篇：-3-autorelease" class="headerlink" title="内存管理篇： 3.autorelease"></a>内存管理篇： 3.autorelease</h2><blockquote>
<p><strong>autorelease的实质：</strong><br><em>将创建的对象加入到NSAutoreleasePool管理“数组”中，并告知ARC系统暂时不要对此对象进行处理。待pool对象在其所属的NSRunLoop循环一次完成，准备释放（drain）时，对“数组”中的所有对象依次调用release方法。此时ARC再对对象进行内存管理。</em></p>
</blockquote>
<a id="more"></a>
<h3 id="GNUstep的实现"><a href="#GNUstep的实现" class="headerlink" title="GNUstep的实现"></a>GNUstep的实现</h3><p>GNUstep的版本使用了同NSMutableArray一样的连接列表，将被标记的对象加入到“正在使用中的”autoreleasePool对象中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSObject.m中：</span></div><div class="line">- (id)autorelease &#123;</div><div class="line">    [NSAutoreleasePool addObject:self];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// NSAutoreleasePool.m中：</span></div><div class="line">+ (<span class="keyword">void</span>)addObject:(id)anObj &#123;</div><div class="line">    NSAutoreleasePool *pool = 获取正在使用中的pool；</div><div class="line">    <span class="keyword">if</span> (pool != nil) &#123;</div><div class="line">        [pool addObject:anObj];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addObject:(id)anObj &#123;</div><div class="line">    <span class="comment">// 加入到内部管理的数组中</span></div><div class="line">    [<span class="built_in">array</span> addObject:anObj];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="方法调用优化：在GNUstep实现的版本中，为了提高autorelease方法执行的速度，使用了“IMP-Caching”的方式，及将函数指针提前缓存，需要时跳过了“objc-msgSend”的过程，直接调用："><a href="#方法调用优化：在GNUstep实现的版本中，为了提高autorelease方法执行的速度，使用了“IMP-Caching”的方式，及将函数指针提前缓存，需要时跳过了“objc-msgSend”的过程，直接调用：" class="headerlink" title="方法调用优化：在GNUstep实现的版本中，为了提高autorelease方法执行的速度，使用了“IMP Caching”的方式，及将函数指针提前缓存，需要时跳过了“objc_msgSend”的过程，直接调用："></a>方法调用优化：在GNUstep实现的版本中，为了提高autorelease方法执行的速度，使用了“IMP Caching”的方式，及将函数指针提前缓存，需要时跳过了“objc_msgSend”的过程，直接调用：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSObject.m中：</span></div><div class="line"></div><div class="line"><span class="comment">// 缓存类名</span></div><div class="line">id autorelease_class = [NSAutoreleasePool class];</div><div class="line"><span class="comment">// 缓存方法名</span></div><div class="line">SEL autorelease_sel = @selector(<span class="string">"addObject:"</span>);</div><div class="line"><span class="comment">// 缓存方法实现（函数指针）</span></div><div class="line">IMP autorelease_imp = [autorelease_class methodForSelector:autorelease_sel];</div><div class="line"></div><div class="line">- (id)autorelease &#123;</div><div class="line">    <span class="comment">// 直接调用</span></div><div class="line">    (*autorelease_imp)(autorelease_class, autorelease_sel, self);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>由于NSAutoreleasePool覆盖了autorelease的方法实现（其他对象执行的是NSObject的实现），对pool对象发送autorelease消息会抛出异常。<br>即<strong>不能对NSAutoreleasePool对象调用autorelease方法。</strong></p>
</blockquote>
<ul>
<li>补充：<strong>无论编译环境是否为ARC有效，都推荐使用@autoreleasepool块作为替代</strong>，以提高代码可读性。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：-3-autorelease&quot;&gt;&lt;a href=&quot;#内存管理篇：-3-autorelease&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇： 3.autorelease&quot;&gt;&lt;/a&gt;内存管理篇： 3.autorelease&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;autorelease的实质：&lt;/strong&gt;&lt;br&gt;&lt;em&gt;将创建的对象加入到NSAutoreleasePool管理“数组”中，并告知ARC系统暂时不要对此对象进行处理。待pool对象在其所属的NSRunLoop循环一次完成，准备释放（drain）时，对“数组”中的所有对象依次调用release方法。此时ARC再对对象进行内存管理。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》2</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A%202.alloc-retain-release-dealloc%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇： 2.alloc-retain-release-dealloc的实现/</id>
    <published>2019-01-06T07:42:32.544Z</published>
    <updated>2019-01-06T07:59:00.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：-2-alloc-retain-release-dealloc的实现"><a href="#内存管理篇：-2-alloc-retain-release-dealloc的实现" class="headerlink" title="内存管理篇： 2.alloc/retain/release/dealloc的实现"></a>内存管理篇： 2.alloc/retain/release/dealloc的实现</h2><h3 id="GNUstep的实现方式"><a href="#GNUstep的实现方式" class="headerlink" title="GNUstep的实现方式"></a>GNUstep的实现方式</h3><p><strong>GNUstep的版本将引用计数与对象的内存组合在一起，方便读写存取。</strong><br><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546151436-GNUstep%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84.jpg" alt="img"><br>如图所示，使用了一个objc_layout结构体来表示引用计数，其大体结构及alloc的简化代码为：</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_layout</span> &#123;</span></div><div class="line">    <span class="comment">// 引用计数</span></div><div class="line">    NSUInteger retained;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (id)alloc &#123;</div><div class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(struct objc_layout) + 对象大小；</div><div class="line">    <span class="comment">// 创建一段大小为size的连续内存，并写入0</span></div><div class="line">    <span class="comment">// 使用结构体指针指向此地址</span></div><div class="line">    struct objc_layout *p = <span class="built_in">calloc</span>(<span class="number">1</span>, size);</div><div class="line">    <span class="comment">// 返回id类型对象（地址+1即为对象的地址）</span></div><div class="line">    <span class="keyword">return</span> (id)(p + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>由此可知，retainCount即返回结构体中retained成员的值即可：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (NSUinteger)retainCount &#123;</div><div class="line">    <span class="keyword">return</span> NSExtraRefCount(self) + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> NSUInteger</span></div><div class="line"><span class="title">NSExtraRefCount</span><span class="params">(id anObject)</span> &#123;</div><div class="line">    <span class="comment">// 由于对象指向的是+1的地址，故-1即为结构体实例的地址</span></div><div class="line">    <span class="keyword">return</span> ((struct objc_layout *)anObject)[<span class="number">-1</span>].retained;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于初始化的内存中填充数据为0，故新对象的引用计数为1（0+1）。</p>
<p><strong>而对于retain和release操作，即对retained变量进行+1和-1操作即可。而且，在release操作时，当retained为0时，运行时系统即调用dealloc方法，将对象的内存释放。</strong></p>
<h3 id="苹果的实现方式"><a href="#苹果的实现方式" class="headerlink" title="苹果的实现方式"></a>苹果的实现方式</h3><p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546151340-Apple%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E8%A1%A8.jpg" alt="img"></p>
<p>直接看图，<strong>苹果使用了单独的引用计数表来存储所有对象的引用计数。且使用了对象内存地址的hash值作为key，将引用计数作为内容进行保存</strong>。简单的实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)retainCount &#123;</div><div class="line">    <span class="keyword">return</span> (NSUInteger)__CFDoExternRefOperation(OPERATION_retainCount, self);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)retain &#123;</div><div class="line">    <span class="keyword">return</span> (id)__CFDoExternRefOperation(OPERATION_retain, self);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)release &#123;</div><div class="line">    <span class="keyword">return</span> (id)__CFDoExternRefOperation(OPERATION_release, self);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所调用的方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __CFDoExternRefOperation(<span class="keyword">unitptr_t</span> op, id obj) &#123;</div><div class="line">    <span class="comment">// 获取引用计数表</span></div><div class="line">    CFBasicHashRef table = 取得对象对应的散列表(obj);</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    </div><div class="line">    <span class="comment">// 根据操作分发给不同函数</span></div><div class="line">    <span class="keyword">switch</span> (op) &#123;</div><div class="line">    <span class="keyword">case</span> OPERATION_retainCount:</div><div class="line">        <span class="comment">// retainCount</span></div><div class="line">        count = CFBasicHashGetCountOfKey(table, obj);</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    <span class="keyword">case</span> OPERATION_retain:</div><div class="line">        <span class="comment">// retain</span></div><div class="line">        CFBasicHashAddValue(table, obj);</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    <span class="keyword">case</span> OPERATION_release:</div><div class="line">        <span class="comment">// release</span></div><div class="line">        count = CFBasicHashRemoveValue(table, obj);</div><div class="line">        <span class="keyword">return</span> (<span class="number">0</span> == count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>苹果的实现虽然看似没有GNUstep的方式简单，实际上其优点也是显而易见：</p>
<ul>
<li>对象创建时，其内存分配无需考虑引用计数相关逻辑，结构纯粹。</li>
<li>引用计数表中，可以根据内存块的地址追溯对象的原始内存，方便调试及内存泄露检测等功能。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：-2-alloc-retain-release-dealloc的实现&quot;&gt;&lt;a href=&quot;#内存管理篇：-2-alloc-retain-release-dealloc的实现&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇： 2.alloc/retain/release/dealloc的实现&quot;&gt;&lt;/a&gt;内存管理篇： 2.alloc/retain/release/dealloc的实现&lt;/h2&gt;&lt;h3 id=&quot;GNUstep的实现方式&quot;&gt;&lt;a href=&quot;#GNUstep的实现方式&quot; class=&quot;headerlink&quot; title=&quot;GNUstep的实现方式&quot;&gt;&lt;/a&gt;GNUstep的实现方式&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;GNUstep的版本将引用计数与对象的内存组合在一起，方便读写存取。&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546151436-GNUstep%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84.jpg&quot; alt=&quot;img&quot;&gt;&lt;br&gt;如图所示，使用了一个objc_layout结构体来表示引用计数，其大体结构及alloc的简化代码为：&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
