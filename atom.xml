<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭吉吉的瞎记空间</title>
  <subtitle>技术的，瞎说的，啥都有吧。。。希望。。。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-10T03:15:53.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>臭吉吉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KVC基础学习总结</title>
    <link href="http://yoursite.com/2018/04/04/KVC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/04/KVC基础学习总结/</id>
    <published>2018-04-04T06:16:30.000Z</published>
    <updated>2018-04-10T03:15:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li><strong>对象属性值的设置和获取</strong></li>
<li><strong>访问集合属性值的专用API</strong></li>
<li><strong>使用集合操作符</strong></li>
<li><strong>描述非对象的值（基本数据类型和结构体等）</strong></li>
<li><strong>属性类型验证</strong></li>
<li><strong>访问器的搜索方式</strong></li>
</ul>
</blockquote>
<h3 id="对象属性值的设置和获取"><a href="#对象属性值的设置和获取" class="headerlink" title="对象属性值的设置和获取"></a>对象属性值的设置和获取</h3><ol>
<li><p>KVC的通用API<br> setValueForKey(Path):<br> valueForKey(Path):</p>
</li>
<li><p>一次设置、获取多个属性值<br> setValueForKeysWithDictionary: 对内部的每一个属性均发送setValueForKey消息<br> dictionaryWithValueForKeys:    根据keys数组返回字典</p>
</li>
</ol>
<h3 id="访问集合属性值的专用API"><a href="#访问集合属性值的专用API" class="headerlink" title="访问集合属性值的专用API"></a>访问集合属性值的专用API</h3><table>
<thead>
<tr>
<th style="text-align:center">通过key访问集合</th>
<th style="text-align:center">通过keyPath访问集合</th>
<th style="text-align:center">被代理的类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mutableArrayValueForKey:</td>
<td style="text-align:center">mutableArrayValueForKeyPath:</td>
<td style="text-align:center">NSMutableArray</td>
</tr>
<tr>
<td style="text-align:center">mutableSetValueForKey:</td>
<td style="text-align:center">mutableSetValueForKeyPath:</td>
<td style="text-align:center">NSMutableSet</td>
</tr>
<tr>
<td style="text-align:center">mutableOrderedSetValueForKey:</td>
<td style="text-align:center">mutableOrderedSetValueForKeyPath:</td>
<td style="text-align:center">NSMutableOrderedSet</td>
</tr>
</tbody>
</table>
<p>访问集合属性的值时除了可以直接使用基本valueForKey(Path):方法，还可以使用上述三类专用API进行访问。当你对集合属性进行修改（增、删、改）时，上表的三类方法可以更高效的完成任务，他们分别返回一个类似NSMutableArray、NSMutableSet和NSMutableOrderedSet的代理类的对象，可以在此对象上直接调用任何相关类的api来直接操作属性值。</p>
<p>使用此类api管理集合属性的高效体现在：</p>
<ol>
<li>比类型为不可变集合类型属性，通过valueForKey:取值，转换并修改后，再通过setValueForKey:保存回去效率高</li>
<li>比直接将集合属性类型设置成mutable类修改高效</li>
<li>对KVO有效</li>
</ol>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ------------返回一个可变对象的代理类（这里是仿可变数组类型，可以调用所有NSMutableArray的api）</span></div><div class="line">id mutableTransactions = [account mutableArrayValueForKey:@<span class="string">"transactions"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, mutableTransactions);</div><div class="line"><span class="comment">// 对返回的代理类对象进行操作（添加、删除、修改等），会直接在原属性上进行操作。</span></div><div class="line"><span class="comment">// 这比直接通过valueForKey获取集合对象后，修改，再setValueForKey存储回去效率高；也比直接维护一个可变集合属性效率高。</span></div><div class="line"><span class="comment">// 且这种方法对KVO有帮助（直接操作修改集合属性不会触发KVO）</span></div><div class="line">Transaction *targetTransaction = mutableTransactions[<span class="number">0</span>];</div><div class="line">targetTransaction.work = @<span class="string">"hhhhaaaa"</span>;</div><div class="line"><span class="comment">// 再次取出</span></div><div class="line">transactions = [account valueForKeyPath:@<span class="string">"transactions"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, transactions);</div></pre></td></tr></table></figure>
<h3 id="使用集合操作符"><a href="#使用集合操作符" class="headerlink" title="使用集合操作符"></a>使用集合操作符</h3><p>在使用valueForKeyPath:访问集合属性时，可以在keyPath中使用集合操作符来直接操作返回的值。集合操作符使用“@”字符标识，使用集合操作符的keyPath结构如下：</p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/art/keypath.jpg" alt="img"></p>
<p>如图可知：keyPath分为<em>左keyPath、集合操作符、右keyPath</em>三部分。</p>
<p>集合操作符主要分为三类：</p>
<ul>
<li><strong>聚合操作符</strong>：对集合对象进行操作，返回匹配条件的单一对象作为结果（@count除外，它没有右keyPath，且返回一个NSNumber对象）。</li>
</ul>
<p>主要包括：@sum、@max、@min、@avg、@count等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 聚合操作符（操作集合属性，返回单个对象）</span></div><div class="line"><span class="comment">// @count</span></div><div class="line">NSNumber *count = [account valueForKeyPath:@<span class="string">"transactions.@count"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, count); <span class="comment">// @count，省略右keypath</span></div><div class="line"><span class="comment">// @max</span></div><div class="line">NSNumber *maxMoney = [account valueForKeyPath:@<span class="string">"transactions.@max.money"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, maxMoney);</div><div class="line"><span class="comment">// @min</span></div><div class="line">NSNumber *minMoney = [account.transactions valueForKeyPath:@<span class="string">"@min.money"</span>];  <span class="comment">// 直接对集合属性取值，可省略左keypath</span></div><div class="line">NSLog(@<span class="string">"%@"</span>, minMoney);</div><div class="line"><span class="comment">// @sum</span></div><div class="line">NSNumber *sumMoney = [account valueForKeyPath:@<span class="string">"transactions.@sum.money"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, sumMoney);</div></pre></td></tr></table></figure>
<ul>
<li><strong>数组操作符</strong>：对集合对象进行操作，通过对右keyPath指定的值进行操作，返回特定条件的集合对象。</li>
</ul>
<p>主要包括@unionOfObjects和@distinctUnionOfObjects，二者区别是：前者直接返回指定属性的值的数组，不过滤重复的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组操作符（操作集合属性，返回集合对象）</span></div><div class="line"><span class="comment">// @unionOfObjects 指定对象的集合</span></div><div class="line">id unionOfWorks = [account.transactions valueForKeyPath:@<span class="string">"@unionOfObjects.work"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, unionOfWorks);</div><div class="line"><span class="comment">// @distinctUnionOfObjects 指定对象的不重复集合</span></div><div class="line">id distinctUnionOfWorks = [account.transactions valueForKeyPath:@<span class="string">"@distinctUnionOfObjects.work"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, distinctUnionOfWorks);</div></pre></td></tr></table></figure>
<ul>
<li><strong>嵌套操作符</strong>：对于包含属性对象的集合所组成的集合（如数组内部包含的所有元素都是数组，这些子数组内部都是属性对象），嵌套操作符通过对右keyPath指定的值进行操作，返回特定条件的集合对象。</li>
</ul>
<p>包括@unionOfArrays、@distinctUnionOfArrays和@distinctUnionOfSets，前两者对嵌套数组进行操作、第三个对集合（NSSet）进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 嵌套操作符（操作包括集合属性对象的嵌套对象，返回集合对象）</span></div><div class="line">Transaction *moreWork1 = [[Transaction alloc] init];</div><div class="line">moreWork1.work = @<span class="string">"收入10000"</span>;</div><div class="line">moreWork1.payee = @[@<span class="string">"臭吉吉2"</span>, @<span class="string">"jiji2"</span>];</div><div class="line">moreWork1.money = <span class="number">10000</span>;</div><div class="line">Transaction *moreWork2 = [[Transaction alloc] init];</div><div class="line">moreWork2.work = @<span class="string">"支出2002"</span>;</div><div class="line">moreWork2.payee = @[@<span class="string">"赵吉222"</span>];</div><div class="line">moreWork2.money = <span class="number">2002</span>;</div><div class="line">NSArray *nestedTransactions = @[account.transactions, @[moreWork1, moreWork2]]; <span class="comment">// 所有的最小子元素都是transaction对象</span></div><div class="line"><span class="comment">// 注意：@unionOfArrays和@distinctUnionOfArrays的数据源，必须是数组嵌套成的数组，不能是元素与数组组合成的数据源数组。，如下面就不可以</span></div><div class="line"><span class="comment">//    NSArray *nestedTransactions = @[account.transactions, @[moreWork1, moreWork2], moreWork3];</span></div><div class="line"></div><div class="line"><span class="comment">// @unionOfArrays</span></div><div class="line">id unionOfWorksArray = [nestedTransactions valueForKeyPath:@<span class="string">"@unionOfArrays.work"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, unionOfWorksArray);</div><div class="line"><span class="comment">// @distinctUnionOfArrays</span></div><div class="line">id distinctUnionOfWorksArray = [nestedTransactions valueForKeyPath:@<span class="string">"@distinctUnionOfArrays.work"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, distinctUnionOfWorksArray);</div><div class="line"><span class="comment">// @distinctUnionOfSets</span></div><div class="line">NSSet *nestedTransactionsSet = [NSSet setWithObjects:</div><div class="line">    [NSSet setWithArray:account.transactions],</div><div class="line">    [NSSet setWithObjects:moreWork1, moreWork2, nil],</div><div class="line">    nil</div><div class="line">]; <span class="comment">// 所有的最小子元素都是transaction对象，整体及子集合必须都是set</span></div><div class="line">id distinctUnionOfWorksSet = [nestedTransactionsSet valueForKeyPath:@<span class="string">"@distinctUnionOfSets.work"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, distinctUnionOfWorksSet);</div></pre></td></tr></table></figure>
<h3 id="描述非对象的值（基本数据类型和结构体等）"><a href="#描述非对象的值（基本数据类型和结构体等）" class="headerlink" title="描述非对象的值（基本数据类型和结构体等）"></a>描述非对象的值（基本数据类型和结构体等）</h3><ol>
<li>对于基本数据类型的值，使用KVC进行设置和获取时需要将值进行对NSNumber类的封包和解包。</li>
<li>对于内置的结构体，如NSPoint、NSRange、NSRect和NSSize，需要使用NSValue类对数据进行封包和解包。</li>
<li>对于自定义的结构体，使用NSValue的通用api对数据进行封包和解包。</li>
</ol>
<p>对于自定义结构体的KVC，举例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    float x;</div><div class="line">    float y;</div><div class="line">    float z;</div><div class="line">&#125; ThreeFloats;</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic) ThreeFloats threeFloats;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    // ------自定义的非对象数据KVC测试（自定义结构体转NSValue）</div><div class="line">    // 创建结构体数据</div><div class="line">    ThreeFloats floats = &#123;</div><div class="line">        1., 2., 3.</div><div class="line">    &#125;;</div><div class="line">    // 转化为NSValue</div><div class="line">    NSValue *customStructValue = [NSValue valueWithBytes:&amp;floats objCType:@encode(ThreeFloats)];</div><div class="line">    // KVC保存</div><div class="line">    [self setValue:customStructValue forKey:@"threeFloats"];</div><div class="line">    // 读取值</div><div class="line">    NSValue *propertyValue = [self valueForKey:@"threeFloats"];</div><div class="line">    // 转回结构体值</div><div class="line">    ThreeFloats resultFloats;</div><div class="line">    [propertyValue getValue:&amp;resultFloats size:sizeof(ThreeFloats)];</div><div class="line">    NSLog(@"%f, %f, %f", resultFloats.x, resultFloats.y, resultFloats.z);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="属性类型验证"><a href="#属性类型验证" class="headerlink" title="属性类型验证"></a>属性类型验证</h3><p>KVC协议定义了一些方法用于验证属性。除了使用key或keyPath进行设置和获取值以外，还可以使用它们进行属性验证。当调用validateValue:forKey:error（或者validateValue:forKeyPath:error）方法时，协议方法的默认实现是去查找是否对key存在validate[key]:error:方法。如果没有实现此方法，则验证方法默认通过，返回YES；如果你实现了这个key的方法，则会根据此方法的验证结果来返回原验证结果。</p>
<p>你实现的validate[key]:error:方法根据key的值和error的指针，有三种验证实现方案：</p>
<ol>
<li>判定传入的值符合要求，直接返回YES，且不修改值和错误对象。</li>
<li>判定传入的值不符合，且不对此值进行类型修正（如类型转换等）。这种情况下，方法返回NO，并且对用户传入的错误指针（如果传入了）进行赋值，包含其中的错误信息。</li>
<li>判定传入的值不符合，但是创建个符合要求的新值进行替换。这种情况下，方法返回YES，且把传入的值的指针指向此新值（一定不要直接修改传入的值，就算是个mutable类对象也不行），并且不用处理错误信息。</li>
</ol>
<p>举例来说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line">@interface Transaction : NSObject</div><div class="line"></div><div class="line"><span class="comment">/** 工作内容类型（这里用于验证属性） */</span></div><div class="line">@property (copy, nonatomic) NSString *work;</div><div class="line"></div><div class="line"><span class="comment">/** 收款人数组 一对多 */</span></div><div class="line">@property (nonatomic) NSArray&lt;NSString *&gt; *payee;</div><div class="line"><span class="comment">/** 钱数 */</span></div><div class="line">@property (nonatomic) NSInteger money;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"Transaction.h"</span></span></div><div class="line"></div><div class="line">@implementation Transaction</div><div class="line"></div><div class="line">- (BOOL)validateWork:(id * _Nullable)workValue error:(out NSError * _Nullable *)error &#123;</div><div class="line">    <span class="keyword">if</span> (![*workValue isKindOfClass:[NSString class]]) &#123;</div><div class="line"><span class="comment">//        // 不修改，直接返回错误</span></div><div class="line"><span class="comment">//        if (error) &#123;</span></div><div class="line"><span class="comment">//            *error = [NSError errorWithDomain:@"validate error" code:9999 userInfo:@&#123;@"reason": @"invalid type"&#125;];</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line"><span class="comment">//        return NO;</span></div><div class="line">        <span class="comment">// 将值修改为符合要求的值</span></div><div class="line">        *workValue = [NSString stringWithFormat:@<span class="string">"%@"</span>, *workValue];</div><div class="line">        <span class="keyword">return</span> YES;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"><span class="comment">/** 外部调用 */</span></div><div class="line"></div><div class="line"><span class="comment">// -----------测试属性验证</span></div><div class="line"><span class="comment">// 对应类中如果没有自己实现validate&lt;Key&gt;:error:方法，则验证无效，都返回YES</span></div><div class="line"><span class="comment">// validate&lt;Key&gt;:error:方法中可以对数据进行合法性判断，返回错误；或将不合法数据转化为合法数据（创建个新数据），返回成功。</span></div><div class="line">NSError *error = nil;</div><div class="line">id targetValue = @<span class="number">123</span>;	<span class="comment">// 这里错误传入了NSNumber对象，用以进行验证</span></div><div class="line">BOOL isValid = [targetTransaction validateValue:&amp;targetValue forKey:@<span class="string">"work"</span> error:&amp;error];</div><div class="line">NSLog(@<span class="string">"%d"</span>, isValid);</div></pre></td></tr></table></figure>
<h3 id="访问器的搜索方式"><a href="#访问器的搜索方式" class="headerlink" title="访问器的搜索方式"></a>访问器的搜索方式</h3><p><strong>NSObject提供给NSKeyValueCoding协议的默认实现，是使用基于键（key）的访问器，根据一系列规则来调用对象的属性。</strong>这些协议方法使用一个键（key）参数来搜索对象实例的访问器（accessor）、实例变量和一些遵循确定命名规范的方法。了解搜索的工作原理，不仅有助于追踪KVC对象的行为，还可以帮助编写自己的兼容对象（类似KVC）。</p>
<ul>
<li><strong>基本getter的搜索模式（valueForKey:的工作模式）：</strong></li>
</ul>
<ol>
<li><strong>首先依次查找访问方法set[Key]、[key]、is[Key]、_[key]。</strong>找到则跳到【5】中处理结果，否则进入下一步。</li>
<li><strong>若没有找到访问器方法，则搜索匹配名为countOf[Key]和objectIn[Key]AtIndex:的实例方法（与NSArray中定义的原方法一致），还有[key]AtIndexes:方法（与NSArray中的objectsAtIndexes:一致）。如果找到了第一个方法和后两者之一，则创建并返回一个集合代理对象来响应所有的NSArray的方法（给代理对象发送NSArray方法时会自动组合调用以上实现的方法）。</strong>不满足则进入下一步【3】。<br> 代理对象会把收到的所有的NSArray的消息（即API调用）转化成给KVC相关对象（即类实例对象）组合发送countOf[Key]、objectIn[Key]AtIndex:和[key]AtIndexes:消息。如果原类中额外实现了get[Key]:range:方法，此代理对象也会适时使用，以提高性能。实际上，代理对象会和原实例对象一起工作，让它看起来就像是一个NSArray对象（虽然不是）。</li>
<li><strong>当没有找到访问器方法和数组的访问方法时，系统再继续查找一组三个名为countOf[Key]、enumeratorOf[Key]和memberOf[Key]:的实例方法(都是NSSet类中的方法)。三个方法都找到，则创建一个集合代理对象来响应所有的NSSet方法并返回。</strong>不满足则进入下一步【4】。<br> 与NSArray的情况一样，系统会根据实现的方法生成并返回一个NSSet的代理对象，与原对象一起工作，来使其看起来像是一个NSSet对象（与上面一样，给返回的代理集合对象调用NSSet的api，你实现的countOf[Key]、enumeratorOf[Key]和memberOf[Key]:方法就会被组合调用。）。</li>
<li><strong>访问器方法和集合访问方法组都没有找到，系统会查看类中是否实现了accessInstanceVariablesDirectly，如果该方法返回YES，则进入成员列表中进行进一步查找。依次查找名为_[key]、_is[Key]、[key]和is[Key]的成员变量。</strong>找到则跳到【5】中处理结果，否则进入下一步。</li>
<li>如果得到的属性值是对象指针，直接返回结果。如果值是一个支持NSNumber转换的基本数据类型值，则封包成NSNumber对象返回。如果是一个不支持NSNumber转换的基本数据类型值（如结构体），则封包成NSValue对象返回。</li>
<li>若以上查找均失败，则触发valueForUndefinedKey:方法，默认抛出异常。子类可以覆盖此方法。</li>
</ol>
<ul>
<li><strong>基本setter的搜索模式（setValue:forKey:的工作模式）：</strong></li>
</ul>
<p>默认实现是，给定key和value参数作为输入，试图把key设置为value（对于非对象属性，要先解包成相应值）。被调用的对象依照下面的程序进行查找：</p>
<ol>
<li><strong>依次查找名为set[Key]:或_set[Key]的访问器方法，找到后，使用输入值触发该方法并完成（依照需要先解包值）。</strong></li>
<li><strong>没找到访问器时，查看类方法accessInstanceVariablesDirectly，如果返回YES，依次查找成员变量中的类似_[key]、_is[Key]或is[Key]。找到，使用输入值触发该方法并完成（依照需要先解包值）。</strong></li>
<li><strong>以上都没找到，则触发setValue:forUndefinedKey:方法。默认抛出异常，子类可以覆盖并提供其他行为（如赋值给其他属性等）。</strong></li>
</ol>
<ul>
<li><strong>可变数组的搜索模式：</strong></li>
</ul>
<p>mutableArrayValueForKey:方法默认实现是输入key，返回调用对象的以key命名的属性（要求此属性是数组或可变数组类型，不可变数组无法实现步骤【1】）。此访问器的调用程序如下：</p>
<ol>
<li>查找一组方法命名如insertObject:in[Key]AtIndex:和removeObjectFrom[Key]AtIndex:（与NSMutableArray中的insertObject:atIndex和removeObjectAtIndex:一致），或者名为insert[Key]:atIndexed:和removeObjectsAtIndexes:（与NSMutableArray的insertObjects:atIndexes:和removeObjectsAtIndexesL:一致）。<br> 如果调用对象至少包含一个插入方法和一个删除方法，就返回一个可变代理对象。以后通过给此代理对象发送NSMutableArray的所有消息，都会通过组合调用insertObject:in[Key]AtIndex:、removeObjectFrom[Key]AtIndex:、insert[Key]:atIndexed:和removeObjectsAtIndexes:方法的形式来进行响应（或者可以直接将这些方法声明在.h文件中，外部类实例直接调用此方法也可以直接触发KVO机制）。<br> 如果原类的对象还实现了可选的替换方法，如replaceObjectIn[Key]AtIndex:withObject:或replace[Key]AtIndexes:with[Key]:，代理对象也会适时调用此方法来提高效率。</li>
<li><p>如果类的实例对象没有这些可变的数组方法，就查找名字如set[Key]:的访问方法进行匹配。在这种情况下，返回的代理对象都是通过调用原始对象的set[Key]:方法来间接响应NSMutableArray的消息。</p>
<blockquote>
<p>注意：<br>步骤【2】中的机制由于需要每次创建新的集合对象（set[Key]:，setter方法设置，而不是修改已存在的对象），导致性能要比步骤【1】中要差了不少。所以自己设计KVC相关对象时要避免这种代码。</p>
</blockquote>
</li>
<li><p>既没有找到可变数组方法，也没有找到访问器，查看类的accessInstanceVariablesDirectly方法是否返回YES，是则依次去类的成员变量中查询是否存在如_[key]或[key]。若存在，则返回一个代理对象，系统会把代理对象收到的每个NSMutableArray的消息都转发给这个成员变量，这个变量的类型需要是NSMutableArray或其子类。</p>
</li>
<li>如果上面所有的步骤都失败了，就返回一个可变的集合代理对象，作为参数，来触发setValue:forUndefinedKey:方法。默认在内部抛出NSUndefinedKeyException异常，子类可以覆盖进行其他处理。</li>
</ol>
<blockquote>
<p>查了好多东西，发现只有在KVO时，使用此可变容器的api进行KVC属性设置。由于调用此api返回的是可变集合对象，且是系统在运行时动态生成的，内部已经包含了KVO使用的isa指针等。当对此代理对象调用NSMutableArray方法时，会自动触发KVO机制。</p>
</blockquote>
<p>其他如可变无序集合和可变有序集合的搜索模式与此类似，不再细说。</p>
<h3 id="参考内容："><a href="#参考内容：" class="headerlink" title="参考内容："></a>参考内容：</h3><ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/BasicPrinciples.html#//apple_ref/doc/uid/20002170-BAJEAIEE" target="_blank" rel="external">Key-Value Coding Fundamentals</a></li>
<li><a href="https://www.jianshu.com/p/45cbd324ea65" target="_blank" rel="external">iOS开发技巧系列—详解KVC(我告诉你KVC的一切)</a></li>
<li><a href="http://liumh.com/2015/08/22/ios-nsmutablearray-kvo/" target="_blank" rel="external">iOS如何为NSMutableArray添加KVO</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对象属性值的设置和获取&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问集合属性值的专用API&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用集合操作符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;stron
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS Protocol（协议）的简单总结</title>
    <link href="http://yoursite.com/2018/04/03/iOS%20Protocol%EF%BC%88%E5%8D%8F%E8%AE%AE%EF%BC%89%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/03/iOS Protocol（协议）的简单总结/</id>
    <published>2018-04-03T02:50:26.000Z</published>
    <updated>2018-04-03T03:00:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>协议保存在类结构的协议表中，我们可以使用runtime的相关api查看指定类遵循的协议，或动态修改遵循的协议等。</p>
<h3 id="语法总结："><a href="#语法总结：" class="headerlink" title="语法总结："></a>语法总结：</h3><ol>
<li>协议中可以声明<strong>方法、属性</strong></li>
<li>协议方法分为可选可必选</li>
<li><strong>协议属性不会自动合成</strong>（与@dynamic的property一样）</li>
<li>协议可继承（通过xcode创建的protocol文件，默认继承了NSObject协议），且为单继承，子协议默认继承了父协议的所有内容</li>
</ol>
<h3 id="使用建议："><a href="#使用建议：" class="headerlink" title="使用建议："></a>使用建议：</h3><ol>
<li>当主类遵循多个协议时，可以使用category将主类分开，防止代码量过大且过于复杂</li>
<li>协议可以让使用类匿名（即对外返回id<xxx>的对象），公开的api放到protocol中，一般用于设计framework等。可以参见NSFetchResultController类的设计。</xxx></li>
</ol>
<h3 id="参考内容："><a href="#参考内容：" class="headerlink" title="参考内容："></a>参考内容：</h3><ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithProtocols/WorkingwithProtocols.html#//apple_ref/doc/uid/TP40011210-CH11-SW1" target="_blank" rel="external">Working with Protocols</a></li>
<li></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;协议保存在类结构的协议表中，我们可以使用runtime的相关api查看指定类遵循的协议，或动态修改遵循的协议等。&lt;/p&gt;
&lt;h3 id=&quot;语法总结：&quot;&gt;&lt;a href=&quot;#语法总结：&quot; class=&quot;headerlink&quot; title=&quot;语法总结：&quot;&gt;&lt;/a&gt;语法总结：&lt;/
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 2.0 方法调用中的动态绑定和消息转发</title>
    <link href="http://yoursite.com/2018/03/30/Objective-C%202.0%20%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>http://yoursite.com/2018/03/30/Objective-C 2.0 动态绑定和消息转发/</id>
    <published>2018-03-30T06:06:41.000Z</published>
    <updated>2018-03-30T09:16:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li><strong>OC方法调用的实质</strong></li>
<li><strong>动态绑定和消息转发的流程</strong></li>
<li><strong>动态绑定实例（添加实例方法、添加类方法）</strong></li>
<li><strong>消息转发实例</strong></li>
<li><strong>消息转发模拟“多继承”以及二者的区别</strong></li>
<li><strong>使用消息转发代替继承</strong></li>
</ul>
</blockquote>
<h3 id="OC方法调用的实质"><a href="#OC方法调用的实质" class="headerlink" title="OC方法调用的实质"></a>OC方法调用的实质</h3><p>我们都知道，OC是C语言的超集，赋予了C强大的动态特性，其功劳主要归功于OC的运行时系统（runtime）。OC调用方法的实质是发送消息（即objc_msgSend函数）。在编译期，对象理论上可以调用任何方法，即使此方法并没有实现。直到运行期，系统才会根据方法名（SEL）去class的数据结构中查找对应方法进行方法调用。</p>
<h3 id="动态绑定和消息转发的流程"><a href="#动态绑定和消息转发的流程" class="headerlink" title="动态绑定和消息转发的流程"></a>动态绑定和消息转发的流程</h3><p>给对象（类的实例）发送消息（即调用方法）的大致流程如下：</p>
<ol>
<li>根据实例的isa指针确定所属class</li>
<li>在class的缓存表中查看是否存在此方法。若存在，加入缓存表后，找到对应IMP直接调用</li>
<li>不存在缓存时，在class的方法表中查找。若存在，加入缓存表后，找到对应IMP直接调用</li>
<li>方法表不存在时，根据class的super_class指针，在父类的方法表中继续查找。若存在，加入缓存表后，找到对应IMP直接调用</li>
<li>都没有查找到时，runtime会启动动态绑定，调用resolveInstanceMethod方法，此时，可以动态添加此方法到class中。如已添加，加入缓存表后，找到对应IMP直接调用</li>
<li>若没有动态添加方法，runtime会启动快速消息转发机制，即调用forwardTargetForSelector方法。我们可以直接返回一个类实例，指定其为调用者的代理对象，直接执行其对应的方法</li>
<li>如果没有指定代理对象，runtime会启动完整的消息转发机制（forwardInvocation）：首先，调用methodSignatureForSelector方法，返回一个包含此方法实例对象的方法签名；接着，系统会根据此方法签名，生成一个NSInvacation对象（包含着方法选择器等信息），带有此参数并调用forwardInvocation方法。我们在forwardInvocation中，使用invacation对象调用invokeWithTarget方法，传入需要转发的实例对象。即完成了消息转发，系统会自动调用转发对象的对应方法，并将结果返回给最初的调用者。</li>
<li>如果我们没有把消息转发给任何对象，最后系统会调用doesNotRecognizeMethod方法，并在其内部抛出异常，即表示无法处理此消息，最终默认crash掉APP。</li>
</ol>
<blockquote>
<p>以上步骤中，1~4为方法的正常调用流程，5为动态绑定流程，6~8为消息转发流程。</p>
</blockquote>
<p>转发一张动态绑定和消息转发的流程图（上面的步骤5~8）：<br><img src="https://upload-images.jianshu.io/upload_images/1457495-8ee6afef466e6177.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<h3 id="动态绑定实例"><a href="#动态绑定实例" class="headerlink" title="动态绑定实例"></a>动态绑定实例</h3><ul>
<li>添加实例方法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    [self performSelector:@selector(missingMethod:) withObject:@<span class="string">"haha"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    <span class="keyword">if</span> (NSSelectorFromString(@<span class="string">"missingMethod:"</span>) == sel) &#123;</div><div class="line">        <span class="comment">// 是我们调用的方法，使用runtime添加实现</span></div><div class="line">        <span class="comment">// 方法描述中，v--void；@--id；:--SEL</span></div><div class="line">        class_addMethod([self class], sel, (IMP)missingMethodIMP, <span class="string">"v@:@\"NSString\""</span>);</div><div class="line">        <span class="keyword">return</span> YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 返回默认实现</span></div><div class="line">    <span class="keyword">return</span> [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">missingMethodIMP</span><span class="params">(id self, SEL _cmd, NSString *param)</span> </span>&#123;</div><div class="line">    NSLog(@<span class="string">"calling missingMethodIMP with: %@"</span>, param);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>添加类方法：</li>
</ul>
<p>我们知道，与实例方法不同，类方法是保存在类所属元类的方法表中（即class -&gt; isa -&gt; meta class -&gt; method list）。所以给类动态绑定类方法，需要绑定到元类中，通过resolveClassMethod进行添加：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    [[self <span class="class"><span class="keyword">class</span>] <span class="title">performSelector</span>:</span>@selector(missingClassMethod:) withObject:@<span class="string">"haha"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel &#123;</div><div class="line">    <span class="keyword">if</span> (NSSelectorFromString(@<span class="string">"missingClassMethod:"</span>) == sel) &#123;</div><div class="line">        <span class="comment">// 是我们调用的方法，使用runtime添加实现</span></div><div class="line">        <span class="comment">// 获取meta class</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *className = class_getName(self);</div><div class="line">        id metaClass = objc_getMetaClass(className);</div><div class="line">        <span class="comment">// 添加方法</span></div><div class="line">        <span class="keyword">return</span> class_addMethod(metaClass, sel, (IMP)missingClassMethodIMP, <span class="string">"v@:@\"NSString\""</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [super resolveClassMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">missingClassMethodIMP</span><span class="params">(id self, SEL _cmd, NSString *param)</span> </span>&#123;</div><div class="line">    NSLog(@<span class="string">"calling missingClassMethodIMP with: %@"</span>, param);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="消息转发实例"><a href="#消息转发实例" class="headerlink" title="消息转发实例"></a>消息转发实例</h3><p>这里只列举了实例方法的消息转发。对于类方法的消息转发，只需将对应的“-”改为“+”即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line">@interface ClassAForForward : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"ClassAForForward.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"ClassBForForward.h"</span></span></div><div class="line"></div><div class="line">@implementation ClassAForForward</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    <span class="comment">// 这里只是演示一下，首先会进入动态绑定过程</span></div><div class="line">    <span class="comment">// 由于没有任何作用，会进入消息转发流程</span></div><div class="line">    <span class="keyword">return</span> [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="comment">// 此方法可以直接指定转发的对象</span></div><div class="line">    <span class="comment">// 省略了获取方法签名和生成转发对象组合的方式</span></div><div class="line">    <span class="comment">// 效率高</span></div><div class="line">    <span class="keyword">if</span> (aSelector == NSSelectorFromString(@<span class="string">"methodB"</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> [[ClassBForForward alloc] init];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 直接返回，则会触发完整的消息转发机制</span></div><div class="line">    <span class="keyword">return</span> [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</div><div class="line">    <span class="keyword">if</span> (!signature) &#123;</div><div class="line">        <span class="comment">// 找不到SEL对应的方法签名，</span></div><div class="line">        <span class="comment">// 提供一个自定义的方法签名，返回给本类用于转发调用（forwardInvocation）</span></div><div class="line">        ClassBForForward *bInstance = [[ClassBForForward alloc] init];</div><div class="line">        <span class="comment">// 将带有此selector的类的方法签名返回给本类</span></div><div class="line">        <span class="comment">// 使本类调用“转发调用”方法（forwardInvocation）【即runtime会生成一个invocation传入到转发方法中并调用】</span></div><div class="line">        <span class="comment">// 相当于带有selector的类实例“代理”了本类执行selector</span></div><div class="line">        signature = [bInstance methodSignatureForSelector:aSelector];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> signature;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(NSInvocation *)anInvocation &#123;</div><div class="line">    SEL aSelector = [anInvocation selector];</div><div class="line">    <span class="keyword">if</span> (aSelector) &#123;</div><div class="line">        <span class="comment">// 本类实例指定代理对象来调用selector</span></div><div class="line">        <span class="comment">// 转发给代理对象</span></div><div class="line">        ClassBForForward *bInstance = [[ClassBForForward alloc] init];</div><div class="line">        [anInvocation invokeWithTarget:bInstance];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 返回给系统继续调用（调用doesNotRecognizeSelector方法）</span></div><div class="line">        [super forwardInvocation:anInvocation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)doesNotRecognizeSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="comment">// 最终无法转发的方法，会执行这里，之后默认crash</span></div><div class="line">    [super doesNotRecognizeSelector:aSelector];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="消息转发模拟“多继承”以及二者的区别"><a href="#消息转发模拟“多继承”以及二者的区别" class="headerlink" title="消息转发模拟“多继承”以及二者的区别"></a>消息转发模拟“多继承”以及二者的区别</h3><p>面向对象编程，其实根本目的就是为了代码复用。面向对象的方式之一就是继承，但由于OC只支持单继承，一定程度上减少了很多代码复用的机会，而且并不是所有的类都可以直接继承（如OC的类簇）。而消息转发机制可以在一定程度上解决这个问题。</p>
<p>个人理解，消息转发实际上与代理模式一样，调用者本身不具备指定功能，通过代理对象调用方法来间接实现自己的功能。外部看起来与本身直接调用一样。当把多个功能分别转发给多个对象后，调用者本身就具备了多个类的多种功能，看起来就像是多继承一样。这也就赋予了OC“多继承”的功能，而且实现了代码复用（功能复用）。</p>
<p>但是消息转发和真正的多继承还是存在明显区别的：</p>
<ul>
<li>多继承是“多合一”：多个父类的功能组合生成子类，子类的功能及结构会变多且复杂。</li>
<li>消息转发是“一分多”：通过代理对象，将多个功能分发到多个类中进行实现，本类的实际结构和功能则相对简单，且对外部透明。</li>
</ul>
<h3 id="使用消息转发代替继承"><a href="#使用消息转发代替继承" class="headerlink" title="使用消息转发代替继承"></a>使用消息转发代替继承</h3><p>虽然消息转发隐藏了细节，在外部看起来像是调用类存在某种功能（实现了这个方法），或者是你认为调用类“继承”了转发类。但实际上，通过诸如respondsToSelector、isKindOfClass等函数还是可以识别出真相（此类函数只会查看本身的继承链，不会查看转发链）。如果你想要完全模拟“继承”，则需要覆盖此类方法才行。<br><em>官方文档有说过，一定要慎用消息转发，在没有彻底弄清转发机制和本类及转发类的功能时，不要乱用这个机制。</em></p>
<p>参考内容：</p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1" target="_blank" rel="external">Message Forwarding</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html#//apple_ref/doc/uid/TP40008048-CH102-SW1" target="_blank" rel="external">Dynamic Method Resolution</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;OC方法调用的实质&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态绑定和消息转发的流程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态绑定实例（添加实例方法、添加类方法）&lt;/strong&gt;&lt;/li&gt;

    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 2.0的category</title>
    <link href="http://yoursite.com/2018/03/26/Objective-C%202.0%20category/"/>
    <id>http://yoursite.com/2018/03/26/Objective-C 2.0 category/</id>
    <published>2018-03-26T14:40:03.000Z</published>
    <updated>2018-03-27T09:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li><strong>class和category的数据结构</strong></li>
<li><strong>为什么category只能添加方法，不能添加属性？</strong></li>
<li><strong>category为何不要覆盖父类方法？</strong></li>
<li><strong>多个category覆盖同名方法的执行顺序</strong></li>
<li><strong>category与extension的区别</strong></li>
<li><strong>关联对象和其他补充</strong></li>
</ul>
</blockquote>
<h3 id="class和category的数据结构"><a href="#class和category的数据结构" class="headerlink" title="class和category的数据结构"></a>class和category的数据结构</h3><p>在学习runtime时，可以知道，<em>OC的所有数据结构，包括对象、类、方法、协议等等，都是C的结构体</em>。<br>类的实例，即对象，主要只包含了一个isa指针，指向其所属的class。而class的isa指针则指向其元类（meta class），元类的isa指向根原类，根元类isa指向自身。</p>
<p>来一张转烂了的图，顺便说明isa和super指针的指向关系：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3270116-4fef3651af3f80d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="img"></p>
<p>class的主要数据结构（元类与其相同）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></div><div class="line">	Class isa    OBJC_ISA_AVAILABILITY;</div><div class="line">	</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">	Class super_class;    <span class="comment">// 父类</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">// 类名</span></div><div class="line">	<span class="keyword">long</span> version;    <span class="comment">// 类版本信息，默认0</span></div><div class="line">	<span class="keyword">long</span> info;    <span class="comment">// 类信息</span></div><div class="line">	<span class="keyword">long</span> instance_size;    <span class="comment">// 类实例变量大小</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>;</span>    <span class="comment">// 成员变量链表</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodlists</span>;</span>    <span class="comment">// 方法链表</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>;</span>    <span class="comment">// 方法缓存</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>;</span>    <span class="comment">// 遵循的协议链表</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>简要说明下：</p>
<ul>
<li>根据class的数据结构，即可了解runtime的主要功能：可以在运行时获取类的相关信息，包括实例变量、方法列表、协议列表等，且可以通过相关api对各部分进行增删改查等操作（甚至是修改method的实现）。</li>
<li>OC中的方法调用，并非在编译期确定调用地址，而是在运行时才会确定调用方法的真正地址（通过objc_msgsend函数进行方法调用）。子类的方法调用，会在methodlist中查找，未找到后，会在父类的methodlist中继续查找，直到找到后调用（未找到后进入消息转发）。找到后，会将此method的地址放入cache中，以加快访问。</li>
</ul>
<p>我们主要讨论的category，其结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">// 类名</span></div><div class="line">	<span class="keyword">classref_t</span> cls;    <span class="comment">// 类</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span>    <span class="comment">// 保存添加的实例方法的链表</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>    <span class="comment">// 保存添加的类方法的链表</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>    <span class="comment">// 保存实现的协议方法的链表</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span>    <span class="comment">// 保存所有添加的属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="为什么category只能添加方法，不能添加属性？"><a href="#为什么category只能添加方法，不能添加属性？" class="headerlink" title="为什么category只能添加方法，不能添加属性？"></a>为什么category只能添加方法，不能添加属性？</h3><p>从category的结构中可以看出，<strong>由于内部只保存了属性，并不包含ivar（成员变量才能保存属性的值），即只生成了setter和getter方法的声明，没有对应实现，更没有对应的成员变量保存</strong>。所以在category中添加属性，需要使用runtime的相关对象（associate_object）进行。<br>而且对于category来说，<strong>添加的方法会在编译后添加到主类的方法列表中（实例方法添加到主类，类方法添加到主类所属的元类中）</strong>。</p>
<h3 id="category为何不要覆盖父类方法？"><a href="#category为何不要覆盖父类方法？" class="headerlink" title="category为何不要覆盖父类方法？"></a>category为何不要覆盖父类方法？</h3><p>我们都知道，在category中覆盖父类方法时，系统会弹出警告（主类也实现了此方法），且调用原方法时，系统会执行category的实现，从而导致原始方法实现被覆盖。这里是为什么？<br>我们知道，由于category的方法在runtime加载后会添加到本类的方法表中，方法表保存的是方法的SEL，可以推测：</p>
<ol>
<li>原SEL被覆盖</li>
<li>两个同名方法都被加入到方法表中，调用时只执行了category的</li>
</ol>
<p>另一个问题是，runtime在加载时，对于本类和category的加载顺序是什么。</p>
<p>参照以下代码可以验证：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">// 主类</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface TestClassForCategory : NSObject</div><div class="line"></div><div class="line">- (void)testMethod;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#import "TestClassForCategory.h"</div><div class="line"></div><div class="line">@implementation TestClassForCategory</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@"load === TestClassForCategory");</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)testMethod &#123;</div><div class="line">    NSLog(@"instance method~~~~");</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">// 分类（category）</div><div class="line">#import "TestClassForCategory.h"</div><div class="line"></div><div class="line">@interface TestClassForCategory (Category1)</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#import "TestClassForCategory+Category1.h"</div><div class="line"></div><div class="line">@implementation TestClassForCategory (Category1)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@"load === TestClassForCategory+Category1");</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)testMethod &#123;</div><div class="line">    // category的方法会添加到</div><div class="line">    NSLog(@"category1----");</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我们可以在自己的测试类中，实例化TestClassForCategory并调用testMethod方法，可以看到输出结果：</p>
<blockquote>
<p>2018-03-27 07:55:10.278999+0800 Runtime_Learning2[3506:4499896] load === TestClassForCategory<br>2018-03-27 07:55:10.280645+0800 Runtime_Learning2[3506:4499896] load === TestClassForCategory+Category1<br>2018-03-27 07:55:14.702309+0800 Runtime_Learning2[3506:4499896] category1—-</p>
</blockquote>
<p>由此可以证明，<strong>runtime加载时，首先加载主类，然后加载category。</strong></p>
<p>我们通过runtime的api来获取一下TestClassForCategory的方法表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 打印TestClassForCategory的methodlist</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> methodlistCount;</div><div class="line">Method *methodlist =  class_copyMethodList([TestClassForCategory class], &amp;methodlistCount);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodlistCount; i++) &#123;</div><div class="line">    Method method = methodlist[i];</div><div class="line">    SEL sel = method_getName(method);</div><div class="line">    IMP imp = method_getImplementation(method);</div><div class="line">    NSLog(@<span class="string">"method - %@"</span>, NSStringFromSelector(sel));</div><div class="line">    imp();</div><div class="line">&#125;</div><div class="line"><span class="built_in">free</span>(methodlist);</div></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<blockquote>
<p>2018-03-27 07:55:10.683704+0800 Runtime_Learning2[3506:4499896] method - testMethod<br>2018-03-27 07:55:10.683855+0800<br>Runtime_Learning2[3506:4499896] category1—-<br>2018-03-27 07:55:10.683965+0800 Runtime_Learning2[3506:4499896] method - testMethod<br>2018-03-27 07:55:10.684055+0800 Runtime_Learning2[3506:4499896] instance method<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&gt; </div><div class="line"></div><div class="line">可以看到，**在主类的方法表中，果然保存了主类和分类两个SEL，且方法实现均可以被调用**。联系着load方法的执行顺序，我们可以知道，**class在方法列表中添加方法时，是依照“头部插入”的方式（“头插法”）来修改链表的**。</div><div class="line">原理如下（转自[iOS OC中分类Category实现原理](http://blog.sina.com.cn/s/blog_14679a7d20102xae4.html)）：</div><div class="line"></div><div class="line">![img](http://img.blog.csdn.net/20180131104524542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hpaHVib2tl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</div><div class="line"></div><div class="line">由此可见，当分类中覆盖了主类的方法后，**由于分类的方法在原方法前部，导致调用方法时，系统查找到第一个方法后，直接返回执行，本类方法不会执行**。所以一般不建议在分类中覆盖主类方法。特别是给系统类添加分类时，由于本类或其父类可能会有相同的方法声明，导致被分类覆盖。</div><div class="line"></div><div class="line">为避免此类问题的出现，可以在分类中声明方法时，添加自定义的方法前缀。</div><div class="line"></div><div class="line">### 多个category覆盖同名方法的执行顺序</div><div class="line"></div><div class="line">我们知道，在类的方法表中添加方法使用的是“头插法”，但当给主类添加多个分类时，分类方法的加载顺序又是如何呢？</div><div class="line">根据代码来看：</div><div class="line"></div><div class="line">``` C</div><div class="line">// 在以上代码的基础上再添加第二个category</div><div class="line">#import &quot;TestClassForCategory.h&quot;</div><div class="line"></div><div class="line">@interface TestClassForCategory (Category2)</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#import &quot;TestClassForCategory+Category2.h&quot;</div><div class="line"></div><div class="line">@implementation TestClassForCategory (Category2)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;load === TestClassForCategory+Category2&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)testMethod &#123;</div><div class="line">    // category的方法会添加到</div><div class="line">    NSLog(@&quot;category2----&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line">```</div><div class="line">执行结果如下：</div><div class="line">&gt; </div><div class="line">&gt; 2018-03-27 10:58:50.708610+0800 Runtime_Learning2[4434:4568830] load === TestClassForCategory</div><div class="line">&gt; 2018-03-27 10:58:50.711459+0800 Runtime_Learning2[4434:4568830] load === TestClassForCategory+Category1</div><div class="line">&gt; 2018-03-27 10:58:50.712078+0800 Runtime_Learning2[4434:4568830] load === TestClassForCategory+Category2</div><div class="line">&gt; 2018-03-27 10:58:50.927215+0800 Runtime_Learning2[4434:4568830] method - testMethod</div><div class="line">&gt; 2018-03-27 10:58:50.927375+0800 Runtime_Learning2[4434:4568830] category2----</div><div class="line">&gt; 2018-03-27 10:58:50.927585+0800 Runtime_Learning2[4434:4568830] method - testMethod</div><div class="line">&gt; 2018-03-27 10:58:50.928280+0800 Runtime_Learning2[4434:4568830] category1----</div><div class="line">&gt; 2018-03-27 10:58:50.928472+0800 Runtime_Learning2[4434:4568830] method - testMethod</div><div class="line">&gt; 2018-03-27 10:58:50.928653+0800 Runtime_Learning2[4434:4568830] instance method</div></pre></td></tr></table></figure></p>
<p>2018-03-27 10:58:53.851391+0800 Runtime_Learning2[4434:4568830] category2—-</p>
</blockquote>
<p>可以看到，最后加载的category2，则执行方法指向的是category2的方法。原因在哪呢？</p>
<p>在工程TARGETS -&gt; Build Phases -&gt; Compile Sources中，我们可以看到，自上而下，编译资源的顺序是：Category1.m、Category2.m，我们可以自己上下调整编译顺序并执行，结果显而易见：</p>
<p><strong>多个category的加载顺序（也是方法的覆盖顺序）是依照Compile Sources的顺序自上而下确定的。</strong></p>
<p><em>注意，返回值不同的方法也会覆盖，因为SEL与返回值无关。</em></p>
<p>所以，多个分类同时覆盖主类的方法时，执行结果无法直接确定，可能会出现不可预估的问题。</p>
<h3 id="category与extension的区别"><a href="#category与extension的区别" class="headerlink" title="category与extension的区别"></a>category与extension的区别</h3><p>一般来说，我们都会认为class extension（类的扩展）是匿名的category，因为语法详尽，且功能相似，但实际上来说，二者可以说是<em>完全不同</em>。</p>
<ul>
<li><p>extension: </p>
<ol>
<li>它是class的一部分，与interface、implementation三者共同组成class，声明周期与class相同。</li>
<li>分类是在编译期确定的，内部声明的属性和方法在编译期直接组成class结构体的数据（属性会自动生成ivar并合成setter和getter，分别添加到class的ivar_list和method_list中）。</li>
<li>分类声明的方法，实现必须在class的implementation中，所以没有本类的源代码无法添加extension。</li>
</ol>
</li>
<li><p>category:</p>
<ol>
<li>与class本体无关，可以单独存在。</li>
<li>扩展是在编译期编译，在运行时加载到类中。category由于其数据结构所限，只能添加方法实现、属性声明和协议实现，内部不包含ivar成员变量，所以无法保存数据（声明的属性不能生成对应的ivar，也不能合成出setter和getter的实现）。</li>
<li>编译期由于class结构布局和数据已经确定，在运行时，category只能将方法添加到class的方法链表中，其他东西无法修改（class的实例大小等在编译期已确定，无法修改）。</li>
</ol>
</li>
</ul>
<h3 id="关联对象和其他补充"><a href="#关联对象和其他补充" class="headerlink" title="关联对象和其他补充"></a>关联对象和其他补充</h3><ul>
<li><p>由于在category中添加属性，需要使用关联对象（associate object）进行添加和访问，那关联对象的数据保存在哪里呢？</p>
<p>  所有的关联对象都由AssociationsManager进行统一管理（添加、删除等），保存在全局map中，其中key是这个相关对象的指针地址，value则是单独的一个AssociationsHashMap，里面保存着key-value对。</p>
</li>
<li><p>提问：在class的load方法中，可以调用Category的方法吗？<br>  答：可以。runtime加载class和category等是在load方法调用前执行的，此时Category的方法已经加载到class的方法列表中，可以直接调用。</p>
</li>
<li><p>提问：当Category已经覆盖了Class中的方法时，如何调用Class中的原方法？<br>  答：由于使用“头插法”，Category的方法已经在Class的方法列表头部。系统调用方法时是从头开始检索，查到对应Method后即跳转IMP进行调用。我们可以使用runtime的api手动遍历Class的方法表，找到最后一个同名方法，直接调用IMP。</p>
</li>
<li><p>扩展一个类的方式：</p>
<ol>
<li>子类化</li>
<li>使用category</li>
<li>使用协议抽象（如UITableView的delegate和data source，可以给具有显示功能的类进行扩展）</li>
</ol>
</li>
</ul>
<p>参考内容：</p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="external">Customizing Existing Classes
</a></li>
<li><a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">深入理解Objective-C：Category
</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_14679a7d20102xae4.html" target="_blank" rel="external">iOS OC中分类Category实现原理</a></li>
<li><a href="https://www.jianshu.com/p/87cfbdda0a68" target="_blank" rel="external">【iOS】category 重写方法的调用</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;class和category的数据结构&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为什么category只能添加方法，不能添加属性？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;category为何不要
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS runtime学习</title>
    <link href="http://yoursite.com/2018/03/14/iOS%20runtime%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/03/14/iOS runtime学习/</id>
    <published>2018-03-14T03:33:33.000Z</published>
    <updated>2018-03-27T03:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开坑，待补-，学习总结"><a href="#开坑，待补-，学习总结" class="headerlink" title="开坑，待补~，学习总结~"></a>开坑，待补~，学习总结~</h3><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="external">Objective-C Runtime Programming Guide</a></li>
<li><a href="https://www.jianshu.com/p/0e6eb2f9ed5d" target="_blank" rel="external">iOS-runtime通篇详解-上</a></li>
<li><a href="https://www.jianshu.com/p/f1544b27d007" target="_blank" rel="external">iOS-runtime通篇详解-下</a></li>
<li><a href="https://www.jianshu.com/p/efeb33712445#" target="_blank" rel="external">Runtime全方位装逼指南
</a></li>
<li><a href="https://www.jianshu.com/p/19f280afcb24" target="_blank" rel="external">iOS 模块详解—「Runtime面试、工作」看我就 🐒 了 ^_^.</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开坑，待补-，学习总结&quot;&gt;&lt;a href=&quot;#开坑，待补-，学习总结&quot; class=&quot;headerlink&quot; title=&quot;开坑，待补~，学习总结~&quot;&gt;&lt;/a&gt;开坑，待补~，学习总结~&lt;/h3&gt;&lt;h3 id=&quot;参考资料：&quot;&gt;&lt;a href=&quot;#参考资料：&quot; cla
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS RunLoop学习</title>
    <link href="http://yoursite.com/2018/03/07/iOS%20RunLoop%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/03/07/iOS RunLoop学习/</id>
    <published>2018-03-07T06:21:53.000Z</published>
    <updated>2018-03-09T08:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RunLoop简介及与线程的关系："><a href="#RunLoop简介及与线程的关系：" class="headerlink" title="RunLoop简介及与线程的关系："></a>RunLoop简介及与线程的关系：</h3><p>简而言之，RunLoop就是一个“do-while”循环–一个事件队列循环。循环时，系统会依次从事件队列中取出事件并执行；没有事件处理时，RunLoop会进入休眠，等待事件唤醒处理，以节省系统资源，即“休眠-&gt;事件唤醒-&gt;处理事件-&gt;休眠…”的逻辑。</p>
<p>在iOS中，RunLoop存在的类为CFRunLoopRef和NSRunLoop。前者为CoreFoundation框架，C语言编写，线程安全；后者是OC封装，线程不安全。</p>
<p><strong>RunLoop与线程是一一对应的</strong>。根据源代码（苹果的官方文档或下面的参考资料中可以看到）可知，RunLoop对象存在于底层的一个全局字典中，key为线程（线程指针），value为RunLoop对象。</p>
<p><strong>应用初始化时，系统自动创建此全局字典，并自动创建主线程的RunLoop，以保证APP在运行时不退出。子线程的RunLoop不会自动创建。</strong>由于系统没有直接提供创建RunLoop的API，在子线程中只能通过CFRunLoopGetCurrent()或[NSRunLoop currentRunLoop]来间接获取Runloop（子线程中首次访问RunLoop时，系统会创建RunLoop对象并保存到全局字典中）。获取主线程的RunLoop的方式是CFRunLoopGetMain()和[NSRunLoop mainRunLoop]。</p>
<h3 id="RunLoop的组成结构："><a href="#RunLoop的组成结构：" class="headerlink" title="RunLoop的组成结构："></a>RunLoop的组成结构：</h3><p>先看图（摘自<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>）</p>
<p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" alt="img"></p>
<p>如图所示，RunLoop对象包含了若干个Mode对象（CFRunLoopModeRef），一个Mode对象中包含了若干个Item（Item为Source、Observer或Timer的一种或几种）。</p>
<p>其中<strong>CFRunLoopSourceRef</strong>分为Source0和Source1两种：source0对象只有一个Call_Out回调函数指针，不能主动唤醒RunLoop，处理事件时只能依照RunLoop的执行顺序被动执行或外界手动唤醒；source1对象则不同，除了带有Call_Out回调外，还包含一个Mach_Port端口参数（每个Source1唯一），外部可以通过这个端口与其进行线程间通信，且source1事件可以主动唤醒RunLoop进行处理。</p>
<p><strong>CFRunLoopObserverRef</strong>即为监听者，带有Call_Out函数回调函数指针，外部可以监听对应Observer来识别当前RunLoop的活动状态，RunLoop的活动状态包括:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</div><div class="line">	<span class="comment">// 即将进入RunLoop</span></div><div class="line">	kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>), </div><div class="line">	<span class="comment">// 即将处理Timer</span></div><div class="line">	kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</div><div class="line">	<span class="comment">// 即将处理Source</span></div><div class="line">	kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>),</div><div class="line">	<span class="comment">// 即将进入休眠</span></div><div class="line">	kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>),</div><div class="line">	<span class="comment">// 刚刚从睡眠中唤醒</span></div><div class="line">	kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>),</div><div class="line">	<span class="comment">// 即将退出RunLoop</span></div><div class="line">	kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>CFRunLoopTimerRef</strong>是基于时间的触发器，也包含一个Call_Out回调函数指针（还有RunLoop上所有timer对象共享的的Mach_Port端口），与上层的NSTimer相同（toll-free bridged），添加到系统后，RunLoop会提前计算好触发时间并添加到RunLoop中，等待到时间时自动执行回调。</p>
<p><strong>Timer、Source0（1）、Observer同城为mode item。一个item可以添加到多个item中（下面的common item会说明）。而且，只有当至少包含一个item的mode存在时，对应的RunLoop对象才会持续运行且不退出（线程“保活”的原因）。</strong></p>
<h3 id="RunLoop-Mode的结构："><a href="#RunLoop-Mode的结构：" class="headerlink" title="RunLoop Mode的结构："></a>RunLoop Mode的结构：</h3><p>大致结构如下（摘自<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>），可以在APP启动后打印[NSRunLoop currentRunloop]自行查看完整RunLoop对象的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></div><div class="line">	CFStringRef _name;	<span class="comment">// mode的名称（如“kCFRunLoopDefaultMode”）</span></div><div class="line">	CFMutableSetRef _source0;</div><div class="line">	CFMutableSetRef _source1;</div><div class="line">	CFMutableArrayRef _observers;</div><div class="line">	CFMutableArrayRef _timers;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></div><div class="line">	CFMutableSetRef _commonModes;</div><div class="line">	CFMutableSetRef _commonModeItems;</div><div class="line">	CFRunLoopModeRef _currentMode;	<span class="comment">// 当前所处mode（即mode的name）</span></div><div class="line">	CFMutableSetRef _modes;		<span class="comment">// 包含所有支持的mode</span></div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面中的<strong>commonModes即为“标记为Common的mode对象集合”。对应的共享item即为commonModeItems集合。每当RunLoop内容变化时，_commonModeItems里面的所有item（observer、timer和source）都会同步到所有的commonModes的mode中。</strong></p>
<p>例如，对主线程的RunLoop来说，commonModes即包含两个：kCFRunLoopDefaultMode（NSDefaultRunLoopMode）和UITrackingRunLoopMode。其中当app处于列表滑动状态时，主线程处于trackingMode；其余时候处于defaultMode。</p>
<p><strong>同一时间，RunLoop只能处于一个mode模式下工作，切换mode时需要退出并重新指定mode。</strong></p>
<h3 id="RunLoop的内部逻辑："><a href="#RunLoop的内部逻辑：" class="headerlink" title="RunLoop的内部逻辑："></a>RunLoop的内部逻辑：</h3><p>就是“do-while”，看图（摘自<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>）：</p>
<p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_1.png" alt="img"></p>
<p>主要的运行循环为2~9步，这部分实现了“do-while”的逻辑；<br>核心为第7步，在没有事件待处理时，进行休眠，等待事件唤醒。</p>
<h3 id="RunLoop“休眠”机制："><a href="#RunLoop“休眠”机制：" class="headerlink" title="RunLoop“休眠”机制："></a>RunLoop“休眠”机制：</h3><p><strong>休眠时，RunLoop执行的核心函数为：mach_msg();</strong><br>此函数为XNU内核的Mach层的基本函数。Mach对象间使用“消息”在端口（“port”）之间进行进程间通信。<br>mach_msg()函数实际调用了函数mach_msg_trap()，即Mach陷阱函数。调用后，系统会切换至内核态，内核态中的mach_msg()函数完成真正的工作（休眠等待、唤醒等）。</p>
<p>看图（摘自<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>）：<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_5.png" alt="img"></p>
<h3 id="RunLoop在APP中的功能："><a href="#RunLoop在APP中的功能：" class="headerlink" title="RunLoop在APP中的功能："></a>RunLoop在APP中的功能：</h3><ul>
<li>AutoReleasePool:</li>
</ul>
<p>App启动后，iOS在主线程的RunLoop中注册了两个Observer，回调都是_wrapRunLoopWithAutoreleasePoolHandler()，其中一个优先级为最高（-2147483647），一个为最低（2147483647），这保证了创建自动释放池在所有代码运行之前，且释放池在所有任务之后，使整个app的代码运行在自动释放池中，防止了内存泄漏。</p>
<ul>
<li>事件响应：</li>
</ul>
<p><strong>iOS注册的用于接收系统硬件事件的Source1对象，回调为__IOHIDEventSystemClientCallback()，用于处理触摸、按键、传感器等事件。</strong></p>
<p>处理逻辑为：SpringBoard接收到转化后的IOHIDEvent事件，通过mach_port转发给需要的App进程，之后source1的回调会主动触发，调用<strong>UIApplicationHandleEventQueue()进行应用内分发。
</strong>UIApplicationHandleEventQueue()会将事件包装成UIEvent进行处理或分发。其中，手势、屏幕旋转等转发给UIWindow进行处理，通常的UIButton点击、touchBegin等触摸事件直接在这个回调中进行处理。</p>
<ul>
<li>手势识别：</li>
</ul>
<p>识别手势时，系统会先调用cancel将touchBegin等事件进行打断，随后会将对应的UIGestureRecognizer标记为待处理。<br>iOS注册的beforeWaiting的observer所对应的回调即为集中处理手势识别的函数：_UIGestureRecognizerUpdateObserver()。其内部会检测所有已标记的手势对象，并调用手势的回调函数。</p>
<ul>
<li>界面更新：</li>
</ul>
<p>当我们设置了view的frame，更新了view或者layer的层次后，甚至手动调用setNeedsDisplay或setNeedsLayout后，系统并不是立即渲染页面，而是将所有的界面更新请求添加到一个整体的容器中，等待下个RunLoop事件运行时，才进行统一更新。</p>
<p>iOS会在RunLoop中注册一个Observer，分别监听beforeWaiting和Exit状态，对应的回调为_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。在这两个状态中，系统会遍历容器中所有的UI更新请求，并统一渲染更新。</p>
<ul>
<li>定时器：</li>
</ul>
<p>NSTimer即为CFRunLoopTimerRef（timer对象）。注册NSTimer后，系统会在指定的触发时间在RunLoop中添加好timer事件及回调（由于有tolerance时间，不会特别准确，而且若回调timer时，线程正在执行繁重的任务，可能会导致此次调用被错过）。<br>CADisplayLink，是一个与屏幕刷新率相同的定时器（与NSTimer不同，内部为source对象）。功能上与timer相同，且仍然会被长任务卡住。</p>
<ul>
<li>PerformSelector：</li>
</ul>
<p>调用NSObject的performSelector:afterDelay:时，系统即创建一个timer并添加到线程的RunLoop中（与timer相同）。若此时线程没有RunLoop，则此方法无效（子线程需调用[[NSRunLoop currentRunLoop] run]才可）。</p>
<ul>
<li>GCD：</li>
</ul>
<p>主要是在dispatch_async(dispatch_get_main_queue(), block)中，libDispatch会发消息主动唤醒主线程的RunLoop，RunLoop即获取block并在<strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>()中执行这个block。但是在子线程的GCD异步函数中，还是直接由libDispatch进行处理。</p>
<ul>
<li>网络请求：</li>
</ul>
<p>iOS的网络请求此下而上分为：</p>
<blockquote>
<p>CFSocket    -&gt; 负责基本的socket通信<br>CFNetwork    -&gt; socket的封装（ASIHTTPRequest在这工作）<br>NSURLConnection    -&gt; AFNetworking 1.x<br>NSURLSession        -&gt; AFNetworking 2.x，Alamofire</p>
</blockquote>
<p>这里解释一下NSURLConnection的delegate不断被调用的原因，NSURLConnection的主要工作过程，看图先（摘自<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>）：</p>
<p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_network.png" alt="img"></p>
<p>NSURLConcentration在调用start开始请求后，delegate会获取请求线程的RunLoop对象，在其中的defaultMode中添加4个source0对象。其中CFMultiplexerSource负责delegate的各种回调，CFHTTPCookieStorage负责各种Cookie。<br>开始网络传输时，NSURLConcentration创建了两个新线程（上图中的CFSocket线程和ConnectionLoader线程），ConnectionLoader线程的RunLoop会接受底层socket线程的source1传递的消息，并通过请求线程的source0事件，唤醒请求线程并调用相应的delegate回调。</p>
<h3 id="实际应用举例："><a href="#实际应用举例：" class="headerlink" title="实际应用举例："></a>实际应用举例：</h3><ul>
<li>监听RunLoop的运行状态（添加observer到RunLoop）：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">CFAllocatorRef allocator = CFAllocatorGetDefault(); <span class="comment">// 内存开辟方式</span></div><div class="line">CFOptionFlags activites = kCFRunLoopAllActivities; <span class="comment">// 监控活动类型（这里是所有类型）</span></div><div class="line">Boolean repeats = <span class="literal">true</span>; <span class="comment">// 重复监听</span></div><div class="line">CFIndex order = <span class="number">0</span>; <span class="comment">// 优先级</span></div><div class="line"><span class="comment">// 给主线程的runloop添加observer</span></div><div class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(allocator, activites, repeats, order, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</div><div class="line">    <span class="keyword">switch</span> (activity) &#123;</div><div class="line">        <span class="keyword">case</span> kCFRunLoopEntry:</div><div class="line">            NSLog(@<span class="string">"runloop进入了~"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCFRunLoopBeforeTimers:</div><div class="line">            NSLog(@<span class="string">"准备执行timer了~"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCFRunLoopBeforeSources:</div><div class="line">            NSLog(@<span class="string">"准备执行source了~"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</div><div class="line">            NSLog(@<span class="string">"准备休眠了~"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCFRunLoopAfterWaiting:</div><div class="line">            NSLog(@<span class="string">"刚刚唤醒~"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCFRunLoopExit:</div><div class="line">            NSLog(@<span class="string">"退出了runloop~"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 添加observer到主runloop的defaultMode上</span></div><div class="line">CFRunLoopRef mainRunLoop = CFRunLoopGetMain();</div><div class="line">CFRunLoopMode runLoopMode = kCFRunLoopDefaultMode;</div><div class="line">CFRunLoopAddObserver(mainRunLoop, observer, runLoopMode);</div></pre></td></tr></table></figure>
<ul>
<li>设置定时器（添加timer到RunLoop）：</li>
</ul>
<ol>
<li>使用NSTimer在子线程创建：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    [NSTimer scheduledTimerWithTimeInterval:<span class="number">5</span> repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</div><div class="line">        NSLog(@<span class="string">"hahahah~"</span>);</div><div class="line">    &#125;];</div><div class="line">    <span class="comment">// 默认在子线程是不存在RunLoop的，必须告知系统创建</span></div><div class="line">    <span class="comment">// 且保持RunLoop不退出的前提是，存在一个item（timer、observer或source）</span></div><div class="line">    [[NSRunLoop currentRunLoop] run];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如上所示，不调用RunLoop的run方法，timer在子线程不会执行。</p>
<ol>
<li>使用GCD的dispatch的资源对象创建：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">/** 使用GCD添加的timer */</div><div class="line">@property (strong, nonatomic) dispatch_source_t timer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    [self addTimerToRunLoop];</div><div class="line">&#125;</div><div class="line"></div><div class="line">/** 向runloop上添加timer（这里是GCD方式） */</div><div class="line">- (void)addTimerToRunLoop &#123;</div><div class="line">//    dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">    dispatch_queue_t myQueue = dispatch_queue_create("com.jiji.my_queue", DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    </div><div class="line">//    dispatch_queue_t mainQueue = dispatch_get_main_queue();</div><div class="line">    </div><div class="line">    // 在队列中创建timer资源对象</div><div class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, myQueue);</div><div class="line">    // 保留timer（GCD不会保留timer资源对象）</div><div class="line">    self.timer = timer;</div><div class="line">    </div><div class="line">    </div><div class="line">    // 设置timer资源的间隔和宽容度</div><div class="line">    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</div><div class="line">    // 设置timer资源的事件回调</div><div class="line">    dispatch_source_set_event_handler(timer, ^&#123;</div><div class="line">        NSLog(@"==%@==", [NSThread currentThread]);</div><div class="line">    &#125;);</div><div class="line">    // 启动timer资源</div><div class="line">    dispatch_resume(timer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)cancelTimer &#123;</div><div class="line">    dispatch_cancel(self.timer);</div><div class="line">    self.timer = nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注意，使用GCD的方式创建timer，系统不会保留dispatch_source_t对象，需要自己保留，否则创建后会直接释放。取消时使用dispatch_cancel()。</p>
<ul>
<li>performSelector测试：</li>
</ul>
<p>在子线程中调用performSelector：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// backgroundThread</span></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="comment">// 相当于直接调用（没有通过runloop直接同步执行）</span></div><div class="line">    [self performSelector:@selector(performTask) withObject:nil];</div><div class="line"></div><div class="line">    NSLog(@<span class="string">"before ---- %@"</span>, [NSRunLoop currentRunLoop]);</div><div class="line"></div><div class="line">    <span class="comment">// 直接调用不执行（runloop没有启动）</span></div><div class="line">    <span class="comment">// 实际上是在runloop的mode中加入了source0和source1两个事件</span></div><div class="line">    [self performSelector:@selector(performTask) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</div><div class="line"></div><div class="line">    NSLog(@<span class="string">"after ==== %@"</span>, [NSRunLoop currentRunLoop]);</div><div class="line"></div><div class="line">    <span class="comment">// 启动runloop</span></div><div class="line">    [[NSRunLoop currentRunLoop] run];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>线程“保活”：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">/** 保证不结束的自定义线程 */</div><div class="line">@property (strong, nonatomic) NSThread *liveThread;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    // 保活线程测试</div><div class="line">    [self liveThreadTest];    </div><div class="line">&#125;</div><div class="line"></div><div class="line">/** 长时间存活的线程 */</div><div class="line">- (void)liveThreadTest &#123;</div><div class="line">    self.liveThread = [[NSThread alloc] initWithTarget:self selector:@selector(startLiveThread) object:nil];</div><div class="line">    [self.liveThread start];</div><div class="line">    // 点击一次屏幕，执行一次线程的任务</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)startLiveThread &#123;</div><div class="line">    NSLog(@"%@", NSStringFromSelector(_cmd));</div><div class="line">    // 在自定义线程中添加一个source1对象（这里是NSPort对象）到runloop中</div><div class="line">    // 并启动runloop</div><div class="line">    // 以保证runloop一直有任务而不退出</div><div class="line">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">    [[NSRunLoop currentRunLoop] run];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)liveThreadTask &#123;</div><div class="line">    NSLog(@"%@", NSStringFromSelector(_cmd));</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;    </div><div class="line">    // 在自定义线程中执行任务</div><div class="line">    [self performSelector:@selector(liveThreadTask) onThread:self.liveThread withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<ul>
<li>在scrollView滑动时，也可以执行主线程的定时器：</li>
</ul>
<p>将timer添加到主线程RunLoop的commonMode中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:<span class="number">0.5</span> repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</div><div class="line">    NSLog(@<span class="string">"timer---"</span>);</div><div class="line">&#125;];</div><div class="line">[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="external">Run Loops</a></li>
<li><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></li>
<li><a href="http://www.cnblogs.com/kenshincui/p/6823841.html" target="_blank" rel="external">iOS刨根问底-深入理解RunLoop</a></li>
<li><a href="http://www.imlifengfeng.com/blog/?p=487" target="_blank" rel="external">iOS RunLoop详解</a></li>
<li><a href="http://www.jb51.net/article/123505.htm" target="_blank" rel="external">Dispatch Source Timer的使用及注意事项介绍</a></li>
<li><a href="https://www.jianshu.com/p/536184bfd163" target="_blank" rel="external">IOS—实例化讲解RunLoop
</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RunLoop简介及与线程的关系：&quot;&gt;&lt;a href=&quot;#RunLoop简介及与线程的关系：&quot; class=&quot;headerlink&quot; title=&quot;RunLoop简介及与线程的关系：&quot;&gt;&lt;/a&gt;RunLoop简介及与线程的关系：&lt;/h3&gt;&lt;p&gt;简而言之，RunLo
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS GCD学习总结</title>
    <link href="http://yoursite.com/2018/03/05/ios_GCD_learning/"/>
    <id>http://yoursite.com/2018/03/05/ios_GCD_learning/</id>
    <published>2018-03-05T03:20:48.000Z</published>
    <updated>2018-03-06T03:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCD是苹果以C语言编写、从队列和任务的角度设计的多线程编程框架。避免了开发者直接操作线程，降低了因操作不当导致的多线程性能下降、死锁等情况的可能性。使用GCD，可以降低多线程开发的门槛，最大限度地提升APP性能，开发人员可以专注于业务的开发。（注：在swift中，苹果重写了GCD，api均为swift接口，保持了开发语言的一致性。）"><a href="#GCD是苹果以C语言编写、从队列和任务的角度设计的多线程编程框架。避免了开发者直接操作线程，降低了因操作不当导致的多线程性能下降、死锁等情况的可能性。使用GCD，可以降低多线程开发的门槛，最大限度地提升APP性能，开发人员可以专注于业务的开发。（注：在swift中，苹果重写了GCD，api均为swift接口，保持了开发语言的一致性。）" class="headerlink" title="GCD是苹果以C语言编写、从队列和任务的角度设计的多线程编程框架。避免了开发者直接操作线程，降低了因操作不当导致的多线程性能下降、死锁等情况的可能性。使用GCD，可以降低多线程开发的门槛，最大限度地提升APP性能，开发人员可以专注于业务的开发。（注：在swift中，苹果重写了GCD，api均为swift接口，保持了开发语言的一致性。）"></a>GCD是苹果以C语言编写、从队列和任务的角度设计的多线程编程框架。避免了开发者直接操作线程，降低了因操作不当导致的多线程性能下降、死锁等情况的可能性。使用GCD，可以降低多线程开发的门槛，最大限度地提升APP性能，开发人员可以专注于业务的开发。（注：在swift中，苹果重写了GCD，api均为swift接口，保持了开发语言的一致性。）</h2><h3 id="主要组成："><a href="#主要组成：" class="headerlink" title="主要组成："></a>主要组成：</h3><ul>
<li>队列：主要分为<strong>串行队列</strong>和<strong>并发队列</strong>两种。在iOS系统中，系统预先提供了两个现成可以直接使用的队列，分别是<strong>主队列</strong>和<strong>全局队列</strong>，其中<strong>主队列</strong>即我们常说的APP主线程。</li>
<li>任务：在OC中以<strong>block</strong>作为单位，分为<strong>“同步任务”</strong>和<strong>“异步任务”</strong>。</li>
</ul>
<p>其中，队列和任务可以根据需要随意组合使用。</p>
<h3 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h3><h4 id="创建和获取队列："><a href="#创建和获取队列：" class="headerlink" title="创建和获取队列："></a>创建和获取队列：</h4><ul>
<li>创建串行队列：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t myQueue = dispatch_queue)create(&quot;com.jiji.my_queue&quot;, DISPATCH_QUEUE_SERIAL);</div></pre></td></tr></table></figure>
<p>串行队列即为单任务队列，任务只能按加入顺序执行。</p>
<ul>
<li>创建并发队列：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t myQueue = dispatch_queue)create(&quot;com.jiji.my_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<p>并发队列，同时可以执行多个任务。</p>
<ul>
<li>获取主队列：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</div></pre></td></tr></table></figure>
<p>主队列，UI操作都在这个队列上进行。</p>
<ul>
<li>获取全局队列：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div></pre></td></tr></table></figure>
<p>其中，全局队列的第一参数为优先级，这里默认为default，第二个参数为预留参数。我们一般可以在这个队列中处理一些耗时任务，如网络请求、IO等。</p>
<h4 id="向队列中派发任务并执行任务："><a href="#向队列中派发任务并执行任务：" class="headerlink" title="向队列中派发任务并执行任务："></a>向队列中派发任务并执行任务：</h4><p>创建同步或异步任务时，都需要指定派发到的队列。</p>
<ul>
<li>串行队列 + 同步任务：</li>
</ul>
<p>本质上是在派发任务所在的线程中（不创建新线程），依次执行任务，完成一个后执行下一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</div><div class="line">dispatch_queue_t myQueue = dispatch_queue_create(&quot;com.jiji.my_queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;block 1---- %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;block 2---- %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;block 3---- %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 14:00:56.434341+0800 Thread_Test2[5813:216673] current thread = <nsthread: 0x600000068f00="">{number = 1, name = main}<br>2018-03-05 14:00:58.435759+0800 Thread_Test2[5813:216673] block 1—- <nsthread: 0x600000068f00="">{number = 1, name = main}<br>2018-03-05 14:01:00.437177+0800 Thread_Test2[5813:216673] block 2—- <nsthread: 0x600000068f00="">{number = 1, name = main}<br>2018-03-05 14:01:02.438452+0800 Thread_Test2[5813:216673] block 3—- <nsthread: 0x600000068f00="">{number = 1, name = main}</nsthread:></nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>从上面的例子可以看出，向串行队列中派发的同步任务，执行时并没有开启新的线程，只是在当前线程中直接执行（这里是在主线程向队列派发任务，所以直接在主线程执行）。</p>
<ul>
<li>串行队列 + 异步任务：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</div><div class="line">dispatch_queue_t myQueue = dispatch_queue_create(&quot;com.jiji.my_queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;block 1---- %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;block 2---- %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;block 3---- %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 14:08:13.786385+0800 Thread_Test2[5952:225569] current thread = <nsthread: 0x60400007c340="">{number = 1, name = main}<br>2018-03-05 14:08:15.787681+0800 Thread_Test2[5952:225858] block 1—- <nsthread: 0x60000027d680="">{number = 3, name = (null)}<br>2018-03-05 14:08:17.788864+0800 Thread_Test2[5952:225858] block 2—- <nsthread: 0x60000027d680="">{number = 3, name = (null)}<br>2018-03-05 14:08:19.790784+0800 Thread_Test2[5952:225858] block 3—- <nsthread: 0x60000027d680="">{number = 3, name = (null)}</nsthread:></nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>可以看到，向串行队列中派发异步任务，任务会在新线程中执行依次执行（系统单独创建了新线程）。</p>
<ul>
<li>并发队列 + 同步任务：</li>
</ul>
<p>这个要与“串行队列+同步”对比着来看：<br>直接在同一队列中向并发队列派发同步任务时（如都在主线程直接往队列中派发同步任务），结果是相同的，都是依次执行任务，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 创建并发队列</div><div class="line">dispatch_queue_t myQueue = dispatch_queue_create(&quot;com.jiji.myQueue1&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">// 添加同步任务</div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block0---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:5];</div><div class="line">    NSLog(@&quot;finished block0!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    sleep(2);</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 14:53:14.154154+0800 Thread_Test2[6775:272681] start block0———<nsthread: 0x6000000641c0="">{number = 1, name = main}<br>2018-03-05 14:53:19.156046+0800 Thread_Test2[6775:272681] finished block0!!!!!!!!<br>2018-03-05 14:53:19.156402+0800 Thread_Test2[6775:272681] start block1———<nsthread: 0x6000000641c0="">{number = 1, name = main}<br>2018-03-05 14:53:21.157883+0800 Thread_Test2[6775:272681] finished block1!!!!!!!!<br>2018-03-05 14:53:21.158132+0800 Thread_Test2[6775:272681] start block2———<nsthread: 0x6000000641c0="">{number = 1, name = main}<br>2018-03-05 14:53:23.159384+0800 Thread_Test2[6775:272681] finished block2!!!!!!!!<br>2018-03-05 14:53:23.159621+0800 Thread_Test2[6775:272681] start block3———<nsthread: 0x6000000641c0="">{number = 1, name = main}<br>2018-03-05 14:53:25.160953+0800 Thread_Test2[6775:272681] finished block3!!!!!!!!</nsthread:></nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>看起来与“串行队列+同步”没有什么区别，这是由于派发任务（可以看做从上到下执行代码，将block加入）都在同一队列（这里是主线程）中执行。</p>
<p>但是，当我们在不同的队列（即不同线程）中同时向你的并发队列中派发同步任务时，结果就不同了（这里才真正体现出了并发队列的并发性，即同时执行任务）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// 创建并发队列</div><div class="line">dispatch_queue_t myQueue = dispatch_queue_create(&quot;com.jiji.myQueue1&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">// 添加同步任务</div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block0---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:5];</div><div class="line">    NSLog(@&quot;finished block0!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 在全局队列中向自定义队列中派发同步任务</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">//        NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</div><div class="line"></div><div class="line">    // 添加同步任务</div><div class="line">    dispatch_sync(myQueue, ^&#123;</div><div class="line">        NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">        [NSThread sleepForTimeInterval:2];</div><div class="line">        NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    sleep(2);</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 14:59:05.769961+0800 Thread_Test2[6879:280233] start block0———<nsthread: 0x600000069080="">{number = 1, name = main}<br>2018-03-05 14:59:10.770410+0800 Thread_Test2[6879:280233] finished block0!!!!!!!!<br>2018-03-05 14:59:10.770848+0800 Thread_Test2[6879:280233] start block2———<nsthread: 0x600000069080="">{number = 1, name = main}<br>2018-03-05 14:59:10.770956+0800 Thread_Test2[6879:280344] start block1———<nsthread: 0x600000273880="">{number = 3, name = (null)}<br>2018-03-05 14:59:12.771788+0800 Thread_Test2[6879:280233] finished block2!!!!!!!!<br>2018-03-05 14:59:12.772043+0800 Thread_Test2[6879:280233] start block3———<nsthread: 0x600000069080="">{number = 1, name = main}<br>2018-03-05 14:59:12.772084+0800 Thread_Test2[6879:280344] finished block1!!!!!!!!<br>2018-03-05 14:59:14.772608+0800 Thread_Test2[6879:280233] finished block3!!!!!!!!</nsthread:></nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>可以看到，执行任务的顺序为“0-2-1-3”（这里是由于block1是在其他线程中派发所致），但是执行时，仔细观察，在同一线程中执行的任务，都是依次执行并完成（与串行队列相同），<strong>但是在不同线程中（block1和block2所在线程），block是并行执行的，这里体现了并发队列的并发性</strong>。所以不能武断地认定“并发队列+同步”与“串行队列+同步”效果相同。这里需要尤其注意！（作为对比，“串行队列+同步”的情况下，在不同线程中派发同步任务，虽然派发顺序可能不同，但任务依然是串行执行，童鞋们请自行验证~）</p>
<ul>
<li>并发队列 + 异步任务：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_async(globalQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(globalQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(globalQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 15:14:22.892746+0800 Thread_Test2[7097:295593] start block1———<nsthread: 0x604000465fc0="">{number = 3, name = (null)}<br>2018-03-05 15:14:22.892746+0800 Thread_Test2[7097:295584] start block2———<nsthread: 0x600000271cc0="">{number = 4, name = (null)}<br>2018-03-05 15:14:22.892756+0800 Thread_Test2[7097:295582] start block3———<nsthread: 0x6000002718c0="">{number = 5, name = (null)}<br>2018-03-05 15:14:24.897942+0800 Thread_Test2[7097:295584] finished block2!!!!!!!!<br>2018-03-05 15:14:24.897947+0800 Thread_Test2[7097:295582] finished block3!!!!!!!!<br>2018-03-05 15:14:24.897942+0800 Thread_Test2[7097:295593] finished block1!!!!!!!!</nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>可以看到，系统开启了三个新线程，同时执行了任务，即“并发+异步”。</p>
<blockquote>
<p>综上所述，</p>
<p><em>“同步”</em>与<em>“异步”</em>的关键是<strong>是否开启新线程</strong>；</p>
<p><em>“串行”</em>与<em>“并发”</em>的关键是<strong>是否可以同时执行任务</strong>。</p>
</blockquote>
<p><em>特别情况–“主队列”</em>：</p>
<ul>
<li>主队列 + 同步任务：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</div><div class="line">dispatch_sync(mainQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_sync(mainQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_sync(mainQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：直接死锁。</p>
<p>死锁原因：由于同步任务的执行顺序是“派发任务1-&gt;执行任务1-&gt;派发任务2-&gt;执行任务2…”，即下一个任务的派发要在上一个任务完成之后才能继续。然而，在主队列中，被派发的任务（block对象）会添加到主队列的末端。此时，<strong>派发任务函数没有返回（没有执行完成），会给主队列的线程加锁；新添加的任务由于在末端，前面的任务没有完成，就没有机会执行，也就不能返回；派发任务函数就不可能再继续往下执行（互相依赖），从而造成死锁</strong>。</p>
<p>解决方案：在其他队列（非主线程）中向主队列派发同步任务，或在主队列中派发异步任务。</p>
<p>同样，在串行队列自身内部派发同步任务（“异步任务嵌套同步”或“同步任务嵌套同步”），同样会导致死锁。</p>
<ul>
<li>主队列 + 异步任务：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</div><div class="line">dispatch_async(mainQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(mainQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(mainQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 15:57:48.249706+0800 Thread_Test2[7880:347161] start block1———<nsthread: 0x604000065d00="">{number = 1, name = main}<br>2018-03-05 15:57:50.250190+0800 Thread_Test2[7880:347161] finished block1!!!!!!!!<br>2018-03-05 15:57:50.250654+0800 Thread_Test2[7880:347161] start block2———<nsthread: 0x604000065d00="">{number = 1, name = main}<br>2018-03-05 15:57:52.251663+0800 Thread_Test2[7880:347161] finished block2!!!!!!!!<br>2018-03-05 15:57:52.252088+0800 Thread_Test2[7880:347161] start block3———<nsthread: 0x604000065d00="">{number = 1, name = main}<br>2018-03-05 15:57:54.253489+0800 Thread_Test2[7880:347161] finished block3!!!!!!!!</nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>可见，在主队列派发异步任务，是在主线程同步执行（<strong>主队列中执行异步任务不会开启新线程</strong>）。</p>
<h4 id="延迟执行任务："><a href="#延迟执行任务：" class="headerlink" title="延迟执行任务："></a>延迟执行任务：</h4><p>使用Dispatch_after函数和dispatch_time_t变量，向指定队列添加延迟指定时间执行的异步任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;start-----&quot;);</div><div class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</div><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)3.0 * NSEC_PER_SEC);</div><div class="line">dispatch_after(time, mainQueue, ^&#123;</div><div class="line">    NSLog(@&quot;executing block!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;end======&quot;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 16:34:15.672982+0800 Thread_Test2[8449:389175] start—–<br>2018-03-05 16:34:15.673193+0800 Thread_Test2[8449:389175] end======<br>2018-03-05 16:34:18.673343+0800 Thread_Test2[8449:389175] executing block!!!!!!!!</p>
</blockquote>
<h4 id="只执行一次的任务（线程安全）："><a href="#只执行一次的任务（线程安全）：" class="headerlink" title="只执行一次的任务（线程安全）："></a>只执行一次的任务（线程安全）：</h4><p>使用Dispatch_once函数和静态的dispatch_once_t变量实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">    NSLog(@&quot;正在执行~~ %ld&quot;, onceToken);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;%ld&quot;, onceToken);</div></pre></td></tr></table></figure>
<p>连续执行两次，执行结果：</p>
<blockquote>
<p>2018-03-05 17:14:38.877559+0800 Thread_Test2[9012:424274] 正在执行~~ 1024<br>2018-03-05 17:14:38.877732+0800 Thread_Test2[9012:424274] -1<br>2018-03-05 17:14:41.878217+0800 Thread_Test2[9012:424274] -1</p>
</blockquote>
<p>由于onceToken变量为静态或全局变量，执行一次后会赋值为-1，以后即不会执行，dispatch_once函数可以保证在整个app运行期间只执行一次，且多线程安全（多线程同时调用时会同步执行，block执行完毕后才返回）。常用于单例设计中。</p>
<h4 id="栅栏任务（任务分隔）："><a href="#栅栏任务（任务分隔）：" class="headerlink" title="栅栏任务（任务分隔）："></a>栅栏任务（任务分隔）：</h4><ul>
<li>dispatch_barrier_async:</li>
</ul>
<p>使用dispatch_barrier_async函数派发的任务将队列中之前和之后的异步任务分隔开（执行完此栅栏任务才执行后面的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t myQueue = dispatch_queue_create(&quot;com.jiji.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_barrier_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start barrier block---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished barrier block-=-=-=-=&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block4---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block4!!!!!!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 17:50:53.017995+0800 Thread_Test2[9520:461498] start block1———<nsthread: 0x604000470ac0="">{number = 3, name = (null)}<br>2018-03-05 17:50:53.017995+0800 Thread_Test2[9520:461499] start block2———<nsthread: 0x604000470b00="">{number = 4, name = (null)}<br>2018-03-05 17:50:55.019075+0800 Thread_Test2[9520:461498] finished block1!!!!!!!!<br>2018-03-05 17:50:55.019075+0800 Thread_Test2[9520:461499] finished block2!!!!!!!!<br>2018-03-05 17:50:55.019459+0800 Thread_Test2[9520:461499] start barrier block———<nsthread: 0x604000470b00="">{number = 4, name = (null)}<br>2018-03-05 17:50:57.021234+0800 Thread_Test2[9520:461499] finished barrier block-=-=-=-=<br>2018-03-05 17:50:57.021626+0800 Thread_Test2[9520:461499] start block3———<nsthread: 0x604000470b00="">{number = 4, name = (null)}<br>2018-03-05 17:50:57.021644+0800 Thread_Test2[9520:461498] start block4———<nsthread: 0x604000470ac0="">{number = 3, name = (null)}<br>2018-03-05 17:50:59.025274+0800 Thread_Test2[9520:461499] finished block3!!!!!!!!<br>2018-03-05 17:50:59.025250+0800 Thread_Test2[9520:461498] finished block4!!!!!!!!</nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>注意：dispatch_barrier_async所派发到的队列<strong>必须是自己创建的并发队列</strong>，才会起到分隔作用，<strong>在串行或自带的全局队列中派发相当于普通的dispatch_async异步函数</strong>。</p>
<ul>
<li>dispatch_barrier_sync:</li>
</ul>
<p>与async版本大致作用相同，都是在自己的异步队列中起到分隔任务执行的作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t myQueue = dispatch_queue_create(&quot;com.jiji.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_barrier_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start barrier block---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished barrier block-=-=-=-=&quot;);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;aaa----&quot;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;bbb===&quot;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block4---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block4!!!!!!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 18:20:42.129155+0800 Thread_Test2[9940:497853] start block2———<nsthread: 0x60400026e280="">{number = 4, name = (null)}<br>2018-03-05 18:20:42.129156+0800 Thread_Test2[9940:497854] start block1———<nsthread: 0x600000274180="">{number = 3, name = (null)}<br>2018-03-05 18:20:44.133480+0800 Thread_Test2[9940:497853] finished block2!!!!!!!!<br>2018-03-05 18:20:44.133480+0800 Thread_Test2[9940:497854] finished block1!!!!!!!!<br>2018-03-05 18:20:44.134002+0800 Thread_Test2[9940:497766] start barrier block———<nsthread: 0x6000000698c0="">{number = 1, name = main}<br>2018-03-05 18:20:46.134747+0800 Thread_Test2[9940:497766] finished barrier block-=-=-=-=<br>2018-03-05 18:20:46.136687+0800 Thread_Test2[9940:497766] aaa—-<br>2018-03-05 18:20:46.138866+0800 Thread_Test2[9940:497766] bbb===<br>2018-03-05 18:20:46.138930+0800 Thread_Test2[9940:497853] start block3———<nsthread: 0x60400026e280="">{number = 4, name = (null)}<br>2018-03-05 18:20:46.144088+0800 Thread_Test2[9940:497851] start block4———<nsthread: 0x600000273c80="">{number = 5, name = (null)}<br>2018-03-05 18:20:48.150834+0800 Thread_Test2[9940:497853] finished block3!!!!!!!!<br>2018-03-05 18:20:48.151900+0800 Thread_Test2[9940:497851] finished block4!!!!!!!!</nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>可见，与async作用大体一致，都是分隔两组任务的执行。区别是：“aaa”和“bbb”的输出是在barrier的任务完成之后。也就是说，<strong>dispatch_barrier_sync派发任务会阻碍当前线程运行，直到barrier的任务完成返回后再继续执行后面的代码</strong>（主线程任务和后面的派发）；而async的版本不会阻碍当前线程执行（会直接先输出“aaa”和“bbb”）。此外，<strong>在串行队列或自带的全局队列中派发barrier任务，相当于dispatch_sync</strong>。</p>
<h4 id="迭代派发任务："><a href="#迭代派发任务：" class="headerlink" title="迭代派发任务："></a>迭代派发任务：</h4><p>使用dispatch_apply函数可以向队列中迭代派发多个任务，相当于GCD版本的for循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//    dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">//    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.jiji.my_serial_queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.jiji.my_concurrent_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_apply((size_t)5, concurrentQueue, ^(size_t index) &#123;</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;apply -- %ld, thread = %@&quot;, index, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;finished---&quot;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 21:26:02.462338+0800 Thread_Test2[11015:575150] apply – 0, thread = <nsthread: 0x60400007b040="">{number = 1, name = main}<br>2018-03-05 21:26:02.464843+0800 Thread_Test2[11015:575416] apply – 1, thread = <nsthread: 0x60000046ed80="">{number = 5, name = (null)}<br>2018-03-05 21:26:02.464840+0800 Thread_Test2[11015:575417] apply – 2, thread = <nsthread: 0x6040002763c0="">{number = 3, name = (null)}<br>2018-03-05 21:26:02.464854+0800 Thread_Test2[11015:575418] apply – 3, thread = <nsthread: 0x604000276280="">{number = 4, name = (null)}<br>2018-03-05 21:26:04.463205+0800 Thread_Test2[11015:575150] apply – 4, thread = <nsthread: 0x60400007b040="">{number = 1, name = main}<br>2018-03-05 21:26:04.463406+0800 Thread_Test2[11015:575150] finished—</nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>如上所示：</p>
<ul>
<li>在并发队列或全局队列中，dispatch_apply会派发size_t数量的异步任务，同时阻塞派发线程，待迭代的所有任务全部完成后继续向下执行（并发队列里是并发执行）。同时，系统会动态创建并分配任务的执行线程，防止线程的大量创建，优化多线程执行效率。</li>
<li>在串行队列中，直接按照dispatch_sync同步任务，在派发线程中串行执行。</li>
<li>在主队列中，死锁（主线程派发同步任务导致）。</li>
</ul>
<blockquote>
<p>应用场景：<br>以像素为单位的image处理（防止线程爆炸）；<br>字典转模型（并发队列，异步处理后，回到主线程）</p>
</blockquote>
<h4 id="队列组："><a href="#队列组：" class="headerlink" title="队列组："></a>队列组：</h4><p>以组的形式管理多个队列执行任务：</p>
<ul>
<li>支持以dispatch_group_async的方式派发异步任务到组中；（dispatch_group_enter和dispatch_group_leave与dispatch_async配合使用效果相同）</li>
<li>支持以dispatch_group_wait的方式阻塞当前队列组，直到执行完成所有派发的任务或到达超时时间后再继续向下执行（完成和超时后，队列组会清空）；</li>
<li>dispatch_group_notify派发的任务在所有组任务完成后执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">// 创建组</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line"></div><div class="line">// 派发到全局队列中的异步任务，添加到组中</div><div class="line">dispatch_group_async(group, globalQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 以dispatch_group_enter的方式添加异步任务到组中</div><div class="line">dispatch_group_enter(group);</div><div class="line">dispatch_async(globalQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">    </div><div class="line">    // dispatch_group_leave从组中移除任务</div><div class="line">    dispatch_group_leave(group);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 等待任务（这里是等待组中的任务全部完成）</div><div class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line"></div><div class="line">// 派发到全局队列中的异步任务，添加到组中</div><div class="line">dispatch_group_async(group, globalQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 全部执行完毕，切换回主线程执行</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;finished all!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 22:25:57.183194+0800 Thread_Test2[11842:630278] start block2———<nsthread: 0x60400027f800="">{number = 5, name = (null)}<br>2018-03-05 22:25:57.183195+0800 Thread_Test2[11842:630275] start block1———<nsthread: 0x6000004765c0="">{number = 4, name = (null)}<br>2018-03-05 22:25:59.184596+0800 Thread_Test2[11842:630275] finished block1!!!!!!!!<br>2018-03-05 22:25:59.184662+0800 Thread_Test2[11842:630278] finished block2!!!!!!!!<br>2018-03-05 22:25:59.185201+0800 Thread_Test2[11842:630278] start block3———<nsthread: 0x60400027f800="">{number = 5, name = (null)}<br>2018-03-05 22:26:01.189667+0800 Thread_Test2[11842:630278] finished block3!!!!!!!!<br>2018-03-05 22:26:01.189929+0800 Thread_Test2[11842:630025] finished all!!!</nsthread:></nsthread:></nsthread:></p>
</blockquote>
<h4 id="信号量："><a href="#信号量：" class="headerlink" title="信号量："></a>信号量：</h4><p><strong>信号量是一种基于计数器的多线程同步机制，用来管理对资源的并发访问。</strong></p>
<p>计数器为原子性的值，可以保证多线程安全，使用时，分为两种情况：</p>
<ol>
<li>初始值为0时，可以把两个线程的异步任务变为同步任务（控制先后执行顺序，线程同步）；</li>
<li>初始值大于0时，可以限制队列中的并发任务数（是几则同时可以有几个任务并发执行）；</li>
</ol>
<p>相关函数：</p>
<ul>
<li>dispatch_semaphore_create(value)：创建信号量（参数为并发数）</li>
<li>dispatch_semaphore_wait(semaphore)：抢占资源，信号量值-1</li>
<li>dispatch_semaphore_signal(semaphore)：释放资源，信号量值+1</li>
</ul>
<p>相关实例：</p>
<ul>
<li>“异步”变“同步”：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</div><div class="line"></div><div class="line">__block int number = 0;</div><div class="line"></div><div class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_async(globalQueue, ^&#123;</div><div class="line">    number = 100;</div><div class="line">    // 信号值+1，恢复派发线程继续执行</div><div class="line">    dispatch_semaphore_signal(semaphore);</div><div class="line">&#125;);</div><div class="line">// 初值是0，即为阻塞当前线程，一直等待</div><div class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">NSLog(@&quot;number = %d&quot;, number);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 23:02:29.855585+0800 Thread_Test2[12363:659768] number = 100</p>
</blockquote>
<ul>
<li>控制并发线程数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">// 同时只允许一个线程执行任务</div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">    dispatch_async(globalQueue, ^&#123;</div><div class="line">        // 抢占资源（-1）</div><div class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">        NSLog(@&quot;index = %d, semaphore = %@&quot;, i, semaphore);</div><div class="line">        // 释放资源（+1）</div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 23:20:34.300704+0800 Thread_Test2[12777:682814] index = 0, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.300918+0800 Thread_Test2[12777:682816] index = 1, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.301175+0800 Thread_Test2[12777:682815] index = 2, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.302360+0800 Thread_Test2[12777:682813] index = 3, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.303131+0800 Thread_Test2[12777:682814] index = 5, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.304928+0800 Thread_Test2[12777:682826] index = 4, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.305489+0800 Thread_Test2[12777:682816] index = 6, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.306229+0800 Thread_Test2[12777:682827] index = 7, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.306518+0800 Thread_Test2[12777:682829] index = 8, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.306642+0800 Thread_Test2[12777:682828] index = 9, semaphore = <os_dispatch_semaphore: 0x604000291b70=""></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></p>
</blockquote>
<p><strong>信号量初值为1时，即为线程加锁</strong>（前一个任务抢占资源后，下一个异步任务执行时，由于信号量值为0，线程进入等待状态，知道前一任务释放资源后继续执行）。</p>
<ul>
<li>保证数据的线程安全：</li>
</ul>
<p>实例：两个窗口的卖票问题（多线程间的数据共享与一致性）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">&#123;</div><div class="line">    /** 同步卖票系统的信号量 */</div><div class="line">    dispatch_semaphore_t _ticketSemaphore;</div><div class="line">    /** 余票总数 */</div><div class="line">    int _surplusTicketsCount;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">	[self initTicketStatus];</div><div class="line">&#125;</div><div class="line">/** 初始化票及窗口信息 */</div><div class="line">- (void)initTicketStatus &#123;</div><div class="line">    // 每个售票口都是按顺序卖票，所以是串行队列</div><div class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.my_queue1&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.my_queue2&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    </div><div class="line">    // 共50张票</div><div class="line">    _surplusTicketsCount = 50;</div><div class="line">    </div><div class="line">    // 信号量同步两个窗口（同时只能一个窗口操作）</div><div class="line">    _ticketSemaphore = dispatch_semaphore_create(1);</div><div class="line">    </div><div class="line">    // 两个窗口同时开卖（每个队列异步执行卖票任务）</div><div class="line">    __weak typeof(self) weakSelf = self;</div><div class="line">    dispatch_async(queue1, ^&#123;</div><div class="line">        [weakSelf saleTicket];</div><div class="line">    &#125;);</div><div class="line">    dispatch_async(queue2, ^&#123;</div><div class="line">        [weakSelf saleTicket];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)saleTicket &#123;</div><div class="line">    while (1) &#123;</div><div class="line">        // 获取资源（-1），此时信号量值为0，加锁</div><div class="line">        dispatch_semaphore_wait(_ticketSemaphore, DISPATCH_TIME_FOREVER);</div><div class="line">        </div><div class="line">        if (_surplusTicketsCount &gt; 0) &#123;</div><div class="line">            _surplusTicketsCount -= 1;</div><div class="line">            NSLog(@&quot;剩余票数：%d，窗口为：%@&quot;,</div><div class="line">                  _surplusTicketsCount,</div><div class="line">                  [NSThread currentThread]</div><div class="line">            );</div><div class="line">//            [NSThread sleepForTimeInterval:0.2];  // 不加延时时，多线程访问的顺序和值都有问题</div><div class="line">            </div><div class="line">            // 解锁(+1)，恢复资源</div><div class="line">            dispatch_semaphore_signal(_ticketSemaphore);</div><div class="line">        &#125; else &#123;</div><div class="line">            NSLog(@&quot;票已卖完，剩余票数：%d&quot;, _surplusTicketsCount);</div><div class="line">            </div><div class="line">            // 解锁(+1)，恢复资源</div><div class="line">            dispatch_semaphore_signal(_ticketSemaphore);</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>执行结果：两个队列任务依次执行，且执行时，余票信息正常输出。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><a href="https://www.jianshu.com/p/2d57c72016c6" target="_blank" rel="external">iOS多线程：『GCD』详尽总结</a></li>
<li><a href="http://blog.csdn.net/liuyang11908/article/details/70757534" target="_blank" rel="external"> iOS GCD之dispatch_semaphore（信号量）</a></li>
<li><a href="http://blog.csdn.net/u013046795/article/details/47057585" target="_blank" rel="external">通过GCD中的dispatch<em>barrier</em>(a)sync加强对sync中所谓等待的理解</a></li>
<li><a href="http://www.cocoachina.com/bbs/read.php?tid=1482884" target="_blank" rel="external">GCD中在主线程中用同步函数分派任务到串行队列中会产生死锁是什么原因？</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GCD是苹果以C语言编写、从队列和任务的角度设计的多线程编程框架。避免了开发者直接操作线程，降低了因操作不当导致的多线程性能下降、死锁等情况的可能性。使用GCD，可以降低多线程开发的门槛，最大限度地提升APP性能，开发人员可以专注于业务的开发。（注：在swift中
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Swift 3.0语法学习记录</title>
    <link href="http://yoursite.com/2017/08/15/Swift%203.0%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2017/08/15/Swift 3.0语法学习记录/</id>
    <published>2017-08-15T15:51:51.000Z</published>
    <updated>2017-08-16T05:44:56.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>重载运算符时，前置运算符需要在“func”关键字前添加<strong>“<em>prefix</em>”</strong>关键字：</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2D</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> y = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> +<span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="keyword">left</span>.x + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>.y + <span class="keyword">right</span>.y)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这里是前置运算符重载，需要添加“prefix”标识</span></div><div class="line"><span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> -<span class="params">(origin: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: -origin.x, y: -origin.y)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> vec1 = <span class="type">Vector2D</span>(x: <span class="number">2</span>, y: <span class="number">3</span>)</div><div class="line"><span class="keyword">let</span> vec2 = <span class="type">Vector2D</span>(x: <span class="number">1</span>, y: <span class="number">4</span>)</div><div class="line"><span class="keyword">let</span> vec3 = vec1 + vec2</div><div class="line"><span class="keyword">let</span> vec4 = -vec1</div></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>&gt; 此外，“infix”为中置操作符（如+、-、*、/等两边都需要操作数的）；“postfix”为后置操作符；当然，“prefix”为前置操作符。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;重载运算符时，前置运算符需要在“func”关键字前添加&lt;strong&gt;“&lt;em&gt;prefix&lt;/em&gt;”&lt;/strong&gt;关键字：&lt;/p&gt;
  &lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>四维矩阵？？？</title>
    <link href="http://yoursite.com/2017/08/07/%E5%9B%9B%E7%BB%B4%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2017/08/07/四维矩阵学习记录/</id>
    <published>2017-08-07T08:29:38.000Z</published>
    <updated>2017-08-07T08:57:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>看了个好东西，<a href="http://www.cnblogs.com/graphics/archive/2012/08/02/2616017.html" target="_blank" rel="external">矩阵-DirectX与OpenGL的不同</a>，原帖讲的很清楚</p>
<blockquote>
<p>一直不明白iOS为啥用四维矩阵来表示三维的东西（其他平台可能也如此吧~）</p>
<p>iOS平台上，使用OpenGL的四维矩阵表示空间</p>
</blockquote>
<p><img src="http://pic002.cnblogs.com/images/2012/64257/2012073120462521.gif" alt=""></p>
<p>上面这个是标准的四维矩阵（这个是DirectX的，与OpenGL的互为转置矩阵，即ios的为竖着的“m11, m12, m13, m14”）</p>
<p><img src="http://pic002.cnblogs.com/images/2012/64257/2012073121020368.gif" alt=""></p>
<p>其中，(Tx，Ty，Tz)为平移分量（对应iOS的“m41, m42, m43”）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了个好东西，&lt;a href=&quot;http://www.cnblogs.com/graphics/archive/2012/08/02/2616017.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;矩阵-DirectX与OpenGL的不同&lt;/a&gt;，
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SceneKit学习记录1_物理身体</title>
    <link href="http://yoursite.com/2017/07/18/SceneKit%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/"/>
    <id>http://yoursite.com/2017/07/18/SceneKit学习记录1/</id>
    <published>2017-07-18T05:34:31.000Z</published>
    <updated>2017-07-18T05:58:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/documentation/scenekit/scnphysicsbody?language=objc" target="_blank" rel="external">原文档</a></p>
<h1 id="物理身体类型（SCNPhysicsBodyType）"><a href="#物理身体类型（SCNPhysicsBodyType）" class="headerlink" title="物理身体类型（SCNPhysicsBodyType）"></a>物理身体类型（SCNPhysicsBodyType）</h1><blockquote>
<p>分为三类：</p>
<ul>
<li>静态身体：SCNPhysicsBodyTypeStatic</li>
<li>动态身体：SCNPhysicsBodyTypeDynamic</li>
<li>运动身体：SCNPhysicsBodyTypeKinematic</li>
</ul>
</blockquote>
<p><strong>作用</strong>：</p>
<ul>
<li>静态身体：不会被力或碰撞影响，不能移动</li>
<li>动态身体：可以被其他类型的身体碰撞或施加力</li>
<li>运动身体：不会被力或碰撞影响，但是可以直接移动他们去碰撞动态身体</li>
</ul>
<h4 id="Static（静态身体）"><a href="#Static（静态身体）" class="headerlink" title="Static（静态身体）"></a>Static（静态身体）</h4><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">影响</th>
<th style="text-align:center">被影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Static</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">Dynamic</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">Kinematic</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<h4 id="Dynamic（动态身体）"><a href="#Dynamic（动态身体）" class="headerlink" title="Dynamic（动态身体）"></a>Dynamic（动态身体）</h4><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">影响</th>
<th style="text-align:center">被影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Static</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">Dynamic</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Kinematic</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<h4 id="KineMatic（运动身体）"><a href="#KineMatic（运动身体）" class="headerlink" title="KineMatic（运动身体）"></a>KineMatic（运动身体）</h4><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">影响</th>
<th style="text-align:center">被影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Static</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">Dynamic</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">Kinematic</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/scenekit/scnphysicsbody?language=objc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ARKit文档瞎翻译（9）</title>
    <link href="http://yoursite.com/2017/07/04/ARKit_doc_9/"/>
    <id>http://yoursite.com/2017/07/04/ARKit_doc_9/</id>
    <published>2017-07-04T07:19:48.000Z</published>
    <updated>2017-07-04T08:23:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/documentation/arkit/arscnview/providing_3d_virtual_content_with_scenekit" target="_blank" rel="external">原文请戳</a></p>
<h1 id="使用SceneKit提供3D内容"><a href="#使用SceneKit提供3D内容" class="headerlink" title="使用SceneKit提供3D内容"></a>使用SceneKit提供3D内容</h1><p>使用SceneKit来添加逼真的3D对象到你的AR体验中</p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在AR中放置SpriteKit内容，你首先需要一个运行中的AR会话对象（参考<a href="https://developer.apple.com/documentation/arkit/building_a_basic_ar_experience?language=objc" target="_blank" rel="external">创建一个基本的AR体验</a>）。</p>
<p>因为ARKit可以自动匹配SceneKit空间到现实空间中，所以放置一个虚拟对象以便可以维持真实世界中的位置，只需要适当地设置这个对象的SceneKit位置就可以。举例来说，在一个默认配置中，下面的代码放置一个10cm的立方体，初始位置在相机前方20厘米处：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> cubeNode = <span class="type">SCNNode</span>(geometry: <span class="type">SCNBox</span>(width: <span class="number">0.1</span>, height: <span class="number">0.1</span>, length: <span class="number">0.1</span>, chamferRadius: <span class="number">0</span>))</div><div class="line">cubeNode.posotion = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">0.2</span>)<span class="comment">// SceneKit/AR坐标系以“米”为单位</span></div><div class="line">sceneView.scene.rootNode.addChildNode(cubeNode)</div></pre></td></tr></table></figure>
<p>以上代码直接在视图的SceneKit场景中放置了一个物体，由于ARKit匹配了SceneKit空间到现实空间中，该物体会自动追踪其在现实世界的位置。</p>
<p>追踪现实位置，你不仅可以使用<a href="https://developer.apple.com/documentation/arkit/aranchor" target="_blank" rel="external">ARAnchor</a>类，或通过创建你自己的锚点并把他们添加到会话对象中，还可以监听ARKit自动创建的锚点。比如，当物体检测功能已打开，ARKit会为<br>每一个检测到的物体添加并更新锚点。要为这些锚点添加可见内容，可以向下面这样实现<a href="https://developer.apple.com/documentation/arkit/arscnviewdelegate" target="_blank" rel="external">ARSCNViewDelegate</a>的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">renderer</span><span class="params">(<span class="number">_</span> renderer: SCNSceneRenderer, didAdd node: SCNNode, <span class="keyword">for</span> anchor: ARAnchor)</span></span> &#123;</div><div class="line">	<span class="comment">// 这个可视物体只允许已检测到的物体</span></div><div class="line">	<span class="keyword">guard</span> <span class="keyword">let</span> planeAnchor = anchor <span class="keyword">as</span>? <span class="type">ARPlaneAnchor</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</div><div class="line">	</div><div class="line">	<span class="comment">// 使用它的位置和大小创建一个SceneKit物体来使节点可见</span></div><div class="line">	<span class="keyword">let</span> plane = <span class="type">SCNPlane</span>(width: <span class="type">SCFloat</span>(planeAnchor.extent.x), height: <span class="type">CGFloat</span>(planeAnchor.extent.z))</div><div class="line">	<span class="keyword">let</span> planeNode = <span class="type">SCNNode</span>(geometry: plane)</div><div class="line">	planeNode.position = <span class="type">SCNVector3Make</span>(planeAnchor.center.x, <span class="number">0</span>, planeAnchor.center.z)</div><div class="line">	</div><div class="line">	<span class="comment">// SCNPlanes在他们自己的坐标空间中式垂直朝向的</span></div><div class="line">	<span class="comment">// 旋转它来匹配水平朝向的ARPlaneAnchor</span></div><div class="line">	planeNode.transform = <span class="type">SCNMatrix4MakeRotation</span>(-<span class="type">Float</span>.pi / <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">	</div><div class="line">	<span class="comment">// 像锚点一样，ARKit拥有这个节点，所以把这个物体添加为一个子节点。</span></div><div class="line">	node.addChildNode(planeNode)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="设计3D资源遵循的最好实践"><a href="#设计3D资源遵循的最好实践" class="headerlink" title="设计3D资源遵循的最好实践"></a>设计3D资源遵循的最好实践</h2><ul>
<li>使用SceneKit自身的光照模型创建资源以便可以有更逼真的外观。（查看<a href="https://developer.apple.com/documentation/scenekit/scnmaterial" target="_blank" rel="external">SCNMaterial</a>类和<a href="https://developer.apple.com/library/content/samplecode/Badger/Introduction/Intro.html#//apple_ref/doc/uid/TP40017309" target="_blank" rel="external">獾：SceneKit高级渲染</a>示例代码工程）</li>
<li>烤周围的遮罩阴影以便所有物体都可以在大场景的光照条件下都有合适的光照。</li>
<li>在AR中如果你想要创建一个虚拟物体并把它放置到外界的水平面上，你需要在3D资源中包含一个带有温和的阴影纹理的透明物体，并把它放到虚拟物体下面。</li>
</ul>
<h2 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h2><h6 id="session"><a href="#session" class="headerlink" title="session"></a><a href="https://developer.apple.com/documentation/arkit/arskview/2865589-session?language=objc" target="_blank" rel="external">session</a></h6><pre><code>在视图内容中管理着运动追踪和相机图像处理的AR会话对象
</code></pre><h6 id="scene"><a href="#scene" class="headerlink" title="scene"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2875547-scene?language=objc" target="_blank" rel="external">scene</a></h6><pre><code>视图中显示的SceneKit场景
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/arkit/arscnview/providing_3d_virtual_content_with_scenekit&quot; target=&quot;_blank&quot; rel=&quot;exter
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ARKit文档瞎翻译（8）</title>
    <link href="http://yoursite.com/2017/07/04/ARKit_doc_8/"/>
    <id>http://yoursite.com/2017/07/04/ARKit_doc_8/</id>
    <published>2017-07-04T06:05:03.000Z</published>
    <updated>2017-07-04T07:37:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/documentation/arkit/arscnview?language=objc" target="_blank" rel="external">原文请戳</a></p>
<h1 id="ARSCNView"><a href="#ARSCNView" class="headerlink" title="ARSCNView"></a>ARSCNView</h1><p>使用3D的SceneKit内容进而增强相机来显示AR体验的一种视图。</p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ARSCNView提供了一种最简单的方式来创建AR体验，即混合了虚拟的3D内容到相机捕捉的真实世界的视图中。当你运行视图提供的<a href="https://developer.apple.com/documentation/arkit/arsession?language=objc" target="_blank" rel="external">ARSession</a>对象时：</p>
<ul>
<li>该视图会自动渲染从相机拍摄到的实时视频并将其作为背景。</li>
<li>该视图的SceneKit场景坐标系可以直接响应通过会话配置的AR坐标系。</li>
<li>该视图会自动移动它的SceneKit相机来匹配设备在现实世界中的移动。</li>
</ul>
<p>因为ARKit可以自动匹配SceneKit空间到真实世界中，所以放置一个虚拟物体以便可以维持在现实中的位置，只需要适当地设置这个对象的SceneKit位置就可以。</p>
<p>你无需必须使用<a href="https://developer.apple.com/documentation/arkit/aranchor?language=objc" target="_blank" rel="external">ARAnchor</a>类来追踪添加到场景中的物体位置，但是通过实现<a href="https://developer.apple.com/documentation/arkit/arscnviewdelegate?language=objc" target="_blank" rel="external">ARSCNViewDelegate</a>中的方法，你可以添加SceneKit内容到任何被ARKit自动识别出的锚点上。</p>
<h2 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><h6 id="使用SceneKit提供3D的虚拟内容"><a href="#使用SceneKit提供3D的虚拟内容" class="headerlink" title="使用SceneKit提供3D的虚拟内容"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/providing_3d_virtual_content_with_scenekit?language=objc" target="_blank" rel="external">使用SceneKit提供3D的虚拟内容</a></h6><pre><code>使用SceneKit来添加逼真的3D对象到你的AR体验中
</code></pre><h6 id="session"><a href="#session" class="headerlink" title="session"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2865796-session?language=objc" target="_blank" rel="external">session</a></h6><pre><code>管理着视图内容中的运动追踪和相机视图处理的AR会话对象
</code></pre><h6 id="scene"><a href="#scene" class="headerlink" title="scene"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2875547-scene?language=objc" target="_blank" rel="external">scene</a></h6><pre><code>显示在视图中的SceneKit场景
</code></pre><h3 id="负责AR更新"><a href="#负责AR更新" class="headerlink" title="负责AR更新"></a>负责AR更新</h3><h6 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2865797-delegate?language=objc" target="_blank" rel="external">delegate</a></h6><pre><code>你提供的一个对象，用于使用SceneKit内容来同步处理视图的AR场景信息。
</code></pre><h6 id="ARSCNViewDelegate"><a href="#ARSCNViewDelegate" class="headerlink" title="ARSCNViewDelegate"></a><a href="https://developer.apple.com/documentation/arkit/arscnviewdelegate?language=objc" target="_blank" rel="external">ARSCNViewDelegate</a></h6><pre><code>可以实现的一系列方法，你可以用他们使用AR会话对象来同步处理SceneKit内容。
</code></pre><h3 id="真实世界表面的碰撞检测"><a href="#真实世界表面的碰撞检测" class="headerlink" title="真实世界表面的碰撞检测"></a>真实世界表面的碰撞检测</h3><h6 id="hitTest-types"><a href="#hitTest-types" class="headerlink" title="- hitTest:types:"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2875544-hittest?language=objc" target="_blank" rel="external">- hitTest:types:</a></h6><pre><code>在截取的相机图像中搜索真实世界的物体或AR锚点，与SceneKit视图中的一个点相对应。
</code></pre><h3 id="映射内容到现实世界的位置中"><a href="#映射内容到现实世界的位置中" class="headerlink" title="映射内容到现实世界的位置中"></a>映射内容到现实世界的位置中</h3><h6 id="anchorForNode"><a href="#anchorForNode" class="headerlink" title="- anchorForNode:"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2875546-anchorfornode?language=objc" target="_blank" rel="external">- anchorForNode:</a></h6><pre><code>如果存在，返回与指定SceneKit节点相关的AR锚点
</code></pre><h6 id="nodeForAnchor"><a href="#nodeForAnchor" class="headerlink" title="- nodeForAnchor:"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2874122-nodeforanchor?language=objc" target="_blank" rel="external">- nodeForAnchor:</a></h6><pre><code>如果存在，返回与指定AR锚点相关的SceneKit节点
</code></pre><h3 id="处理场景光照"><a href="#处理场景光照" class="headerlink" title="处理场景光照"></a>处理场景光照</h3><h6 id="automaticallyUpdatesLighting"><a href="#automaticallyUpdatesLighting" class="headerlink" title="automaticallyUpdatesLighting"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2887446-automaticallyupdateslighting?language=objc" target="_blank" rel="external">automaticallyUpdatesLighting</a></h6><pre><code>一个布尔值，指定了在视图的场景中，是否需要ARKit创建并更新SceneKit光照。
</code></pre><h3 id="调试AR显示"><a href="#调试AR显示" class="headerlink" title="调试AR显示"></a>调试AR显示</h3><h6 id="ARSCNDebugOptions"><a href="#ARSCNDebugOptions" class="headerlink" title="ARSCNDebugOptions"></a><a href="https://developer.apple.com/documentation/arkit/arscndebugoptions?language=objc" target="_blank" rel="external">ARSCNDebugOptions</a></h6><pre><code>绘制遮罩内容的一些设置项来帮助调试在SceneKit视图中的AR追踪功能。
</code></pre><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h3 id="继承自"><a href="#继承自" class="headerlink" title="继承自"></a>继承自</h3><p><a href="https://developer.apple.com/documentation/scenekit/scnview?language=objc" target="_blank" rel="external">SCNView</a></p>
<h2 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h2><h3 id="基本视图"><a href="#基本视图" class="headerlink" title="基本视图"></a>基本视图</h3><h6 id="创建一个基本的AR体验"><a href="#创建一个基本的AR体验" class="headerlink" title="创建一个基本的AR体验"></a><a href="https://developer.apple.com/documentation/arkit/building_a_basic_ar_experience?language=objc" target="_blank" rel="external">创建一个基本的AR体验</a></h6><pre><code>配置一个AR会话对象并使用SceneKit或SpriteKit来显示AR内容
</code></pre><h6 id="ARSKView"><a href="#ARSKView" class="headerlink" title="ARSKView"></a><a href="https://developer.apple.com/documentation/arkit/arskview?language=objc" target="_blank" rel="external">ARSKView</a></h6><pre><code>使用2D的SpriteKit内容进而增强相机来显示AR体验的一种视图。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/arkit/arscnview?language=objc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文请戳&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ARS
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ARKit文档瞎翻译（7）</title>
    <link href="http://yoursite.com/2017/07/04/ARKit_doc_7/"/>
    <id>http://yoursite.com/2017/07/04/ARKit_doc_7/</id>
    <published>2017-07-04T03:28:14.000Z</published>
    <updated>2017-07-04T06:51:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/documentation/arkit/arskview?language=objc" target="_blank" rel="external">原文请戳</a></p>
<h1 id="ARSKView"><a href="#ARSKView" class="headerlink" title="ARSKView"></a>ARSKView</h1><p>使用2D的SpriteKit内容进而增强相机来显示AR体验的一种视图。</p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用ARSKView类，可以在设备相机拍摄的真实世界视图的3D空间中放置2D元素来创建AR体验。当你运行这个视图提供的<a href="https://developer.apple.com/documentation/arkit/arsession?language=objc" target="_blank" rel="external">ARSession</a>对象时：</p>
<ul>
<li>该视图会自动渲染从相机拍摄到的实时视频并将其作为背景。</li>
<li>当你实现了<a href="https://developer.apple.com/documentation/arkit/arskviewdelegate?language=objc" target="_blank" rel="external">ARSKViewDelegate</a>的方法把SpriteKit内容和真实世界的位置联系在一起时，该视图会自动缩放并旋转SpriteKit节点，以便他们在相机中看起来就像可以在真实世界中追踪到一样。</li>
</ul>
<h2 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><h6 id="使用SpriteKit提供2D虚拟内容"><a href="#使用SpriteKit提供2D虚拟内容" class="headerlink" title="使用SpriteKit提供2D虚拟内容"></a><a href="https://developer.apple.com/documentation/arkit/arskview/providing_2d_virtual_content_with_spritekit?language=objc" target="_blank" rel="external">使用SpriteKit提供2D虚拟内容</a></h6><pre><code>在AR体验中，使用SpriteKit在3D空间中放置2D图片
</code></pre><h6 id="session"><a href="#session" class="headerlink" title="session"></a><a href="https://developer.apple.com/documentation/arkit/arskview/2865589-session?language=objc" target="_blank" rel="external">session</a></h6><pre><code>管理着视图内容中的运动追踪和相机视图处理的AR会话对象
</code></pre><h3 id="负责AR更新"><a href="#负责AR更新" class="headerlink" title="负责AR更新"></a>负责AR更新</h3><h6 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a><a href="https://developer.apple.com/documentation/arkit/arskview/2865597-delegate?language=objc" target="_blank" rel="external">delegate</a></h6><pre><code>你提供的一个对象，用于使用SpriteKit内容来同步处理视图中的AR场景信息。
</code></pre><h6 id="ARSKViewDelegate"><a href="#ARSKViewDelegate" class="headerlink" title="ARSKViewDelegate"></a><a href="https://developer.apple.com/documentation/arkit/arskviewdelegate?language=objc" target="_blank" rel="external">ARSKViewDelegate</a></h6><pre><code>可以实现的一系列方法，你可以用他们使用AR会话对象来同步处理SpriteKit内容。
</code></pre><h3 id="真实世界表面的碰撞检测"><a href="#真实世界表面的碰撞检测" class="headerlink" title="真实世界表面的碰撞检测"></a>真实世界表面的碰撞检测</h3><h6 id="hitTest-types"><a href="#hitTest-types" class="headerlink" title="- hitTest:types:"></a><a href="https://developer.apple.com/documentation/arkit/arskview/2875733-hittest?language=objc" target="_blank" rel="external">- hitTest:types:</a></h6><pre><code>在截取的相机图像中搜索真实世界的物体或AR锚点，与SpriteKit视图中的一个点相对应。
</code></pre><h3 id="映射内容到真实世界的位置中"><a href="#映射内容到真实世界的位置中" class="headerlink" title="映射内容到真实世界的位置中"></a>映射内容到真实世界的位置中</h3><h6 id="anchorForNode"><a href="#anchorForNode" class="headerlink" title="- anchorForNode:"></a><a href="https://developer.apple.com/documentation/arkit/arskview/2875729-anchorfornode?language=objc" target="_blank" rel="external">- anchorForNode:</a></h6><pre><code>如果存在，返回与指定SpriteKit节点相关的AR锚点
</code></pre><h6 id="nodeForAnchor"><a href="#nodeForAnchor" class="headerlink" title="- nodeForAnchor:"></a><a href="https://developer.apple.com/documentation/arkit/arskview/2873513-nodeforanchor?language=objc" target="_blank" rel="external">- nodeForAnchor:</a></h6><pre><code>如果存在，返回与指定AR锚点相关的SpriteKit节点
</code></pre><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h3 id="继承自"><a href="#继承自" class="headerlink" title="继承自"></a>继承自</h3><p><a href="https://developer.apple.com/documentation/spritekit/skview?language=objc" target="_blank" rel="external">SKView</a></p>
<h2 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h2><h3 id="基本视图"><a href="#基本视图" class="headerlink" title="基本视图"></a>基本视图</h3><h6 id="创建一个基本的AR体验"><a href="#创建一个基本的AR体验" class="headerlink" title="创建一个基本的AR体验"></a><a href="https://developer.apple.com/documentation/arkit/building_a_basic_ar_experience?language=objc" target="_blank" rel="external">创建一个基本的AR体验</a></h6><pre><code>配置一个AR会话对象并使用SceneKit或SpriteKit来显示AR内容
</code></pre><h6 id="ARSCNView"><a href="#ARSCNView" class="headerlink" title="ARSCNView"></a><a href="https://developer.apple.com/documentation/arkit/arscnview?language=objc" target="_blank" rel="external">ARSCNView</a></h6><pre><code>使用3D的SceneKit内容进而增强相机来显示AR体验的一种视图。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/arkit/arskview?language=objc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文请戳&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ARSK
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ARKit文档瞎翻译（6）</title>
    <link href="http://yoursite.com/2017/07/03/ARKit_doc_6/"/>
    <id>http://yoursite.com/2017/07/03/ARKit_doc_6/</id>
    <published>2017-07-03T14:06:55.000Z</published>
    <updated>2017-07-03T15:01:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/documentation/arkit/arskview/providing_2d_virtual_content_with_spritekit?language=objc" target="_blank" rel="external">原文请戳</a></p>
<h1 id="使用SpriteKit提供2D内容"><a href="#使用SpriteKit提供2D内容" class="headerlink" title="使用SpriteKit提供2D内容"></a>使用SpriteKit提供2D内容</h1><p>在AR体验中，使用SpriteKit在3D空间中放置2D图片</p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在AR中放置SpriteKit内容，你首先需要一个运行中的AR会话对象（参考<a href="https://developer.apple.com/documentation/arkit/building_a_basic_ar_experience?language=objc" target="_blank" rel="external">创建一个基本的AR体验</a>）。</p>
<p>SpriteKit是内置的2D虚拟内容，但是AR需要的是真实世界的3D空间。使用<a href="https://developer.apple.com/documentation/arkit/arskview?language=objc" target="_blank" rel="external">ARSKView</a>类通过提供2D精灵（<a href="https://developer.apple.com/documentation/spritekit/sknode?language=objc" target="_blank" rel="external">SKNode</a>对象）相当于真实世界的3D位置（<a href="https://developer.apple.com/documentation/arkit/aranchor?language=objc" target="_blank" rel="external">ARAnchor</a>对象）来创建AR体验。当使用者移动设备，与锚点相似，视图会自动旋转并且缩放SpriteKit节点，以至于他们在相机中看起来就像是在真实世界中一样可以追踪。</p>
<p>举例来说，你可以放置2D图片就像是漂浮在3D空间中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个在相机前面0.2米的平移变换</span></div><div class="line"><span class="keyword">var</span> translation = matrix_identity_float4x4</div><div class="line">translation.column.<span class="number">3</span>.z = -<span class="number">0.2</span></div><div class="line"><span class="keyword">let</span> transform = simd_mul(view.session.currentFrame.camera.transform, translation)</div><div class="line">	</div><div class="line"><span class="comment">//在会话对象上添加一个新锚点</span></div><div class="line"><span class="keyword">let</span> anchor = <span class="type">ARAnchor</span>(transform: transform)</div><div class="line">view.session.add(anchor: anchor)</div><div class="line">	</div><div class="line"><span class="comment">//（其他的什么...）提供一个标签结点来代表锚点</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">view</span><span class="params">(<span class="number">_</span> view: ARSKView, nodeFor anchor: ARAnchor)</span></span> -&gt; <span class="type">SKNode</span>? &#123;</div><div class="line">	<span class="keyword">return</span> <span class="type">SKLabelNode</span>(text: <span class="string">"👾"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面中<a href="https://developer.apple.com/documentation/arkit/arskviewdelegate/2865596-view?language=objc" target="_blank" rel="external">view:nodeForAnchor:</a>方法返回一个<a href="https://developer.apple.com/documentation/spritekit/sklabelnode?language=objc" target="_blank" rel="external">SKLabelNode</a>对象，它可以显示一个文字标签。像大多数的SpriteKit节点一样，这个类创建了一个2D的虚拟替代物，所以<a href="https://developer.apple.com/documentation/arkit/arskview?language=objc" target="_blank" rel="external">ARSKView</a>类展现节点用一种广告牌的方式：精灵缩放并且旋转（沿着它的z轴）以至于它看起来就像是跟随着3D位置中的锚点一样，但是总是朝向着相机。</p>
<hr>
<h2 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><h6 id="session"><a href="#session" class="headerlink" title="session"></a><a href="https://developer.apple.com/documentation/arkit/arskview/2865589-session?language=objc" target="_blank" rel="external">session</a></h6><pre><code>在视图内容中管理着运动追踪和相机图像处理的AR会话对象
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/arkit/arskview/providing_2d_virtual_content_with_spritekit?language=objc&quot; target=&quot;_bla
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ARKit文档瞎翻译（5）</title>
    <link href="http://yoursite.com/2017/07/03/ARKit_doc_5/"/>
    <id>http://yoursite.com/2017/07/03/ARKit_doc_5/</id>
    <published>2017-07-03T08:27:40.000Z</published>
    <updated>2017-07-03T14:58:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/documentation/arkit/building_a_basic_ar_experience?language=objc" target="_blank" rel="external">原文请戳</a></p>
<h1 id="创建一个基本的AR体验"><a href="#创建一个基本的AR体验" class="headerlink" title="创建一个基本的AR体验"></a>创建一个基本的AR体验</h1><p>配置一个AR会话对象并使用SceneKit或SpriteKit来显示AR内容</p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当你使用<a href="https://developer.apple.com/documentation/arkit/arscnview?language=objc" target="_blank" rel="external">ARSSNView</a>或<a href="https://developer.apple.com/documentation/arkit/arskview?language=objc" target="_blank" rel="external">ARSKView</a>类，ARKit会自动处理创建AR体验中的基本需求：每个视图都显示了一个以实时相机视图作为背景并且渲染了一个你提供的2D或3D覆盖层来创建那个真实世界中的幻想内容。使用其中一个类，你需要配置你想要创建的AR体验的种类，并且为你的覆盖层内容选择位置和代表。</p>
<p>若使用自己的视图来创建AR体验，请看<a href="https://developer.apple.com/documentation/arkit/displaying_an_ar_experience_with_metal?language=objc" target="_blank" rel="external">使用Metal来展示AR体验</a>。</p>
<blockquote>
<p>备注：<br>这篇文章覆盖了在XCode工程模板中的代码。想要查看完整示例代码，使用AR模板创建一个新的iOS工程，并且在内容技术弹出菜单中选择SceneKit或SpriteKit。</p>
</blockquote>
<h2 id="配置并运行AR会话"><a href="#配置并运行AR会话" class="headerlink" title="配置并运行AR会话"></a>配置并运行AR会话</h2><p><a href="https://developer.apple.com/documentation/arkit/arscnview?language=objc" target="_blank" rel="external">ARSCNView</a>和<a href="https://developer.apple.com/documentation/arkit/arskview?language=objc" target="_blank" rel="external">ARSKView</a>类都包含了一个在创建AR体验中负责运动追踪和图像处理的<a href="https://developer.apple.com/documentation/arkit/arsession?language=objc" target="_blank" rel="external">ARSession</a>对象。可是，为了能够运行这个会话，你必须要提供一个会话配置。</p>
<p><img src="https://docs-assets.developer.apple.com/published/ffb3831f78/50bedfc6-93ce-400c-a41d-35728e32d653.png" alt="关系图"></p>
<p><a href="https://developer.apple.com/documentation/arkit/arworldtrackingsessionconfiguration?language=objc" target="_blank" rel="external">ARWorldTrackingSessionConfiguration</a>类提供了更高精度的运动追踪并且开放了一些特性来帮助你放置虚拟内容到真实世界的平面上。在世界追踪不可用的情况下，基本类<a href="https://developer.apple.com/documentation/arkit/arsessionconfiguration?language=objc" target="_blank" rel="external">ARSessionConfiguration</a>提供了简单的运动追踪来许可较少的AR体验。为了允许一个AR会话，使用一个你指定的选项来创建一个会话配置对象，之后在你的<a href="https://developer.apple.com/documentation/arkit/arscnview?language=objc" target="_blank" rel="external">ARSCNView</a>或<a href="https://developer.apple.com/documentation/arkit/arskview?language=objc" target="_blank" rel="external">ARSKView</a>实例的<a href="https://developer.apple.com/documentation/arkit/arscnview/2865796-session?language=objc" target="_blank" rel="external">session</a>对象上调用<a href="https://developer.apple.com/documentation/arkit/arsession/2875735-runwithconfiguration?language=objc" target="_blank" rel="external">runWithConfiguration:options:</a>方法。</p>
<pre><code class="swift"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> {
    <span class="keyword">super</span>.viewWillAppear(animated)

    <span class="comment">// Create a session configuration</span>
    <span class="keyword">let</span> configuration = <span class="type">ARWorldTrackingConfiguation</span>()
    configuration.planeDetection = .horizontal

    <span class="comment">// Run the view's session</span>
    sceneView.session.run(configuration)
}
</code></pre>
<blockquote>
<p>注意</p>
<p>只有视图将要显示在屏幕上时再运行你的会话。</p>
</blockquote>
<p>在你已经设置好你的会话对象后，在视图中使用SceneKit或SpriteKit来放置虚拟内容。</p>
<hr>
<h2 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h2><h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><h6 id="使用SceneKit提供3D虚拟内容"><a href="#使用SceneKit提供3D虚拟内容" class="headerlink" title="使用SceneKit提供3D虚拟内容"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/providing_3d_virtual_content_with_scenekit?language=objc" target="_blank" rel="external">使用SceneKit提供3D虚拟内容</a></h6><pre><code>在AR体验中，使用SceneKit添加逼真的3D对象
</code></pre><h6 id="使用SpriteKit提供2D虚拟内容"><a href="#使用SpriteKit提供2D虚拟内容" class="headerlink" title="使用SpriteKit提供2D虚拟内容"></a><a href="https://developer.apple.com/documentation/arkit/arskview/providing_2d_virtual_content_with_spritekit?language=objc" target="_blank" rel="external">使用SpriteKit提供2D虚拟内容</a></h6><pre><code>在AR体验中，使用SpriteKit在3D空间中放置2D图片
</code></pre><h2 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h2><h3 id="基本视图"><a href="#基本视图" class="headerlink" title="基本视图"></a>基本视图</h3><h6 id="ARSCNView"><a href="#ARSCNView" class="headerlink" title="ARSCNView"></a><a href="https://developer.apple.com/documentation/arkit/arscnview?language=objc" target="_blank" rel="external">ARSCNView</a></h6><pre><code>在AR体验中，使用3D的SceneKit内容来增强相机视图的一种视图。
</code></pre><h6 id="ARSKView"><a href="#ARSKView" class="headerlink" title="ARSKView"></a><a href="https://developer.apple.com/documentation/arkit/arskview?language=objc" target="_blank" rel="external">ARSKView</a></h6><pre><code>在AR体验中，使用2D的SpriteKit内容来增强相机视图的一种视图。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/arkit/building_a_basic_ar_experience?language=objc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文请
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ARKit文档瞎翻译（4）</title>
    <link href="http://yoursite.com/2017/07/03/ARKit_doc_4/"/>
    <id>http://yoursite.com/2017/07/03/ARKit_doc_4/</id>
    <published>2017-07-03T06:49:35.000Z</published>
    <updated>2017-07-03T08:25:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARKit文档瞎翻译（4）"><a href="#ARKit文档瞎翻译（4）" class="headerlink" title="ARKit文档瞎翻译（4）"></a>ARKit文档瞎翻译（4）</h1><p><a href="https://developer.apple.com/documentation/arkit/arsession?language=objc" target="_blank" rel="external">原文请戳</a></p>
<h2 id="ARSession"><a href="#ARSession" class="headerlink" title="ARSession"></a>ARSession</h2><p>一个处理AR中设备相机和运动过程的共享对象。</p>
<hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个ARSession对象整合了在ARKit中以你自己的方式创建AR的主要过程。这个过程包括从设备运动传感器读取数据、控制设备相机和在截取的相机图片中进行图像识别。这个会话整合了所有这些结果来创建一个在设备所在的真实世界和你模拟AR内容的虚拟空间所组成的镜像世界。</p>
<p>使用ARKit创建的每一个AR体验都需要一个单独的ARSession对象。如果你使用一个<a href="https://developer.apple.com/documentation/arkit/arscnview?language=objc" target="_blank" rel="external">ARSCNView</a>或<a href="https://developer.apple.com/documentation/arkit/arskview?language=objc" target="_blank" rel="external">ARSKView</a>对象来简易地创建AR中的视觉部分，那么视图对象便已经包含了一个ARSession实例。如果你用自己的渲染器来创建AR内容，你就需要自己实例化并维护一个ARSession对象了。</p>
<p>运行一个会话需要一个会话配置：<a href="https://developer.apple.com/documentation/arkit/arsessionconfiguration?language=objc" target="_blank" rel="external">ARSessionConfiguration</a>类或其子类<a href="https://developer.apple.com/documentation/arkit/arworldtrackingsessionconfiguration?language=objc" target="_blank" rel="external">ARWorldTrackingSessionConfiguration</a>类的实例。这些类决定了ARKit如何追踪一个设备相对真实世界的位置和运动，并且影响了你能创建的AR体验的种类。</p>
<h3 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h3><h4 id="配置并运行一个会话"><a href="#配置并运行一个会话" class="headerlink" title="配置并运行一个会话"></a>配置并运行一个会话</h4><h6 id="runWithConfiguration-options"><a href="#runWithConfiguration-options" class="headerlink" title="- runWithConfiguration:options:"></a><a href="https://developer.apple.com/documentation/arkit/arsession/2875735-runwithconfiguration?language=objc" target="_blank" rel="external">- runWithConfiguration:options:</a></h6><pre><code>为会话使用指定配置和设置来启动一个AR过程
</code></pre><blockquote>
<p><a href="https://developer.apple.com/documentation/arkit/arsessionrunoptions?language=objc" target="_blank" rel="external">ARSessionRunOptions</a><br>当你改变配置时，此选项影响了如何改变一个ARSession当前状态。</p>
<p><a href="https://developer.apple.com/documentation/arkit/arsession/2865609-configuration?language=objc" target="_blank" rel="external">configuration</a><br>会话中一个定义了运动和场景追踪行为的对象。</p>
</blockquote>
<h6 id="pause"><a href="#pause" class="headerlink" title="- pause"></a><a href="https://developer.apple.com/documentation/arkit/arsession/2865619-pause?language=objc" target="_blank" rel="external">- pause</a></h6><pre><code>暂停处理会话
</code></pre><h4 id="负责AR更新"><a href="#负责AR更新" class="headerlink" title="负责AR更新"></a>负责AR更新</h4><h6 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a><a href="https://developer.apple.com/documentation/arkit/arsession/2865614-delegate?language=objc" target="_blank" rel="external">delegate</a></h6><pre><code>一个你提供的对象来接收捕获的视频图像和追踪信息，或者为会话中的状态改变进行回应处理。
</code></pre><h6 id="delegateQueue"><a href="#delegateQueue" class="headerlink" title="delegateQueue"></a><a href="https://developer.apple.com/documentation/arkit/arsession/2875726-delegatequeue?language=objc" target="_blank" rel="external">delegateQueue</a></h6><pre><code>会话调用你的一系列代理方法的派发队列
</code></pre><h6 id="ARSessionDelegate"><a href="#ARSessionDelegate" class="headerlink" title="ARSessionDelegate"></a><a href="https://developer.apple.com/documentation/arkit/arsessiondelegate?language=objc" target="_blank" rel="external">ARSessionDelegate</a></h6><pre><code>在AR会话中你可以实现的一些方法来接收捕获的视频帧图像和处理追踪状态。
</code></pre><h6 id="ARSessionObserver"><a href="#ARSessionObserver" class="headerlink" title="ARSessionObserver"></a><a href="https://developer.apple.com/documentation/arkit/arsessionobserver?language=objc" target="_blank" rel="external">ARSessionObserver</a></h6><pre><code>在AR会话中你可以实现的一些方法来对状态的改变进行回应。
</code></pre><h3 id="显示并与AR内容进行交互"><a href="#显示并与AR内容进行交互" class="headerlink" title="显示并与AR内容进行交互"></a>显示并与AR内容进行交互</h3><h6 id="currentFrame"><a href="#currentFrame" class="headerlink" title="currentFrame"></a><a href="https://developer.apple.com/documentation/arkit/arsession/2865621-currentframe?language=objc" target="_blank" rel="external">currentFrame</a></h6><pre><code>视频帧图像，带有相关的AR场景信息，是会话对象最近捕获的
</code></pre><h6 id="addAnchor"><a href="#addAnchor" class="headerlink" title="- addAnchor:"></a><a href="https://developer.apple.com/documentation/arkit/arsession/2865612-addanchor?language=objc" target="_blank" rel="external">- addAnchor:</a></h6><pre><code>添加可以被会话对象追踪的指定锚点
</code></pre><h6 id="removeAnchor"><a href="#removeAnchor" class="headerlink" title="- removeAnchor:"></a><a href="https://developer.apple.com/documentation/arkit/arsession/2865607-removeanchor?language=objc" target="_blank" rel="external">- removeAnchor:</a></h6><pre><code>移除可以被会话对象追踪的指定锚点
</code></pre><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><h6 id="runWithConfiguration"><a href="#runWithConfiguration" class="headerlink" title="- runWithConfiguration:"></a><a href="https://developer.apple.com/documentation/arkit/arsession/2865608-runwithconfiguration?language=objc" target="_blank" rel="external">- runWithConfiguration:</a></h6><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h6 id="继承自-NSObject"><a href="#继承自-NSObject" class="headerlink" title="继承自        NSObject"></a>继承自        <a href="https://developer.apple.com/documentation/objectivec/nsobject?language=objc" target="_blank" rel="external">NSObject</a></h6>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARKit文档瞎翻译（4）&quot;&gt;&lt;a href=&quot;#ARKit文档瞎翻译（4）&quot; class=&quot;headerlink&quot; title=&quot;ARKit文档瞎翻译（4）&quot;&gt;&lt;/a&gt;ARKit文档瞎翻译（4）&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ARKit文档瞎翻译（3）</title>
    <link href="http://yoursite.com/2017/07/03/ARKit_doc_3/"/>
    <id>http://yoursite.com/2017/07/03/ARKit_doc_3/</id>
    <published>2017-07-03T03:41:38.000Z</published>
    <updated>2017-07-03T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARKit文档瞎翻译（3）"><a href="#ARKit文档瞎翻译（3）" class="headerlink" title="ARKit文档瞎翻译（3）"></a>ARKit文档瞎翻译（3）</h1><p><a href="https://developer.apple.com/documentation/arkit/understanding_augmented_reality" target="_blank" rel="external">原文请戳</a></p>
<h2 id="理解AR"><a href="#理解AR" class="headerlink" title="理解AR"></a>理解AR</h2><h6 id="探索概念、特性和最棒的实践来创建伟大的AR体验。"><a href="#探索概念、特性和最棒的实践来创建伟大的AR体验。" class="headerlink" title="探索概念、特性和最棒的实践来创建伟大的AR体验。"></a>探索概念、特性和最棒的实践来创建伟大的AR体验。</h6><hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="https://docs-assets.developer.apple.com/published/b99f86dcfb/75ae3206-121a-47ed-9464-af0f322443cc.png" alt="demo图片1"></p>
<p>对于AR来说，最基本的需求，即ARKit定义的特征，就是在用户生活的真实世界和放置虚拟物体的虚拟空间之间创建并保持一致的能力。当你的app把实时相机图像和虚拟物体结合在一起展示出来的时候，用户就会体验到了增强现实的魅力：幻想你的虚拟内容是真实世界的一部分。</p>
<h3 id="世界追踪是如何工作的"><a href="#世界追踪是如何工作的" class="headerlink" title="世界追踪是如何工作的"></a>世界追踪是如何工作的</h3><p>为了在真实和虚拟空间中创建一个高度一致的世界，ARKit使用了一项叫做<em>visual-inertial odometry</em>的技术。这项技术可以将iOS的设备感应器和相机拍摄的场景进行的电脑视觉识别结合到一起。ARKit识别出场景图像中的显著特征，通过视频帧的这些特征追踪出位置上的不同点，并把这些信息同运动感应数据进行比较。最终就生成了一个带有设备位置和运动信息的高精度模型。</p>
<h3 id="最好的实践和限制"><a href="#最好的实践和限制" class="headerlink" title="最好的实践和限制"></a>最好的实践和限制</h3><p>世界追踪是一项不太准确的技术。这项技术经常可以制作出令人惊叹的精准度，进而产生出AR体验。可是，它（即AR体验）的产生依赖设备物理环境的细致程度（物理环境并不总是很稳定或者一些很难估测到的不确定错误）。为了能够建立高质量的AR体验，注意以下警告和建议。</p>
<p><strong>利用可预测的光照条件来设计AR。</strong>世界追踪需要图像识别，即需要清晰地图像。当相机不能看清细节，比如当相机对着一扇白墙或场景较暗时，追踪的质量会降低。</p>
<p><strong>使用有效的追踪信息来提供给用户反馈。</strong>世界追踪把图像识别和设备运动结合到了一起。ARKit开发出了对场景更好的理解能力，如当设备正在移动，甚至是很微小的偏移。过重的运动（如过远、过快或者剧烈的摇动）会导致在视频帧间产生模糊的图像或过大的追踪距离，从而降低了追踪质量。<a href="https://developer.apple.com/documentation/arkit/arcamera" target="_blank" rel="external">ARCamera</a>类提供了追踪状态原因信息，使用它你可以开发出告知用户如何处理低质量追踪环境的UI界面。</p>
<p><strong>为产生清晰的结果允许花费一些时间来进行物体检测，并且当你得到需要的结果后关闭检测。</strong>物体检测的结果会多次改变–当物体第一次被探测到时，它的位置和大小可能是不准确的。只要该物体还持续地呆在场景之中，ARKit就会抽象出估测的位置和大小。一旦在场景中有一个大的水平面存在时，在你已经使用该物体并放置内容后，ARKit就会持续改变该物体的锚点位置、大小和变化。</p>
<h2 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h2><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><h6 id="class-ARSession"><a href="#class-ARSession" class="headerlink" title="class ARSession"></a>class <a href="https://developer.apple.com/documentation/arkit/arsession" target="_blank" rel="external">ARSession</a></h6><h6 id="一个共享对象，负责管理AR中的设备相机和运动处理的需求。"><a href="#一个共享对象，负责管理AR中的设备相机和运动处理的需求。" class="headerlink" title="一个共享对象，负责管理AR中的设备相机和运动处理的需求。"></a>一个共享对象，负责管理AR中的设备相机和运动处理的需求。</h6><h4 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h4><h6 id="创建基本的AR体验"><a href="#创建基本的AR体验" class="headerlink" title="创建基本的AR体验"></a><a href="https://developer.apple.com/documentation/arkit/building_a_basic_ar_experience" target="_blank" rel="external"><em>创建基本的AR体验</em></a></h6><h6 id="配置一个AR会话并使用SceneKit或SpriteKit来显示AR内容"><a href="#配置一个AR会话并使用SceneKit或SpriteKit来显示AR内容" class="headerlink" title="配置一个AR会话并使用SceneKit或SpriteKit来显示AR内容"></a>配置一个AR会话并使用SceneKit或SpriteKit来显示AR内容</h6>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARKit文档瞎翻译（3）&quot;&gt;&lt;a href=&quot;#ARKit文档瞎翻译（3）&quot; class=&quot;headerlink&quot; title=&quot;ARKit文档瞎翻译（3）&quot;&gt;&lt;/a&gt;ARKit文档瞎翻译（3）&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ARKit文档瞎翻译（2）</title>
    <link href="http://yoursite.com/2017/06/29/ARKit_doc_2/"/>
    <id>http://yoursite.com/2017/06/29/ARKit_doc_2/</id>
    <published>2017-06-29T08:19:03.000Z</published>
    <updated>2017-07-03T04:53:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARKit文档瞎翻译（2）"><a href="#ARKit文档瞎翻译（2）" class="headerlink" title="ARKit文档瞎翻译（2）"></a>ARKit文档瞎翻译（2）</h1><p><a href="https://developer.apple.com/documentation/arkit" target="_blank" rel="external">原文请戳</a></p>
<h2 id="ARKit"><a href="#ARKit" class="headerlink" title="ARKit"></a>ARKit</h2><h6 id="在你的app或游戏中结合iOS的设备相机和运动感应器来产生增强现实的体验。"><a href="#在你的app或游戏中结合iOS的设备相机和运动感应器来产生增强现实的体验。" class="headerlink" title="在你的app或游戏中结合iOS的设备相机和运动感应器来产生增强现实的体验。"></a>在你的app或游戏中结合iOS的设备相机和运动感应器来产生增强现实的体验。</h6><hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>增强现实（AR）描述了以一种在相机提供的现实视图中添加2D或3D元素并且使这些元素展现在现实世界中的用户体验。ARKit结合了设备的运动追踪、相机场景捕捉、高级场景处理和便捷地显示来简化创建AR任务的体验。</p>
<blockquote>
<p>注意：</p>
<p>ARKit需要搭载A9或更高型号处理器的iOS设备。</p>
<p>如果你的app只被允许在支持ARKit的设备上运行，请在Info.plist中的<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW3" target="_blank" rel="external">UIRequiredDeviceCapabilities</a>组中添加arkit键值。如果AR是你app的第二特性，使用<a href="https://developer.apple.com/documentation/arkit/arsessionconfiguration/2867255-issupported" target="_blank" rel="external">isSupported</a>属性来决定当前设备是否支持你用的会话配置。</p>
</blockquote>
<h3 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h3><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><h6 id="理解AR"><a href="#理解AR" class="headerlink" title="理解AR"></a><a href="https://developer.apple.com/documentation/arkit/understanding_augmented_reality" target="_blank" rel="external"><em>理解AR</em></a></h6><h6 id="探索概念、特性和最棒的实践来创建伟大的AR体验。"><a href="#探索概念、特性和最棒的实践来创建伟大的AR体验。" class="headerlink" title="探索概念、特性和最棒的实践来创建伟大的AR体验。"></a>探索概念、特性和最棒的实践来创建伟大的AR体验。</h6><h6 id="class-ARSession"><a href="#class-ARSession" class="headerlink" title="class ARSession"></a>class <a href="https://developer.apple.com/documentation/arkit/arsession" target="_blank" rel="external">ARSession</a></h6><h6 id="一个共享对象，负责管理AR中的设备相机和运动处理的需求。"><a href="#一个共享对象，负责管理AR中的设备相机和运动处理的需求。" class="headerlink" title="一个共享对象，负责管理AR中的设备相机和运动处理的需求。"></a>一个共享对象，负责管理AR中的设备相机和运动处理的需求。</h6><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h6 id="class-ARSessionConfiguation"><a href="#class-ARSessionConfiguation" class="headerlink" title="class ARSessionConfiguation"></a>class <a href="https://developer.apple.com/documentation/arkit/arsessionconfiguration" target="_blank" rel="external">ARSessionConfiguation</a></h6><h6 id="一个只追踪设备方向的基本配置"><a href="#一个只追踪设备方向的基本配置" class="headerlink" title="一个只追踪设备方向的基本配置"></a>一个只追踪设备方向的基本配置</h6><h6 id="class-ARWordTrackingSessionConfiguration"><a href="#class-ARWordTrackingSessionConfiguration" class="headerlink" title="class ARWordTrackingSessionConfiguration"></a>class <a href="https://developer.apple.com/documentation/arkit/arworldtrackingsessionconfiguration" target="_blank" rel="external">ARWordTrackingSessionConfiguration</a></h6><h6 id="一个追踪设备方向和位置，并且通过设备相机检测真实世界朝向的配置"><a href="#一个追踪设备方向和位置，并且通过设备相机检测真实世界朝向的配置" class="headerlink" title="一个追踪设备方向和位置，并且通过设备相机检测真实世界朝向的配置"></a>一个追踪设备方向和位置，并且通过设备相机检测真实世界朝向的配置</h6><h4 id="基本视图"><a href="#基本视图" class="headerlink" title="基本视图"></a>基本视图</h4><h6 id="创建基本的AR体验"><a href="#创建基本的AR体验" class="headerlink" title="创建基本的AR体验"></a><a href="https://developer.apple.com/documentation/arkit/building_a_basic_ar_experience" target="_blank" rel="external"><em>创建基本的AR体验</em></a></h6><h6 id="配置一个AR会话并使用SceneKit或SpriteKit来显示AR内容"><a href="#配置一个AR会话并使用SceneKit或SpriteKit来显示AR内容" class="headerlink" title="配置一个AR会话并使用SceneKit或SpriteKit来显示AR内容"></a>配置一个AR会话并使用SceneKit或SpriteKit来显示AR内容</h6><h6 id="class-ARSCNView"><a href="#class-ARSCNView" class="headerlink" title="class ARSCNView"></a>class <a href="https://developer.apple.com/documentation/arkit/arscnview" target="_blank" rel="external">ARSCNView</a></h6><h6 id="一个负责显示包含3DSceneKit内容的相机界面的AR视图"><a href="#一个负责显示包含3DSceneKit内容的相机界面的AR视图" class="headerlink" title="一个负责显示包含3DSceneKit内容的相机界面的AR视图"></a>一个负责显示包含3DSceneKit内容的相机界面的AR视图</h6><h6 id="class-ARSKView"><a href="#class-ARSKView" class="headerlink" title="class ARSKView"></a>class <a href="https://developer.apple.com/documentation/arkit/arskview" target="_blank" rel="external">ARSKView</a></h6><h6 id="一个负责显示包含了2DSpriteKit内容的相机界面的AR视图"><a href="#一个负责显示包含了2DSpriteKit内容的相机界面的AR视图" class="headerlink" title="一个负责显示包含了2DSpriteKit内容的相机界面的AR视图"></a>一个负责显示包含了2DSpriteKit内容的相机界面的AR视图</h6><h4 id="自定义视图"><a href="#自定义视图" class="headerlink" title="自定义视图"></a>自定义视图</h4><h6 id="使用Metal显示一个AR体验"><a href="#使用Metal显示一个AR体验" class="headerlink" title="使用Metal显示一个AR体验"></a><a href="https://developer.apple.com/documentation/arkit/displaying_an_ar_experience_with_metal" target="_blank" rel="external">使用Metal显示一个AR体验</a></h6><h6 id="通过渲染相机图片并使用位置追踪信息创建一个自定义的AR视图来显示覆盖内容"><a href="#通过渲染相机图片并使用位置追踪信息创建一个自定义的AR视图来显示覆盖内容" class="headerlink" title="通过渲染相机图片并使用位置追踪信息创建一个自定义的AR视图来显示覆盖内容"></a>通过渲染相机图片并使用位置追踪信息创建一个自定义的AR视图来显示覆盖内容</h6><h4 id="真实世界的对象和位置"><a href="#真实世界的对象和位置" class="headerlink" title="真实世界的对象和位置"></a>真实世界的对象和位置</h4><h6 id="class-ARAnchor"><a href="#class-ARAnchor" class="headerlink" title="class ARAnchor"></a>class <a href="https://developer.apple.com/documentation/arkit/aranchor" target="_blank" rel="external">ARAnchor</a></h6><h6 id="在AR场景中可用于放置物体的一个真实世界的位置和朝向"><a href="#在AR场景中可用于放置物体的一个真实世界的位置和朝向" class="headerlink" title="在AR场景中可用于放置物体的一个真实世界的位置和朝向"></a>在AR场景中可用于放置物体的一个真实世界的位置和朝向</h6><h6 id="class-ARPlaneAnchor"><a href="#class-ARPlaneAnchor" class="headerlink" title="class ARPlaneAnchor"></a>class <a href="https://developer.apple.com/documentation/arkit/arplaneanchor" target="_blank" rel="external">ARPlaneAnchor</a></h6><h6 id="在AR会话中真实世界水平面检测的位置和方向信息"><a href="#在AR会话中真实世界水平面检测的位置和方向信息" class="headerlink" title="在AR会话中真实世界水平面检测的位置和方向信息"></a>在AR会话中真实世界水平面检测的位置和方向信息</h6><h6 id="class-ARHitTestResult"><a href="#class-ARHitTestResult" class="headerlink" title="class ARHitTestResult"></a>class <a href="https://developer.apple.com/documentation/arkit/arhittestresult" target="_blank" rel="external">ARHitTestResult</a></h6><h6 id="AR会话中通过在设备相机视图中检查一个点在现实世界的表面信息"><a href="#AR会话中通过在设备相机视图中检查一个点在现实世界的表面信息" class="headerlink" title="AR会话中通过在设备相机视图中检查一个点在现实世界的表面信息"></a>AR会话中通过在设备相机视图中检查一个点在现实世界的表面信息</h6><h4 id="相机和场景细节"><a href="#相机和场景细节" class="headerlink" title="相机和场景细节"></a>相机和场景细节</h4><h6 id="class-ARFrame"><a href="#class-ARFrame" class="headerlink" title="class ARFrame"></a>class <a href="https://developer.apple.com/documentation/arkit/arframe" target="_blank" rel="external">ARFrame</a></h6><h6 id="AR会话中截取的一帧视频截图和位置追踪信息"><a href="#AR会话中截取的一帧视频截图和位置追踪信息" class="headerlink" title="AR会话中截取的一帧视频截图和位置追踪信息"></a>AR会话中截取的一帧视频截图和位置追踪信息</h6><h6 id="class-ARCamera"><a href="#class-ARCamera" class="headerlink" title="class ARCamera"></a>class <a href="https://developer.apple.com/documentation/arkit/arcamera" target="_blank" rel="external">ARCamera</a></h6><h6 id="AR会话中从一个截取的视频帧中得到的相机位置和图像特征信息"><a href="#AR会话中从一个截取的视频帧中得到的相机位置和图像特征信息" class="headerlink" title="AR会话中从一个截取的视频帧中得到的相机位置和图像特征信息"></a>AR会话中从一个截取的视频帧中得到的相机位置和图像特征信息</h6><h6 id="class-ARLightEstimate"><a href="#class-ARLightEstimate" class="headerlink" title="class ARLightEstimate"></a>class <a href="https://developer.apple.com/documentation/arkit/arlightestimate" target="_blank" rel="external">ARLightEstimate</a></h6><h6 id="AR会话中从一个截取的视频帧中预测场景中的光照信息"><a href="#AR会话中从一个截取的视频帧中预测场景中的光照信息" class="headerlink" title="AR会话中从一个截取的视频帧中预测场景中的光照信息"></a>AR会话中从一个截取的视频帧中预测场景中的光照信息</h6>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARKit文档瞎翻译（2）&quot;&gt;&lt;a href=&quot;#ARKit文档瞎翻译（2）&quot; class=&quot;headerlink&quot; title=&quot;ARKit文档瞎翻译（2）&quot;&gt;&lt;/a&gt;ARKit文档瞎翻译（2）&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ARKit文档瞎翻译（1）</title>
    <link href="http://yoursite.com/2017/06/29/ARKit_doc_1/"/>
    <id>http://yoursite.com/2017/06/29/ARKit_doc_1/</id>
    <published>2017-06-29T07:37:05.000Z</published>
    <updated>2017-07-03T07:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARKit文档瞎翻译（1）"><a href="#ARKit文档瞎翻译（1）" class="headerlink" title="ARKit文档瞎翻译（1）"></a>ARKit文档瞎翻译（1）</h1><p><a href="https://developer.apple.com/arkit/" target="_blank" rel="external">看不下去就戳真相地址</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="虚拟内部测量（VIO）"><a href="#虚拟内部测量（VIO）" class="headerlink" title="虚拟内部测量（VIO）"></a>虚拟内部测量（VIO）</h3><p>ARKit使用VIO系统来精确测量整个世界。VIO把相机传感器的数据和CoreMotion数据引入到一起。这两方面输入允许设备来感知如何高精度地在空间中移动，且不需要任何额外校准。</p>
<h3 id="场景理解和光照预估"><a href="#场景理解和光照预估" class="headerlink" title="场景理解和光照预估"></a>场景理解和光照预估</h3><p>有了ARKit，iPhone和iPad可以识别相机视图提供的场景并识别出空间中的水平面。ARKit可以检测出诸如桌面、地面等水平面，并且可以在特定的小位置追踪并放置物体。ARKit还可以使用相机传感器来预估场景中整体的光照总量并把合适的光照投射到虚拟物体上。</p>
<h3 id="高性能的硬件和渲染优化"><a href="#高性能的硬件和渲染优化" class="headerlink" title="高性能的硬件和渲染优化"></a>高性能的硬件和渲染优化</h3><p>ARKit运行在苹果的A9和A10处理器上。这些处理器有出色的性能表现可以实现快速的场景理解并可以让你在真实的场景中搭建详尽真实的虚拟内容。你可以在诸如Metal、SceneKit或第三方平台工具如Unity和Unreal Engine等地方使用这些为ARKit带来的优化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARKit文档瞎翻译（1）&quot;&gt;&lt;a href=&quot;#ARKit文档瞎翻译（1）&quot; class=&quot;headerlink&quot; title=&quot;ARKit文档瞎翻译（1）&quot;&gt;&lt;/a&gt;ARKit文档瞎翻译（1）&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博文</title>
    <link href="http://yoursite.com/2017/06/05/%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%8B/"/>
    <id>http://yoursite.com/2017/06/05/测试一下/</id>
    <published>2017-06-05T14:48:25.000Z</published>
    <updated>2017-06-05T14:48:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一篇博文"><a href="#第一篇博文" class="headerlink" title="第一篇博文"></a>第一篇博文</h1><ul>
<li>太不容易了</li>
<li>太不容易了</li>
<li>太不容易了</li>
</ul>
<p>但是，我成功啦，撒花<del>~</del>~</p>
<p>以后要加油~💪</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一篇博文&quot;&gt;&lt;a href=&quot;#第一篇博文&quot; class=&quot;headerlink&quot; title=&quot;第一篇博文&quot;&gt;&lt;/a&gt;第一篇博文&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;太不容易了&lt;/li&gt;
&lt;li&gt;太不容易了&lt;/li&gt;
&lt;li&gt;太不容易了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
