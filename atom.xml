<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭吉吉的瞎记空间</title>
  <subtitle>技术的，瞎说的，啥都有吧。。。希望。。。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-26T09:08:20.566Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>臭吉吉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Effective Objective-C 20 编写高质量iOS与OS X代码的52个有效方法》读书笔记</title>
    <link href="http://yoursite.com/2018/12/25/%E3%80%8AEffective%20Objective-C%2020%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/25/《Effective Objective-C 20 编写高质量iOS与OS X代码的52个有效方法》读书笔记/</id>
    <published>2018-12-25T02:49:27.623Z</published>
    <updated>2018-12-26T09:08:20.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第1章：熟悉Objective-C"><a href="#第1章：熟悉Objective-C" class="headerlink" title="第1章：熟悉Objective-C"></a>第1章：熟悉Objective-C</h2><h3 id="第4条：多用类型常量，少用-define预处理指令"><a href="#第4条：多用类型常量，少用-define预处理指令" class="headerlink" title="第4条：多用类型常量，少用#define预处理指令"></a>第4条：多用类型常量，少用#define预处理指令</h3><ul>
<li>声明类型常量好处是，编译器可以知道此变量的类型，且可以防止外部随意修改</li>
<li>声明规则：<a id="more"></a>
<ul>
<li><strong>全局常量</strong>：<em>使用extern开头，类名作为常量前缀（OC无命名空间，避免冲突），const修饰常量名，头文件声明，实现文件赋值</em>。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在ViewController.h中声明通知名</span></div><div class="line"><span class="comment">/** ViewController视图已加载通知 */</span></div><div class="line"><span class="keyword">extern</span> NSString * <span class="keyword">const</span> ViewControllerViewDidLoadNotification;</div><div class="line"></div><div class="line"><span class="comment">// 在ViewController.m中赋值通知名</span></div><div class="line">NSString *<span class="keyword">const</span> ViewControllerViewDidLoadNotification = @<span class="string">"ViewControllerViewDidLoadNotification"</span>;</div></pre></td></tr></table></figure>
<pre><code>- **局部常量**（类内使用的）：*使用static开头，“k”作为常量前缀，const修饰常量名，在实现文件中声明及赋值*。这种局部常量（static + const）的优点是：**编译器不会创建符号，会像#define一样，把遇到的所有变量直接替换，但是带有类型信息**。
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 动画时长 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> NSTimeInterval kAnimationDuration = <span class="number">0.3</span>;</div></pre></td></tr></table></figure>
<h3 id="第5条：用枚举表示状态、选项、状态码"><a href="#第5条：用枚举表示状态、选项、状态码" class="headerlink" title="第5条：用枚举表示状态、选项、状态码"></a>第5条：用枚举表示状态、选项、状态码</h3><ul>
<li>如果枚举值的选项可以进行组合，则使用时，用“按位或”操作（“|”）。声明枚举时，使用二进制进行表示。</li>
<li><p>NS_OPTIONS和NS_ENUM其实都是定义的宏，可以向下兼容（编译器支持新枚举特性时生成的enum带有类型声明，否则没有）。</p>
<blockquote>
<p>凡是需要以按位或操作来组合的枚举都应使用NS_OPTIONS定义。若是枚举不需要相互组合，则应使用NS_ENUM来定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_OPTIONS</span><span class="params">(NSUInteger, UIViewAutoresizing)</span> </span>&#123;</div><div class="line">    UIViewAutoresizingNone                 = <span class="number">0</span>,</div><div class="line">    UIViewAutoresizingFlexibleLeftMargin   = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    UIViewAutoresizingFlexibleWidth        = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    UIViewAutoresizingFlexibleRightMargin  = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    UIViewAutoresizingFlexibleTopMargin    = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    UIViewAutoresizingFlexibleHeight       = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    UIViewAutoresizingFlexibleBottomMargin = <span class="number">1</span> &lt;&lt; <span class="number">5</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_ENUM</span><span class="params">(NSInteger, UIViewAnimationTransition)</span> </span>&#123;</div><div class="line">    UIViewAnimationTransitionNone,</div><div class="line">    UIViewAnimationTransitionFlipFromLeft,</div><div class="line">    UIViewAnimationTransitionFlipFromRight,</div><div class="line">    UIViewAnimationTransitionCurlUp,</div><div class="line">    UIViewAnimationTransitionCurlDown,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>在switch语句中，使用枚举变量时，不要加default分支，这样编译器会提示是否还有未枚举的分支。</p>
</li>
</ul>
<h2 id="第2章：对象、消息、运行期"><a href="#第2章：对象、消息、运行期" class="headerlink" title="第2章：对象、消息、运行期"></a>第2章：对象、消息、运行期</h2><h3 id="第7条：在对象内部尽量直接访问实例变量"><a href="#第7条：在对象内部尽量直接访问实例变量" class="headerlink" title="第7条：在对象内部尽量直接访问实例变量"></a>第7条：在对象内部尽量直接访问实例变量</h3><blockquote>
<ul>
<li>在对象内部读取数据时，应该直接通过实例变量来读；而写入数据时，则应通过属性来写。</li>
<li>在初始化和dealloc方法中，总应该直接通过实例变量来读写数据。</li>
<li>有时会使用惰性初始化技术配置某份数据，这种情况下，需要通过属性来读取数据。</li>
</ul>
</blockquote>
<h3 id="第8条：理解“对象等同性”这一概念"><a href="#第8条：理解“对象等同性”这一概念" class="headerlink" title="第8条：理解“对象等同性”这一概念"></a>第8条：理解“对象等同性”这一概念</h3><ul>
<li><p>NSObject协议中用于判定对象相等的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isEqual:(id)object;</div><div class="line">- (NSUInteger)hash;</div><div class="line"><span class="comment">// 协议里hash为只读属性： @property (readonly) NSUInteger hash;</span></div></pre></td></tr></table></figure>
</li>
<li><p><em>如果两个对象相等，则其hash值必然相等；反之则不一定</em>（因为isEqual:方法先回判断两者是否为相同类型）。</p>
</li>
<li>自定义类型中，若提供判定对象相等方法，可以实现上述方法和属性。</li>
</ul>
<h3 id="第11条：理解objc-msgSend的作用"><a href="#第11条：理解objc-msgSend的作用" class="headerlink" title="第11条：理解objc_msgSend的作用"></a>第11条：理解objc_msgSend的作用</h3><ul>
<li><em>objc_msgSend使用了“<strong>尾调用优化</strong>”技术（tail-call optimization），实质上即为<strong>函数调用的栈帧的复用</strong></em>。<ul>
<li>一般来说，函数调用时，会在栈中生成新的栈帧（申请一块新的栈内存），跳转过去进行新函数的调用。当在函数执行过程中，如果再次调用其他函数，会再次压入新的栈帧并跳转，直到依次调用完毕再返回并释放栈帧的内存。</li>
<li>对于OC来说，<strong>当函数调用中，如果返回值“仅仅”是调用其他函数（没有其他任何操作，如进行其他运算等），则会把当前函数调用的栈帧直接交给调用的新函数（自身数据变为新函数的）</strong>。这样即避免了重复申请内存，而且调用地址不必来回跳转，在多个函数调用时对效率的提升和内存控制尤其有效。</li>
<li><a href="https://www.jianshu.com/p/9e3cd9b1095a?from=timeline&amp;isappinstalled=0" target="_blank" rel="external">iOS objc_msgSend尾调用优化机制详解</a></li>
</ul>
</li>
</ul>
<h3 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h3><ul>
<li><strong>动态方法解析</strong>：<em>在方法未找到时执行的第一步操作，即</em>resolveInstanceMethod<em>和</em>resolveClassMethod<em>方法。在此函数中使用class_addMethod可以为当前类添加动态实例方法或类方法（类方法要添加到class的meta class中）</em>。之后，当前实例即会缓存并调用新添加的方法，且以后会在缓存列表内直接调用，不再进行方法解析步骤。一般来说，我们会在存在@dymamic修饰的属性所属的类中通过此方法来提供实现，比如Core Data的数据类中。</li>
<li><strong>备援接收者</strong>：动态解析过程若没有提供方法时，则进入此步骤。<em>在方法</em>forwardingTargetForSelector<em>方法中，运行时系统会将此selector对应的消息原封不动转发给返回的对象</em>。利用<em>此方法可以模拟出”多继承“</em>：即将对应方法转发给可以执行的类实例。</li>
<li><strong>完整的消息转发机制</strong>：上一步只能转发原始消息，如果对方法参数等需要二次修改，则需要通过此步骤（上一步没有成功执行即会进入此步，所以性能代价会大一些）。<em>系统会通过forwardInvocation方法，将原target、selector和parameter等封装为NSInvocation对象。我们需要将此invocation的目标改为对应的接收者，使其执行。也可以对selector进行修改，如增删改参数，甚至改变selector。不能处理时，通过super返回给父类实例进行处理，直到NSObject最终触发doesNotRecognizeSelector方法，抛出异常</em>。</li>
</ul>
<h2 id="接口与API设计"><a href="#接口与API设计" class="headerlink" title="接口与API设计"></a>接口与API设计</h2><h3 id="第15条：用前缀避免命名空间冲突"><a href="#第15条：用前缀避免命名空间冲突" class="headerlink" title="第15条：用前缀避免命名空间冲突"></a>第15条：用前缀避免命名空间冲突</h3><ul>
<li>双字符前缀是苹果官方使用的，自己需要使用至少三字符的前缀，避免冲突。</li>
<li>类的实现文件中定义的c函数在编译后的目标文件（.o）中会成为顶级符号（全局符号），所有也需要添加前缀。</li>
<li>自己封装的库中，若引用了其他第三方库，应对第三方库的类文件分别添加前缀命名。防止其他项目引入本库后，再引入同样的第三方库产生命名冲突。</li>
</ul>
<h3 id="第16条：提供“全能初始化”方法"><a href="#第16条：提供“全能初始化”方法" class="headerlink" title="第16条：提供“全能初始化”方法"></a>第16条：提供“全能初始化”方法</h3><ul>
<li>类中存在多个初始化方法是，需要指定一个作为“全能初始化”方法（designed initializer），使其余方法都通过此方法进行实例的初始化。对后期修改维护有利。</li>
<li><p>子类继承时，<strong>如果子类存在自己独特的“全能初始化”方法，则必须要覆盖父类的全能初始化方法（防止使用父类的方法创建子类实例）</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 父类：矩形类</span></div><div class="line"></div><div class="line"><span class="comment">// EOCRectangle.h</span></div><div class="line">@interface EOCRectangle: NSObject</div><div class="line"></div><div class="line">@property (nonatomic, assign, readonly) <span class="keyword">float</span> width;</div><div class="line">@property (nonatomic, assign, readonly) <span class="keyword">float</span> height;</div><div class="line"></div><div class="line">- (id)initWithWidth:(<span class="keyword">float</span>)width </div><div class="line">         andHeight:(<span class="keyword">float</span>)height;</div><div class="line">         </div><div class="line">@end</div><div class="line"></div><div class="line"><span class="comment">// EOCRectangle.m</span></div><div class="line">@implementation EOCRectangle</div><div class="line"></div><div class="line"><span class="comment">/** designed initializer */</span></div><div class="line">- (id)initWithWidth:(<span class="keyword">float</span>)width </div><div class="line">         andHeight:(<span class="keyword">float</span>)height &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        _width = width;</div><div class="line">        _height = height;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** overrided initializer */</span></div><div class="line">- (id)init &#123;</div><div class="line">    <span class="keyword">return</span> [self initWithWidth:<span class="number">5.0f</span> andHeight:<span class="number">10.0f</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"><span class="comment">// 子类：正方形类</span></div><div class="line"></div><div class="line"><span class="comment">// EOCSquare.h</span></div><div class="line">@interface EOCSquare: EOCRectangle</div><div class="line"></div><div class="line">- (id)initWithDimension:(<span class="keyword">float</span>)dimension;</div><div class="line">         </div><div class="line">@end</div><div class="line"><span class="comment">// EOCSquare.m</span></div><div class="line">@implementation EOCSquare</div><div class="line"><span class="comment">/** designed initializer */</span></div><div class="line">- (id)initWithDimension:(<span class="keyword">float</span>)dimension &#123;</div><div class="line">    <span class="keyword">return</span> [super initWithWidth:dimension height:dimension];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** overrided initializer */</span></div><div class="line">- (id)initWithWidth:(<span class="keyword">float</span>)width </div><div class="line">         andHeight:(<span class="keyword">float</span>)height &#123;</div><div class="line">    <span class="keyword">float</span> dimension = MAX(width, height);</div><div class="line">    <span class="keyword">return</span> [self initWithDimension:dimenson];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
<li><p><em>如果类中存在多种完全不同的初始化方式，则需要多个“全能初始化”方法</em>。如遵循NSCoding协议的类，需要实现<em>initWithCoder</em>方法作为单独的“全能初始化”方法。</p>
</li>
</ul>
<h3 id="第18条：尽量使用不可变对象"><a href="#第18条：尽量使用不可变对象" class="headerlink" title="第18条：尽量使用不可变对象"></a>第18条：尽量使用不可变对象</h3><ul>
<li><p>需要公开的属性，尽量用“readonly”进行语义修饰，防止外部进行修改；内部修改时，在分类中可以修改为“readwrite”</p>
<ol>
<li>由于iOS的属性一般使用“nonatomic”进行修饰，为了防止极端情况下，内部修改属性时，外部读取产生的数据不统一的情况，可以使用GCD的同步操作对读取和修改进行统一处理。</li>
<li>不考虑外部使用“KVC”的方式对只读属性设置，甚至是根据实例内存布局通过内存偏移量对属性进行强制修改的情况，还是应该尽量遵循此属性声明方式。</li>
</ol>
</li>
<li><p>对于可变集合对象，尽量不要作为公开属性。</p>
<ol>
<li>可以声明为分类中的属性，或是类的成员变量。在外部使用不可变的版本进行属性公开。</li>
<li>增删改等方式，提供公开方法用以外部调用。</li>
</ol>
</li>
</ul>
<h3 id="第20条：为私有方法名加前缀"><a href="#第20条：为私有方法名加前缀" class="headerlink" title="第20条：为私有方法名加前缀"></a>第20条：为私有方法名加前缀</h3><ul>
<li>为普通类的私有方法（在实现文件中的声明并只提供内部调用的方法）的方法名前，添加“p_”作为前缀，提高调试效率。</li>
<li>对于自定义的库文件类，甚至可以使用“类名 + _”的方式为私有方法命名，尽量减少命名冲突。</li>
</ul>
<h3 id="第21条：理解Objective-C错误类型"><a href="#第21条：理解Objective-C错误类型" class="headerlink" title="第21条：理解Objective-C错误类型"></a>第21条：理解Objective-C错误类型</h3><ul>
<li>在ARC下，代码不是“异常安全”（exception safe）的：即当抛出异常时，本应该在作用域末尾自动释放的内存，便不会释放了（MRC下，需要开发者在抛出异常之前手动释放所有内存，极易出错）。</li>
</ul>
<h2 id="第4章-协议与分类"><a href="#第4章-协议与分类" class="headerlink" title="第4章 协议与分类"></a>第4章 协议与分类</h2><h3 id="第23条：通过委托与数据源协议进行对象间通信"><a href="#第23条：通过委托与数据源协议进行对象间通信" class="headerlink" title="第23条：通过委托与数据源协议进行对象间通信"></a>第23条：通过委托与数据源协议进行对象间通信</h3><ul>
<li><p>协议分类及数据流向</p>
<ol>
<li><em>若某类实例需要让其他对象代替实现某些逻辑功能，则可以把需要实现逻辑的方法抽象为协议，让“其他对象”成为其“委托对象”，实现协议的方法</em>。此模式即为“<strong>委托模式</strong>”，数据流向为“Class -&gt; Delegate”。如：UITableViewDelegate，tableView实例将处理列表点击等行为委托给代理对象（如UIViewController实例）。 </li>
<li><em>若某类实例需要通过一些方法获取数据，则可以把这些方法抽象为协议，让“其他对象”成为其“委托对象”，实现协议的方法</em>。这种委托模式也称为“<strong>数据源模式</strong>”，数据流向为“Data Source -&gt; Class”。如：UITableViewDataSource，tableView实例从代理对象（如UIViewController实例）中获取列表的数据等。<br><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F.jpg" alt="img"></li>
</ol>
</li>
<li><p>提高协议方法的调用效率</p>
<ol>
<li>众所周知，对于optional的协议方法，调用前需要进行实现判断（使用respondsToSelector方法）。若在委托对象中频繁调用此方法（如下载progress等），每次进行响应判断，意义不大，且效率可能会出现瓶颈。针对此情况，可以使用“位段”方式（bitField）进行优化，对于是否能够响应协议方法调用，只需要一个二进制位（bit）即可进行表示。所以，可以为委托对象所属的类声明一个结构体成员变量。此结构体内部的成员与所有的optional协议方法一一对应，成员值均为0或1。然后，在设置代理对象时，将所有的实现情况进行判断并赋值到此结构体成员变量中。即可在实际回调协议方法是免去每次进行响应判断，提高效率。<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">@porotocol DownloadProtocol: NSObject</div><div class="line">...</div><div class="line">@optional</div><div class="line">- (<span class="keyword">void</span>)onDownloadingProgress:(CGFloat)progress;</div><div class="line">...</div><div class="line">@end</div><div class="line"></div><div class="line">...</div><div class="line"><span class="meta">#import <span class="meta-string">"DownloadProtocol.h"</span></span></div><div class="line"></div><div class="line">@interface MyClass: NSObject</div><div class="line"></div><div class="line">@property (nonatomic, weak) id&lt;DownloadProtocol&gt; delegate;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@<span class="function">interface <span class="title">MyClass</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 声明结构体变量成员</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">        NSInteger onDownloadProgress: <span class="number">0</span></div><div class="line">    &#125; _downloadProtocolFlag;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MyClass: NSObject </div><div class="line"></div><div class="line"><span class="comment">// 手动实现delegate的setter，对代理对象的方法实现情况进行检查并缓存</span></div><div class="line">- (<span class="keyword">void</span>)setDelegate:(id&lt;DownloadProtocol&gt;)delegate &#123;</div><div class="line">    _delegate = delegate;</div><div class="line">    <span class="comment">// 对所有optional方法依次检查，这里只是一个</span></div><div class="line">    _downloadProtocolFlag.onDownloadProgress = [_delegate respondsToSelector:@selector(onDownloadProgress:)]; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实际调用时，即可简化判断，提高效率</span></div><div class="line">- (<span class="keyword">void</span>)testMyDownloadProgress:(CGFloat)progress &#123;</div><div class="line">    <span class="keyword">if</span> (_downloadProtocolFlag.onDownloadProgress) &#123;</div><div class="line">    [self.delegate onDownloadProgress: progress];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="第24条：将类的实现代码分散到便于管理的数个分类之中"><a href="#第24条：将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="第24条：将类的实现代码分散到便于管理的数个分类之中"></a>第24条：将类的实现代码分散到便于管理的数个分类之中</h3><ul>
<li>有时无需继承父类时，可有使用分类（Category）方式扩展类的功能。</li>
<li>使用分类将不同功能的的代码分隔到不同区块中，可以防止原始类过于庞大，代码逻辑清晰，便于调试（调用信息的符号中会显示为不同的分类）。</li>
<li>对于类或模块内部的私有方法，可以创建private分类，且不对外公开。</li>
</ul>
<h3 id="第25条：总是为第三方类的分类名称加前缀"><a href="#第25条：总是为第三方类的分类名称加前缀" class="headerlink" title="第25条：总是为第三方类的分类名称加前缀"></a>第25条：总是为第三方类的分类名称加前缀</h3><ul>
<li>在OC中，由于分类是在运行期进行加载，且各分类的加载顺序依照编译顺序而定（在build phrase中可以手动修改，当然分类的加载是在本类之后），故分类中可以覆盖本类的方法。但是，当多个分类同时覆盖本类方法后，便无法确定调用时的版本了（只能依靠build phrase顺序）【分类的方法在加载时，依照类似链表“头插法”的方式，将方法添加到类的方法列表头部，原始方法则被挤到了后面，所以当调用方法时，系统只找到第一个方法后便直接跳转执行】。所以，为了避免分类异常覆盖本类方法时，需要如下做法进行改进（OC没有命名空间）：<ul>
<li>创建类的分类时，需要为分类名前添加自定义的前缀</li>
<li>创建分类的方法时，需要为各方法名前也添加自定义的前缀</li>
</ul>
</li>
</ul>
<h3 id="第26条：勿在分类中声明属性"><a href="#第26条：勿在分类中声明属性" class="headerlink" title="第26条：勿在分类中声明属性"></a>第26条：勿在分类中声明属性</h3><ul>
<li><strong>“属性”实质上是数据的封装，背后有成员变量作为数据支持，系统只是合成了setter和getter</strong>。</li>
<li>分类中不能生成真正属性的原因：由于编译期，本类的内存布局结构已经确定（实例变量区域的偏移量及大小已经确定），分类在运行期加载时，已经无法在本类的实例变量区域进行操作。</li>
<li><p>分类中声明并实现“属性”的方法：</p>
<ol>
<li>使用正常语法声明，使用相关对象（associate object）实现属性的setter和getter（只是模拟属性，添加了内存管理语义）。</li>
<li>使用@dynamic关键字告知编译器，在运行期再提供实现。可以通过方法转发的方式（如resolveInstanceMethod）提供动态实现。</li>
</ol>
</li>
<li><p>由于属性是实例变量的封装，所以建议属性依照实例变量的方式，在主类的头文件中直接进行声明。</p>
</li>
<li><strong>分类只是用于扩展类的功能，而非提供类的额外存储</strong>。</li>
</ul>
<h3 id="第27条：使用“class-continuation分类”隐藏实现细节"><a href="#第27条：使用“class-continuation分类”隐藏实现细节" class="headerlink" title="第27条：使用“class-continuation分类”隐藏实现细节"></a>第27条：使用“class-continuation分类”隐藏实现细节</h3><ul>
<li>此”class-continuation分类”即为类的扩展（extension）。这是唯一可以在其中同时声明实例变量、属性和方法的匿名“分类”。原因：<strong>类的扩展是与本类源码一起在编译期共同确定类的内存布局</strong>，所以此时会将扩展的实例变量等一同加载到类的对应部分。</li>
<li>可以将不对外公开的方法、属性和实例变量等放在扩展中。</li>
<li>在扩展中引用C++代码，可以只在当前类中引入C++编译器进行混合编译（类实现文件要用“.mm”为后缀），头文件对外仍然只公布简洁的OC风格接口。</li>
<li>可以在头文件中声明只读属性，扩展中重新声明为可读写属性，内部使用setter进行数据修改时，可以正常触发KVO监听回调。</li>
<li>在扩展中遵循只在内部使用的协议。</li>
</ul>
<h3 id="第28条：通过协议提供匿名对象"><a href="#第28条：通过协议提供匿名对象" class="headerlink" title="第28条：通过协议提供匿名对象"></a>第28条：通过协议提供匿名对象</h3><ul>
<li>对于无需外部关心的类（只关心提供的功能），可以将所需功能封装为协议，将类名淡化为遵循此协议的匿名对象（id<myprotocol>）。</myprotocol></li>
<li>此种设计方法可以在后端进行实现替换，而对前端调用方完全透明，增加了编码的灵活程度，也降低了耦合（例如使用不同类数据库进行数据存取，协议中只提供通用的连接、断开、增删改查等方法即可）。</li>
</ul>
<h2 id="第5章-内存管理"><a href="#第5章-内存管理" class="headerlink" title="第5章 内存管理"></a>第5章 内存管理</h2><h3 id="第29条：理解引用计数"><a href="#第29条：理解引用计数" class="headerlink" title="第29条：理解引用计数"></a>第29条：理解引用计数</h3><p>在手动管理内存模式下，内存管理语义为“strong”的属性，其setter一般都是如此实现的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setFoo:(id)foo &#123;</div><div class="line">    <span class="comment">// 1.保留新值</span></div><div class="line">    [foo retain];</div><div class="line">    <span class="comment">// 2.释放原有值</span></div><div class="line">    [_foo release];</div><div class="line">    <span class="comment">// 3.赋值</span></div><div class="line">    _foo = foo</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，为何1和2步骤不能交换呢？<br>因为，当使用重复的foo对象进行设置时（假设foo对象只被本类实例保留），先释放，会导致foo对象内存被系统回收。致使setter失败【使用ARC即可避免此问题发生】。</p>
<h3 id="第30条：以ARC简化引用计数"><a href="#第30条：以ARC简化引用计数" class="headerlink" title="第30条：以ARC简化引用计数"></a>第30条：以ARC简化引用计数</h3><ul>
<li><p>使用ARC时必须遵循的方法命名规则</p>
<ul>
<li>方法名以“alloc、new、copy和mutableCopy”为开头时，其返回对象的内存管理由调用方负责。即在方法中，系统不会自动添加内存管理语句。</li>
<li>方法名以其他方式命名的，其返回对象的内存管理由方法自身负责。即在方法中，系统会自动给返回的对象添加autorelease操作。</li>
<li>ARC对代码的额外优化：<ul>
<li>编译期：对于多次的retain和release操作，ARC会根据情况适当成对的抵消掉此调用操作。</li>
<li>运行期：例如，对于使用方法调用返回autorelease的对象，ARC会使用objc_autoreleaseReturnValue来替代传统的autorelease方法，此时会检查函数返回之后的代码：若调用方需要对此对象进行保留，则不会执行autorelease操作，而是设置全局标志位；调用方retain时，使用objc_retainAutoreleasedReturnValue函数，检查此标志位，若已置位，则不执行retain操作，直接使用。这样，通过检测标志位代替传统的autorelease和retain，优化了执行效率。</li>
</ul>
</li>
</ul>
</li>
<li><p>ARC如何清理实例变量</p>
<ul>
<li>在ARC环境下，系统会利用Objective-C++的清理例程（cleanup routine）特性，待回收的对象会调用所有C++对象的析构函数。ARC借住此特性，会在dealloc中生成清理内存的代码。</li>
<li>对于非OC对象，如CF对象或手动malloc的对象，在dealloc方法中还是需要手动释放这些对象的内存</li>
<li>在deallc中无需调用super方法。</li>
</ul>
</li>
<li><p>覆写内存管理方法</p>
<ul>
<li>不能调用或覆盖release和retain等内存管理方法【单例中尤其注意】：ARC会优化retain、release等相关操作，使其不经过OC的消息派发机制（方法调用），底层使用了c函数版本进行了实现。</li>
</ul>
</li>
</ul>
<h3 id="第31条：在dealloc方法中只释放引用并解除监听"><a href="#第31条：在dealloc方法中只释放引用并解除监听" class="headerlink" title="第31条：在dealloc方法中只释放引用并解除监听"></a>第31条：在dealloc方法中只释放引用并解除监听</h3><ul>
<li>ARC下，dealloc方法会自动释放创建的OC对象的引用，但需要手动释放Core Foundation创建的对象和其他手动申请内存并创建的c对象。</li>
<li>dealloc中尽量不要调用其他方法（如实例方法等）</li>
<li>dealloc过程中，由于实例已经处于“释放状态”，无法确保代码会执行在确定的线程上。故不能在释放是执行异步多线程代码。</li>
<li>dealloc中释放KVO监听和NSNotificationCenter中注册的通知</li>
<li>对于创建和释放开销较大和系统稀缺的资源，一般单独创建自己的清理方法（如数据库对象的“连接”和“关闭”操作等）。使用完成后即提示调用者进行及时的资源清理，而不是在dealloc中释放内存【dealloc中可以检查是否正确清理此对象，没有则自动调用并给出debug提示】。</li>
</ul>
<h3 id="第35条：用“僵尸对象”调试内存管理问题"><a href="#第35条：用“僵尸对象”调试内存管理问题" class="headerlink" title="第35条：用“僵尸对象”调试内存管理问题"></a>第35条：用“僵尸对象”调试内存管理问题</h3><ul>
<li>在“XCode-&gt;Scheme-&gt;Run-&gt;Diagnostics”中，勾选“Enable Zombie Objects”选项，开启功能。</li>
<li>在调试模式中，开启此功能，可以防止已释放对象的内存被覆盖重用，可以帮助追溯调用过程和类型信息等。</li>
<li><p>已释放对象转化为“僵尸对象”的过程（“僵尸模式”开启的情况下，NSObject的dealloc会在运行期swizzle成类似以下代码）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取待释放对象所属的类</span></div><div class="line">Class cls = object_getClass(self);</div><div class="line"></div><div class="line"><span class="comment">// 获取类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *clsName = class_getName(cls);</div><div class="line"></div><div class="line"><span class="comment">// 生成僵尸类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *zombieClsName = <span class="string">"_NSZombie_"</span> + clsName;</div><div class="line"></div><div class="line"><span class="comment">// 查看是否存在此类</span></div><div class="line">Class zombieCls = objc_lookUpClass(zombieClsName);</div><div class="line"></div><div class="line"><span class="comment">// 不存在，则创建此类</span></div><div class="line"><span class="keyword">if</span> (!zombieCls) &#123;</div><div class="line">    <span class="comment">// 获取名为“_NSZombie_”的样板类</span></div><div class="line">    Class baseZombieCls = objc_lookUpClass(<span class="string">"_NSZombie_"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 复制样板类来创建此类</span></div><div class="line">    zombieCls = objc_duplicateClass(baseZombieCls, zombieClsName, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 正常释放实例</span></div><div class="line">objc_destructInstance(self);</div><div class="line"></div><div class="line"><span class="comment">// 将实例所属类指向新的僵尸类（替换isa指向）</span></div><div class="line">objc_setClass(self, zombieCls);</div><div class="line"></div><div class="line"><span class="comment">// 现在，self即为“_NSZombie_原始类名”的实例了</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>“僵尸类“为”根类“，只存在isa指针，没有任何方法实现（样本类的拷贝）。故其实例接收到的所有消息都需要进行完整的消息转发</strong>。被转发的消息响应过程的伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取对象类名</span></div><div class="line">Class cls = objc_getClass(self);</div><div class="line"></div><div class="line"><span class="comment">// 查看是否为”僵尸类“</span></div><div class="line"><span class="keyword">if</span> (String_has_prefix(clsName, <span class="string">"_NSZombie_"</span>)) &#123;</div><div class="line">    <span class="comment">// 是，则对象是”僵尸对象“</span></div><div class="line">    </div><div class="line">    <span class="comment">// 获取原始类名（去掉前缀）</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *originClsName = substring_from(clsName, <span class="number">10</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取消息的选择器名</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *selectorName = sel_getName(_cmd);</div><div class="line">    </div><div class="line">    <span class="comment">// 输出消息</span></div><div class="line">    Log(<span class="string">"*** -[%s %s]: message sent to deallocated instance %p"</span>, originClsName, selectorName, self);</div><div class="line">    </div><div class="line">    <span class="comment">// 结束程序</span></div><div class="line">    <span class="built_in">abort</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="第6章-块与大中枢派发"><a href="#第6章-块与大中枢派发" class="headerlink" title="第6章 块与大中枢派发"></a>第6章 块与大中枢派发</h2><h3 id="第37条：理解“块”这一概念"><a href="#第37条：理解“块”这一概念" class="headerlink" title="第37条：理解“块”这一概念"></a>第37条：理解“块”这一概念</h3><ul>
<li>块的内部结构（内存布局）：</li>
</ul>
<table>
<thead>
<tr>
<th>Block</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>void*</td>
<td>isa</td>
<td>指向Class对象的指针</td>
</tr>
<tr>
<td>int</td>
<td>flags</td>
<td></td>
</tr>
<tr>
<td>int</td>
<td>reserved</td>
<td></td>
</tr>
<tr>
<td>void (<em>)(void </em>, …)</td>
<td>invoke</td>
<td>实现函数的指针</td>
</tr>
<tr>
<td>struct *</td>
<td>descriptor</td>
<td>块的描述信息</td>
</tr>
<tr>
<td>捕获到的外部变量…</td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>isa指针，指向的是Block的类型。Block分为三种类型：_NSConcreteStackBlock，_NSConcreteMallocBlock和_NSConcreteGlobalBlock。其中，_NSConcreteStackBlock分配在占内存上；_NSConcreteMallocBlock分配在堆内存上，有引用计数（即为对象），会捕获外部变量；_NSConcreteGlobalBlock不捕获变量（内部不使用外部变量的Block即为全局Block），内存在编译期即可确定，相当于单例。</li>
<li>其中，<strong>invoke实现函数的参数为Block结构体实例的指针</strong>，使用它<em>可以方便地从内存中读取出捕获到的变量</em>。</li>
<li>捕获到的变量，对于对象，只是拷贝了其指针（对象的引用计数+1）</li>
</ol>
<table>
<thead>
<tr>
<th>descriptor</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>unsigned long int</td>
<td>reserved</td>
<td></td>
</tr>
<tr>
<td>unsigned long int</td>
<td>size</td>
<td></td>
</tr>
<tr>
<td>void (<em>)(void </em>, void *)</td>
<td>copy</td>
<td>拷贝辅助函数</td>
</tr>
<tr>
<td>void (<em>)(void </em>, coid *)</td>
<td>dispose</td>
<td>释放辅助函数</td>
</tr>
</tbody>
</table>
<p>描述结构体中，copy和dispose函数的作用是拷贝和释放Block实例时，对捕获到的变量进行拷贝和释放操作。</p>
<h3 id="第39条：用handler块降低代码分散程度"><a href="#第39条：用handler块降低代码分散程度" class="headerlink" title="第39条：用handler块降低代码分散程度"></a>第39条：用handler块降低代码分散程度</h3><ul>
<li>使用Block代替Delegate，可以使代码分布整体化，降低分散程度。特别是<strong>对于自身实例作为多个不同对象的Delegate时（如多个UITableView实例均使用self作为delegate），由于每个Delegate均存在自己单独的handler回调，省去了对于不同对象判断执行的过程，使代码更加简洁</strong>。</li>
<li>设置带有handler回调的API时，根据需要可以添加执行队列（NSOperation或GCD等）参数。外部调用时，可以根据不同需要灵活配置（如系统添加通知的方法addObserverForName方法）。</li>
</ul>
<h3 id="第41条：多用派发队列，少用同步锁"><a href="#第41条：多用派发队列，少用同步锁" class="headerlink" title="第41条：多用派发队列，少用同步锁"></a>第41条：多用派发队列，少用同步锁</h3><p>我们知道，在iOS端，为了保证性能，类中property的内存语义一般被设置为“nonatomic”。但是极端情况下，为了保证属性的读写为原子操作，需要单独进行处理。一般来说，可以使用synchronized关键字对self进行同步加锁，或者使用NSLock进行锁操作，但是频繁读写时效率会很低。<br>为了保证效率，使用GCD的派发队列进行property的读写操作优化：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TestClass.h</span></div><div class="line">@interface TestClass : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSString *testName;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"><span class="comment">// TestClass.m</span></div><div class="line">@<span class="function">interface <span class="title">TestClass</span> <span class="params">()</span> </span>&#123;</div><div class="line">    NSString *_testName;</div><div class="line">    <span class="keyword">dispatch_queue_t</span> _propertyQueue;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation</div><div class="line">- (instancetype)init &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        <span class="comment">// 创建并发队列</span></div><div class="line">        _propertyQueue = dispatch_queue_create(<span class="string">"com.TestClass.p_queue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div><div class="line">- (NSString *)testName &#123;</div><div class="line">    <span class="comment">// 并发队列读取（使用async是因为需要同步返回函数值，实质上也是并发执行）</span></div><div class="line">    __block NSString *tmpValue;</div><div class="line">    dispatch_sync(_propertyQueue, ^&#123;</div><div class="line">        tmpValue = self-&gt;_testName;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> tmpValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setTestName:(NSString *)testName &#123;</div><div class="line">    <span class="comment">// 使用barrier，可以保证此处为原子操作（其余操作等待完成后才开始执行）</span></div><div class="line">    dispatch_barrier_async(_propertyQueue, ^&#123;</div><div class="line">        self-&gt;_testName = testName;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：</p>
<ul>
<li>使用dispatch_barrier_async或dispatch_barrier_sync方法时，必须保证执行的队列是手动创建的并发队列，不能是串行或者系统的全局队列**。</li>
<li>栅栏方法同步和异步版本的区别是：同步添加Block时，队列会等待Block执行完毕后再返回（继续执行下面的代码）；异步时，则立即返回，可以将后面的任务派发的队列中（但是不会执行），等待栅栏Block执行完毕后，继续执行其他任务。</li>
<li>在property中两种版本均可。但是同步版本的效率更高（异步版本需要拷贝Block）。</li>
</ul>
<p><strong>对于property，getter使用自定义并发队列的async操作，setter使用自定义并发队列的barrier操作。</strong></p>
<h3 id="第42条：多用GCD，少用performSelector系列方法"><a href="#第42条：多用GCD，少用performSelector系列方法" class="headerlink" title="第42条：多用GCD，少用performSelector系列方法"></a>第42条：多用GCD，少用performSelector系列方法</h3><p>除了performSelector系列方法的API局限性以外（不能传多于两个参数、线程相关API参数过少、参数只能为对象类型、不能调用c方法等），最重要的是内存管理方面的缺失。示例如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SEL selector;</div><div class="line"><span class="keyword">if</span> (<span class="comment">/** 条件1 */</span>) &#123;</div><div class="line">    selector = @SEL(newObject);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/** 条件2 */</span>) &#123;</div><div class="line">    selector = @SEL(copy);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    selector = @SEL(someProperty)</div><div class="line">&#125;</div><div class="line"><span class="comment">// object为类实例，包含newObject构造器、copy方法和someProperty属性</span></div><div class="line">id ret = [object performSelector:selector];</div></pre></td></tr></table></figure></p>
<p>在ARC环境下，如果是条件1和2，编译器会将执行后返回对象的内存管理权交给接收者；如果是直接设置属性，则不进行内存管理。由于现在selector的选择是在运行时进行绑定，编译器就无法根据方法签名（名称、参数及返回值类型）使用ARC进行内存管理了（甚至不知道改selector是否存在）。所以，这种写法下，编译器会提示警告，可能会发生内存泄漏。<br>使用Block配合GCD的相关方法可以有效解决这些问题，如参数、线程、内存管理等。</p>
<h3 id="第43条：掌握GCD及操作队列的使用时机"><a href="#第43条：掌握GCD及操作队列的使用时机" class="headerlink" title="第43条：掌握GCD及操作队列的使用时机"></a>第43条：掌握GCD及操作队列的使用时机</h3><ul>
<li>在解决多线程与任务管理的问题时，可以根据需要灵活选用GCD或操作队列（NSOperationQueue）进行处理。</li>
<li>操作队列是Objective-C的API，底层使用GCD进行实现，具备了大多数GCD的功能，其优点如下：<ul>
<li>可以取消尚未执行的任务（NSOperation对象）。</li>
<li>可以对操作的执行状况使用KVO进行监听，如“isCancelled”、“isFinished”等。</li>
<li>可以对单个的操作进行优先级设置（即执行线程的优先级）；GCD只能对并发的派发队列进行优先级设置，颗粒度不够细。</li>
<li>对不同操作之间可以设置依赖关系。通过设置依赖，更容易控制不同任务之间的执行顺序。</li>
<li>可以重用任务对象（NSOperation），系统默认实现了NSBlockOperation子类。由于支持了面向对象，我们可以根据需要对父类进行继承，扩展操作对象的功能。</li>
</ul>
</li>
</ul>
<h3 id="第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务："><a href="#第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务：" class="headerlink" title="第44条：通过Dispatch Group机制，根据系统资源状况来执行任务："></a>第44条：通过Dispatch Group机制，根据系统资源状况来执行任务：</h3><p><strong>在后台自动执行一系列任务，完成后通知主线程</strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对象数组，这里是模拟多个需要执行任务的对象</span></div><div class="line">NSArray *objects = @[...];</div><div class="line"></div><div class="line"><span class="comment">// 后台执行，需要获取并发队列</span></div><div class="line"><span class="keyword">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 一系列任务，可以编写成组</span></div><div class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</div><div class="line"></div><div class="line"><span class="comment">// 自动执行：异步加入组中，不能阻塞执行队列</span></div><div class="line"><span class="keyword">for</span> (id object in objects) &#123;</div><div class="line">    dispatch_group_async(</div><div class="line">        group, </div><div class="line">        globalQueue,</div><div class="line">        ^&#123; [object performTask]; &#125;</div><div class="line">    );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 完成后通知主线程</span></div><div class="line">dispatch_group_notify(</div><div class="line">    group,</div><div class="line">    dispatch_get_main_queue(),</div><div class="line">    ^&#123;</div><div class="line">        <span class="comment">// 主线程执行代码</span></div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>主要是利用了GCD并发队列的强大功能，GCD会根据系统资源占用情况，自动分配CPU核心和不同数量的执行线程去并发执行任务，可以最大限度的优化多线程编程性能。通过dispatch_group_t对象，可以根据需要阻塞（可以使用dispatch_group_wait）执行队列或是监控任务的执行过程。</p>
<h3 id="第46条：不要使用dispatch-get-current-queue"><a href="#第46条：不要使用dispatch-get-current-queue" class="headerlink" title="第46条：不要使用dispatch_get_current_queue"></a>第46条：不要使用dispatch_get_current_queue</h3><blockquote>
<p>首先结论是：<strong>dispatch_get_current_queue对避免代码死锁没有任何作用，因为它返回的只是当前队列的名称，而不是当前执行任务所在的队列！！！</strong></p>
</blockquote>
<p>我们以队列层级的例子一步步进行验证：</p>
<ol>
<li>父队列为串行队列rootQueue；子队列有两个，分别为串行队列serialQueue和并行队列concurrentQueue。我们分别向两个子队列中派发任务，看一下实际的执行情况：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根队列</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">void</span> *rootQueueKey = <span class="string">"com.jiji.rootQueue"</span>;</div><div class="line"><span class="keyword">dispatch_queue_t</span> rootQueue = dispatch_queue_create(rootQueueKey, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line"><span class="comment">// 创建两个队列</span></div><div class="line"><span class="keyword">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.jiji.concurrent1"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="keyword">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.jiji.serial1"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line"><span class="comment">// 设置两个子队列的根队列为rootQueue（串行）</span></div><div class="line">dispatch_set_target_queue(concurrentQueue, rootQueue);</div><div class="line">dispatch_set_target_queue(serialQueue, rootQueue);</div><div class="line"></div><div class="line"><span class="comment">// 配置任务：</span></div><div class="line"><span class="comment">// 并行子队列异步派发两个任务</span></div><div class="line">dispatch_async(concurrentQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task1"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_async(concurrentQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task2"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 串行子队列异步派发两个任务</span></div><div class="line">dispatch_async(serialQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task3"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_async(serialQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task4"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行结果如下：</p>
<blockquote>
<p>TestIos[32776:25904922] task1<br>TestIos[32776:25904922] task2<br>TestIos[32776:25904922] task3<br>TestIos[32776:25904922] task4</p>
</blockquote>
<p>以上情况表明：不管子队列是串行还是并行队列，由于根队列为串行，最终任务的执行情况为串行执行。</p>
<ol>
<li>现在，我的疑问是，由于任务串行执行，是否证明真正执行任务的队列是串行队列（根队列）？带着这个疑问，我们先验证一下：<br>我们修改一下代码，在task1的执行块中，查看一下当前队列：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_async(concurrentQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task1"</span>);</div><div class="line">    NSLog(@<span class="string">"%@"</span>, dispatch_get_current_queue());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>执行结果：</p>
<blockquote>
<p>TestIos[32776:25904922] <os_dispatch_queue: com.jiji.concurrent1=""></os_dispatch_queue:></p>
</blockquote>
<p>看来不是，还是在并发队列这个子队列中。<br>那现在做个假设，如果在此任务中，再向其根队列派发一个同步任务进行验证（如果死锁，证明实际任务运行在根队列中；否则就在当前子队列中）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_async(concurrentQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task1"</span>);</div><div class="line">    NSLog(@<span class="string">"%@"</span>, dispatch_get_current_queue());</div><div class="line">    <span class="comment">// 添加同步任务</span></div><div class="line">    dispatch_sync(rootQueue, ^&#123;</div><div class="line">        NSLog(@<span class="string">"new task!!!"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>结果很显然，发生了死锁，证明实际上此任务是在根队列（target queue）中执行（向serialQueue中派发同步任务也会如此，虽然不会死锁，但线程一直等待，永远不会返回）。</p>
<p><strong>这也就证明了，实际上<em>dispatch_get_current_queue</em>方法并没有返回真正的运行队列</strong>。如果以此API返回值进行判断，则无法保证多线程环境下代码执行的准确性。</p>
<ol>
<li>那若是如此，如何来确保任务执行在正确的队列中？使用<em>dispatch_queue_set_specfic</em>和<em>dispatch_get_specific</em>两个API即可。我们修改一下示例代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根队列</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">void</span> *rootQueueKey = <span class="string">"com.jiji.rootQueue"</span>;</div><div class="line"><span class="keyword">dispatch_queue_t</span> rootQueue = dispatch_queue_create(rootQueueKey, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="comment">// 根队列用指定key进行标记</span></div><div class="line">dispatch_queue_set_specific(rootQueue, rootQueueKey, &amp;rootQueueKey, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建两个队列</span></div><div class="line"><span class="keyword">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.jiji.concurrent1"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="keyword">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.jiji.serial1"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line"><span class="comment">// 设置两个子队列的根队列为rootQueue（串行）</span></div><div class="line">dispatch_set_target_queue(concurrentQueue, rootQueue);</div><div class="line">dispatch_set_target_queue(serialQueue, rootQueue);</div><div class="line"><span class="comment">// 配置任务：</span></div><div class="line">dispatch_async(concurrentQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task1"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 根据key获取队列绑定的值（存在，则当前队列即为key所对应的队列）</span></div><div class="line">    <span class="keyword">void</span> *context = dispatch_get_specific(rootQueueKey);</div><div class="line">    <span class="keyword">if</span> (context) &#123;</div><div class="line">        <span class="comment">// 当前执行在根队列上，不可以向根队列及任何子队列派发同步任务</span></div><div class="line">        NSLog(@<span class="string">"NO!!!!!!"</span>);</div><div class="line">        <span class="comment">// 但是，调用dispatch_get_current_queue()返回的队列，可以让你误以为是在本队列执行，所以可能会向其他队列派发同步任务，继而发生死锁。这也就是绝对不要使用此API的原因。</span></div><div class="line">        NSLog(@<span class="string">"%@"</span>, dispatch_get_current_queue());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 可以派发任意任务</span></div><div class="line">        NSLog(@<span class="string">"OK~"</span>);</div><div class="line">        dispatch_sync(rootQueue, ^&#123;</div><div class="line">            NSLog(@<span class="string">"new task!!!"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如代码所示，<strong>当dispatch_get_specific返回对应的数据时，证明当前运行队列即为检查的目标队列</strong>。如果此时还需要向此队列派发同步任务，只要直接执行任务即可，无需派发。</p>
<ul>
<li>注意：对于实现真正原子操作的property来说，由于实现setter和getter时使用了自定义队列，且setter中使用同步方式返回实例的值。为了防止死锁发生，一定要避免他人使用相同队列对属性进行访问。</li>
</ul>
<h2 id="第7章-系统框架"><a href="#第7章-系统框架" class="headerlink" title="第7章 系统框架"></a>第7章 系统框架</h2><h3 id="第48条：多用块枚举，少用for循环"><a href="#第48条：多用块枚举，少用for循环" class="headerlink" title="第48条：多用块枚举，少用for循环"></a>第48条：多用块枚举，少用for循环</h3><ol>
<li><p>快速枚举（for…in）：</p>
<ul>
<li>比传统for循环更高效，与NSEnumerator一样但语法更简洁。</li>
<li>可以遍历如NSArray、NSDictionary、NSSet及自定义Collection（需遵循NSFastEnumeration协议）。</li>
<li>NSEnumerator由于也遵循NSFastEnumeration协议，所以可以支持用快速枚举对集合进行反向遍历。</li>
<li>缺点是不支持获取对象索引。</li>
</ul>
</li>
<li><p>使用集合带有Block参数的遍历API进行集合遍历：</p>
<ul>
<li>方便获取对象索引及字典键值</li>
<li>可以直接修改Block的参数类型为对象类型，利用编译器特性，省去了进行显示地类型转换</li>
<li>对于可以配置NSEnumerationOptions的版本，可以方便设置如反向遍历、并发遍历（底层使用GCD队列）等功能。</li>
</ul>
</li>
</ol>
<h3 id="第49条：对自定义其内存管理语义的collection使用无缝桥接"><a href="#第49条：对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="第49条：对自定义其内存管理语义的collection使用无缝桥接"></a>第49条：对自定义其内存管理语义的collection使用无缝桥接</h3><ol>
<li><p>主要先说一下OC对象和CF变量指针的转换方式：</p>
<ul>
<li>__bridge: 互相转换均可，不进行内存所有权转换。即转换后仍然使用原系统对对象或变量进行内存管理（OC使用ARC，CF手动使用CFRelease）</li>
<li>__bridge_transfer：一般用于CF-&gt;OC的过程中，转换所有权。转换后的OC对象，系统自动使用ARC对其进行内存管理。</li>
<li>__bridge_retained：一般用于OC-&gt;CF的过程中，转换所有权。转换后的CF变量，其指针的引用计数+1，需要使用CFRelease等函数进行手动内存管理。</li>
</ul>
</li>
<li><p>可以通过CF框架，使用C语言API创建集合对象，之后利用桥接转换为OC对象，即可得到符合自定义内存管理语义的集合对象。</p>
<ul>
<li>如使用NSDictionary时，需要key无需支持NSCopy协议，则可以使用此方法，创建CFDictionaryRef指针（在CFDictionaryRetainCallBack和CFDictionaryReleaseCallBack中进行修改）后，使用__bridge_transfer转换为OC对象并转换所有权。</li>
</ul>
</li>
</ol>
<h3 id="第51条：精简initialize与load的实现代码"><a href="#第51条：精简initialize与load的实现代码" class="headerlink" title="第51条：精简initialize与load的实现代码"></a>第51条：精简initialize与load的实现代码</h3><ol>
<li><strong>+(void)load</strong>:</li>
</ol>
<ul>
<li>运行时系统启动时，加载Class或Category时会调用（只有Class和Category存在此方法，且只执行一次）。</li>
<li>load方法不遵循继承体系，只有对应的Class活Category实现后才会被调用。</li>
<li>系统首先加载所有Class，后加载Category。Class间加载顺序无法确定（不要在Class的load方法中调用其他Class）。</li>
<li>load方法执行时会阻塞程序运行，所以不要执行复杂任务或加锁。<blockquote>
<p>自己只在Category中利用load方法，swizzle过所属Class的方法，在内部实现自定义功能（如记录日志）。</p>
</blockquote>
</li>
</ul>
<ol>
<li><strong>+(void)initialize</strong>:</li>
</ol>
<ul>
<li>被调用时为“懒加载”：运行时系统在首次调用Class时，先调用本方法；不访问不调用。</li>
<li>initialize方法执行时，运行时系统已启动完毕，加载（load）了所有相关类，可以在此调用任意类的任意方法。但是<em>需要注意避免“循环引用”导致的死锁</em>（如ClassA的initialize中调用ClassB，ClassB首次执行，initialize中使用ClassA）。</li>
<li>本方法遵循继承体系，本类未实现时会执行父类的版本。</li>
<li>initialize方法执行时，是“线程安全”的，会阻塞其他类运行，无需加锁。但是，方法无法确定其执行线程，所以仍然不能运行过于复杂的任务（如果是UI线程则会导致APP无响应）。</li>
</ul>
<blockquote>
<p>正确用法举例：</p>
<ol>
<li>在initialize中初始化声明为全局static的OC对象（由于在编译期只能初始化基本数据类型或NSString变量或常量）。</li>
<li>单例类可以用于初始化内部数据。</li>
</ol>
</blockquote>
<h3 id="第52条：别忘了NSTimer会保留其目标对象"><a href="#第52条：别忘了NSTimer会保留其目标对象" class="headerlink" title="第52条：别忘了NSTimer会保留其目标对象"></a>第52条：别忘了NSTimer会保留其目标对象</h3><p>举例来说，以常用的直接在当前runloop中配置计时器“<em>scheduledTimerWithTimeInterval: target: selector: userInfo: repeats:</em>”为例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@interface EOCClass: NSObject &#123;</div><div class="line">    NSTimer *_pollTimer;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)startPolling;</div><div class="line">- (<span class="keyword">void</span>)stopPolling;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClass</div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    [_pollTimer invalidate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)stopPolling &#123;</div><div class="line">    [_pollTimer invalidate];</div><div class="line">    _pollTimer = nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)startPolling &#123;</div><div class="line">    _pollTimer = [NSTimer scheduledTimerWithTimeInterval:<span class="number">5.0</span></div><div class="line">        target:self</div><div class="line">        selector:@selector(p_doPoll)</div><div class="line">        userInfo:nil</div><div class="line">        repeat:YES</div><div class="line">    ];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)p_doPoll &#123;</div><div class="line">    <span class="comment">// ...task</span></div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>以上代码可以很明显地看出，由于_pollTimer的target是self，即NSTimer保留了EOCClass实例，且_pollTimer是EOCClass的实例变量，在ARC下隐含为强引用的内存管理方式，最终导致了引用循环。</p>
<p><strong>解决方法：</strong><br><em>由于类对象本身即为单例，使用类对象作为NSTimer的target即可巧妙“避免”此问题发生。</em></p>
<p>这里使用了NSTimer的Category进行处理，免除使用第三方类或者自定义单例对象：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@interface NSTimer (EOCBlocksSupport)</div><div class="line">+ (NSTimer *)scheduledTimerWithTimerInterval:(NSTimeInterval)interval</div><div class="line">    block:(void (^)())block</div><div class="line">    repeats:(BOOL)repeats;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation NSTimer (EOCBlocksSupport)</div><div class="line"></div><div class="line">+ (NSTimer *)scheduledTimerWithTimerInterval:(NSTimeInterval)interval</div><div class="line">    block:(void (^)())block</div><div class="line">    repeats:(BOOL)repeats &#123;</div><div class="line">    </div><div class="line">    return [self scheduledTimerWithTimerInterval:interval</div><div class="line">        target:self</div><div class="line">        selector:@selector(eoc_blockInvoke:)</div><div class="line">        userInfo:[block copy]</div><div class="line">        repeats:repeats</div><div class="line">    ];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)eoc_blockInvoke:(NSTimer *)timer &#123;</div><div class="line">    // 取出timer中设置的userInfo，并转换为block对象</div><div class="line">    void (^block)() = timer.userInfo;</div><div class="line">    if (block) &#123;</div><div class="line">        // 执行</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>配置定时器时，按如下方式:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)startPolling &#123;</div><div class="line">    <span class="comment">// 声明self的弱引用指针（使Block对象通过弱指针保留对象，引用计数不变）</span></div><div class="line">    __weak EOCClass *weakSelf = self;</div><div class="line">    _pollTimer = [NSTimer scheduledTimerWithTimerInterval:<span class="number">5.0</span></div><div class="line">    block:^&#123;</div><div class="line">        <span class="comment">// 声明强指针指向weakSelf，可防止使用时对象被释放</span></div><div class="line">        __strong EOCClass *strongSelf = weakSelf;</div><div class="line">        [strongSelf p_doPoll];</div><div class="line">    &#125;</div><div class="line">    repeats:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上所示，</p>
<ul>
<li>此时只有EOCClass的实例保留了定时器，定时器对象并不会保留self。完成使用后，self即可被正常释放，同时定时器被取消。</li>
<li>使用<strong>weak指针还可以保证更加安全（相比</strong>unsafe_unretain），因为self实例释放后，若是忘记取消定时器，对weak指针发消息是安全的。</li>
</ul>
<blockquote>
<p><em>注意</em>：NSTimer类在iOS10中新增了带有Block参数的API，不过使用时依然要注意循环引用的问题。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第1章：熟悉Objective-C&quot;&gt;&lt;a href=&quot;#第1章：熟悉Objective-C&quot; class=&quot;headerlink&quot; title=&quot;第1章：熟悉Objective-C&quot;&gt;&lt;/a&gt;第1章：熟悉Objective-C&lt;/h2&gt;&lt;h3 id=&quot;第4条：多用类型常量，少用-define预处理指令&quot;&gt;&lt;a href=&quot;#第4条：多用类型常量，少用-define预处理指令&quot; class=&quot;headerlink&quot; title=&quot;第4条：多用类型常量，少用#define预处理指令&quot;&gt;&lt;/a&gt;第4条：多用类型常量，少用#define预处理指令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;声明类型常量好处是，编译器可以知道此变量的类型，且可以防止外部随意修改&lt;/li&gt;
&lt;li&gt;声明规则：
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>mpvue开发微信小程序的准备工作</title>
    <link href="http://yoursite.com/2018/09/29/mpvue%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/09/29/mpvue开发微信小程序的准备工作/</id>
    <published>2018-09-29T09:50:05.106Z</published>
    <updated>2018-09-29T10:02:39.270Z</updated>
    
    <content type="html"><![CDATA[<p>使用Vue.js都可以开发小程序了，喜大普奔啊~</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">方式</th>
<th style="text-align:center">补充</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">新建工程</td>
<td style="text-align:center">官方模板工程</td>
<td style="text-align:center">1. vue init mpvue/mpvue-quickstart myProject 2. cd myProject 3. npm install 4. npm run dev</td>
</tr>
<tr>
<td style="text-align:center">网络请求</td>
<td style="text-align:center">fly.js或自己封装请求方法</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">数据缓存</td>
<td style="text-align:center">vuex</td>
<td style="text-align:center">模板工程中带有配置选项</td>
</tr>
<tr>
<td style="text-align:center">本地存储</td>
<td style="text-align:center">wx.localStorage</td>
<td style="text-align:center">小程序的自带存储模块</td>
</tr>
<tr>
<td style="text-align:center">路由</td>
<td style="text-align:center">mpvue-router-patch</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">第三方UI组件</td>
<td style="text-align:center">MinUI、iView WeApp、WeUI WXSS、ZanUI WeApp、Wux WeApp</td>
<td style="text-align:center">1. 将使用的组件文件拷贝到mpvue工程的static路径下  2. 在需要使用的page文件夹下，新建“main.json”文件，内部的对象中引入：<img src="http://p8r3sk4om.bkt.clouddn.com/mpvue1" alt="img">  3.在vue文件中的template中即可直接使用</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Vue.js都可以开发小程序了，喜大普奔啊~&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>NSInvocation的莫名crash</title>
    <link href="http://yoursite.com/2018/09/29/NSInvocation%E7%9A%84%E8%8E%AB%E5%90%8Dcrash/"/>
    <id>http://yoursite.com/2018/09/29/NSInvocation的莫名crash/</id>
    <published>2018-09-29T09:06:39.676Z</published>
    <updated>2018-09-29T09:45:08.620Z</updated>
    
    <content type="html"><![CDATA[<h4 id="NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数："><a href="#NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数：" class="headerlink" title="NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数："></a>NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数：</h4><a id="more"></a>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface NSObject (PerformSelector)</div><div class="line"></div><div class="line">- (id)performSelector:(SEL)aSelector</div><div class="line">        withArguments:(NSArray *)arguments;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#import "NSObject+PerformSelector.h"</div><div class="line"></div><div class="line">@implementation NSObject (PerformSelector)</div><div class="line"></div><div class="line">- (id)performSelector:(SEL)aSelector</div><div class="line">        withArguments:(NSArray *)arguments &#123;</div><div class="line">    if (!aSelector) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    NSMethodSignature *signature = [[self class] instanceMethodSignatureForSelector:aSelector];</div><div class="line">    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];</div><div class="line">    invocation.target = self;</div><div class="line">    invocation.selector = aSelector;</div><div class="line">    </div><div class="line">    if ([arguments isKindOfClass:[NSArray class]]) &#123;</div><div class="line">        // 减2是因为signature的参数包含固定的self和_cmd</div><div class="line">        NSInteger count = MIN(arguments.count, signature.numberOfArguments - 2);</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            // 返回指定index的参数类型</div><div class="line">            const char *type = [signature getArgumentTypeAtIndex:(i + 2)];</div><div class="line">            // 类型是OC对象（本函数的参数为NSArray，所以都是对象）</div><div class="line">            if (strcmp(type, "@") == 0) &#123;</div><div class="line">                // 取出参数</div><div class="line">                id argument = arguments[i];</div><div class="line">                // 设置参数（copy到invocation上）</div><div class="line">                // 【同样，invocation的参数列表中前两个也是self和_cmd】</div><div class="line">                [invocation setArgument:&amp;argument atIndex:(i + 2)];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 调用函数（此时会动态配置返回值）</div><div class="line">    [invocation invoke];</div><div class="line">    </div><div class="line">    // 取回返回值    </div><div class="line">    id returnValue = @1;</div><div class="line">    if (strcmp(signature.methodReturnType, "@") == 0) &#123;</div><div class="line">        // 返回值是OC对象，取回赋值到指针（这里是给野指针赋值，使其存在内容）</div><div class="line">        [invocation getReturnValue:&amp;returnValue];</div><div class="line">    &#125;</div><div class="line">    return returnValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>示例类如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line">@interface TestClass : NSObject</div><div class="line"></div><div class="line">- (NSString *)saySomething:(NSString *)a</div><div class="line">                         b:(NSString *)b</div><div class="line">                         c:(NSString *)c;</div><div class="line">@end</div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"TestClass.h"</span></span></div><div class="line"></div><div class="line">@implementation TestClass</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSDictionary *)saySomething:(NSString *)a</div><div class="line">                             b:(NSString *)b</div><div class="line">                             c:(NSString *)c &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;</div><div class="line">             @<span class="string">"a"</span>: a,</div><div class="line">             @<span class="string">"b"</span>: b,</div><div class="line">             @<span class="string">"c"</span>: c</div><div class="line">             &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>调用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TestClass *tc = [[TestClass alloc] init];</div><div class="line">        result = [tc performSelector:@selector(saySomething:b:c:) withArguments:@[@<span class="string">"Tom"</span>, @<span class="string">"Jim"</span>, @<span class="string">"Li Lei"</span>]];</div><div class="line">        NSLog(@<span class="string">"result = %@"</span>, result);</div></pre></td></tr></table></figure>
<p>以上，解决了使用performSelector调用时只能传递单个参数的尴尬问题。但是，问题来了~~</p>
<p>运行时，会发生crash。try-catch也无法捕获异常，觉得颇为诡异。之后，再打开zombie检测后，发现如下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2018-09-29 17:15:18.926491+0800 InvocationTest1[37029:49376429] *** -[__NSDictionaryI release]: message sent to deallocated instance 0x60000086aec0</div></pre></td></tr></table></figure>
<p>原来是返回值被过渡释放导致。</p>
<p>究其原因，可以在NSInvocation的类文档中查到，主要就一句：</p>
<blockquote>
<p>This class does not retain the arguments for the contained invocation by default. </p>
</blockquote>
<p>即为，本类默认不对参数进行保留操作。</p>
<p>实质上，不仅如此，通过调用<em>getReturnValue:</em>方法并查阅说明可以知道，此方法只是根据给定的指针，创建buffer并将返回值写入其中。并未对其进行内存管理。</p>
<p>现在回到代码。由于performSelector函数中，只是使用了临时变量指向并返回，导致NSInvocation的返回值对象的引用计数实际上是0，即创建完就要被释放。所以，当performSelector函数执行完成后，实际上返回值已经被释放。由于外侧调用者也没有对其进行保留等其他操作，导致调用者的作用域结束后，返回值会再次收到release操作，即发生crash。</p>
<p>那么，如何解决此问题呢？<br>两种方式：</p>
<ol>
<li><strong>在调用NSInvocation对象的<em>getReturnValue:</em>方法时，不要传入OC对象指针，使用C指针（void *），并在最终桥接转换为OC对象。</strong>这种是本人比较推荐的方式，由于此实质上是往buffer内写入内容，使用C指针会更加严谨，而且避免了ARC内存释放导致的crash，返回时桥接转换为对象即可（这种情况也兼容所有数据类型）。</li>
</ol>
<p>将performSelector的代码修正为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *returnValue = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(signature.methodReturnType, <span class="string">"@"</span>) == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// 返回值是OC对象，取回赋值到指针（这里是给野指针赋值，使其存在内容）</span></div><div class="line">    [invocation getReturnValue:&amp;returnValue];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> (__bridge id)returnValue;</div></pre></td></tr></table></figure>
<ol>
<li><strong>使用__unsafe_unretained修饰OC指针，避免ARC对返回值进行内存管理。</strong>使用__weak同样可以达到效果，不过感觉上有点懵，需要继续深入查看内存管理相关的内容了。。。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">id __unsafe_unretained returnValue = @<span class="number">1</span>;</div><div class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(signature.methodReturnType, <span class="string">"@"</span>) == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// 返回值是OC对象，取回赋值到指针（这里是给野指针赋值，使其存在内容）</span></div><div class="line">    [invocation getReturnValue:&amp;returnValue];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> returnValue;</div></pre></td></tr></table></figure>
<p>问题解决。。。</p>
<p>测试程序代码：<a href="https://github.com/Choujiji/NSInvocationTest" target="_blank" rel="external">测试NSInvocation调用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数：&quot;&gt;&lt;a href=&quot;#NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数：&quot; class=&quot;headerlink&quot; title=&quot;NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数：&quot;&gt;&lt;/a&gt;NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数：&lt;/h4&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中“严谨”的单例模式</title>
    <link href="http://yoursite.com/2018/09/07/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/07/单例模式/</id>
    <published>2018-09-07T07:34:18.943Z</published>
    <updated>2018-09-07T08:01:57.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>由于OC中的方法天生就是public的（就算只写到.m中，在运行时也可以调用到。。。），平时使用的单例方法也未必严谨，所以，看了书，受教了~（还好一般老老实实使用类方法创建单例的无所谓）。</p>
</blockquote>
<h4 id="实现一个“严谨”的单例类"><a href="#实现一个“严谨”的单例类" class="headerlink" title="实现一个“严谨”的单例类"></a>实现一个“严谨”的单例类</h4><p>一般来说，提供一个类方法入口，使用dispatch_once_t保护，使用静态类变量保存，即可成功一个创建线程安全的单例对象。</p>
<p>但是，当调用者在不知情的情况下，调用传统的二段式创建、new或者allocWithZone方法分配内存，甚至是调用copy或multableCopy方法时，都可以创建新的实例对象。所以，为了避免，就需要我们对这些方法依次堵住，重写时，直接在方法内部调用单例方法即可。并且，单例方法的实例化对象时，使用[[super allocWithZone:nil] init]来替代默认（自身的方法已经被重写了）。即可得到“严谨”的单例类。</p>
<h4 id="关于单例类的继承"><a href="#关于单例类的继承" class="headerlink" title="关于单例类的继承"></a>关于单例类的继承</h4><p>平时都不这么用啊。。。确实是。。。不过既然书中提到了，也查阅了一下，说一说哇。。。（当前的示例代码中无法实现此功能）</p>
<p>书中说，使用NSAllocateObject()函数手动分配内存，可以实现子类创建自己的单例对象，但是由于现在是ARC环境，此函数早已不可用，需要对单例类单独“-fno-objc-arc”来开后门才行。另一篇博文<a href="https://www.jianshu.com/p/e1a3a5525452" target="_blank" rel="external">IOS单例模式下多线程和继承写法总结</a>里面，也有讨论过，通过查找源码的方式（alloc -&gt; allocWithZone: -&gt; class_createInstance() 的过程），直接使用runtime中的创建实例方法也能达到同样的效果（前提也是MRC环境下），d=====(￣▽￣*)b厉害。</p>
<p>所以，平时不这么用。。。</p>
<blockquote>
<p>示例代码地址：<a href="https://github.com/Choujiji/DesignPatterns_Learning/tree/master/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/%E5%8D%95%E4%BE%8B" target="_blank" rel="external">Singleton</a></p>
</blockquote>
<h4 id="其他资料："><a href="#其他资料：" class="headerlink" title="其他资料："></a>其他资料：</h4><ul>
<li><a href="https://www.jianshu.com/p/d2d33f519764?utm_source=desktop&amp;utm_medium=timeline" target="_blank" rel="external">iOS中的单例模式</a></li>
<li><a href="https://www.jianshu.com/p/a92c0283f243" target="_blank" rel="external">iOS 单例模式</a></li>
<li><a href="https://www.jianshu.com/p/e1a3a5525452" target="_blank" rel="external">IOS单例模式下多线程和继承写法总结</a></li>
<li><a href="http://justinyan.me/post/1306" target="_blank" rel="external">从 Objective-C 里的 Alloc 和 AllocWithZone 谈起</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于OC中的方法天生就是public的（就算只写到.m中，在运行时也可以调用到。。。），平时使用的单例方法也未必严谨，所以，看了书，受教了~（还好一般老老实实使用类方法创建单例的无所谓）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;实现一
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>生成器模式</title>
    <link href="http://yoursite.com/2018/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/05/设计模式之建造者模式/</id>
    <published>2018-09-05T04:03:27.472Z</published>
    <updated>2018-09-06T05:07:49.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图示："><a href="#图示：" class="headerlink" title="图示："></a>图示：</h3><p>以下分别是类图与时序图<br><img src="http://p8r3sk4om.bkt.clouddn.com/374636-20170808225735589-1433194842.jpg" alt="img"><br><img src="http://p8r3sk4om.bkt.clouddn.com/20170503144820580.png" alt="img"><br><a id="more"></a></p>
<h3 id="先举个例子，个人看来，生成器模式的“Client-Director-Builder”相当于小的软件开发公司的“老板-产品经理-程序员”的模式。"><a href="#先举个例子，个人看来，生成器模式的“Client-Director-Builder”相当于小的软件开发公司的“老板-产品经理-程序员”的模式。" class="headerlink" title="先举个例子，个人看来，生成器模式的“Client - Director - Builder”相当于小的软件开发公司的“老板 - 产品经理 - 程序员”的模式。"></a>先举个例子，个人看来，生成器模式的<em>“Client - Director - Builder”</em>相当于小的软件开发公司的<em>“老板 - 产品经理 - 程序员”</em>的模式。</h3><ul>
<li>老板（<em>Client</em>）：</li>
</ul>
<ol>
<li>决定了公司员工的生死去留（管理其他二者角色的生命周期，负责创建、保留和释放）</li>
<li>提需求，公司要做什么项目（调用Director并传递产品需求）</li>
<li>验收项目（获取产品）</li>
</ol>
<ul>
<li>产品经理（<em>Director</em>）：</li>
</ul>
<ol>
<li>知道要做什么项目，依照自定顺序分解成开发模块（从Client获取到产品需求并分解）</li>
<li>管理着程序员（Director中包含Builder成员）</li>
<li>命令程序员按照模块进行开发（按照顺序调用builder的建造方法进行产品生产）</li>
</ol>
<ul>
<li>程序员（<em>Builder</em>）:</li>
</ul>
<ol>
<li>新建工程（初始化产品对象）</li>
<li>按照需求开发编码（根据Director的调用执行各种生产函数，给产品赋值）</li>
<li>开发完毕后提交程序（根据外部调用返回创建完成的产品对象）</li>
</ol>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><p>使用获取并生产电脑作为示例。稍作解释：<br>Computer类为Product；ComputerMaker为抽象Builder，AppleComputerMaker和LenovoComputerMaker为实体Builder；ComputerSeller为Director。</p>
<blockquote>
<p>代码地址：<a href="https://github.com/Choujiji/DesignPatterns_Learning/tree/master/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">ComputerMaker</a></p>
</blockquote>
<h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><ul>
<li>优点：</li>
</ul>
<ol>
<li><em>拆分模块，解耦合</em>：</li>
</ol>
<blockquote>
<ol>
<li>把创建复杂对象的过程拆分为多个子过程，且由Builder模块独立负责；</li>
<li>Director只负责创建顺序等业务逻辑，并调用Builder进行生产，稳定性好；</li>
<li>Client只负责将制定Builder提供给Director，并向Director提出生产要求并获取产品，隐藏了整个生产过程。</li>
</ol>
</blockquote>
<ol>
<li><em>易扩展</em>：</li>
</ol>
<blockquote>
<p>Builder的抽象父类（或协议）制定所有的子过程，并对外提供获取产品接口，子类Builder实现生产过程。所以，添加新产品时，只要子类化Builder并覆盖创建自己的生产过程即可。Director无需修改。</p>
</blockquote>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li><em>使用场景少</em>：</li>
</ol>
<blockquote>
<ol>
<li>所有的Builder都是由统一的抽象Builder类继承而来，只能生产一种类型产品，不同产品之间的差异少。</li>
<li>生产的产品结构复杂，否则没必要引入此模式。</li>
</ol>
</blockquote>
<ol>
<li><em>类结构容易庞大</em>：</li>
</ol>
<blockquote>
<p>生产多个产品时，需要创建多个Builder类，类个数易变多。</p>
</blockquote>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><a href="https://www.cnblogs.com/xcsn/p/7309761.html" target="_blank" rel="external">Head First设计模式之生成器模式</a></li>
<li><a href="https://blog.csdn.net/free1985/article/details/71123618#commentBox" target="_blank" rel="external">设计模式讲解与代码实践（二）——生成器</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;图示：&quot;&gt;&lt;a href=&quot;#图示：&quot; class=&quot;headerlink&quot; title=&quot;图示：&quot;&gt;&lt;/a&gt;图示：&lt;/h3&gt;&lt;p&gt;以下分别是类图与时序图&lt;br&gt;&lt;img src=&quot;http://p8r3sk4om.bkt.clouddn.com/374636-20170808225735589-1433194842.jpg&quot; alt=&quot;img&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://p8r3sk4om.bkt.clouddn.com/20170503144820580.png&quot; alt=&quot;img&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>这只是测试，新的小家（其实是tag）</title>
    <link href="http://yoursite.com/2018/05/15/%E6%B5%8B%E8%AF%95%E4%BA%8C%E4%B8%8B/"/>
    <id>http://yoursite.com/2018/05/15/测试二下/</id>
    <published>2018-05-15T02:24:06.602Z</published>
    <updated>2018-05-15T02:24:06.602Z</updated>
    
    <summary type="html">
    
      真的，里面没有内容
    
    </summary>
    
    
      <category term="react-native" scheme="http://yoursite.com/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>使用代码初始化StoryBoard中的ViewController</title>
    <link href="http://yoursite.com/2018/05/15/%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%9D%E5%A7%8B%E5%8C%96StoryBoard%E4%B8%AD%E7%9A%84ViewController/"/>
    <id>http://yoursite.com/2018/05/15/使用代码初始化StoryBoard中的ViewController/</id>
    <published>2018-05-15T01:49:33.088Z</published>
    <updated>2018-05-15T03:49:55.025Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取StoryBoard对象（这里使用的是默认的主bundle中的文件）</span></div><div class="line">UIStoryboard *storyBoard = [UIStoryboard storyboardWithName:@<span class="string">"Main"</span> bundle:nil];</div><div class="line"><span class="comment">// 使用ID在StoryBoard对象中获取并初始化新的ViewController</span></div><div class="line">BasicKVO_ViewController *vc1 = [storyBoard instantiateViewControllerWithIdentifier:@<span class="string">"BasicKVO_VC"</span>];</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>代码如上面所示，其中，BasicKVO_VC是在StoryBoard文件中对应的UIViewController的“Identity inspector”面板中的“Storyboard ID”。</p>
<p><img src="http://p8r3sk4om.bkt.clouddn.com/blog-image1.png" alt="image"></p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><a href="https://blog.csdn.net/u012449749/article/details/50495202" target="_blank" rel="external">代码获取Storyboard中的ViewController</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 获取StoryBoard对象（这里使用的是默认的主bundle中的文件）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;UIStoryboard *storyBoard = [UIStoryboard storyboardWithName:@&lt;span class=&quot;string&quot;&gt;&quot;Main&quot;&lt;/span&gt; bundle:nil];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用ID在StoryBoard对象中获取并初始化新的ViewController&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;BasicKVO_ViewController *vc1 = [storyBoard instantiateViewControllerWithIdentifier:@&lt;span class=&quot;string&quot;&gt;&quot;BasicKVO_VC&quot;&lt;/span&gt;];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>KVC基础学习总结</title>
    <link href="http://yoursite.com/2018/04/04/KVC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/04/KVC基础学习总结/</id>
    <published>2018-04-04T06:16:30.000Z</published>
    <updated>2018-05-15T02:18:54.524Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li><strong>对象属性值的设置和获取</strong></li>
<li><strong>访问集合属性值的专用API</strong></li>
<li><strong>使用集合操作符</strong></li>
<li><strong>描述非对象的值（基本数据类型和结构体等）</strong></li>
<li><strong>属性类型验证</strong></li>
<li><strong>访问器的搜索方式</strong></li>
</ul>
</blockquote>
<a id="more"></a>
<h3 id="对象属性值的设置和获取"><a href="#对象属性值的设置和获取" class="headerlink" title="对象属性值的设置和获取"></a>对象属性值的设置和获取</h3><ol>
<li><p>KVC的通用API<br> setValueForKey(Path):<br> valueForKey(Path):</p>
</li>
<li><p>一次设置、获取多个属性值<br> setValueForKeysWithDictionary: 对内部的每一个属性均发送setValueForKey消息<br> dictionaryWithValueForKeys:    根据keys数组返回字典</p>
</li>
</ol>
<h3 id="访问集合属性值的专用API"><a href="#访问集合属性值的专用API" class="headerlink" title="访问集合属性值的专用API"></a>访问集合属性值的专用API</h3><table>
<thead>
<tr>
<th style="text-align:center">通过key访问集合</th>
<th style="text-align:center">通过keyPath访问集合</th>
<th style="text-align:center">被代理的类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mutableArrayValueForKey:</td>
<td style="text-align:center">mutableArrayValueForKeyPath:</td>
<td style="text-align:center">NSMutableArray</td>
</tr>
<tr>
<td style="text-align:center">mutableSetValueForKey:</td>
<td style="text-align:center">mutableSetValueForKeyPath:</td>
<td style="text-align:center">NSMutableSet</td>
</tr>
<tr>
<td style="text-align:center">mutableOrderedSetValueForKey:</td>
<td style="text-align:center">mutableOrderedSetValueForKeyPath:</td>
<td style="text-align:center">NSMutableOrderedSet</td>
</tr>
</tbody>
</table>
<p>访问集合属性的值时除了可以直接使用基本valueForKey(Path):方法，还可以使用上述三类专用API进行访问。当你对集合属性进行修改（增、删、改）时，上表的三类方法可以更高效的完成任务，他们分别返回一个类似NSMutableArray、NSMutableSet和NSMutableOrderedSet的代理类的对象，可以在此对象上直接调用任何相关类的api来直接操作属性值。</p>
<p>使用此类api管理集合属性的高效体现在：</p>
<ol>
<li>比类型为不可变集合类型属性，通过valueForKey:取值，转换并修改后，再通过setValueForKey:保存回去效率高</li>
<li>比直接将集合属性类型设置成mutable类修改高效</li>
<li>对KVO有效</li>
</ol>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ------------返回一个可变对象的代理类（这里是仿可变数组类型，可以调用所有NSMutableArray的api）</span></div><div class="line">id mutableTransactions = [account mutableArrayValueForKey:@<span class="string">"transactions"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, mutableTransactions);</div><div class="line"><span class="comment">// 对返回的代理类对象进行操作（添加、删除、修改等），会直接在原属性上进行操作。</span></div><div class="line"><span class="comment">// 这比直接通过valueForKey获取集合对象后，修改，再setValueForKey存储回去效率高；也比直接维护一个可变集合属性效率高。</span></div><div class="line"><span class="comment">// 且这种方法对KVO有帮助（直接操作修改集合属性不会触发KVO）</span></div><div class="line">Transaction *targetTransaction = mutableTransactions[<span class="number">0</span>];</div><div class="line">targetTransaction.work = @<span class="string">"hhhhaaaa"</span>;</div><div class="line"><span class="comment">// 再次取出</span></div><div class="line">transactions = [account valueForKeyPath:@<span class="string">"transactions"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, transactions);</div></pre></td></tr></table></figure>
<h3 id="使用集合操作符"><a href="#使用集合操作符" class="headerlink" title="使用集合操作符"></a>使用集合操作符</h3><p>在使用valueForKeyPath:访问集合属性时，可以在keyPath中使用集合操作符来直接操作返回的值。集合操作符使用“@”字符标识，使用集合操作符的keyPath结构如下：</p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/art/keypath.jpg" alt="img"></p>
<p>如图可知：keyPath分为<em>左keyPath、集合操作符、右keyPath</em>三部分。</p>
<p>集合操作符主要分为三类：</p>
<ul>
<li><strong>聚合操作符</strong>：对集合对象进行操作，返回匹配条件的单一对象作为结果（@count除外，它没有右keyPath，且返回一个NSNumber对象）。</li>
</ul>
<p>主要包括：@sum、@max、@min、@avg、@count等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 聚合操作符（操作集合属性，返回单个对象）</span></div><div class="line"><span class="comment">// @count</span></div><div class="line">NSNumber *count = [account valueForKeyPath:@<span class="string">"transactions.@count"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, count); <span class="comment">// @count，省略右keypath</span></div><div class="line"><span class="comment">// @max</span></div><div class="line">NSNumber *maxMoney = [account valueForKeyPath:@<span class="string">"transactions.@max.money"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, maxMoney);</div><div class="line"><span class="comment">// @min</span></div><div class="line">NSNumber *minMoney = [account.transactions valueForKeyPath:@<span class="string">"@min.money"</span>];  <span class="comment">// 直接对集合属性取值，可省略左keypath</span></div><div class="line">NSLog(@<span class="string">"%@"</span>, minMoney);</div><div class="line"><span class="comment">// @sum</span></div><div class="line">NSNumber *sumMoney = [account valueForKeyPath:@<span class="string">"transactions.@sum.money"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, sumMoney);</div></pre></td></tr></table></figure>
<ul>
<li><strong>数组操作符</strong>：对集合对象进行操作，通过对右keyPath指定的值进行操作，返回特定条件的集合对象。</li>
</ul>
<p>主要包括@unionOfObjects和@distinctUnionOfObjects，二者区别是：前者直接返回指定属性的值的数组，不过滤重复的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组操作符（操作集合属性，返回集合对象）</span></div><div class="line"><span class="comment">// @unionOfObjects 指定对象的集合</span></div><div class="line">id unionOfWorks = [account.transactions valueForKeyPath:@<span class="string">"@unionOfObjects.work"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, unionOfWorks);</div><div class="line"><span class="comment">// @distinctUnionOfObjects 指定对象的不重复集合</span></div><div class="line">id distinctUnionOfWorks = [account.transactions valueForKeyPath:@<span class="string">"@distinctUnionOfObjects.work"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, distinctUnionOfWorks);</div></pre></td></tr></table></figure>
<ul>
<li><strong>嵌套操作符</strong>：对于包含属性对象的集合所组成的集合（如数组内部包含的所有元素都是数组，这些子数组内部都是属性对象），嵌套操作符通过对右keyPath指定的值进行操作，返回特定条件的集合对象。</li>
</ul>
<p>包括@unionOfArrays、@distinctUnionOfArrays和@distinctUnionOfSets，前两者对嵌套数组进行操作、第三个对集合（NSSet）进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 嵌套操作符（操作包括集合属性对象的嵌套对象，返回集合对象）</span></div><div class="line">Transaction *moreWork1 = [[Transaction alloc] init];</div><div class="line">moreWork1.work = @<span class="string">"收入10000"</span>;</div><div class="line">moreWork1.payee = @[@<span class="string">"臭吉吉2"</span>, @<span class="string">"jiji2"</span>];</div><div class="line">moreWork1.money = <span class="number">10000</span>;</div><div class="line">Transaction *moreWork2 = [[Transaction alloc] init];</div><div class="line">moreWork2.work = @<span class="string">"支出2002"</span>;</div><div class="line">moreWork2.payee = @[@<span class="string">"赵吉222"</span>];</div><div class="line">moreWork2.money = <span class="number">2002</span>;</div><div class="line">NSArray *nestedTransactions = @[account.transactions, @[moreWork1, moreWork2]]; <span class="comment">// 所有的最小子元素都是transaction对象</span></div><div class="line"><span class="comment">// 注意：@unionOfArrays和@distinctUnionOfArrays的数据源，必须是数组嵌套成的数组，不能是元素与数组组合成的数据源数组。，如下面就不可以</span></div><div class="line"><span class="comment">//    NSArray *nestedTransactions = @[account.transactions, @[moreWork1, moreWork2], moreWork3];</span></div><div class="line"></div><div class="line"><span class="comment">// @unionOfArrays</span></div><div class="line">id unionOfWorksArray = [nestedTransactions valueForKeyPath:@<span class="string">"@unionOfArrays.work"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, unionOfWorksArray);</div><div class="line"><span class="comment">// @distinctUnionOfArrays</span></div><div class="line">id distinctUnionOfWorksArray = [nestedTransactions valueForKeyPath:@<span class="string">"@distinctUnionOfArrays.work"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, distinctUnionOfWorksArray);</div><div class="line"><span class="comment">// @distinctUnionOfSets</span></div><div class="line">NSSet *nestedTransactionsSet = [NSSet setWithObjects:</div><div class="line">    [NSSet setWithArray:account.transactions],</div><div class="line">    [NSSet setWithObjects:moreWork1, moreWork2, nil],</div><div class="line">    nil</div><div class="line">]; <span class="comment">// 所有的最小子元素都是transaction对象，整体及子集合必须都是set</span></div><div class="line">id distinctUnionOfWorksSet = [nestedTransactionsSet valueForKeyPath:@<span class="string">"@distinctUnionOfSets.work"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, distinctUnionOfWorksSet);</div></pre></td></tr></table></figure>
<h3 id="描述非对象的值（基本数据类型和结构体等）"><a href="#描述非对象的值（基本数据类型和结构体等）" class="headerlink" title="描述非对象的值（基本数据类型和结构体等）"></a>描述非对象的值（基本数据类型和结构体等）</h3><ol>
<li>对于基本数据类型的值，使用KVC进行设置和获取时需要将值进行对NSNumber类的封包和解包。</li>
<li>对于内置的结构体，如NSPoint、NSRange、NSRect和NSSize，需要使用NSValue类对数据进行封包和解包。</li>
<li>对于自定义的结构体，使用NSValue的通用api对数据进行封包和解包。</li>
</ol>
<p>对于自定义结构体的KVC，举例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    float x;</div><div class="line">    float y;</div><div class="line">    float z;</div><div class="line">&#125; ThreeFloats;</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic) ThreeFloats threeFloats;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    // ------自定义的非对象数据KVC测试（自定义结构体转NSValue）</div><div class="line">    // 创建结构体数据</div><div class="line">    ThreeFloats floats = &#123;</div><div class="line">        1., 2., 3.</div><div class="line">    &#125;;</div><div class="line">    // 转化为NSValue</div><div class="line">    NSValue *customStructValue = [NSValue valueWithBytes:&amp;floats objCType:@encode(ThreeFloats)];</div><div class="line">    // KVC保存</div><div class="line">    [self setValue:customStructValue forKey:@"threeFloats"];</div><div class="line">    // 读取值</div><div class="line">    NSValue *propertyValue = [self valueForKey:@"threeFloats"];</div><div class="line">    // 转回结构体值</div><div class="line">    ThreeFloats resultFloats;</div><div class="line">    [propertyValue getValue:&amp;resultFloats size:sizeof(ThreeFloats)];</div><div class="line">    NSLog(@"%f, %f, %f", resultFloats.x, resultFloats.y, resultFloats.z);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="属性类型验证"><a href="#属性类型验证" class="headerlink" title="属性类型验证"></a>属性类型验证</h3><p>KVC协议定义了一些方法用于验证属性。除了使用key或keyPath进行设置和获取值以外，还可以使用它们进行属性验证。当调用validateValue:forKey:error（或者validateValue:forKeyPath:error）方法时，协议方法的默认实现是去查找是否对key存在validate[key]:error:方法。如果没有实现此方法，则验证方法默认通过，返回YES；如果你实现了这个key的方法，则会根据此方法的验证结果来返回原验证结果。</p>
<p>你实现的validate[key]:error:方法根据key的值和error的指针，有三种验证实现方案：</p>
<ol>
<li>判定传入的值符合要求，直接返回YES，且不修改值和错误对象。</li>
<li>判定传入的值不符合，且不对此值进行类型修正（如类型转换等）。这种情况下，方法返回NO，并且对用户传入的错误指针（如果传入了）进行赋值，包含其中的错误信息。</li>
<li>判定传入的值不符合，但是创建个符合要求的新值进行替换。这种情况下，方法返回YES，且把传入的值的指针指向此新值（一定不要直接修改传入的值，就算是个mutable类对象也不行），并且不用处理错误信息。</li>
</ol>
<p>举例来说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line">@interface Transaction : NSObject</div><div class="line"></div><div class="line"><span class="comment">/** 工作内容类型（这里用于验证属性） */</span></div><div class="line">@property (copy, nonatomic) NSString *work;</div><div class="line"></div><div class="line"><span class="comment">/** 收款人数组 一对多 */</span></div><div class="line">@property (nonatomic) NSArray&lt;NSString *&gt; *payee;</div><div class="line"><span class="comment">/** 钱数 */</span></div><div class="line">@property (nonatomic) NSInteger money;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"Transaction.h"</span></span></div><div class="line"></div><div class="line">@implementation Transaction</div><div class="line"></div><div class="line">- (BOOL)validateWork:(id * _Nullable)workValue error:(out NSError * _Nullable *)error &#123;</div><div class="line">    <span class="keyword">if</span> (![*workValue isKindOfClass:[NSString class]]) &#123;</div><div class="line"><span class="comment">//        // 不修改，直接返回错误</span></div><div class="line"><span class="comment">//        if (error) &#123;</span></div><div class="line"><span class="comment">//            *error = [NSError errorWithDomain:@"validate error" code:9999 userInfo:@&#123;@"reason": @"invalid type"&#125;];</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line"><span class="comment">//        return NO;</span></div><div class="line">        <span class="comment">// 将值修改为符合要求的值</span></div><div class="line">        *workValue = [NSString stringWithFormat:@<span class="string">"%@"</span>, *workValue];</div><div class="line">        <span class="keyword">return</span> YES;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"><span class="comment">/** 外部调用 */</span></div><div class="line"></div><div class="line"><span class="comment">// -----------测试属性验证</span></div><div class="line"><span class="comment">// 对应类中如果没有自己实现validate&lt;Key&gt;:error:方法，则验证无效，都返回YES</span></div><div class="line"><span class="comment">// validate&lt;Key&gt;:error:方法中可以对数据进行合法性判断，返回错误；或将不合法数据转化为合法数据（创建个新数据），返回成功。</span></div><div class="line">NSError *error = nil;</div><div class="line">id targetValue = @<span class="number">123</span>;	<span class="comment">// 这里错误传入了NSNumber对象，用以进行验证</span></div><div class="line">BOOL isValid = [targetTransaction validateValue:&amp;targetValue forKey:@<span class="string">"work"</span> error:&amp;error];</div><div class="line">NSLog(@<span class="string">"%d"</span>, isValid);</div></pre></td></tr></table></figure>
<h3 id="访问器的搜索方式"><a href="#访问器的搜索方式" class="headerlink" title="访问器的搜索方式"></a>访问器的搜索方式</h3><p><strong>NSObject提供给NSKeyValueCoding协议的默认实现，是使用基于键（key）的访问器，根据一系列规则来调用对象的属性。</strong>这些协议方法使用一个键（key）参数来搜索对象实例的访问器（accessor）、实例变量和一些遵循确定命名规范的方法。了解搜索的工作原理，不仅有助于追踪KVC对象的行为，还可以帮助编写自己的兼容对象（类似KVC）。</p>
<ul>
<li><strong>基本getter的搜索模式（valueForKey:的工作模式）：</strong></li>
</ul>
<ol>
<li><strong>首先依次查找访问方法set[Key]、[key]、is[Key]、_[key]。</strong>找到则跳到【5】中处理结果，否则进入下一步。</li>
<li><strong>若没有找到访问器方法，则搜索匹配名为countOf[Key]和objectIn[Key]AtIndex:的实例方法（与NSArray中定义的原方法一致），还有[key]AtIndexes:方法（与NSArray中的objectsAtIndexes:一致）。如果找到了第一个方法和后两者之一，则创建并返回一个集合代理对象来响应所有的NSArray的方法（给代理对象发送NSArray方法时会自动组合调用以上实现的方法）。</strong>不满足则进入下一步【3】。<br> 代理对象会把收到的所有的NSArray的消息（即API调用）转化成给KVC相关对象（即类实例对象）组合发送countOf[Key]、objectIn[Key]AtIndex:和[key]AtIndexes:消息。如果原类中额外实现了get[Key]:range:方法，此代理对象也会适时使用，以提高性能。实际上，代理对象会和原实例对象一起工作，让它看起来就像是一个NSArray对象（虽然不是）。</li>
<li><strong>当没有找到访问器方法和数组的访问方法时，系统再继续查找一组三个名为countOf[Key]、enumeratorOf[Key]和memberOf[Key]:的实例方法(都是NSSet类中的方法)。三个方法都找到，则创建一个集合代理对象来响应所有的NSSet方法并返回。</strong>不满足则进入下一步【4】。<br> 与NSArray的情况一样，系统会根据实现的方法生成并返回一个NSSet的代理对象，与原对象一起工作，来使其看起来像是一个NSSet对象（与上面一样，给返回的代理集合对象调用NSSet的api，你实现的countOf[Key]、enumeratorOf[Key]和memberOf[Key]:方法就会被组合调用。）。</li>
<li><strong>访问器方法和集合访问方法组都没有找到，系统会查看类中是否实现了accessInstanceVariablesDirectly，如果该方法返回YES，则进入成员列表中进行进一步查找。依次查找名为_[key]、_is[Key]、[key]和is[Key]的成员变量。</strong>找到则跳到【5】中处理结果，否则进入下一步。</li>
<li>如果得到的属性值是对象指针，直接返回结果。如果值是一个支持NSNumber转换的基本数据类型值，则封包成NSNumber对象返回。如果是一个不支持NSNumber转换的基本数据类型值（如结构体），则封包成NSValue对象返回。</li>
<li>若以上查找均失败，则触发valueForUndefinedKey:方法，默认抛出异常。子类可以覆盖此方法。</li>
</ol>
<ul>
<li><strong>基本setter的搜索模式（setValue:forKey:的工作模式）：</strong></li>
</ul>
<p>默认实现是，给定key和value参数作为输入，试图把key设置为value（对于非对象属性，要先解包成相应值）。被调用的对象依照下面的程序进行查找：</p>
<ol>
<li><strong>依次查找名为set[Key]:或_set[Key]的访问器方法，找到后，使用输入值触发该方法并完成（依照需要先解包值）。</strong></li>
<li><strong>没找到访问器时，查看类方法accessInstanceVariablesDirectly，如果返回YES，依次查找成员变量中的类似_[key]、_is[Key]或is[Key]。找到，使用输入值触发该方法并完成（依照需要先解包值）。</strong></li>
<li><strong>以上都没找到，则触发setValue:forUndefinedKey:方法。默认抛出异常，子类可以覆盖并提供其他行为（如赋值给其他属性等）。</strong></li>
</ol>
<ul>
<li><strong>可变数组的搜索模式：</strong></li>
</ul>
<p>mutableArrayValueForKey:方法默认实现是输入key，返回调用对象的以key命名的属性（要求此属性是数组或可变数组类型，不可变数组无法实现步骤【1】）。此访问器的调用程序如下：</p>
<ol>
<li>查找一组方法命名如insertObject:in[Key]AtIndex:和removeObjectFrom[Key]AtIndex:（与NSMutableArray中的insertObject:atIndex和removeObjectAtIndex:一致），或者名为insert[Key]:atIndexed:和removeObjectsAtIndexes:（与NSMutableArray的insertObjects:atIndexes:和removeObjectsAtIndexesL:一致）。<br> 如果调用对象至少包含一个插入方法和一个删除方法，就返回一个可变代理对象。以后通过给此代理对象发送NSMutableArray的所有消息，都会通过组合调用insertObject:in[Key]AtIndex:、removeObjectFrom[Key]AtIndex:、insert[Key]:atIndexed:和removeObjectsAtIndexes:方法的形式来进行响应（或者可以直接将这些方法声明在.h文件中，外部类实例直接调用此方法也可以直接触发KVO机制）。<br> 如果原类的对象还实现了可选的替换方法，如replaceObjectIn[Key]AtIndex:withObject:或replace[Key]AtIndexes:with[Key]:，代理对象也会适时调用此方法来提高效率。</li>
<li><p>如果类的实例对象没有这些可变的数组方法，就查找名字如set[Key]:的访问方法进行匹配。在这种情况下，返回的代理对象都是通过调用原始对象的set[Key]:方法来间接响应NSMutableArray的消息。</p>
<blockquote>
<p>注意：<br>步骤【2】中的机制由于需要每次创建新的集合对象（set[Key]:，setter方法设置，而不是修改已存在的对象），导致性能要比步骤【1】中要差了不少。所以自己设计KVC相关对象时要避免这种代码。</p>
</blockquote>
</li>
<li><p>既没有找到可变数组方法，也没有找到访问器，查看类的accessInstanceVariablesDirectly方法是否返回YES，是则依次去类的成员变量中查询是否存在如_[key]或[key]。若存在，则返回一个代理对象，系统会把代理对象收到的每个NSMutableArray的消息都转发给这个成员变量，这个变量的类型需要是NSMutableArray或其子类。</p>
</li>
<li>如果上面所有的步骤都失败了，就返回一个可变的集合代理对象，作为参数，来触发setValue:forUndefinedKey:方法。默认在内部抛出NSUndefinedKeyException异常，子类可以覆盖进行其他处理。</li>
</ol>
<blockquote>
<p>查了好多东西，发现只有在KVO时，使用此可变容器的api进行KVC属性设置。由于调用此api返回的是可变集合对象，且是系统在运行时动态生成的，内部已经包含了KVO使用的isa指针等。当对此代理对象调用NSMutableArray方法时，会自动触发KVO机制。</p>
</blockquote>
<p>其他如可变无序集合和可变有序集合的搜索模式与此类似，不再细说。</p>
<h3 id="参考内容："><a href="#参考内容：" class="headerlink" title="参考内容："></a>参考内容：</h3><ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/BasicPrinciples.html#//apple_ref/doc/uid/20002170-BAJEAIEE" target="_blank" rel="external">Key-Value Coding Fundamentals</a></li>
<li><a href="https://www.jianshu.com/p/45cbd324ea65" target="_blank" rel="external">iOS开发技巧系列—详解KVC(我告诉你KVC的一切)</a></li>
<li><a href="http://liumh.com/2015/08/22/ios-nsmutablearray-kvo/" target="_blank" rel="external">iOS如何为NSMutableArray添加KVO</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对象属性值的设置和获取&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问集合属性值的专用API&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用集合操作符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;描述非对象的值（基本数据类型和结构体等）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;属性类型验证&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问器的搜索方式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS Protocol（协议）的简单总结</title>
    <link href="http://yoursite.com/2018/04/03/iOS%20Protocol%EF%BC%88%E5%8D%8F%E8%AE%AE%EF%BC%89%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/03/iOS Protocol（协议）的简单总结/</id>
    <published>2018-04-03T02:50:26.000Z</published>
    <updated>2018-05-15T02:18:57.631Z</updated>
    
    <content type="html"><![CDATA[<p>协议保存在类结构的协议表中，我们可以使用runtime的相关api查看指定类遵循的协议，或动态修改遵循的协议等。</p>
<a id="more"></a>
<h3 id="语法总结："><a href="#语法总结：" class="headerlink" title="语法总结："></a>语法总结：</h3><ol>
<li>协议中可以声明<strong>方法、属性</strong></li>
<li>协议方法分为可选可必选</li>
<li><strong>协议属性不会自动合成</strong>（与@dynamic的property一样）</li>
<li>协议可继承（通过xcode创建的protocol文件，默认继承了NSObject协议），且为单继承，子协议默认继承了父协议的所有内容</li>
</ol>
<h3 id="使用建议："><a href="#使用建议：" class="headerlink" title="使用建议："></a>使用建议：</h3><ol>
<li>当主类遵循多个协议时，可以使用category将主类分开，防止代码量过大且过于复杂</li>
<li>协议可以让使用类匿名（即对外返回id<xxx>的对象），公开的api放到protocol中，一般用于设计framework等。可以参见NSFetchResultController类的设计。</xxx></li>
</ol>
<h3 id="参考内容："><a href="#参考内容：" class="headerlink" title="参考内容："></a>参考内容：</h3><ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithProtocols/WorkingwithProtocols.html#//apple_ref/doc/uid/TP40011210-CH11-SW1" target="_blank" rel="external">Working with Protocols</a></li>
<li></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;协议保存在类结构的协议表中，我们可以使用runtime的相关api查看指定类遵循的协议，或动态修改遵循的协议等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 2.0 方法调用中的动态绑定和消息转发</title>
    <link href="http://yoursite.com/2018/03/30/Objective-C%202.0%20%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>http://yoursite.com/2018/03/30/Objective-C 2.0 动态绑定和消息转发/</id>
    <published>2018-03-30T06:06:41.000Z</published>
    <updated>2018-05-15T02:19:01.521Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li><strong>OC方法调用的实质</strong></li>
<li><strong>动态绑定和消息转发的流程</strong></li>
<li><strong>动态绑定实例（添加实例方法、添加类方法）</strong></li>
<li><strong>消息转发实例</strong></li>
<li><strong>消息转发模拟“多继承”以及二者的区别</strong></li>
<li><strong>使用消息转发代替继承</strong></li>
</ul>
</blockquote>
<a id="more"></a>
<h3 id="OC方法调用的实质"><a href="#OC方法调用的实质" class="headerlink" title="OC方法调用的实质"></a>OC方法调用的实质</h3><p>我们都知道，OC是C语言的超集，赋予了C强大的动态特性，其功劳主要归功于OC的运行时系统（runtime）。OC调用方法的实质是发送消息（即objc_msgSend函数）。在编译期，对象理论上可以调用任何方法，即使此方法并没有实现。直到运行期，系统才会根据方法名（SEL）去class的数据结构中查找对应方法进行方法调用。</p>
<h3 id="动态绑定和消息转发的流程"><a href="#动态绑定和消息转发的流程" class="headerlink" title="动态绑定和消息转发的流程"></a>动态绑定和消息转发的流程</h3><p>给对象（类的实例）发送消息（即调用方法）的大致流程如下：</p>
<ol>
<li>根据实例的isa指针确定所属class</li>
<li>在class的缓存表中查看是否存在此方法。若存在，加入缓存表后，找到对应IMP直接调用</li>
<li>不存在缓存时，在class的方法表中查找。若存在，加入缓存表后，找到对应IMP直接调用</li>
<li>方法表不存在时，根据class的super_class指针，在父类的方法表中继续查找。若存在，加入缓存表后，找到对应IMP直接调用</li>
<li>都没有查找到时，runtime会启动动态绑定，调用resolveInstanceMethod方法，此时，可以动态添加此方法到class中。如已添加，加入缓存表后，找到对应IMP直接调用</li>
<li>若没有动态添加方法，runtime会启动快速消息转发机制，即调用forwardTargetForSelector方法。我们可以直接返回一个类实例，指定其为调用者的代理对象，直接执行其对应的方法</li>
<li>如果没有指定代理对象，runtime会启动完整的消息转发机制（forwardInvocation）：首先，调用methodSignatureForSelector方法，返回一个包含此方法实例对象的方法签名；接着，系统会根据此方法签名，生成一个NSInvacation对象（包含着方法选择器等信息），带有此参数并调用forwardInvocation方法。我们在forwardInvocation中，使用invacation对象调用invokeWithTarget方法，传入需要转发的实例对象。即完成了消息转发，系统会自动调用转发对象的对应方法，并将结果返回给最初的调用者。</li>
<li>如果我们没有把消息转发给任何对象，最后系统会调用doesNotRecognizeMethod方法，并在其内部抛出异常，即表示无法处理此消息，最终默认crash掉APP。</li>
</ol>
<blockquote>
<p>以上步骤中，1~4为方法的正常调用流程，5为动态绑定流程，6~8为消息转发流程。</p>
</blockquote>
<p>转发一张动态绑定和消息转发的流程图（上面的步骤5~8）：<br><img src="https://upload-images.jianshu.io/upload_images/1457495-8ee6afef466e6177.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<h3 id="动态绑定实例"><a href="#动态绑定实例" class="headerlink" title="动态绑定实例"></a>动态绑定实例</h3><ul>
<li>添加实例方法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    [self performSelector:@selector(missingMethod:) withObject:@<span class="string">"haha"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    <span class="keyword">if</span> (NSSelectorFromString(@<span class="string">"missingMethod:"</span>) == sel) &#123;</div><div class="line">        <span class="comment">// 是我们调用的方法，使用runtime添加实现</span></div><div class="line">        <span class="comment">// 方法描述中，v--void；@--id；:--SEL</span></div><div class="line">        class_addMethod([self class], sel, (IMP)missingMethodIMP, <span class="string">"v@:@\"NSString\""</span>);</div><div class="line">        <span class="keyword">return</span> YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 返回默认实现</span></div><div class="line">    <span class="keyword">return</span> [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">missingMethodIMP</span><span class="params">(id self, SEL _cmd, NSString *param)</span> </span>&#123;</div><div class="line">    NSLog(@<span class="string">"calling missingMethodIMP with: %@"</span>, param);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>添加类方法：</li>
</ul>
<p>我们知道，与实例方法不同，类方法是保存在类所属元类的方法表中（即class -&gt; isa -&gt; meta class -&gt; method list）。所以给类动态绑定类方法，需要绑定到元类中，通过resolveClassMethod进行添加：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    [[self <span class="class"><span class="keyword">class</span>] <span class="title">performSelector</span>:</span>@selector(missingClassMethod:) withObject:@<span class="string">"haha"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel &#123;</div><div class="line">    <span class="keyword">if</span> (NSSelectorFromString(@<span class="string">"missingClassMethod:"</span>) == sel) &#123;</div><div class="line">        <span class="comment">// 是我们调用的方法，使用runtime添加实现</span></div><div class="line">        <span class="comment">// 获取meta class</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *className = class_getName(self);</div><div class="line">        id metaClass = objc_getMetaClass(className);</div><div class="line">        <span class="comment">// 添加方法</span></div><div class="line">        <span class="keyword">return</span> class_addMethod(metaClass, sel, (IMP)missingClassMethodIMP, <span class="string">"v@:@\"NSString\""</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [super resolveClassMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">missingClassMethodIMP</span><span class="params">(id self, SEL _cmd, NSString *param)</span> </span>&#123;</div><div class="line">    NSLog(@<span class="string">"calling missingClassMethodIMP with: %@"</span>, param);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="消息转发实例"><a href="#消息转发实例" class="headerlink" title="消息转发实例"></a>消息转发实例</h3><p>这里只列举了实例方法的消息转发。对于类方法的消息转发，只需将对应的“-”改为“+”即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line">@interface ClassAForForward : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"ClassAForForward.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"ClassBForForward.h"</span></span></div><div class="line"></div><div class="line">@implementation ClassAForForward</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    <span class="comment">// 这里只是演示一下，首先会进入动态绑定过程</span></div><div class="line">    <span class="comment">// 由于没有任何作用，会进入消息转发流程</span></div><div class="line">    <span class="keyword">return</span> [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="comment">// 此方法可以直接指定转发的对象</span></div><div class="line">    <span class="comment">// 省略了获取方法签名和生成转发对象组合的方式</span></div><div class="line">    <span class="comment">// 效率高</span></div><div class="line">    <span class="keyword">if</span> (aSelector == NSSelectorFromString(@<span class="string">"methodB"</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> [[ClassBForForward alloc] init];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 直接返回，则会触发完整的消息转发机制</span></div><div class="line">    <span class="keyword">return</span> [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</div><div class="line">    <span class="keyword">if</span> (!signature) &#123;</div><div class="line">        <span class="comment">// 找不到SEL对应的方法签名，</span></div><div class="line">        <span class="comment">// 提供一个自定义的方法签名，返回给本类用于转发调用（forwardInvocation）</span></div><div class="line">        ClassBForForward *bInstance = [[ClassBForForward alloc] init];</div><div class="line">        <span class="comment">// 将带有此selector的类的方法签名返回给本类</span></div><div class="line">        <span class="comment">// 使本类调用“转发调用”方法（forwardInvocation）【即runtime会生成一个invocation传入到转发方法中并调用】</span></div><div class="line">        <span class="comment">// 相当于带有selector的类实例“代理”了本类执行selector</span></div><div class="line">        signature = [bInstance methodSignatureForSelector:aSelector];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> signature;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(NSInvocation *)anInvocation &#123;</div><div class="line">    SEL aSelector = [anInvocation selector];</div><div class="line">    <span class="keyword">if</span> (aSelector) &#123;</div><div class="line">        <span class="comment">// 本类实例指定代理对象来调用selector</span></div><div class="line">        <span class="comment">// 转发给代理对象</span></div><div class="line">        ClassBForForward *bInstance = [[ClassBForForward alloc] init];</div><div class="line">        [anInvocation invokeWithTarget:bInstance];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 返回给系统继续调用（调用doesNotRecognizeSelector方法）</span></div><div class="line">        [super forwardInvocation:anInvocation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)doesNotRecognizeSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="comment">// 最终无法转发的方法，会执行这里，之后默认crash</span></div><div class="line">    [super doesNotRecognizeSelector:aSelector];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="消息转发模拟“多继承”以及二者的区别"><a href="#消息转发模拟“多继承”以及二者的区别" class="headerlink" title="消息转发模拟“多继承”以及二者的区别"></a>消息转发模拟“多继承”以及二者的区别</h3><p>面向对象编程，其实根本目的就是为了代码复用。面向对象的方式之一就是继承，但由于OC只支持单继承，一定程度上减少了很多代码复用的机会，而且并不是所有的类都可以直接继承（如OC的类簇）。而消息转发机制可以在一定程度上解决这个问题。</p>
<p>个人理解，消息转发实际上与代理模式一样，调用者本身不具备指定功能，通过代理对象调用方法来间接实现自己的功能。外部看起来与本身直接调用一样。当把多个功能分别转发给多个对象后，调用者本身就具备了多个类的多种功能，看起来就像是多继承一样。这也就赋予了OC“多继承”的功能，而且实现了代码复用（功能复用）。</p>
<p>但是消息转发和真正的多继承还是存在明显区别的：</p>
<ul>
<li>多继承是“多合一”：多个父类的功能组合生成子类，子类的功能及结构会变多且复杂。</li>
<li>消息转发是“一分多”：通过代理对象，将多个功能分发到多个类中进行实现，本类的实际结构和功能则相对简单，且对外部透明。</li>
</ul>
<h3 id="使用消息转发代替继承"><a href="#使用消息转发代替继承" class="headerlink" title="使用消息转发代替继承"></a>使用消息转发代替继承</h3><p>虽然消息转发隐藏了细节，在外部看起来像是调用类存在某种功能（实现了这个方法），或者是你认为调用类“继承”了转发类。但实际上，通过诸如respondsToSelector、isKindOfClass等函数还是可以识别出真相（此类函数只会查看本身的继承链，不会查看转发链）。如果你想要完全模拟“继承”，则需要覆盖此类方法才行。<br><em>官方文档有说过，一定要慎用消息转发，在没有彻底弄清转发机制和本类及转发类的功能时，不要乱用这个机制。</em></p>
<p>参考内容：</p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1" target="_blank" rel="external">Message Forwarding</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html#//apple_ref/doc/uid/TP40008048-CH102-SW1" target="_blank" rel="external">Dynamic Method Resolution</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;OC方法调用的实质&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态绑定和消息转发的流程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态绑定实例（添加实例方法、添加类方法）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息转发实例&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息转发模拟“多继承”以及二者的区别&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用消息转发代替继承&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 2.0的category</title>
    <link href="http://yoursite.com/2018/03/26/Objective-C%202.0%20category/"/>
    <id>http://yoursite.com/2018/03/26/Objective-C 2.0 category/</id>
    <published>2018-03-26T14:40:03.000Z</published>
    <updated>2018-05-15T02:18:58.508Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li><strong>class和category的数据结构</strong></li>
<li><strong>为什么category只能添加方法，不能添加属性？</strong></li>
<li><strong>category为何不要覆盖父类方法？</strong></li>
<li><strong>多个category覆盖同名方法的执行顺序</strong></li>
<li><strong>category与extension的区别</strong></li>
<li><strong>关联对象和其他补充</strong></li>
</ul>
</blockquote>
<a id="more"></a>
<h3 id="class和category的数据结构"><a href="#class和category的数据结构" class="headerlink" title="class和category的数据结构"></a>class和category的数据结构</h3><p>在学习runtime时，可以知道，<em>OC的所有数据结构，包括对象、类、方法、协议等等，都是C的结构体</em>。<br>类的实例，即对象，主要只包含了一个isa指针，指向其所属的class。而class的isa指针则指向其元类（meta class），元类的isa指向根原类，根元类isa指向自身。</p>
<p>来一张转烂了的图，顺便说明isa和super指针的指向关系：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3270116-4fef3651af3f80d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="img"></p>
<p>class的主要数据结构（元类与其相同）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></div><div class="line">	Class isa    OBJC_ISA_AVAILABILITY;</div><div class="line">	</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">	Class super_class;    <span class="comment">// 父类</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">// 类名</span></div><div class="line">	<span class="keyword">long</span> version;    <span class="comment">// 类版本信息，默认0</span></div><div class="line">	<span class="keyword">long</span> info;    <span class="comment">// 类信息</span></div><div class="line">	<span class="keyword">long</span> instance_size;    <span class="comment">// 类实例变量大小</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>;</span>    <span class="comment">// 成员变量链表</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodlists</span>;</span>    <span class="comment">// 方法链表</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>;</span>    <span class="comment">// 方法缓存</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>;</span>    <span class="comment">// 遵循的协议链表</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>简要说明下：</p>
<ul>
<li>根据class的数据结构，即可了解runtime的主要功能：可以在运行时获取类的相关信息，包括实例变量、方法列表、协议列表等，且可以通过相关api对各部分进行增删改查等操作（甚至是修改method的实现）。</li>
<li>OC中的方法调用，并非在编译期确定调用地址，而是在运行时才会确定调用方法的真正地址（通过objc_msgsend函数进行方法调用）。子类的方法调用，会在methodlist中查找，未找到后，会在父类的methodlist中继续查找，直到找到后调用（未找到后进入消息转发）。找到后，会将此method的地址放入cache中，以加快访问。</li>
</ul>
<p>我们主要讨论的category，其结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">// 类名</span></div><div class="line">	<span class="keyword">classref_t</span> cls;    <span class="comment">// 类</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span>    <span class="comment">// 保存添加的实例方法的链表</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>    <span class="comment">// 保存添加的类方法的链表</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>    <span class="comment">// 保存实现的协议方法的链表</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span>    <span class="comment">// 保存所有添加的属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="为什么category只能添加方法，不能添加属性？"><a href="#为什么category只能添加方法，不能添加属性？" class="headerlink" title="为什么category只能添加方法，不能添加属性？"></a>为什么category只能添加方法，不能添加属性？</h3><p>从category的结构中可以看出，<strong>由于内部只保存了属性，并不包含ivar（成员变量才能保存属性的值），即只生成了setter和getter方法的声明，没有对应实现，更没有对应的成员变量保存</strong>。所以在category中添加属性，需要使用runtime的相关对象（associate_object）进行。<br>而且对于category来说，<strong>添加的方法会在编译后添加到主类的方法列表中（实例方法添加到主类，类方法添加到主类所属的元类中）</strong>。</p>
<h3 id="category为何不要覆盖父类方法？"><a href="#category为何不要覆盖父类方法？" class="headerlink" title="category为何不要覆盖父类方法？"></a>category为何不要覆盖父类方法？</h3><p>我们都知道，在category中覆盖父类方法时，系统会弹出警告（主类也实现了此方法），且调用原方法时，系统会执行category的实现，从而导致原始方法实现被覆盖。这里是为什么？<br>我们知道，由于category的方法在runtime加载后会添加到本类的方法表中，方法表保存的是方法的SEL，可以推测：</p>
<ol>
<li>原SEL被覆盖</li>
<li>两个同名方法都被加入到方法表中，调用时只执行了category的</li>
</ol>
<p>另一个问题是，runtime在加载时，对于本类和category的加载顺序是什么。</p>
<p>参照以下代码可以验证：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">// 主类</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface TestClassForCategory : NSObject</div><div class="line"></div><div class="line">- (void)testMethod;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#import "TestClassForCategory.h"</div><div class="line"></div><div class="line">@implementation TestClassForCategory</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@"load === TestClassForCategory");</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)testMethod &#123;</div><div class="line">    NSLog(@"instance method~~~~");</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">// 分类（category）</div><div class="line">#import "TestClassForCategory.h"</div><div class="line"></div><div class="line">@interface TestClassForCategory (Category1)</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#import "TestClassForCategory+Category1.h"</div><div class="line"></div><div class="line">@implementation TestClassForCategory (Category1)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@"load === TestClassForCategory+Category1");</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)testMethod &#123;</div><div class="line">    // category的方法会添加到</div><div class="line">    NSLog(@"category1----");</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我们可以在自己的测试类中，实例化TestClassForCategory并调用testMethod方法，可以看到输出结果：</p>
<blockquote>
<p>2018-03-27 07:55:10.278999+0800 Runtime_Learning2[3506:4499896] load === TestClassForCategory<br>2018-03-27 07:55:10.280645+0800 Runtime_Learning2[3506:4499896] load === TestClassForCategory+Category1<br>2018-03-27 07:55:14.702309+0800 Runtime_Learning2[3506:4499896] category1—-</p>
</blockquote>
<p>由此可以证明，<strong>runtime加载时，首先加载主类，然后加载category。</strong></p>
<p>我们通过runtime的api来获取一下TestClassForCategory的方法表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 打印TestClassForCategory的methodlist</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> methodlistCount;</div><div class="line">Method *methodlist =  class_copyMethodList([TestClassForCategory class], &amp;methodlistCount);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodlistCount; i++) &#123;</div><div class="line">    Method method = methodlist[i];</div><div class="line">    SEL sel = method_getName(method);</div><div class="line">    IMP imp = method_getImplementation(method);</div><div class="line">    NSLog(@<span class="string">"method - %@"</span>, NSStringFromSelector(sel));</div><div class="line">    imp();</div><div class="line">&#125;</div><div class="line"><span class="built_in">free</span>(methodlist);</div></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<blockquote>
<p>2018-03-27 07:55:10.683704+0800 Runtime_Learning2[3506:4499896] method - testMethod<br>2018-03-27 07:55:10.683855+0800<br>Runtime_Learning2[3506:4499896] category1—-<br>2018-03-27 07:55:10.683965+0800 Runtime_Learning2[3506:4499896] method - testMethod<br>2018-03-27 07:55:10.684055+0800 Runtime_Learning2[3506:4499896] instance method<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&gt; </div><div class="line"></div><div class="line">可以看到，**在主类的方法表中，果然保存了主类和分类两个SEL，且方法实现均可以被调用**。联系着load方法的执行顺序，我们可以知道，**class在方法列表中添加方法时，是依照“头部插入”的方式（“头插法”）来修改链表的**。</div><div class="line">原理如下（转自[iOS OC中分类Category实现原理](http://blog.sina.com.cn/s/blog_14679a7d20102xae4.html)）：</div><div class="line"></div><div class="line">![img](http://img.blog.csdn.net/20180131104524542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hpaHVib2tl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</div><div class="line"></div><div class="line">由此可见，当分类中覆盖了主类的方法后，**由于分类的方法在原方法前部，导致调用方法时，系统查找到第一个方法后，直接返回执行，本类方法不会执行**。所以一般不建议在分类中覆盖主类方法。特别是给系统类添加分类时，由于本类或其父类可能会有相同的方法声明，导致被分类覆盖。</div><div class="line"></div><div class="line">为避免此类问题的出现，可以在分类中声明方法时，添加自定义的方法前缀。</div><div class="line"></div><div class="line">### 多个category覆盖同名方法的执行顺序</div><div class="line"></div><div class="line">我们知道，在类的方法表中添加方法使用的是“头插法”，但当给主类添加多个分类时，分类方法的加载顺序又是如何呢？</div><div class="line">根据代码来看：</div><div class="line"></div><div class="line">``` C</div><div class="line">// 在以上代码的基础上再添加第二个category</div><div class="line">#import &quot;TestClassForCategory.h&quot;</div><div class="line"></div><div class="line">@interface TestClassForCategory (Category2)</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#import &quot;TestClassForCategory+Category2.h&quot;</div><div class="line"></div><div class="line">@implementation TestClassForCategory (Category2)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;load === TestClassForCategory+Category2&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)testMethod &#123;</div><div class="line">    // category的方法会添加到</div><div class="line">    NSLog(@&quot;category2----&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line">```</div><div class="line">执行结果如下：</div><div class="line">&gt; </div><div class="line">&gt; 2018-03-27 10:58:50.708610+0800 Runtime_Learning2[4434:4568830] load === TestClassForCategory</div><div class="line">&gt; 2018-03-27 10:58:50.711459+0800 Runtime_Learning2[4434:4568830] load === TestClassForCategory+Category1</div><div class="line">&gt; 2018-03-27 10:58:50.712078+0800 Runtime_Learning2[4434:4568830] load === TestClassForCategory+Category2</div><div class="line">&gt; 2018-03-27 10:58:50.927215+0800 Runtime_Learning2[4434:4568830] method - testMethod</div><div class="line">&gt; 2018-03-27 10:58:50.927375+0800 Runtime_Learning2[4434:4568830] category2----</div><div class="line">&gt; 2018-03-27 10:58:50.927585+0800 Runtime_Learning2[4434:4568830] method - testMethod</div><div class="line">&gt; 2018-03-27 10:58:50.928280+0800 Runtime_Learning2[4434:4568830] category1----</div><div class="line">&gt; 2018-03-27 10:58:50.928472+0800 Runtime_Learning2[4434:4568830] method - testMethod</div><div class="line">&gt; 2018-03-27 10:58:50.928653+0800 Runtime_Learning2[4434:4568830] instance method</div></pre></td></tr></table></figure></p>
<p>2018-03-27 10:58:53.851391+0800 Runtime_Learning2[4434:4568830] category2—-</p>
</blockquote>
<p>可以看到，最后加载的category2，则执行方法指向的是category2的方法。原因在哪呢？</p>
<p>在工程TARGETS -&gt; Build Phases -&gt; Compile Sources中，我们可以看到，自上而下，编译资源的顺序是：Category1.m、Category2.m，我们可以自己上下调整编译顺序并执行，结果显而易见：</p>
<p><strong>多个category的加载顺序（也是方法的覆盖顺序）是依照Compile Sources的顺序自上而下确定的。</strong></p>
<p><em>注意，返回值不同的方法也会覆盖，因为SEL与返回值无关。</em></p>
<p>所以，多个分类同时覆盖主类的方法时，执行结果无法直接确定，可能会出现不可预估的问题。</p>
<h3 id="category与extension的区别"><a href="#category与extension的区别" class="headerlink" title="category与extension的区别"></a>category与extension的区别</h3><p>一般来说，我们都会认为class extension（类的扩展）是匿名的category，因为语法详尽，且功能相似，但实际上来说，二者可以说是<em>完全不同</em>。</p>
<ul>
<li><p>extension: </p>
<ol>
<li>它是class的一部分，与interface、implementation三者共同组成class，声明周期与class相同。</li>
<li>分类是在编译期确定的，内部声明的属性和方法在编译期直接组成class结构体的数据（属性会自动生成ivar并合成setter和getter，分别添加到class的ivar_list和method_list中）。</li>
<li>分类声明的方法，实现必须在class的implementation中，所以没有本类的源代码无法添加extension。</li>
</ol>
</li>
<li><p>category:</p>
<ol>
<li>与class本体无关，可以单独存在。</li>
<li>扩展是在编译期编译，在运行时加载到类中。category由于其数据结构所限，只能添加方法实现、属性声明和协议实现，内部不包含ivar成员变量，所以无法保存数据（声明的属性不能生成对应的ivar，也不能合成出setter和getter的实现）。</li>
<li>编译期由于class结构布局和数据已经确定，在运行时，category只能将方法添加到class的方法链表中，其他东西无法修改（class的实例大小等在编译期已确定，无法修改）。</li>
</ol>
</li>
</ul>
<h3 id="关联对象和其他补充"><a href="#关联对象和其他补充" class="headerlink" title="关联对象和其他补充"></a>关联对象和其他补充</h3><ul>
<li><p>由于在category中添加属性，需要使用关联对象（associate object）进行添加和访问，那关联对象的数据保存在哪里呢？</p>
<p>  所有的关联对象都由AssociationsManager进行统一管理（添加、删除等），保存在全局map中，其中key是这个相关对象的指针地址，value则是单独的一个AssociationsHashMap，里面保存着key-value对。</p>
</li>
<li><p>提问：在class的load方法中，可以调用Category的方法吗？<br>  答：可以。runtime加载class和category等是在load方法调用前执行的，此时Category的方法已经加载到class的方法列表中，可以直接调用。</p>
</li>
<li><p>提问：当Category已经覆盖了Class中的方法时，如何调用Class中的原方法？<br>  答：由于使用“头插法”，Category的方法已经在Class的方法列表头部。系统调用方法时是从头开始检索，查到对应Method后即跳转IMP进行调用。我们可以使用runtime的api手动遍历Class的方法表，找到最后一个同名方法，直接调用IMP。</p>
</li>
<li><p>扩展一个类的方式：</p>
<ol>
<li>子类化</li>
<li>使用category</li>
<li>使用协议抽象（如UITableView的delegate和data source，可以给具有显示功能的类进行扩展）</li>
</ol>
</li>
</ul>
<p>参考内容：</p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="external">Customizing Existing Classes
</a></li>
<li><a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">深入理解Objective-C：Category
</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_14679a7d20102xae4.html" target="_blank" rel="external">iOS OC中分类Category实现原理</a></li>
<li><a href="https://www.jianshu.com/p/87cfbdda0a68" target="_blank" rel="external">【iOS】category 重写方法的调用</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;class和category的数据结构&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为什么category只能添加方法，不能添加属性？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;category为何不要覆盖父类方法？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多个category覆盖同名方法的执行顺序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;category与extension的区别&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关联对象和其他补充&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS runtime学习</title>
    <link href="http://yoursite.com/2018/03/14/iOS%20runtime%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/03/14/iOS runtime学习/</id>
    <published>2018-03-14T03:33:33.000Z</published>
    <updated>2018-05-15T02:11:35.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开坑，待补-，学习总结"><a href="#开坑，待补-，学习总结" class="headerlink" title="开坑，待补~，学习总结~"></a>开坑，待补~，学习总结~</h3><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="external">Objective-C Runtime Programming Guide</a></li>
<li><a href="https://www.jianshu.com/p/0e6eb2f9ed5d" target="_blank" rel="external">iOS-runtime通篇详解-上</a></li>
<li><a href="https://www.jianshu.com/p/f1544b27d007" target="_blank" rel="external">iOS-runtime通篇详解-下</a></li>
<li><a href="https://www.jianshu.com/p/efeb33712445#" target="_blank" rel="external">Runtime全方位装逼指南
</a></li>
<li><a href="https://www.jianshu.com/p/19f280afcb24" target="_blank" rel="external">iOS 模块详解—「Runtime面试、工作」看我就 🐒 了 ^_^.</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开坑，待补-，学习总结&quot;&gt;&lt;a href=&quot;#开坑，待补-，学习总结&quot; class=&quot;headerlink&quot; title=&quot;开坑，待补~，学习总结~&quot;&gt;&lt;/a&gt;开坑，待补~，学习总结~&lt;/h3&gt;&lt;h3 id=&quot;参考资料：&quot;&gt;&lt;a href=&quot;#参考资料：&quot; cla
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS RunLoop学习</title>
    <link href="http://yoursite.com/2018/03/07/iOS%20RunLoop%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/03/07/iOS RunLoop学习/</id>
    <published>2018-03-07T06:21:53.000Z</published>
    <updated>2018-05-15T02:18:43.256Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RunLoop简介及与线程的关系："><a href="#RunLoop简介及与线程的关系：" class="headerlink" title="RunLoop简介及与线程的关系："></a>RunLoop简介及与线程的关系：</h3><p>简而言之，RunLoop就是一个“do-while”循环–一个事件队列循环。循环时，系统会依次从事件队列中取出事件并执行；没有事件处理时，RunLoop会进入休眠，等待事件唤醒处理，以节省系统资源，即“休眠-&gt;事件唤醒-&gt;处理事件-&gt;休眠…”的逻辑。</p>
<p>在iOS中，RunLoop存在的类为CFRunLoopRef和NSRunLoop。前者为CoreFoundation框架，C语言编写，线程安全；后者是OC封装，线程不安全。</p>
<a id="more"></a>
<p><strong>RunLoop与线程是一一对应的</strong>。根据源代码（苹果的官方文档或下面的参考资料中可以看到）可知，RunLoop对象存在于底层的一个全局字典中，key为线程（线程指针），value为RunLoop对象。</p>
<p><strong>应用初始化时，系统自动创建此全局字典，并自动创建主线程的RunLoop，以保证APP在运行时不退出。子线程的RunLoop不会自动创建。</strong>由于系统没有直接提供创建RunLoop的API，在子线程中只能通过CFRunLoopGetCurrent()或[NSRunLoop currentRunLoop]来间接获取Runloop（子线程中首次访问RunLoop时，系统会创建RunLoop对象并保存到全局字典中）。获取主线程的RunLoop的方式是CFRunLoopGetMain()和[NSRunLoop mainRunLoop]。</p>
<h3 id="RunLoop的组成结构："><a href="#RunLoop的组成结构：" class="headerlink" title="RunLoop的组成结构："></a>RunLoop的组成结构：</h3><p>先看图（摘自<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>）</p>
<p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" alt="img"></p>
<p>如图所示，RunLoop对象包含了若干个Mode对象（CFRunLoopModeRef），一个Mode对象中包含了若干个Item（Item为Source、Observer或Timer的一种或几种）。</p>
<p>其中<strong>CFRunLoopSourceRef</strong>分为Source0和Source1两种：source0对象只有一个Call_Out回调函数指针，不能主动唤醒RunLoop，处理事件时只能依照RunLoop的执行顺序被动执行或外界手动唤醒；source1对象则不同，除了带有Call_Out回调外，还包含一个Mach_Port端口参数（每个Source1唯一），外部可以通过这个端口与其进行线程间通信，且source1事件可以主动唤醒RunLoop进行处理。</p>
<p><strong>CFRunLoopObserverRef</strong>即为监听者，带有Call_Out函数回调函数指针，外部可以监听对应Observer来识别当前RunLoop的活动状态，RunLoop的活动状态包括:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</div><div class="line">	<span class="comment">// 即将进入RunLoop</span></div><div class="line">	kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>), </div><div class="line">	<span class="comment">// 即将处理Timer</span></div><div class="line">	kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</div><div class="line">	<span class="comment">// 即将处理Source</span></div><div class="line">	kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>),</div><div class="line">	<span class="comment">// 即将进入休眠</span></div><div class="line">	kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>),</div><div class="line">	<span class="comment">// 刚刚从睡眠中唤醒</span></div><div class="line">	kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>),</div><div class="line">	<span class="comment">// 即将退出RunLoop</span></div><div class="line">	kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>CFRunLoopTimerRef</strong>是基于时间的触发器，也包含一个Call_Out回调函数指针（还有RunLoop上所有timer对象共享的的Mach_Port端口），与上层的NSTimer相同（toll-free bridged），添加到系统后，RunLoop会提前计算好触发时间并添加到RunLoop中，等待到时间时自动执行回调。</p>
<p><strong>Timer、Source0（1）、Observer同城为mode item。一个item可以添加到多个item中（下面的common item会说明）。而且，只有当至少包含一个item的mode存在时，对应的RunLoop对象才会持续运行且不退出（线程“保活”的原因）。</strong></p>
<h3 id="RunLoop-Mode的结构："><a href="#RunLoop-Mode的结构：" class="headerlink" title="RunLoop Mode的结构："></a>RunLoop Mode的结构：</h3><p>大致结构如下（摘自<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>），可以在APP启动后打印[NSRunLoop currentRunloop]自行查看完整RunLoop对象的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></div><div class="line">	CFStringRef _name;	<span class="comment">// mode的名称（如“kCFRunLoopDefaultMode”）</span></div><div class="line">	CFMutableSetRef _source0;</div><div class="line">	CFMutableSetRef _source1;</div><div class="line">	CFMutableArrayRef _observers;</div><div class="line">	CFMutableArrayRef _timers;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></div><div class="line">	CFMutableSetRef _commonModes;</div><div class="line">	CFMutableSetRef _commonModeItems;</div><div class="line">	CFRunLoopModeRef _currentMode;	<span class="comment">// 当前所处mode（即mode的name）</span></div><div class="line">	CFMutableSetRef _modes;		<span class="comment">// 包含所有支持的mode</span></div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面中的<strong>commonModes即为“标记为Common的mode对象集合”。对应的共享item即为commonModeItems集合。每当RunLoop内容变化时，_commonModeItems里面的所有item（observer、timer和source）都会同步到所有的commonModes的mode中。</strong></p>
<p>例如，对主线程的RunLoop来说，commonModes即包含两个：kCFRunLoopDefaultMode（NSDefaultRunLoopMode）和UITrackingRunLoopMode。其中当app处于列表滑动状态时，主线程处于trackingMode；其余时候处于defaultMode。</p>
<p><strong>同一时间，RunLoop只能处于一个mode模式下工作，切换mode时需要退出并重新指定mode。</strong></p>
<h3 id="RunLoop的内部逻辑："><a href="#RunLoop的内部逻辑：" class="headerlink" title="RunLoop的内部逻辑："></a>RunLoop的内部逻辑：</h3><p>就是“do-while”，看图（摘自<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>）：</p>
<p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_1.png" alt="img"></p>
<p>主要的运行循环为2~9步，这部分实现了“do-while”的逻辑；<br>核心为第7步，在没有事件待处理时，进行休眠，等待事件唤醒。</p>
<h3 id="RunLoop“休眠”机制："><a href="#RunLoop“休眠”机制：" class="headerlink" title="RunLoop“休眠”机制："></a>RunLoop“休眠”机制：</h3><p><strong>休眠时，RunLoop执行的核心函数为：mach_msg();</strong><br>此函数为XNU内核的Mach层的基本函数。Mach对象间使用“消息”在端口（“port”）之间进行进程间通信。<br>mach_msg()函数实际调用了函数mach_msg_trap()，即Mach陷阱函数。调用后，系统会切换至内核态，内核态中的mach_msg()函数完成真正的工作（休眠等待、唤醒等）。</p>
<p>看图（摘自<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>）：<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_5.png" alt="img"></p>
<h3 id="RunLoop在APP中的功能："><a href="#RunLoop在APP中的功能：" class="headerlink" title="RunLoop在APP中的功能："></a>RunLoop在APP中的功能：</h3><ul>
<li>AutoReleasePool:</li>
</ul>
<p>App启动后，iOS在主线程的RunLoop中注册了两个Observer，回调都是_wrapRunLoopWithAutoreleasePoolHandler()，其中一个优先级为最高（-2147483647），一个为最低（2147483647），这保证了创建自动释放池在所有代码运行之前，且释放池在所有任务之后，使整个app的代码运行在自动释放池中，防止了内存泄漏。</p>
<ul>
<li>事件响应：</li>
</ul>
<p><strong>iOS注册的用于接收系统硬件事件的Source1对象，回调为__IOHIDEventSystemClientCallback()，用于处理触摸、按键、传感器等事件。</strong></p>
<p>处理逻辑为：SpringBoard接收到转化后的IOHIDEvent事件，通过mach_port转发给需要的App进程，之后source1的回调会主动触发，调用<strong>UIApplicationHandleEventQueue()进行应用内分发。
</strong>UIApplicationHandleEventQueue()会将事件包装成UIEvent进行处理或分发。其中，手势、屏幕旋转等转发给UIWindow进行处理，通常的UIButton点击、touchBegin等触摸事件直接在这个回调中进行处理。</p>
<ul>
<li>手势识别：</li>
</ul>
<p>识别手势时，系统会先调用cancel将touchBegin等事件进行打断，随后会将对应的UIGestureRecognizer标记为待处理。<br>iOS注册的beforeWaiting的observer所对应的回调即为集中处理手势识别的函数：_UIGestureRecognizerUpdateObserver()。其内部会检测所有已标记的手势对象，并调用手势的回调函数。</p>
<ul>
<li>界面更新：</li>
</ul>
<p>当我们设置了view的frame，更新了view或者layer的层次后，甚至手动调用setNeedsDisplay或setNeedsLayout后，系统并不是立即渲染页面，而是将所有的界面更新请求添加到一个整体的容器中，等待下个RunLoop事件运行时，才进行统一更新。</p>
<p>iOS会在RunLoop中注册一个Observer，分别监听beforeWaiting和Exit状态，对应的回调为_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。在这两个状态中，系统会遍历容器中所有的UI更新请求，并统一渲染更新。</p>
<ul>
<li>定时器：</li>
</ul>
<p>NSTimer即为CFRunLoopTimerRef（timer对象）。注册NSTimer后，系统会在指定的触发时间在RunLoop中添加好timer事件及回调（由于有tolerance时间，不会特别准确，而且若回调timer时，线程正在执行繁重的任务，可能会导致此次调用被错过）。<br>CADisplayLink，是一个与屏幕刷新率相同的定时器（与NSTimer不同，内部为source对象）。功能上与timer相同，且仍然会被长任务卡住。</p>
<ul>
<li>PerformSelector：</li>
</ul>
<p>调用NSObject的performSelector:afterDelay:时，系统即创建一个timer并添加到线程的RunLoop中（与timer相同）。若此时线程没有RunLoop，则此方法无效（子线程需调用[[NSRunLoop currentRunLoop] run]才可）。</p>
<ul>
<li>GCD：</li>
</ul>
<p>主要是在dispatch_async(dispatch_get_main_queue(), block)中，libDispatch会发消息主动唤醒主线程的RunLoop，RunLoop即获取block并在<strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>()中执行这个block。但是在子线程的GCD异步函数中，还是直接由libDispatch进行处理。</p>
<ul>
<li>网络请求：</li>
</ul>
<p>iOS的网络请求此下而上分为：</p>
<blockquote>
<p>CFSocket    -&gt; 负责基本的socket通信<br>CFNetwork    -&gt; socket的封装（ASIHTTPRequest在这工作）<br>NSURLConnection    -&gt; AFNetworking 1.x<br>NSURLSession        -&gt; AFNetworking 2.x，Alamofire</p>
</blockquote>
<p>这里解释一下NSURLConnection的delegate不断被调用的原因，NSURLConnection的主要工作过程，看图先（摘自<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>）：</p>
<p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_network.png" alt="img"></p>
<p>NSURLConcentration在调用start开始请求后，delegate会获取请求线程的RunLoop对象，在其中的defaultMode中添加4个source0对象。其中CFMultiplexerSource负责delegate的各种回调，CFHTTPCookieStorage负责各种Cookie。<br>开始网络传输时，NSURLConcentration创建了两个新线程（上图中的CFSocket线程和ConnectionLoader线程），ConnectionLoader线程的RunLoop会接受底层socket线程的source1传递的消息，并通过请求线程的source0事件，唤醒请求线程并调用相应的delegate回调。</p>
<h3 id="实际应用举例："><a href="#实际应用举例：" class="headerlink" title="实际应用举例："></a>实际应用举例：</h3><ul>
<li>监听RunLoop的运行状态（添加observer到RunLoop）：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">CFAllocatorRef allocator = CFAllocatorGetDefault(); <span class="comment">// 内存开辟方式</span></div><div class="line">CFOptionFlags activites = kCFRunLoopAllActivities; <span class="comment">// 监控活动类型（这里是所有类型）</span></div><div class="line">Boolean repeats = <span class="literal">true</span>; <span class="comment">// 重复监听</span></div><div class="line">CFIndex order = <span class="number">0</span>; <span class="comment">// 优先级</span></div><div class="line"><span class="comment">// 给主线程的runloop添加observer</span></div><div class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(allocator, activites, repeats, order, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</div><div class="line">    <span class="keyword">switch</span> (activity) &#123;</div><div class="line">        <span class="keyword">case</span> kCFRunLoopEntry:</div><div class="line">            NSLog(@<span class="string">"runloop进入了~"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCFRunLoopBeforeTimers:</div><div class="line">            NSLog(@<span class="string">"准备执行timer了~"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCFRunLoopBeforeSources:</div><div class="line">            NSLog(@<span class="string">"准备执行source了~"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</div><div class="line">            NSLog(@<span class="string">"准备休眠了~"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCFRunLoopAfterWaiting:</div><div class="line">            NSLog(@<span class="string">"刚刚唤醒~"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCFRunLoopExit:</div><div class="line">            NSLog(@<span class="string">"退出了runloop~"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 添加observer到主runloop的defaultMode上</span></div><div class="line">CFRunLoopRef mainRunLoop = CFRunLoopGetMain();</div><div class="line">CFRunLoopMode runLoopMode = kCFRunLoopDefaultMode;</div><div class="line">CFRunLoopAddObserver(mainRunLoop, observer, runLoopMode);</div></pre></td></tr></table></figure>
<ul>
<li>设置定时器（添加timer到RunLoop）：</li>
</ul>
<ol>
<li>使用NSTimer在子线程创建：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    [NSTimer scheduledTimerWithTimeInterval:<span class="number">5</span> repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</div><div class="line">        NSLog(@<span class="string">"hahahah~"</span>);</div><div class="line">    &#125;];</div><div class="line">    <span class="comment">// 默认在子线程是不存在RunLoop的，必须告知系统创建</span></div><div class="line">    <span class="comment">// 且保持RunLoop不退出的前提是，存在一个item（timer、observer或source）</span></div><div class="line">    [[NSRunLoop currentRunLoop] run];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如上所示，不调用RunLoop的run方法，timer在子线程不会执行。</p>
<ol>
<li>使用GCD的dispatch的资源对象创建：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">/** 使用GCD添加的timer */</div><div class="line">@property (strong, nonatomic) dispatch_source_t timer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    [self addTimerToRunLoop];</div><div class="line">&#125;</div><div class="line"></div><div class="line">/** 向runloop上添加timer（这里是GCD方式） */</div><div class="line">- (void)addTimerToRunLoop &#123;</div><div class="line">//    dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">    dispatch_queue_t myQueue = dispatch_queue_create("com.jiji.my_queue", DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    </div><div class="line">//    dispatch_queue_t mainQueue = dispatch_get_main_queue();</div><div class="line">    </div><div class="line">    // 在队列中创建timer资源对象</div><div class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, myQueue);</div><div class="line">    // 保留timer（GCD不会保留timer资源对象）</div><div class="line">    self.timer = timer;</div><div class="line">    </div><div class="line">    </div><div class="line">    // 设置timer资源的间隔和宽容度</div><div class="line">    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</div><div class="line">    // 设置timer资源的事件回调</div><div class="line">    dispatch_source_set_event_handler(timer, ^&#123;</div><div class="line">        NSLog(@"==%@==", [NSThread currentThread]);</div><div class="line">    &#125;);</div><div class="line">    // 启动timer资源</div><div class="line">    dispatch_resume(timer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)cancelTimer &#123;</div><div class="line">    dispatch_cancel(self.timer);</div><div class="line">    self.timer = nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注意，使用GCD的方式创建timer，系统不会保留dispatch_source_t对象，需要自己保留，否则创建后会直接释放。取消时使用dispatch_cancel()。</p>
<ul>
<li>performSelector测试：</li>
</ul>
<p>在子线程中调用performSelector：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// backgroundThread</span></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="comment">// 相当于直接调用（没有通过runloop直接同步执行）</span></div><div class="line">    [self performSelector:@selector(performTask) withObject:nil];</div><div class="line"></div><div class="line">    NSLog(@<span class="string">"before ---- %@"</span>, [NSRunLoop currentRunLoop]);</div><div class="line"></div><div class="line">    <span class="comment">// 直接调用不执行（runloop没有启动）</span></div><div class="line">    <span class="comment">// 实际上是在runloop的mode中加入了source0和source1两个事件</span></div><div class="line">    [self performSelector:@selector(performTask) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</div><div class="line"></div><div class="line">    NSLog(@<span class="string">"after ==== %@"</span>, [NSRunLoop currentRunLoop]);</div><div class="line"></div><div class="line">    <span class="comment">// 启动runloop</span></div><div class="line">    [[NSRunLoop currentRunLoop] run];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>线程“保活”：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">/** 保证不结束的自定义线程 */</div><div class="line">@property (strong, nonatomic) NSThread *liveThread;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    // 保活线程测试</div><div class="line">    [self liveThreadTest];    </div><div class="line">&#125;</div><div class="line"></div><div class="line">/** 长时间存活的线程 */</div><div class="line">- (void)liveThreadTest &#123;</div><div class="line">    self.liveThread = [[NSThread alloc] initWithTarget:self selector:@selector(startLiveThread) object:nil];</div><div class="line">    [self.liveThread start];</div><div class="line">    // 点击一次屏幕，执行一次线程的任务</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)startLiveThread &#123;</div><div class="line">    NSLog(@"%@", NSStringFromSelector(_cmd));</div><div class="line">    // 在自定义线程中添加一个source1对象（这里是NSPort对象）到runloop中</div><div class="line">    // 并启动runloop</div><div class="line">    // 以保证runloop一直有任务而不退出</div><div class="line">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">    [[NSRunLoop currentRunLoop] run];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)liveThreadTask &#123;</div><div class="line">    NSLog(@"%@", NSStringFromSelector(_cmd));</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;    </div><div class="line">    // 在自定义线程中执行任务</div><div class="line">    [self performSelector:@selector(liveThreadTask) onThread:self.liveThread withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<ul>
<li>在scrollView滑动时，也可以执行主线程的定时器：</li>
</ul>
<p>将timer添加到主线程RunLoop的commonMode中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:<span class="number">0.5</span> repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</div><div class="line">    NSLog(@<span class="string">"timer---"</span>);</div><div class="line">&#125;];</div><div class="line">[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="external">Run Loops</a></li>
<li><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></li>
<li><a href="http://www.cnblogs.com/kenshincui/p/6823841.html" target="_blank" rel="external">iOS刨根问底-深入理解RunLoop</a></li>
<li><a href="http://www.imlifengfeng.com/blog/?p=487" target="_blank" rel="external">iOS RunLoop详解</a></li>
<li><a href="http://www.jb51.net/article/123505.htm" target="_blank" rel="external">Dispatch Source Timer的使用及注意事项介绍</a></li>
<li><a href="https://www.jianshu.com/p/536184bfd163" target="_blank" rel="external">IOS—实例化讲解RunLoop
</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RunLoop简介及与线程的关系：&quot;&gt;&lt;a href=&quot;#RunLoop简介及与线程的关系：&quot; class=&quot;headerlink&quot; title=&quot;RunLoop简介及与线程的关系：&quot;&gt;&lt;/a&gt;RunLoop简介及与线程的关系：&lt;/h3&gt;&lt;p&gt;简而言之，RunLoop就是一个“do-while”循环–一个事件队列循环。循环时，系统会依次从事件队列中取出事件并执行；没有事件处理时，RunLoop会进入休眠，等待事件唤醒处理，以节省系统资源，即“休眠-&amp;gt;事件唤醒-&amp;gt;处理事件-&amp;gt;休眠…”的逻辑。&lt;/p&gt;
&lt;p&gt;在iOS中，RunLoop存在的类为CFRunLoopRef和NSRunLoop。前者为CoreFoundation框架，C语言编写，线程安全；后者是OC封装，线程不安全。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS GCD学习总结</title>
    <link href="http://yoursite.com/2018/03/05/ios_GCD_learning/"/>
    <id>http://yoursite.com/2018/03/05/ios_GCD_learning/</id>
    <published>2018-03-05T03:20:48.000Z</published>
    <updated>2018-05-15T02:17:32.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCD是苹果以C语言编写、从队列和任务的角度设计的多线程编程框架。避免了开发者直接操作线程，降低了因操作不当导致的多线程性能下降、死锁等情况的可能性。使用GCD，可以降低多线程开发的门槛，最大限度地提升APP性能，开发人员可以专注于业务的开发。（注：在swift中，苹果重写了GCD，api均为swift接口，保持了开发语言的一致性。）"><a href="#GCD是苹果以C语言编写、从队列和任务的角度设计的多线程编程框架。避免了开发者直接操作线程，降低了因操作不当导致的多线程性能下降、死锁等情况的可能性。使用GCD，可以降低多线程开发的门槛，最大限度地提升APP性能，开发人员可以专注于业务的开发。（注：在swift中，苹果重写了GCD，api均为swift接口，保持了开发语言的一致性。）" class="headerlink" title="GCD是苹果以C语言编写、从队列和任务的角度设计的多线程编程框架。避免了开发者直接操作线程，降低了因操作不当导致的多线程性能下降、死锁等情况的可能性。使用GCD，可以降低多线程开发的门槛，最大限度地提升APP性能，开发人员可以专注于业务的开发。（注：在swift中，苹果重写了GCD，api均为swift接口，保持了开发语言的一致性。）"></a>GCD是苹果以C语言编写、从队列和任务的角度设计的多线程编程框架。避免了开发者直接操作线程，降低了因操作不当导致的多线程性能下降、死锁等情况的可能性。使用GCD，可以降低多线程开发的门槛，最大限度地提升APP性能，开发人员可以专注于业务的开发。（注：在swift中，苹果重写了GCD，api均为swift接口，保持了开发语言的一致性。）</h2><a id="more"></a>
<h3 id="主要组成："><a href="#主要组成：" class="headerlink" title="主要组成："></a>主要组成：</h3><ul>
<li>队列：主要分为<strong>串行队列</strong>和<strong>并发队列</strong>两种。在iOS系统中，系统预先提供了两个现成可以直接使用的队列，分别是<strong>主队列</strong>和<strong>全局队列</strong>，其中<strong>主队列</strong>即我们常说的APP主线程。</li>
<li>任务：在OC中以<strong>block</strong>作为单位，分为<strong>“同步任务”</strong>和<strong>“异步任务”</strong>。</li>
</ul>
<p>其中，队列和任务可以根据需要随意组合使用。</p>
<h3 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h3><h4 id="创建和获取队列："><a href="#创建和获取队列：" class="headerlink" title="创建和获取队列："></a>创建和获取队列：</h4><ul>
<li>创建串行队列：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t myQueue = dispatch_queue)create(&quot;com.jiji.my_queue&quot;, DISPATCH_QUEUE_SERIAL);</div></pre></td></tr></table></figure>
<p>串行队列即为单任务队列，任务只能按加入顺序执行。</p>
<ul>
<li>创建并发队列：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t myQueue = dispatch_queue)create(&quot;com.jiji.my_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<p>并发队列，同时可以执行多个任务。</p>
<ul>
<li>获取主队列：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</div></pre></td></tr></table></figure>
<p>主队列，UI操作都在这个队列上进行。</p>
<ul>
<li>获取全局队列：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div></pre></td></tr></table></figure>
<p>其中，全局队列的第一参数为优先级，这里默认为default，第二个参数为预留参数。我们一般可以在这个队列中处理一些耗时任务，如网络请求、IO等。</p>
<h4 id="向队列中派发任务并执行任务："><a href="#向队列中派发任务并执行任务：" class="headerlink" title="向队列中派发任务并执行任务："></a>向队列中派发任务并执行任务：</h4><p>创建同步或异步任务时，都需要指定派发到的队列。</p>
<ul>
<li>串行队列 + 同步任务：</li>
</ul>
<p>本质上是在派发任务所在的线程中（不创建新线程），依次执行任务，完成一个后执行下一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</div><div class="line">dispatch_queue_t myQueue = dispatch_queue_create(&quot;com.jiji.my_queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;block 1---- %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;block 2---- %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;block 3---- %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 14:00:56.434341+0800 Thread_Test2[5813:216673] current thread = <nsthread: 0x600000068f00="">{number = 1, name = main}<br>2018-03-05 14:00:58.435759+0800 Thread_Test2[5813:216673] block 1—- <nsthread: 0x600000068f00="">{number = 1, name = main}<br>2018-03-05 14:01:00.437177+0800 Thread_Test2[5813:216673] block 2—- <nsthread: 0x600000068f00="">{number = 1, name = main}<br>2018-03-05 14:01:02.438452+0800 Thread_Test2[5813:216673] block 3—- <nsthread: 0x600000068f00="">{number = 1, name = main}</nsthread:></nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>从上面的例子可以看出，向串行队列中派发的同步任务，执行时并没有开启新的线程，只是在当前线程中直接执行（这里是在主线程向队列派发任务，所以直接在主线程执行）。</p>
<ul>
<li>串行队列 + 异步任务：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</div><div class="line">dispatch_queue_t myQueue = dispatch_queue_create(&quot;com.jiji.my_queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;block 1---- %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;block 2---- %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;block 3---- %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 14:08:13.786385+0800 Thread_Test2[5952:225569] current thread = <nsthread: 0x60400007c340="">{number = 1, name = main}<br>2018-03-05 14:08:15.787681+0800 Thread_Test2[5952:225858] block 1—- <nsthread: 0x60000027d680="">{number = 3, name = (null)}<br>2018-03-05 14:08:17.788864+0800 Thread_Test2[5952:225858] block 2—- <nsthread: 0x60000027d680="">{number = 3, name = (null)}<br>2018-03-05 14:08:19.790784+0800 Thread_Test2[5952:225858] block 3—- <nsthread: 0x60000027d680="">{number = 3, name = (null)}</nsthread:></nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>可以看到，向串行队列中派发异步任务，任务会在新线程中执行依次执行（系统单独创建了新线程）。</p>
<ul>
<li>并发队列 + 同步任务：</li>
</ul>
<p>这个要与“串行队列+同步”对比着来看：<br>直接在同一队列中向并发队列派发同步任务时（如都在主线程直接往队列中派发同步任务），结果是相同的，都是依次执行任务，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 创建并发队列</div><div class="line">dispatch_queue_t myQueue = dispatch_queue_create(&quot;com.jiji.myQueue1&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">// 添加同步任务</div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block0---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:5];</div><div class="line">    NSLog(@&quot;finished block0!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    sleep(2);</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 14:53:14.154154+0800 Thread_Test2[6775:272681] start block0———<nsthread: 0x6000000641c0="">{number = 1, name = main}<br>2018-03-05 14:53:19.156046+0800 Thread_Test2[6775:272681] finished block0!!!!!!!!<br>2018-03-05 14:53:19.156402+0800 Thread_Test2[6775:272681] start block1———<nsthread: 0x6000000641c0="">{number = 1, name = main}<br>2018-03-05 14:53:21.157883+0800 Thread_Test2[6775:272681] finished block1!!!!!!!!<br>2018-03-05 14:53:21.158132+0800 Thread_Test2[6775:272681] start block2———<nsthread: 0x6000000641c0="">{number = 1, name = main}<br>2018-03-05 14:53:23.159384+0800 Thread_Test2[6775:272681] finished block2!!!!!!!!<br>2018-03-05 14:53:23.159621+0800 Thread_Test2[6775:272681] start block3———<nsthread: 0x6000000641c0="">{number = 1, name = main}<br>2018-03-05 14:53:25.160953+0800 Thread_Test2[6775:272681] finished block3!!!!!!!!</nsthread:></nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>看起来与“串行队列+同步”没有什么区别，这是由于派发任务（可以看做从上到下执行代码，将block加入）都在同一队列（这里是主线程）中执行。</p>
<p>但是，当我们在不同的队列（即不同线程）中同时向你的并发队列中派发同步任务时，结果就不同了（这里才真正体现出了并发队列的并发性，即同时执行任务）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// 创建并发队列</div><div class="line">dispatch_queue_t myQueue = dispatch_queue_create(&quot;com.jiji.myQueue1&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">// 添加同步任务</div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block0---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:5];</div><div class="line">    NSLog(@&quot;finished block0!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 在全局队列中向自定义队列中派发同步任务</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">//        NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</div><div class="line"></div><div class="line">    // 添加同步任务</div><div class="line">    dispatch_sync(myQueue, ^&#123;</div><div class="line">        NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">        [NSThread sleepForTimeInterval:2];</div><div class="line">        NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    sleep(2);</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 14:59:05.769961+0800 Thread_Test2[6879:280233] start block0———<nsthread: 0x600000069080="">{number = 1, name = main}<br>2018-03-05 14:59:10.770410+0800 Thread_Test2[6879:280233] finished block0!!!!!!!!<br>2018-03-05 14:59:10.770848+0800 Thread_Test2[6879:280233] start block2———<nsthread: 0x600000069080="">{number = 1, name = main}<br>2018-03-05 14:59:10.770956+0800 Thread_Test2[6879:280344] start block1———<nsthread: 0x600000273880="">{number = 3, name = (null)}<br>2018-03-05 14:59:12.771788+0800 Thread_Test2[6879:280233] finished block2!!!!!!!!<br>2018-03-05 14:59:12.772043+0800 Thread_Test2[6879:280233] start block3———<nsthread: 0x600000069080="">{number = 1, name = main}<br>2018-03-05 14:59:12.772084+0800 Thread_Test2[6879:280344] finished block1!!!!!!!!<br>2018-03-05 14:59:14.772608+0800 Thread_Test2[6879:280233] finished block3!!!!!!!!</nsthread:></nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>可以看到，执行任务的顺序为“0-2-1-3”（这里是由于block1是在其他线程中派发所致），但是执行时，仔细观察，在同一线程中执行的任务，都是依次执行并完成（与串行队列相同），<strong>但是在不同线程中（block1和block2所在线程），block是并行执行的，这里体现了并发队列的并发性</strong>。所以不能武断地认定“并发队列+同步”与“串行队列+同步”效果相同。这里需要尤其注意！（作为对比，“串行队列+同步”的情况下，在不同线程中派发同步任务，虽然派发顺序可能不同，但任务依然是串行执行，童鞋们请自行验证~）</p>
<ul>
<li>并发队列 + 异步任务：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_async(globalQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(globalQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(globalQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 15:14:22.892746+0800 Thread_Test2[7097:295593] start block1———<nsthread: 0x604000465fc0="">{number = 3, name = (null)}<br>2018-03-05 15:14:22.892746+0800 Thread_Test2[7097:295584] start block2———<nsthread: 0x600000271cc0="">{number = 4, name = (null)}<br>2018-03-05 15:14:22.892756+0800 Thread_Test2[7097:295582] start block3———<nsthread: 0x6000002718c0="">{number = 5, name = (null)}<br>2018-03-05 15:14:24.897942+0800 Thread_Test2[7097:295584] finished block2!!!!!!!!<br>2018-03-05 15:14:24.897947+0800 Thread_Test2[7097:295582] finished block3!!!!!!!!<br>2018-03-05 15:14:24.897942+0800 Thread_Test2[7097:295593] finished block1!!!!!!!!</nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>可以看到，系统开启了三个新线程，同时执行了任务，即“并发+异步”。</p>
<blockquote>
<p>综上所述，</p>
<p><em>“同步”</em>与<em>“异步”</em>的关键是<strong>是否开启新线程</strong>；</p>
<p><em>“串行”</em>与<em>“并发”</em>的关键是<strong>是否可以同时执行任务</strong>。</p>
</blockquote>
<p><em>特别情况–“主队列”</em>：</p>
<ul>
<li>主队列 + 同步任务：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</div><div class="line">dispatch_sync(mainQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_sync(mainQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_sync(mainQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：直接死锁。</p>
<p>死锁原因：由于同步任务的执行顺序是“派发任务1-&gt;执行任务1-&gt;派发任务2-&gt;执行任务2…”，即下一个任务的派发要在上一个任务完成之后才能继续。然而，在主队列中，被派发的任务（block对象）会添加到主队列的末端。此时，<strong>派发任务函数没有返回（没有执行完成），会给主队列的线程加锁；新添加的任务由于在末端，前面的任务没有完成，就没有机会执行，也就不能返回；派发任务函数就不可能再继续往下执行（互相依赖），从而造成死锁</strong>。</p>
<p>解决方案：在其他队列（非主线程）中向主队列派发同步任务，或在主队列中派发异步任务。</p>
<p>同样，在串行队列自身内部派发同步任务（“异步任务嵌套同步”或“同步任务嵌套同步”），同样会导致死锁。</p>
<ul>
<li>主队列 + 异步任务：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</div><div class="line">dispatch_async(mainQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(mainQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(mainQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 15:57:48.249706+0800 Thread_Test2[7880:347161] start block1———<nsthread: 0x604000065d00="">{number = 1, name = main}<br>2018-03-05 15:57:50.250190+0800 Thread_Test2[7880:347161] finished block1!!!!!!!!<br>2018-03-05 15:57:50.250654+0800 Thread_Test2[7880:347161] start block2———<nsthread: 0x604000065d00="">{number = 1, name = main}<br>2018-03-05 15:57:52.251663+0800 Thread_Test2[7880:347161] finished block2!!!!!!!!<br>2018-03-05 15:57:52.252088+0800 Thread_Test2[7880:347161] start block3———<nsthread: 0x604000065d00="">{number = 1, name = main}<br>2018-03-05 15:57:54.253489+0800 Thread_Test2[7880:347161] finished block3!!!!!!!!</nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>可见，在主队列派发异步任务，是在主线程同步执行（<strong>主队列中执行异步任务不会开启新线程</strong>）。</p>
<h4 id="延迟执行任务："><a href="#延迟执行任务：" class="headerlink" title="延迟执行任务："></a>延迟执行任务：</h4><p>使用Dispatch_after函数和dispatch_time_t变量，向指定队列添加延迟指定时间执行的异步任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;start-----&quot;);</div><div class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</div><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)3.0 * NSEC_PER_SEC);</div><div class="line">dispatch_after(time, mainQueue, ^&#123;</div><div class="line">    NSLog(@&quot;executing block!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;end======&quot;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 16:34:15.672982+0800 Thread_Test2[8449:389175] start—–<br>2018-03-05 16:34:15.673193+0800 Thread_Test2[8449:389175] end======<br>2018-03-05 16:34:18.673343+0800 Thread_Test2[8449:389175] executing block!!!!!!!!</p>
</blockquote>
<h4 id="只执行一次的任务（线程安全）："><a href="#只执行一次的任务（线程安全）：" class="headerlink" title="只执行一次的任务（线程安全）："></a>只执行一次的任务（线程安全）：</h4><p>使用Dispatch_once函数和静态的dispatch_once_t变量实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">    NSLog(@&quot;正在执行~~ %ld&quot;, onceToken);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;%ld&quot;, onceToken);</div></pre></td></tr></table></figure>
<p>连续执行两次，执行结果：</p>
<blockquote>
<p>2018-03-05 17:14:38.877559+0800 Thread_Test2[9012:424274] 正在执行~~ 1024<br>2018-03-05 17:14:38.877732+0800 Thread_Test2[9012:424274] -1<br>2018-03-05 17:14:41.878217+0800 Thread_Test2[9012:424274] -1</p>
</blockquote>
<p>由于onceToken变量为静态或全局变量，执行一次后会赋值为-1，以后即不会执行，dispatch_once函数可以保证在整个app运行期间只执行一次，且多线程安全（多线程同时调用时会同步执行，block执行完毕后才返回）。常用于单例设计中。</p>
<h4 id="栅栏任务（任务分隔）："><a href="#栅栏任务（任务分隔）：" class="headerlink" title="栅栏任务（任务分隔）："></a>栅栏任务（任务分隔）：</h4><ul>
<li>dispatch_barrier_async:</li>
</ul>
<p>使用dispatch_barrier_async函数派发的任务将队列中之前和之后的异步任务分隔开（执行完此栅栏任务才执行后面的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t myQueue = dispatch_queue_create(&quot;com.jiji.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_barrier_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start barrier block---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished barrier block-=-=-=-=&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block4---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block4!!!!!!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 17:50:53.017995+0800 Thread_Test2[9520:461498] start block1———<nsthread: 0x604000470ac0="">{number = 3, name = (null)}<br>2018-03-05 17:50:53.017995+0800 Thread_Test2[9520:461499] start block2———<nsthread: 0x604000470b00="">{number = 4, name = (null)}<br>2018-03-05 17:50:55.019075+0800 Thread_Test2[9520:461498] finished block1!!!!!!!!<br>2018-03-05 17:50:55.019075+0800 Thread_Test2[9520:461499] finished block2!!!!!!!!<br>2018-03-05 17:50:55.019459+0800 Thread_Test2[9520:461499] start barrier block———<nsthread: 0x604000470b00="">{number = 4, name = (null)}<br>2018-03-05 17:50:57.021234+0800 Thread_Test2[9520:461499] finished barrier block-=-=-=-=<br>2018-03-05 17:50:57.021626+0800 Thread_Test2[9520:461499] start block3———<nsthread: 0x604000470b00="">{number = 4, name = (null)}<br>2018-03-05 17:50:57.021644+0800 Thread_Test2[9520:461498] start block4———<nsthread: 0x604000470ac0="">{number = 3, name = (null)}<br>2018-03-05 17:50:59.025274+0800 Thread_Test2[9520:461499] finished block3!!!!!!!!<br>2018-03-05 17:50:59.025250+0800 Thread_Test2[9520:461498] finished block4!!!!!!!!</nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>注意：dispatch_barrier_async所派发到的队列<strong>必须是自己创建的并发队列</strong>，才会起到分隔作用，<strong>在串行或自带的全局队列中派发相当于普通的dispatch_async异步函数</strong>。</p>
<ul>
<li>dispatch_barrier_sync:</li>
</ul>
<p>与async版本大致作用相同，都是在自己的异步队列中起到分隔任务执行的作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t myQueue = dispatch_queue_create(&quot;com.jiji.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_barrier_sync(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start barrier block---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished barrier block-=-=-=-=&quot;);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;aaa----&quot;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;bbb===&quot;);</div><div class="line">dispatch_async(myQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block4---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block4!!!!!!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 18:20:42.129155+0800 Thread_Test2[9940:497853] start block2———<nsthread: 0x60400026e280="">{number = 4, name = (null)}<br>2018-03-05 18:20:42.129156+0800 Thread_Test2[9940:497854] start block1———<nsthread: 0x600000274180="">{number = 3, name = (null)}<br>2018-03-05 18:20:44.133480+0800 Thread_Test2[9940:497853] finished block2!!!!!!!!<br>2018-03-05 18:20:44.133480+0800 Thread_Test2[9940:497854] finished block1!!!!!!!!<br>2018-03-05 18:20:44.134002+0800 Thread_Test2[9940:497766] start barrier block———<nsthread: 0x6000000698c0="">{number = 1, name = main}<br>2018-03-05 18:20:46.134747+0800 Thread_Test2[9940:497766] finished barrier block-=-=-=-=<br>2018-03-05 18:20:46.136687+0800 Thread_Test2[9940:497766] aaa—-<br>2018-03-05 18:20:46.138866+0800 Thread_Test2[9940:497766] bbb===<br>2018-03-05 18:20:46.138930+0800 Thread_Test2[9940:497853] start block3———<nsthread: 0x60400026e280="">{number = 4, name = (null)}<br>2018-03-05 18:20:46.144088+0800 Thread_Test2[9940:497851] start block4———<nsthread: 0x600000273c80="">{number = 5, name = (null)}<br>2018-03-05 18:20:48.150834+0800 Thread_Test2[9940:497853] finished block3!!!!!!!!<br>2018-03-05 18:20:48.151900+0800 Thread_Test2[9940:497851] finished block4!!!!!!!!</nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>可见，与async作用大体一致，都是分隔两组任务的执行。区别是：“aaa”和“bbb”的输出是在barrier的任务完成之后。也就是说，<strong>dispatch_barrier_sync派发任务会阻碍当前线程运行，直到barrier的任务完成返回后再继续执行后面的代码</strong>（主线程任务和后面的派发）；而async的版本不会阻碍当前线程执行（会直接先输出“aaa”和“bbb”）。此外，<strong>在串行队列或自带的全局队列中派发barrier任务，相当于dispatch_sync</strong>。</p>
<h4 id="迭代派发任务："><a href="#迭代派发任务：" class="headerlink" title="迭代派发任务："></a>迭代派发任务：</h4><p>使用dispatch_apply函数可以向队列中迭代派发多个任务，相当于GCD版本的for循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//    dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">//    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.jiji.my_serial_queue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.jiji.my_concurrent_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_apply((size_t)5, concurrentQueue, ^(size_t index) &#123;</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;apply -- %ld, thread = %@&quot;, index, [NSThread currentThread]);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;finished---&quot;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 21:26:02.462338+0800 Thread_Test2[11015:575150] apply – 0, thread = <nsthread: 0x60400007b040="">{number = 1, name = main}<br>2018-03-05 21:26:02.464843+0800 Thread_Test2[11015:575416] apply – 1, thread = <nsthread: 0x60000046ed80="">{number = 5, name = (null)}<br>2018-03-05 21:26:02.464840+0800 Thread_Test2[11015:575417] apply – 2, thread = <nsthread: 0x6040002763c0="">{number = 3, name = (null)}<br>2018-03-05 21:26:02.464854+0800 Thread_Test2[11015:575418] apply – 3, thread = <nsthread: 0x604000276280="">{number = 4, name = (null)}<br>2018-03-05 21:26:04.463205+0800 Thread_Test2[11015:575150] apply – 4, thread = <nsthread: 0x60400007b040="">{number = 1, name = main}<br>2018-03-05 21:26:04.463406+0800 Thread_Test2[11015:575150] finished—</nsthread:></nsthread:></nsthread:></nsthread:></nsthread:></p>
</blockquote>
<p>如上所示：</p>
<ul>
<li>在并发队列或全局队列中，dispatch_apply会派发size_t数量的异步任务，同时阻塞派发线程，待迭代的所有任务全部完成后继续向下执行（并发队列里是并发执行）。同时，系统会动态创建并分配任务的执行线程，防止线程的大量创建，优化多线程执行效率。</li>
<li>在串行队列中，直接按照dispatch_sync同步任务，在派发线程中串行执行。</li>
<li>在主队列中，死锁（主线程派发同步任务导致）。</li>
</ul>
<blockquote>
<p>应用场景：<br>以像素为单位的image处理（防止线程爆炸）；<br>字典转模型（并发队列，异步处理后，回到主线程）</p>
</blockquote>
<h4 id="队列组："><a href="#队列组：" class="headerlink" title="队列组："></a>队列组：</h4><p>以组的形式管理多个队列执行任务：</p>
<ul>
<li>支持以dispatch_group_async的方式派发异步任务到组中；（dispatch_group_enter和dispatch_group_leave与dispatch_async配合使用效果相同）</li>
<li>支持以dispatch_group_wait的方式阻塞当前队列组，直到执行完成所有派发的任务或到达超时时间后再继续向下执行（完成和超时后，队列组会清空）；</li>
<li>dispatch_group_notify派发的任务在所有组任务完成后执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">// 创建组</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line"></div><div class="line">// 派发到全局队列中的异步任务，添加到组中</div><div class="line">dispatch_group_async(group, globalQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block1---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block1!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 以dispatch_group_enter的方式添加异步任务到组中</div><div class="line">dispatch_group_enter(group);</div><div class="line">dispatch_async(globalQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block2---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block2!!!!!!!!&quot;);</div><div class="line">    </div><div class="line">    // dispatch_group_leave从组中移除任务</div><div class="line">    dispatch_group_leave(group);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 等待任务（这里是等待组中的任务全部完成）</div><div class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line"></div><div class="line">// 派发到全局队列中的异步任务，添加到组中</div><div class="line">dispatch_group_async(group, globalQueue, ^&#123;</div><div class="line">    NSLog(@&quot;start block3---------%@&quot;, [NSThread currentThread]);</div><div class="line">    [NSThread sleepForTimeInterval:2];</div><div class="line">    NSLog(@&quot;finished block3!!!!!!!!&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 全部执行完毕，切换回主线程执行</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;finished all!!!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 22:25:57.183194+0800 Thread_Test2[11842:630278] start block2———<nsthread: 0x60400027f800="">{number = 5, name = (null)}<br>2018-03-05 22:25:57.183195+0800 Thread_Test2[11842:630275] start block1———<nsthread: 0x6000004765c0="">{number = 4, name = (null)}<br>2018-03-05 22:25:59.184596+0800 Thread_Test2[11842:630275] finished block1!!!!!!!!<br>2018-03-05 22:25:59.184662+0800 Thread_Test2[11842:630278] finished block2!!!!!!!!<br>2018-03-05 22:25:59.185201+0800 Thread_Test2[11842:630278] start block3———<nsthread: 0x60400027f800="">{number = 5, name = (null)}<br>2018-03-05 22:26:01.189667+0800 Thread_Test2[11842:630278] finished block3!!!!!!!!<br>2018-03-05 22:26:01.189929+0800 Thread_Test2[11842:630025] finished all!!!</nsthread:></nsthread:></nsthread:></p>
</blockquote>
<h4 id="信号量："><a href="#信号量：" class="headerlink" title="信号量："></a>信号量：</h4><p><strong>信号量是一种基于计数器的多线程同步机制，用来管理对资源的并发访问。</strong></p>
<p>计数器为原子性的值，可以保证多线程安全，使用时，分为两种情况：</p>
<ol>
<li>初始值为0时，可以把两个线程的异步任务变为同步任务（控制先后执行顺序，线程同步）；</li>
<li>初始值大于0时，可以限制队列中的并发任务数（是几则同时可以有几个任务并发执行）；</li>
</ol>
<p>相关函数：</p>
<ul>
<li>dispatch_semaphore_create(value)：创建信号量（参数为并发数）</li>
<li>dispatch_semaphore_wait(semaphore)：抢占资源，信号量值-1</li>
<li>dispatch_semaphore_signal(semaphore)：释放资源，信号量值+1</li>
</ul>
<p>相关实例：</p>
<ul>
<li>“异步”变“同步”：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</div><div class="line"></div><div class="line">__block int number = 0;</div><div class="line"></div><div class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_async(globalQueue, ^&#123;</div><div class="line">    number = 100;</div><div class="line">    // 信号值+1，恢复派发线程继续执行</div><div class="line">    dispatch_semaphore_signal(semaphore);</div><div class="line">&#125;);</div><div class="line">// 初值是0，即为阻塞当前线程，一直等待</div><div class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">NSLog(@&quot;number = %d&quot;, number);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 23:02:29.855585+0800 Thread_Test2[12363:659768] number = 100</p>
</blockquote>
<ul>
<li>控制并发线程数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">// 同时只允许一个线程执行任务</div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">    dispatch_async(globalQueue, ^&#123;</div><div class="line">        // 抢占资源（-1）</div><div class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">        NSLog(@&quot;index = %d, semaphore = %@&quot;, i, semaphore);</div><div class="line">        // 释放资源（+1）</div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>2018-03-05 23:20:34.300704+0800 Thread_Test2[12777:682814] index = 0, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.300918+0800 Thread_Test2[12777:682816] index = 1, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.301175+0800 Thread_Test2[12777:682815] index = 2, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.302360+0800 Thread_Test2[12777:682813] index = 3, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.303131+0800 Thread_Test2[12777:682814] index = 5, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.304928+0800 Thread_Test2[12777:682826] index = 4, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.305489+0800 Thread_Test2[12777:682816] index = 6, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.306229+0800 Thread_Test2[12777:682827] index = 7, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.306518+0800 Thread_Test2[12777:682829] index = 8, semaphore = <os_dispatch_semaphore: 0x604000291b70=""><br>2018-03-05 23:20:34.306642+0800 Thread_Test2[12777:682828] index = 9, semaphore = <os_dispatch_semaphore: 0x604000291b70=""></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></os_dispatch_semaphore:></p>
</blockquote>
<p><strong>信号量初值为1时，即为线程加锁</strong>（前一个任务抢占资源后，下一个异步任务执行时，由于信号量值为0，线程进入等待状态，知道前一任务释放资源后继续执行）。</p>
<ul>
<li>保证数据的线程安全：</li>
</ul>
<p>实例：两个窗口的卖票问题（多线程间的数据共享与一致性）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">&#123;</div><div class="line">    /** 同步卖票系统的信号量 */</div><div class="line">    dispatch_semaphore_t _ticketSemaphore;</div><div class="line">    /** 余票总数 */</div><div class="line">    int _surplusTicketsCount;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">	[self initTicketStatus];</div><div class="line">&#125;</div><div class="line">/** 初始化票及窗口信息 */</div><div class="line">- (void)initTicketStatus &#123;</div><div class="line">    // 每个售票口都是按顺序卖票，所以是串行队列</div><div class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.my_queue1&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.my_queue2&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    </div><div class="line">    // 共50张票</div><div class="line">    _surplusTicketsCount = 50;</div><div class="line">    </div><div class="line">    // 信号量同步两个窗口（同时只能一个窗口操作）</div><div class="line">    _ticketSemaphore = dispatch_semaphore_create(1);</div><div class="line">    </div><div class="line">    // 两个窗口同时开卖（每个队列异步执行卖票任务）</div><div class="line">    __weak typeof(self) weakSelf = self;</div><div class="line">    dispatch_async(queue1, ^&#123;</div><div class="line">        [weakSelf saleTicket];</div><div class="line">    &#125;);</div><div class="line">    dispatch_async(queue2, ^&#123;</div><div class="line">        [weakSelf saleTicket];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)saleTicket &#123;</div><div class="line">    while (1) &#123;</div><div class="line">        // 获取资源（-1），此时信号量值为0，加锁</div><div class="line">        dispatch_semaphore_wait(_ticketSemaphore, DISPATCH_TIME_FOREVER);</div><div class="line">        </div><div class="line">        if (_surplusTicketsCount &gt; 0) &#123;</div><div class="line">            _surplusTicketsCount -= 1;</div><div class="line">            NSLog(@&quot;剩余票数：%d，窗口为：%@&quot;,</div><div class="line">                  _surplusTicketsCount,</div><div class="line">                  [NSThread currentThread]</div><div class="line">            );</div><div class="line">//            [NSThread sleepForTimeInterval:0.2];  // 不加延时时，多线程访问的顺序和值都有问题</div><div class="line">            </div><div class="line">            // 解锁(+1)，恢复资源</div><div class="line">            dispatch_semaphore_signal(_ticketSemaphore);</div><div class="line">        &#125; else &#123;</div><div class="line">            NSLog(@&quot;票已卖完，剩余票数：%d&quot;, _surplusTicketsCount);</div><div class="line">            </div><div class="line">            // 解锁(+1)，恢复资源</div><div class="line">            dispatch_semaphore_signal(_ticketSemaphore);</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>执行结果：两个队列任务依次执行，且执行时，余票信息正常输出。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><a href="https://www.jianshu.com/p/2d57c72016c6" target="_blank" rel="external">iOS多线程：『GCD』详尽总结</a></li>
<li><a href="http://blog.csdn.net/liuyang11908/article/details/70757534" target="_blank" rel="external"> iOS GCD之dispatch_semaphore（信号量）</a></li>
<li><a href="http://blog.csdn.net/u013046795/article/details/47057585" target="_blank" rel="external">通过GCD中的dispatch<em>barrier</em>(a)sync加强对sync中所谓等待的理解</a></li>
<li><a href="http://www.cocoachina.com/bbs/read.php?tid=1482884" target="_blank" rel="external">GCD中在主线程中用同步函数分派任务到串行队列中会产生死锁是什么原因？</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GCD是苹果以C语言编写、从队列和任务的角度设计的多线程编程框架。避免了开发者直接操作线程，降低了因操作不当导致的多线程性能下降、死锁等情况的可能性。使用GCD，可以降低多线程开发的门槛，最大限度地提升APP性能，开发人员可以专注于业务的开发。（注：在swift中，苹果重写了GCD，api均为swift接口，保持了开发语言的一致性。）&quot;&gt;&lt;a href=&quot;#GCD是苹果以C语言编写、从队列和任务的角度设计的多线程编程框架。避免了开发者直接操作线程，降低了因操作不当导致的多线程性能下降、死锁等情况的可能性。使用GCD，可以降低多线程开发的门槛，最大限度地提升APP性能，开发人员可以专注于业务的开发。（注：在swift中，苹果重写了GCD，api均为swift接口，保持了开发语言的一致性。）&quot; class=&quot;headerlink&quot; title=&quot;GCD是苹果以C语言编写、从队列和任务的角度设计的多线程编程框架。避免了开发者直接操作线程，降低了因操作不当导致的多线程性能下降、死锁等情况的可能性。使用GCD，可以降低多线程开发的门槛，最大限度地提升APP性能，开发人员可以专注于业务的开发。（注：在swift中，苹果重写了GCD，api均为swift接口，保持了开发语言的一致性。）&quot;&gt;&lt;/a&gt;GCD是苹果以C语言编写、从队列和任务的角度设计的多线程编程框架。避免了开发者直接操作线程，降低了因操作不当导致的多线程性能下降、死锁等情况的可能性。使用GCD，可以降低多线程开发的门槛，最大限度地提升APP性能，开发人员可以专注于业务的开发。（注：在swift中，苹果重写了GCD，api均为swift接口，保持了开发语言的一致性。）&lt;/h2&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift 3.0语法学习记录</title>
    <link href="http://yoursite.com/2017/08/15/Swift%203.0%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2017/08/15/Swift 3.0语法学习记录/</id>
    <published>2017-08-15T15:51:51.000Z</published>
    <updated>2018-05-15T02:19:51.720Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<ul>
<li><p>重载运算符时，前置运算符需要在“func”关键字前添加<strong>“<em>prefix</em>”</strong>关键字：</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2D</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> y = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> +<span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="keyword">left</span>.x + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>.y + <span class="keyword">right</span>.y)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这里是前置运算符重载，需要添加“prefix”标识</span></div><div class="line"><span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> -<span class="params">(origin: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: -origin.x, y: -origin.y)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> vec1 = <span class="type">Vector2D</span>(x: <span class="number">2</span>, y: <span class="number">3</span>)</div><div class="line"><span class="keyword">let</span> vec2 = <span class="type">Vector2D</span>(x: <span class="number">1</span>, y: <span class="number">4</span>)</div><div class="line"><span class="keyword">let</span> vec3 = vec1 + vec2</div><div class="line"><span class="keyword">let</span> vec4 = -vec1</div></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>&gt; 此外，“infix”为中置操作符（如+、-、*、/等两边都需要操作数的）；“postfix”为后置操作符；当然，“prefix”为前置操作符。
</code></pre>]]></content>
    
    <summary type="html">
    
      学习swift时的小随笔记录
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>四维矩阵？？？</title>
    <link href="http://yoursite.com/2017/08/07/%E5%9B%9B%E7%BB%B4%E7%9F%A9%E9%98%B5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2017/08/07/四维矩阵学习记录/</id>
    <published>2017-08-07T08:29:38.000Z</published>
    <updated>2018-05-15T02:17:55.144Z</updated>
    
    <content type="html"><![CDATA[<p>看了个好东西，<a href="http://www.cnblogs.com/graphics/archive/2012/08/02/2616017.html" target="_blank" rel="external">矩阵-DirectX与OpenGL的不同</a>，原帖讲的很清楚</p>
<a id="more"></a>
<blockquote>
<p>一直不明白iOS为啥用四维矩阵来表示三维的东西（其他平台可能也如此吧~）</p>
<p>iOS平台上，使用OpenGL的四维矩阵表示空间</p>
</blockquote>
<p><img src="http://pic002.cnblogs.com/images/2012/64257/2012073120462521.gif" alt=""></p>
<p>上面这个是标准的四维矩阵（这个是DirectX的，与OpenGL的互为转置矩阵，即ios的为竖着的“m11, m12, m13, m14”）</p>
<p><img src="http://pic002.cnblogs.com/images/2012/64257/2012073121020368.gif" alt=""></p>
<p>其中，(Tx，Ty，Tz)为平移分量（对应iOS的“m41, m42, m43”）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了个好东西，&lt;a href=&quot;http://www.cnblogs.com/graphics/archive/2012/08/02/2616017.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;矩阵-DirectX与OpenGL的不同&lt;/a&gt;，原帖讲的很清楚&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>SceneKit学习记录1_物理身体</title>
    <link href="http://yoursite.com/2017/07/18/SceneKit%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/"/>
    <id>http://yoursite.com/2017/07/18/SceneKit学习记录1/</id>
    <published>2017-07-18T05:34:31.000Z</published>
    <updated>2018-05-15T02:19:15.587Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/documentation/scenekit/scnphysicsbody?language=objc" target="_blank" rel="external">原文档</a></p>
<h1 id="物理身体类型（SCNPhysicsBodyType）"><a href="#物理身体类型（SCNPhysicsBodyType）" class="headerlink" title="物理身体类型（SCNPhysicsBodyType）"></a>物理身体类型（SCNPhysicsBodyType）</h1><blockquote>
<p>分为三类：</p>
<ul>
<li>静态身体：SCNPhysicsBodyTypeStatic</li>
<li>动态身体：SCNPhysicsBodyTypeDynamic</li>
<li>运动身体：SCNPhysicsBodyTypeKinematic</li>
</ul>
</blockquote>
<a id="more"></a>
<p><strong>作用</strong>：</p>
<ul>
<li>静态身体：不会被力或碰撞影响，不能移动</li>
<li>动态身体：可以被其他类型的身体碰撞或施加力</li>
<li>运动身体：不会被力或碰撞影响，但是可以直接移动他们去碰撞动态身体</li>
</ul>
<h4 id="Static（静态身体）"><a href="#Static（静态身体）" class="headerlink" title="Static（静态身体）"></a>Static（静态身体）</h4><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">影响</th>
<th style="text-align:center">被影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Static</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">Dynamic</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">Kinematic</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<h4 id="Dynamic（动态身体）"><a href="#Dynamic（动态身体）" class="headerlink" title="Dynamic（动态身体）"></a>Dynamic（动态身体）</h4><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">影响</th>
<th style="text-align:center">被影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Static</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">Dynamic</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Kinematic</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<h4 id="KineMatic（运动身体）"><a href="#KineMatic（运动身体）" class="headerlink" title="KineMatic（运动身体）"></a>KineMatic（运动身体）</h4><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">影响</th>
<th style="text-align:center">被影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Static</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">Dynamic</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">Kinematic</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/scenekit/scnphysicsbody?language=objc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;物理身体类型（SCNPhysicsBodyType）&quot;&gt;&lt;a href=&quot;#物理身体类型（SCNPhysicsBodyType）&quot; class=&quot;headerlink&quot; title=&quot;物理身体类型（SCNPhysicsBodyType）&quot;&gt;&lt;/a&gt;物理身体类型（SCNPhysicsBodyType）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态身体：SCNPhysicsBodyTypeStatic&lt;/li&gt;
&lt;li&gt;动态身体：SCNPhysicsBodyTypeDynamic&lt;/li&gt;
&lt;li&gt;运动身体：SCNPhysicsBodyTypeKinematic&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ARKit文档瞎翻译（9）</title>
    <link href="http://yoursite.com/2017/07/04/ARKit_doc_9/"/>
    <id>http://yoursite.com/2017/07/04/ARKit_doc_9/</id>
    <published>2017-07-04T07:19:48.000Z</published>
    <updated>2018-05-15T02:20:12.289Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/documentation/arkit/arscnview/providing_3d_virtual_content_with_scenekit" target="_blank" rel="external">原文请戳</a></p>
<a id="more"></a>
<h1 id="使用SceneKit提供3D内容"><a href="#使用SceneKit提供3D内容" class="headerlink" title="使用SceneKit提供3D内容"></a>使用SceneKit提供3D内容</h1><p>使用SceneKit来添加逼真的3D对象到你的AR体验中</p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在AR中放置SpriteKit内容，你首先需要一个运行中的AR会话对象（参考<a href="https://developer.apple.com/documentation/arkit/building_a_basic_ar_experience?language=objc" target="_blank" rel="external">创建一个基本的AR体验</a>）。</p>
<p>因为ARKit可以自动匹配SceneKit空间到现实空间中，所以放置一个虚拟对象以便可以维持真实世界中的位置，只需要适当地设置这个对象的SceneKit位置就可以。举例来说，在一个默认配置中，下面的代码放置一个10cm的立方体，初始位置在相机前方20厘米处：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> cubeNode = <span class="type">SCNNode</span>(geometry: <span class="type">SCNBox</span>(width: <span class="number">0.1</span>, height: <span class="number">0.1</span>, length: <span class="number">0.1</span>, chamferRadius: <span class="number">0</span>))</div><div class="line">cubeNode.posotion = <span class="type">SCNVector3</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">0.2</span>)<span class="comment">// SceneKit/AR坐标系以“米”为单位</span></div><div class="line">sceneView.scene.rootNode.addChildNode(cubeNode)</div></pre></td></tr></table></figure>
<p>以上代码直接在视图的SceneKit场景中放置了一个物体，由于ARKit匹配了SceneKit空间到现实空间中，该物体会自动追踪其在现实世界的位置。</p>
<p>追踪现实位置，你不仅可以使用<a href="https://developer.apple.com/documentation/arkit/aranchor" target="_blank" rel="external">ARAnchor</a>类，或通过创建你自己的锚点并把他们添加到会话对象中，还可以监听ARKit自动创建的锚点。比如，当物体检测功能已打开，ARKit会为<br>每一个检测到的物体添加并更新锚点。要为这些锚点添加可见内容，可以向下面这样实现<a href="https://developer.apple.com/documentation/arkit/arscnviewdelegate" target="_blank" rel="external">ARSCNViewDelegate</a>的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">renderer</span><span class="params">(<span class="number">_</span> renderer: SCNSceneRenderer, didAdd node: SCNNode, <span class="keyword">for</span> anchor: ARAnchor)</span></span> &#123;</div><div class="line">	<span class="comment">// 这个可视物体只允许已检测到的物体</span></div><div class="line">	<span class="keyword">guard</span> <span class="keyword">let</span> planeAnchor = anchor <span class="keyword">as</span>? <span class="type">ARPlaneAnchor</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</div><div class="line">	</div><div class="line">	<span class="comment">// 使用它的位置和大小创建一个SceneKit物体来使节点可见</span></div><div class="line">	<span class="keyword">let</span> plane = <span class="type">SCNPlane</span>(width: <span class="type">SCFloat</span>(planeAnchor.extent.x), height: <span class="type">CGFloat</span>(planeAnchor.extent.z))</div><div class="line">	<span class="keyword">let</span> planeNode = <span class="type">SCNNode</span>(geometry: plane)</div><div class="line">	planeNode.position = <span class="type">SCNVector3Make</span>(planeAnchor.center.x, <span class="number">0</span>, planeAnchor.center.z)</div><div class="line">	</div><div class="line">	<span class="comment">// SCNPlanes在他们自己的坐标空间中式垂直朝向的</span></div><div class="line">	<span class="comment">// 旋转它来匹配水平朝向的ARPlaneAnchor</span></div><div class="line">	planeNode.transform = <span class="type">SCNMatrix4MakeRotation</span>(-<span class="type">Float</span>.pi / <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">	</div><div class="line">	<span class="comment">// 像锚点一样，ARKit拥有这个节点，所以把这个物体添加为一个子节点。</span></div><div class="line">	node.addChildNode(planeNode)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="设计3D资源遵循的最好实践"><a href="#设计3D资源遵循的最好实践" class="headerlink" title="设计3D资源遵循的最好实践"></a>设计3D资源遵循的最好实践</h2><ul>
<li>使用SceneKit自身的光照模型创建资源以便可以有更逼真的外观。（查看<a href="https://developer.apple.com/documentation/scenekit/scnmaterial" target="_blank" rel="external">SCNMaterial</a>类和<a href="https://developer.apple.com/library/content/samplecode/Badger/Introduction/Intro.html#//apple_ref/doc/uid/TP40017309" target="_blank" rel="external">獾：SceneKit高级渲染</a>示例代码工程）</li>
<li>烤周围的遮罩阴影以便所有物体都可以在大场景的光照条件下都有合适的光照。</li>
<li>在AR中如果你想要创建一个虚拟物体并把它放置到外界的水平面上，你需要在3D资源中包含一个带有温和的阴影纹理的透明物体，并把它放到虚拟物体下面。</li>
</ul>
<h2 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h2><h6 id="session"><a href="#session" class="headerlink" title="session"></a><a href="https://developer.apple.com/documentation/arkit/arskview/2865589-session?language=objc" target="_blank" rel="external">session</a></h6><pre><code>在视图内容中管理着运动追踪和相机图像处理的AR会话对象
</code></pre><h6 id="scene"><a href="#scene" class="headerlink" title="scene"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2875547-scene?language=objc" target="_blank" rel="external">scene</a></h6><pre><code>视图中显示的SceneKit场景
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/arkit/arscnview/providing_3d_virtual_content_with_scenekit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文请戳&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ARKit文档瞎翻译（8）</title>
    <link href="http://yoursite.com/2017/07/04/ARKit_doc_8/"/>
    <id>http://yoursite.com/2017/07/04/ARKit_doc_8/</id>
    <published>2017-07-04T06:05:03.000Z</published>
    <updated>2018-05-15T02:20:15.595Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/documentation/arkit/arscnview?language=objc" target="_blank" rel="external">原文请戳</a></p>
<a id="more"></a>
<h1 id="ARSCNView"><a href="#ARSCNView" class="headerlink" title="ARSCNView"></a>ARSCNView</h1><p>使用3D的SceneKit内容进而增强相机来显示AR体验的一种视图。</p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ARSCNView提供了一种最简单的方式来创建AR体验，即混合了虚拟的3D内容到相机捕捉的真实世界的视图中。当你运行视图提供的<a href="https://developer.apple.com/documentation/arkit/arsession?language=objc" target="_blank" rel="external">ARSession</a>对象时：</p>
<ul>
<li>该视图会自动渲染从相机拍摄到的实时视频并将其作为背景。</li>
<li>该视图的SceneKit场景坐标系可以直接响应通过会话配置的AR坐标系。</li>
<li>该视图会自动移动它的SceneKit相机来匹配设备在现实世界中的移动。</li>
</ul>
<p>因为ARKit可以自动匹配SceneKit空间到真实世界中，所以放置一个虚拟物体以便可以维持在现实中的位置，只需要适当地设置这个对象的SceneKit位置就可以。</p>
<p>你无需必须使用<a href="https://developer.apple.com/documentation/arkit/aranchor?language=objc" target="_blank" rel="external">ARAnchor</a>类来追踪添加到场景中的物体位置，但是通过实现<a href="https://developer.apple.com/documentation/arkit/arscnviewdelegate?language=objc" target="_blank" rel="external">ARSCNViewDelegate</a>中的方法，你可以添加SceneKit内容到任何被ARKit自动识别出的锚点上。</p>
<h2 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><h6 id="使用SceneKit提供3D的虚拟内容"><a href="#使用SceneKit提供3D的虚拟内容" class="headerlink" title="使用SceneKit提供3D的虚拟内容"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/providing_3d_virtual_content_with_scenekit?language=objc" target="_blank" rel="external">使用SceneKit提供3D的虚拟内容</a></h6><pre><code>使用SceneKit来添加逼真的3D对象到你的AR体验中
</code></pre><h6 id="session"><a href="#session" class="headerlink" title="session"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2865796-session?language=objc" target="_blank" rel="external">session</a></h6><pre><code>管理着视图内容中的运动追踪和相机视图处理的AR会话对象
</code></pre><h6 id="scene"><a href="#scene" class="headerlink" title="scene"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2875547-scene?language=objc" target="_blank" rel="external">scene</a></h6><pre><code>显示在视图中的SceneKit场景
</code></pre><h3 id="负责AR更新"><a href="#负责AR更新" class="headerlink" title="负责AR更新"></a>负责AR更新</h3><h6 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2865797-delegate?language=objc" target="_blank" rel="external">delegate</a></h6><pre><code>你提供的一个对象，用于使用SceneKit内容来同步处理视图的AR场景信息。
</code></pre><h6 id="ARSCNViewDelegate"><a href="#ARSCNViewDelegate" class="headerlink" title="ARSCNViewDelegate"></a><a href="https://developer.apple.com/documentation/arkit/arscnviewdelegate?language=objc" target="_blank" rel="external">ARSCNViewDelegate</a></h6><pre><code>可以实现的一系列方法，你可以用他们使用AR会话对象来同步处理SceneKit内容。
</code></pre><h3 id="真实世界表面的碰撞检测"><a href="#真实世界表面的碰撞检测" class="headerlink" title="真实世界表面的碰撞检测"></a>真实世界表面的碰撞检测</h3><h6 id="hitTest-types"><a href="#hitTest-types" class="headerlink" title="- hitTest:types:"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2875544-hittest?language=objc" target="_blank" rel="external">- hitTest:types:</a></h6><pre><code>在截取的相机图像中搜索真实世界的物体或AR锚点，与SceneKit视图中的一个点相对应。
</code></pre><h3 id="映射内容到现实世界的位置中"><a href="#映射内容到现实世界的位置中" class="headerlink" title="映射内容到现实世界的位置中"></a>映射内容到现实世界的位置中</h3><h6 id="anchorForNode"><a href="#anchorForNode" class="headerlink" title="- anchorForNode:"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2875546-anchorfornode?language=objc" target="_blank" rel="external">- anchorForNode:</a></h6><pre><code>如果存在，返回与指定SceneKit节点相关的AR锚点
</code></pre><h6 id="nodeForAnchor"><a href="#nodeForAnchor" class="headerlink" title="- nodeForAnchor:"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2874122-nodeforanchor?language=objc" target="_blank" rel="external">- nodeForAnchor:</a></h6><pre><code>如果存在，返回与指定AR锚点相关的SceneKit节点
</code></pre><h3 id="处理场景光照"><a href="#处理场景光照" class="headerlink" title="处理场景光照"></a>处理场景光照</h3><h6 id="automaticallyUpdatesLighting"><a href="#automaticallyUpdatesLighting" class="headerlink" title="automaticallyUpdatesLighting"></a><a href="https://developer.apple.com/documentation/arkit/arscnview/2887446-automaticallyupdateslighting?language=objc" target="_blank" rel="external">automaticallyUpdatesLighting</a></h6><pre><code>一个布尔值，指定了在视图的场景中，是否需要ARKit创建并更新SceneKit光照。
</code></pre><h3 id="调试AR显示"><a href="#调试AR显示" class="headerlink" title="调试AR显示"></a>调试AR显示</h3><h6 id="ARSCNDebugOptions"><a href="#ARSCNDebugOptions" class="headerlink" title="ARSCNDebugOptions"></a><a href="https://developer.apple.com/documentation/arkit/arscndebugoptions?language=objc" target="_blank" rel="external">ARSCNDebugOptions</a></h6><pre><code>绘制遮罩内容的一些设置项来帮助调试在SceneKit视图中的AR追踪功能。
</code></pre><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h3 id="继承自"><a href="#继承自" class="headerlink" title="继承自"></a>继承自</h3><p><a href="https://developer.apple.com/documentation/scenekit/scnview?language=objc" target="_blank" rel="external">SCNView</a></p>
<h2 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h2><h3 id="基本视图"><a href="#基本视图" class="headerlink" title="基本视图"></a>基本视图</h3><h6 id="创建一个基本的AR体验"><a href="#创建一个基本的AR体验" class="headerlink" title="创建一个基本的AR体验"></a><a href="https://developer.apple.com/documentation/arkit/building_a_basic_ar_experience?language=objc" target="_blank" rel="external">创建一个基本的AR体验</a></h6><pre><code>配置一个AR会话对象并使用SceneKit或SpriteKit来显示AR内容
</code></pre><h6 id="ARSKView"><a href="#ARSKView" class="headerlink" title="ARSKView"></a><a href="https://developer.apple.com/documentation/arkit/arskview?language=objc" target="_blank" rel="external">ARSKView</a></h6><pre><code>使用2D的SpriteKit内容进而增强相机来显示AR体验的一种视图。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/arkit/arscnview?language=objc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文请戳&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ARKit文档瞎翻译（7）</title>
    <link href="http://yoursite.com/2017/07/04/ARKit_doc_7/"/>
    <id>http://yoursite.com/2017/07/04/ARKit_doc_7/</id>
    <published>2017-07-04T03:28:14.000Z</published>
    <updated>2018-05-15T02:20:18.159Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/documentation/arkit/arskview?language=objc" target="_blank" rel="external">原文请戳</a></p>
<a id="more"></a>
<h1 id="ARSKView"><a href="#ARSKView" class="headerlink" title="ARSKView"></a>ARSKView</h1><p>使用2D的SpriteKit内容进而增强相机来显示AR体验的一种视图。</p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用ARSKView类，可以在设备相机拍摄的真实世界视图的3D空间中放置2D元素来创建AR体验。当你运行这个视图提供的<a href="https://developer.apple.com/documentation/arkit/arsession?language=objc" target="_blank" rel="external">ARSession</a>对象时：</p>
<ul>
<li>该视图会自动渲染从相机拍摄到的实时视频并将其作为背景。</li>
<li>当你实现了<a href="https://developer.apple.com/documentation/arkit/arskviewdelegate?language=objc" target="_blank" rel="external">ARSKViewDelegate</a>的方法把SpriteKit内容和真实世界的位置联系在一起时，该视图会自动缩放并旋转SpriteKit节点，以便他们在相机中看起来就像可以在真实世界中追踪到一样。</li>
</ul>
<h2 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><h6 id="使用SpriteKit提供2D虚拟内容"><a href="#使用SpriteKit提供2D虚拟内容" class="headerlink" title="使用SpriteKit提供2D虚拟内容"></a><a href="https://developer.apple.com/documentation/arkit/arskview/providing_2d_virtual_content_with_spritekit?language=objc" target="_blank" rel="external">使用SpriteKit提供2D虚拟内容</a></h6><pre><code>在AR体验中，使用SpriteKit在3D空间中放置2D图片
</code></pre><h6 id="session"><a href="#session" class="headerlink" title="session"></a><a href="https://developer.apple.com/documentation/arkit/arskview/2865589-session?language=objc" target="_blank" rel="external">session</a></h6><pre><code>管理着视图内容中的运动追踪和相机视图处理的AR会话对象
</code></pre><h3 id="负责AR更新"><a href="#负责AR更新" class="headerlink" title="负责AR更新"></a>负责AR更新</h3><h6 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a><a href="https://developer.apple.com/documentation/arkit/arskview/2865597-delegate?language=objc" target="_blank" rel="external">delegate</a></h6><pre><code>你提供的一个对象，用于使用SpriteKit内容来同步处理视图中的AR场景信息。
</code></pre><h6 id="ARSKViewDelegate"><a href="#ARSKViewDelegate" class="headerlink" title="ARSKViewDelegate"></a><a href="https://developer.apple.com/documentation/arkit/arskviewdelegate?language=objc" target="_blank" rel="external">ARSKViewDelegate</a></h6><pre><code>可以实现的一系列方法，你可以用他们使用AR会话对象来同步处理SpriteKit内容。
</code></pre><h3 id="真实世界表面的碰撞检测"><a href="#真实世界表面的碰撞检测" class="headerlink" title="真实世界表面的碰撞检测"></a>真实世界表面的碰撞检测</h3><h6 id="hitTest-types"><a href="#hitTest-types" class="headerlink" title="- hitTest:types:"></a><a href="https://developer.apple.com/documentation/arkit/arskview/2875733-hittest?language=objc" target="_blank" rel="external">- hitTest:types:</a></h6><pre><code>在截取的相机图像中搜索真实世界的物体或AR锚点，与SpriteKit视图中的一个点相对应。
</code></pre><h3 id="映射内容到真实世界的位置中"><a href="#映射内容到真实世界的位置中" class="headerlink" title="映射内容到真实世界的位置中"></a>映射内容到真实世界的位置中</h3><h6 id="anchorForNode"><a href="#anchorForNode" class="headerlink" title="- anchorForNode:"></a><a href="https://developer.apple.com/documentation/arkit/arskview/2875729-anchorfornode?language=objc" target="_blank" rel="external">- anchorForNode:</a></h6><pre><code>如果存在，返回与指定SpriteKit节点相关的AR锚点
</code></pre><h6 id="nodeForAnchor"><a href="#nodeForAnchor" class="headerlink" title="- nodeForAnchor:"></a><a href="https://developer.apple.com/documentation/arkit/arskview/2873513-nodeforanchor?language=objc" target="_blank" rel="external">- nodeForAnchor:</a></h6><pre><code>如果存在，返回与指定AR锚点相关的SpriteKit节点
</code></pre><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h3 id="继承自"><a href="#继承自" class="headerlink" title="继承自"></a>继承自</h3><p><a href="https://developer.apple.com/documentation/spritekit/skview?language=objc" target="_blank" rel="external">SKView</a></p>
<h2 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h2><h3 id="基本视图"><a href="#基本视图" class="headerlink" title="基本视图"></a>基本视图</h3><h6 id="创建一个基本的AR体验"><a href="#创建一个基本的AR体验" class="headerlink" title="创建一个基本的AR体验"></a><a href="https://developer.apple.com/documentation/arkit/building_a_basic_ar_experience?language=objc" target="_blank" rel="external">创建一个基本的AR体验</a></h6><pre><code>配置一个AR会话对象并使用SceneKit或SpriteKit来显示AR内容
</code></pre><h6 id="ARSCNView"><a href="#ARSCNView" class="headerlink" title="ARSCNView"></a><a href="https://developer.apple.com/documentation/arkit/arscnview?language=objc" target="_blank" rel="external">ARSCNView</a></h6><pre><code>使用3D的SceneKit内容进而增强相机来显示AR体验的一种视图。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/arkit/arskview?language=objc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文请戳&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
