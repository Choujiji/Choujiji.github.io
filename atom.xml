<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭吉吉的瞎记空间</title>
  <subtitle>技术的，瞎说的，啥都有吧。。。希望。。。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-06T07:54:34.109Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>臭吉吉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》9</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A9.ARC%E5%AE%9E%E7%8E%B0%E4%B9%8B__autoreleasing/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇：9.ARC实现之__autoreleasing/</id>
    <published>2019-01-06T07:54:34.109Z</published>
    <updated>2019-01-06T07:54:34.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：9-ARC实现之-autoreleasing"><a href="#内存管理篇：9-ARC实现之-autoreleasing" class="headerlink" title="内存管理篇：9.ARC实现之__autoreleasing"></a>内存管理篇：9.ARC实现之__autoreleasing</h2><ol>
<li>__autoreleasing修饰的变量与在非ARC环境下，对对象调用autorelease方法效果一致：</li>
</ol>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasePool &#123;</div><div class="line">    id __autoreleasing obj = [[NSObject alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转换后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建pool</span></div><div class="line">id pool = objc_autoreleasePoolPush();</div><div class="line"></div><div class="line"><span class="comment">// 创建对象</span></div><div class="line">id obj = objc_msgSend(NSObject, @selector(alloc));</div><div class="line">objc_msgSend(obj, @selector(init));</div><div class="line"></div><div class="line"><span class="comment">// 加入到pool中</span></div><div class="line">objc_autorelease(obj);</div><div class="line"></div><div class="line"><span class="comment">// 释放pool中的对象</span></div><div class="line">objc_autoreleasePoolPop(pool);</div></pre></td></tr></table></figure>
<ol>
<li>对于将非调用方创建的对象，加入到autoreleasePool中的情况，生成的代码如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasePool &#123;</div><div class="line">    id __autoreleasing obj = [NSMutableArray <span class="built_in">array</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转换后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建pool</span></div><div class="line">id pool = objc_autoreleasePoolPush();</div><div class="line"></div><div class="line"><span class="comment">// 创建对象</span></div><div class="line">id obj = objc_msgSend(NSMutableArray, @selector(<span class="built_in">array</span>));</div><div class="line"><span class="comment">// 保留返回的自动释放对象（autorelease优化）</span></div><div class="line">objc_retainAutoreleasedReturnValue(obj);</div><div class="line"></div><div class="line"><span class="comment">// 加入到pool中</span></div><div class="line">objc_autorelease(obj);</div><div class="line"></div><div class="line"><span class="comment">// 释放pool中的对象</span></div><div class="line">objc_autoreleasePoolPop(pool);</div></pre></td></tr></table></figure>
<p>这里在前面<strong>strong的情况中有说过，<strong>对于函数的返回值，ARC使用objc_autoreleaseReturnValue和objc_retainAutoreleasedReturnValue方法进行优化，避免了将生成的对象在pool中进行进入和取出操作</strong>。但是由于接收变量是使用</strong>autoreleasing修饰的，故直接将其加入到pool中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：9-ARC实现之-autoreleasing&quot;&gt;&lt;a href=&quot;#内存管理篇：9-ARC实现之-autoreleasing&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇：9.ARC实现之__autoreleasing&quot;&gt;&lt;/a&gt;内存管理篇：9.ARC实现之__autoreleasing&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;__autoreleasing修饰的变量与在非ARC环境下，对对象调用autorelease方法效果一致：&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》8</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A8.ARC%E5%AE%9E%E7%8E%B0%E4%B9%8B__weak/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇：8.ARC实现之__weak/</id>
    <published>2019-01-06T07:53:26.381Z</published>
    <updated>2019-01-06T07:53:34.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：8-ARC实现之-weak"><a href="#内存管理篇：8-ARC实现之-weak" class="headerlink" title="内存管理篇：8.ARC实现之__weak"></a>内存管理篇：8.ARC实现之__weak</h2><blockquote>
<p>我们知道，weak修饰的变量，其地址是被存储在一个专用的散列表中，此散列表的键值为原内存的散列值（即对象地址的hash值）。</p>
</blockquote>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546747255-weak%E8%A1%A8.jpg" alt="img"></p>
<p>__weak修饰的变量，其主要存在两大功能：</p>
<ol>
<li><strong>当其引用的对象被释放时，此变量自动被赋值为nil</strong>；</li>
<li><strong>使用__weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象</strong>。</li>
</ol>
<a id="more"></a>
<h4 id="当-weak变量引用的对象被释放时，其自动被赋值为nil"><a href="#当-weak变量引用的对象被释放时，其自动被赋值为nil" class="headerlink" title="当__weak变量引用的对象被释放时，其自动被赋值为nil"></a>当__weak变量引用的对象被释放时，其自动被赋值为nil</h4><p>先看示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// obj为强引用变量且已经被赋值</span></div><div class="line">    id __weak obj1 = obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id obj1;</div><div class="line">objc_initWeak(&amp;obj1, obj);</div><div class="line">objc_destroyWeak(&amp;obj1);</div></pre></td></tr></table></figure>
<p>objc_initWeak方法，即为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj1 = <span class="number">0</span>;</div><div class="line">objc_storeWeak(&amp;obj1, obj);</div></pre></td></tr></table></figure>
<p>objc_destroyWeak方法，即为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_storeWeak(&amp;obj1, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>由此可以看出，</p>
<ol>
<li><strong>对于初始化的weak变量：为变量赋值为0，并将其地址存储到weak表中，对象内存的散列值所在的地址中</strong>。</li>
<li><strong>释放weak变量时：则是在weak表中，将对象内存散列值所在地址存储的数据中，将存储的变量清空</strong>。</li>
</ol>
<blockquote>
<p>由于可以使用多个weak变量指向同一对象，所以在weak表中，一个键值的散列地址中可以存储多个weak变量地址。</p>
</blockquote>
<p><em>结论：<br>weak对象释放时，自动置为nil的原因</em>：</p>
<ul>
<li><strong>在系统调用dealloc释放对象时（最后的objc_clear_deallocating方法），ARC会根据对象的引用状态，去weak表中查询对应的weak变量，将变量地址赋值为nil，并将其记录删除。最后将此键值记录一并删除。</strong></li>
<li>注意：此过程需要消耗CPU资源，故不要滥用，需要时再使用（如避免delegate和block导致的引用循环）。</li>
</ul>
<h4 id="使用-weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象"><a href="#使用-weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象" class="headerlink" title="使用__weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象"></a>使用__weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象</h4><p>还是先看实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// obj为强引用变量，且已被赋值</span></div><div class="line">    id __weak obj1 = obj;</div><div class="line">    NSLog(@<span class="string">"%@"</span>, obj1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 初始化weak变量并赋值</span></div><div class="line">id obj1;</div><div class="line">objc_initWeak(&amp;obj1, obj);</div><div class="line"><span class="comment">// ？？？</span></div><div class="line">id tmp = objc_loadWeakRetained(&amp;obj1);</div><div class="line"><span class="comment">// ？？？</span></div><div class="line">objc_autorelease(tmp);</div><div class="line">NSLog(@<span class="string">"%@"</span>, tmp);</div><div class="line"><span class="comment">// 释放weak变量</span></div><div class="line">objc_destroyWeak(&amp;obj1);</div></pre></td></tr></table></figure>
<p>其中：</p>
<ol>
<li><strong>先通过objc_loadWeakRetained方法，将weak变量对应引用的对象取出，并进行retain操作。</strong></li>
<li><strong>使用objc_autorelease方法，将生成的临时对象加入到autoreleasePool中，即可保证对象的生存期，以便正常使用。</strong></li>
</ol>
<p>注意：</p>
<ul>
<li>大量使用weak变量，会在autoreleasePool中插入大量临时变量，增加内存开销，并对CPU进行过多无畏的损耗。</li>
<li>正确的使用方法，是使用strong变量指向weak变量后，再进行使用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">id __weak obj1 = obj;</div><div class="line">id tmp = obj1;</div><div class="line">NSLog(@<span class="string">"1.%@"</span>, tmp);</div><div class="line">NSLog(@<span class="string">"2.%@"</span>, tmp);</div><div class="line">NSLog(@<span class="string">"3.%@"</span>, tmp);</div><div class="line">NSLog(@<span class="string">"4.%@"</span>, tmp);</div><div class="line">NSLog(@<span class="string">"5.%@"</span>, tmp);</div><div class="line"><span class="comment">// 这样，autoreleasePool只会将obj1插入一次</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：8-ARC实现之-weak&quot;&gt;&lt;a href=&quot;#内存管理篇：8-ARC实现之-weak&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇：8.ARC实现之__weak&quot;&gt;&lt;/a&gt;内存管理篇：8.ARC实现之__weak&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们知道，weak修饰的变量，其地址是被存储在一个专用的散列表中，此散列表的键值为原内存的散列值（即对象地址的hash值）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546747255-weak%E8%A1%A8.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;__weak修饰的变量，其主要存在两大功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;当其引用的对象被释放时，此变量自动被赋值为nil&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用__weak修饰的变量时，实际上使用的是添加到autoreleasePool中的对象&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》7</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A7.ARC%E5%AE%9E%E7%8E%B0%E4%B9%8B__strong%E5%8F%8Aautorelease%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇：7.ARC实现之__strong及autorelease优化/</id>
    <published>2019-01-06T07:52:21.263Z</published>
    <updated>2019-01-06T07:52:21.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：7-ARC实现之-strong及autorelease优化"><a href="#内存管理篇：7-ARC实现之-strong及autorelease优化" class="headerlink" title="内存管理篇：7.ARC实现之__strong及autorelease优化"></a>内存管理篇：7.ARC实现之__strong及autorelease优化</h2><blockquote>
<p>对于持有非自己创建的对象的情况，我们知道，这种情况是指对于非“alloc、new、copy和mutableCopy”开头的并返回对象实例的方法，接收方不负责内存管理。<br>ARC会在方法实现中将返回值加入到autoreleasePool中，待接收方从中取出使用，延迟释放时机。</p>
</blockquote>
<a id="more"></a>
<p>但是实际上，代码并不会都如我们想象的那样，因为会有更优化的执行。先看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    id __strong obj = [NSMutableArray <span class="built_in">array</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 发消息创建对象</span></div><div class="line">id obj = objc_msgSend(NSMutableArray, @selector(<span class="built_in">array</span>));</div><div class="line"><span class="comment">// ???</span></div><div class="line">objc_retainAutoreleasedReturnValue(obj);</div><div class="line"><span class="comment">// 正常释放对象</span></div><div class="line">objc_release(obj);</div></pre></td></tr></table></figure>
<p>而对于NSMutableArray的array方法，编译后的模拟代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (id)<span class="built_in">array</span> &#123;</div><div class="line">    <span class="comment">// 正常的二段式创建</span></div><div class="line">    id obj = objc_msgSend(NSMutableArray, @selector(alloc));</div><div class="line">    objc_msgSend(obj, @selector(init));</div><div class="line">    <span class="comment">// ???</span></div><div class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在以上代码中可以看到，在这种情况下，ARC使用了<em>objc_autoreleaseReturnValue</em>替代了autorelease操作，而调用方则使用<em>objc_retainAutoreleasedReturnValue</em>替代了传统的retain操作。作用是什么呢？</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546692024-AutoRelease%E4%BC%98%E5%8C%96.jpg" alt="img"></p>
<blockquote>
<p>使用这对方法（创建对象的方法返回使用objc_autoreleaseReturnValue返回的对象，而接收方使用objc_retainAutoreleasedReturnValue接收返回的对象）时，编译器实际上并没有将生成的对象加入到autoreleasePool中，而是直接将对象传递给接收方。避免了频繁地将对象在autoreleasePool中进行加入、取出操作，以达到最优效率。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：7-ARC实现之-strong及autorelease优化&quot;&gt;&lt;a href=&quot;#内存管理篇：7-ARC实现之-strong及autorelease优化&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇：7.ARC实现之__strong及autorelease优化&quot;&gt;&lt;/a&gt;内存管理篇：7.ARC实现之__strong及autorelease优化&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;对于持有非自己创建的对象的情况，我们知道，这种情况是指对于非“alloc、new、copy和mutableCopy”开头的并返回对象实例的方法，接收方不负责内存管理。&lt;br&gt;ARC会在方法实现中将返回值加入到autoreleasePool中，待接收方从中取出使用，延迟释放时机。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》6</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A%206.%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%88%E9%9D%9EOC%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%EF%BC%89/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇： 6.不要使用静态和动态数组（非OC集合对象）/</id>
    <published>2019-01-06T07:51:20.446Z</published>
    <updated>2019-01-06T07:51:20.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：-6-不要使用静态和动态数组（非OC集合对象）"><a href="#内存管理篇：-6-不要使用静态和动态数组（非OC集合对象）" class="headerlink" title="内存管理篇： 6.不要使用静态和动态数组（非OC集合对象）"></a>内存管理篇： 6.不要使用静态和动态数组（非OC集合对象）</h2><h4 id="静态数组（类似于c数组，非OC的集合对象）："><a href="#静态数组（类似于c数组，非OC的集合对象）：" class="headerlink" title="静态数组（类似于c数组，非OC的集合对象）："></a>静态数组（类似于c数组，非OC的集合对象）：</h4><ul>
<li>使用<strong>strong、</strong>weak和__autoreleasing修饰的静态数组（如：id objs[10]），其初始值也会自动赋值为nil，且当其释放时，子元素也会自动被释放；</li>
</ul>
<a id="more"></a>
<h4 id="动态数组（对象指针实现）："><a href="#动态数组（对象指针实现）：" class="headerlink" title="动态数组（对象指针实现）："></a>动态数组（对象指针实现）：</h4><ol>
<li>声明：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明，指向id的指针：</span></div><div class="line">id __strong *<span class="built_in">array</span> = nil;</div><div class="line"><span class="comment">// 或 指向对象的指针</span></div><div class="line"><span class="comment">// NSObject * __strong *array = nil;</span></div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>动态数组用对象指针表示；</li>
<li>由于对象指针默认为“<strong>autoreleasing”修饰符，所以需要显示指定为“</strong>strong”；</li>
<li>对象指针不会被ARC自动置为nil，需要显示指定。</li>
</ul>
</blockquote>
<ol>
<li>初始化：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 初始化：</span></div><div class="line"><span class="built_in">array</span> = (id __strong *)<span class="built_in">calloc</span>(entries, <span class="keyword">sizeof</span>(id)); </div><div class="line"><span class="comment">// calloc方法会自动将内存空间写入0数据，比malloc配合memset更为安全且简洁</span></div><div class="line"></div><div class="line"><span class="comment">// 使用malloc和memset的错误方式</span></div><div class="line"><span class="built_in">array</span> = (id __strong *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(id) * entries);</div><div class="line"><span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; entries; ++i) &#123;</div><div class="line">    <span class="built_in">array</span>[i] = nil; <span class="comment">// 错误：在ARC下相当于直接释放</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>使用：(与静态数组一致，同样不能放入nil)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">array</span>[<span class="number">0</span>] = [[NSObject alloc] init];</div></pre></td></tr></table></figure>
<ol>
<li>释放：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.依次释放子元素</span></div><div class="line"><span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; entries; ++i) &#123;</div><div class="line">    <span class="built_in">array</span>[i] = nil; <span class="comment">// 在ARC下相当于直接释放对象</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 2.释放动态数组本身</span></div><div class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>原因：由于动态数组是在运行期确定，ARC无法在编译器对其进行内存管理，直接释放数组本身会让子元素发生内存泄漏。</p>
</blockquote>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><p>使用memcpy拷贝数组中的元素和realloc重新分配内存，都可能导致对象内存泄漏或过度释放，所以ARC下也被禁止使用。</p>
<hr>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><blockquote>
<p>直接使用Foundation的集合对象就好了，不要用这种东西。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：-6-不要使用静态和动态数组（非OC集合对象）&quot;&gt;&lt;a href=&quot;#内存管理篇：-6-不要使用静态和动态数组（非OC集合对象）&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇： 6.不要使用静态和动态数组（非OC集合对象）&quot;&gt;&lt;/a&gt;内存管理篇： 6.不要使用静态和动态数组（非OC集合对象）&lt;/h2&gt;&lt;h4 id=&quot;静态数组（类似于c数组，非OC的集合对象）：&quot;&gt;&lt;a href=&quot;#静态数组（类似于c数组，非OC的集合对象）：&quot; class=&quot;headerlink&quot; title=&quot;静态数组（类似于c数组，非OC的集合对象）：&quot;&gt;&lt;/a&gt;静态数组（类似于c数组，非OC的集合对象）：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用&lt;strong&gt;strong、&lt;/strong&gt;weak和__autoreleasing修饰的静态数组（如：id objs[10]），其初始值也会自动赋值为nil，且当其释放时，子元素也会自动被释放；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》5</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A%205.ARC%E7%9A%84%E8%A7%84%E5%88%99%E8%A1%A5%E5%85%85/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇： 5.ARC的规则补充/</id>
    <published>2019-01-06T07:49:49.390Z</published>
    <updated>2019-01-06T07:49:49.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：-5-ARC的规则补充"><a href="#内存管理篇：-5-ARC的规则补充" class="headerlink" title="内存管理篇： 5.ARC的规则补充"></a>内存管理篇： 5.ARC的规则补充</h2><ol>
<li>ARC的方法命名</li>
</ol>
<blockquote>
<p>我们都知道，在内存管理的思考方式中，当方法命名以“alloc、new、copy、mutableCopy”开头或直接命名时，返回对象（必须返回对象）的内存由接收方进行管理。这种方式在ARC中同样适用。</p>
</blockquote>
<p>在ARC环境下，以init或init开头的方法，也需要遵循此规则。且init的方法规定更为严格：</p>
<ul>
<li>必须返回id或类型的对象</li>
<li>必须是实例方法</li>
</ul>
<a id="more"></a>
<hr>
<ol>
<li><strong>OC对象（这里代指Foundation框架中类的对象）不能直接作为C数据结构的成员。</strong><blockquote>
<p>原因：ARC为OC语言编译器特性，不支持对C语言进行内存管理（最新的iOS 12中，好像已经支持此特性了，LLVM真强大。。。）</p>
</blockquote>
</li>
</ol>
<p>对于需要作为成员的OC对象，解决方法：</p>
<ul>
<li>使用“__unsafe_unretained”进行所有权修饰，显示声明并告知编译器不要对其进行内存管理；</li>
<li>通过“__bridge”将OC对象转换为（void *）指针。</li>
</ul>
<hr>
<ol>
<li>显示转换“id”与“void *”</li>
</ol>
<p>对象与C指针之间是通过“__bridge”关键字进行转换，主要分为三种方式：</p>
<blockquote>
<ul>
<li>__bridge</li>
<li>__bridge_retained</li>
<li>__bridge_transfer</li>
</ul>
</blockquote>
<ul>
<li>__bridge:</li>
</ul>
<p>直接转换，忽略ARC内存管理，与添加__unsafe_unretained效果类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">id obj = [[NSObject alloc] init];</div><div class="line"><span class="comment">// 转换为c指针</span></div><div class="line"><span class="keyword">void</span> *p = (__bridge <span class="keyword">void</span> *)obj;</div><div class="line"><span class="comment">// 转换为OC对象</span></div><div class="line">id obj2 = (__bridge id)p;</div></pre></td></tr></table></figure>
<ul>
<li>__bridge_retained:</li>
</ul>
<p>意为“转换后进行保留”，接收方对其自动强引用（同时掌握所有权），与__strong的retain效果类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *p = <span class="number">0</span>;</div><div class="line">&#123;</div><div class="line">    id obj = [[NSObject alloc] init];</div><div class="line">    <span class="comment">// 转换为c指针</span></div><div class="line">    p = (__bridge_retained <span class="keyword">void</span> *)obj;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 出作用域后，obj强引用消失</span></div><div class="line"><span class="comment">// 由于__bridge_retained，p同时也是强引用，对象得以继续生存</span></div><div class="line">NSLog(<span class="string">"%@"</span>, [(__bridge id)p class]);</div></pre></td></tr></table></figure>
<ul>
<li>__bridge_transfer:</li>
</ul>
<p>意为“转换后释放”，原创建方在转换后自动释放自身引用，只由接收方进行内存管理（转换了所有权），与release效果类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *p = xxx;</div><div class="line">id obj = (__bridge_transfer id)p;</div><div class="line"><span class="comment">// 转换后相当于p进行了release操作，只有obj持有对象</span></div></pre></td></tr></table></figure>
<p><strong>OC（Foundation）对象与CF（Core Foundation）对象间的转换</strong>：</p>
<ul>
<li>由于二者基本是等效框架（只是实现语言不同），对象间的转换无需消耗CPU资源，是“免费桥接”（“toll-free bridge”）。</li>
<li>一般转换规则：<ul>
<li>OC -&gt; CF，使用“__bridge_retained”或“CFBridgingRetain”</li>
<li>CF -&gt; OC，使用“__bridge_transfer”或“CFBridgingRelease”（因为一般转换为OC对象后，ARC可以自动介入，防止忘记使用CFRelease手动释放内存）</li>
</ul>
</li>
</ul>
<blockquote>
<p>总结：<strong>尽量不要直接使用__bridge进行转换</strong>，使用时需再三考虑内存管理情况。</p>
</blockquote>
<hr>
<ol>
<li>使用<strong>strong、</strong>weak和__autoreleasing修饰的变量，其初始值会自动赋值为nil</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：-5-ARC的规则补充&quot;&gt;&lt;a href=&quot;#内存管理篇：-5-ARC的规则补充&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇： 5.ARC的规则补充&quot;&gt;&lt;/a&gt;内存管理篇： 5.ARC的规则补充&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;ARC的方法命名&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我们都知道，在内存管理的思考方式中，当方法命名以“alloc、new、copy、mutableCopy”开头或直接命名时，返回对象（必须返回对象）的内存由接收方进行管理。这种方式在ARC中同样适用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在ARC环境下，以init或init开头的方法，也需要遵循此规则。且init的方法规定更为严格：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须返回id或类型的对象&lt;/li&gt;
&lt;li&gt;必须是实例方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》4</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A%204.ARC%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇： 4.ARC的所有权修饰符/</id>
    <published>2019-01-06T07:47:20.057Z</published>
    <updated>2019-01-06T07:48:00.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：-4-ARC的所有权修饰符"><a href="#内存管理篇：-4-ARC的所有权修饰符" class="headerlink" title="内存管理篇： 4.ARC的所有权修饰符"></a>内存管理篇： 4.ARC的所有权修饰符</h2><h3 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h3><blockquote>
<ul>
<li>在ARC下，对象必须通过所有权修饰符进行修饰，系统会根据不同的所有权修饰符对对象进行相应的内存管理。</li>
<li>所有权修饰符包括：<strong>strong、</strong>weak、<strong>unsafe_unretained、</strong>autoreleasing。</li>
</ul>
</blockquote>
<a id="more"></a>
<h4 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="__strong修饰符"></a>__strong修饰符</h4><blockquote>
<ul>
<li>__strong作为默认的所有权修饰符，使用时可以直接省略；</li>
<li>__strong将修饰对象的指针变量声明为强引用（对象的引用计数+1）</li>
</ul>
</blockquote>
<p>__strong修饰的对象，依然符合内存管理的4条思考方式：</p>
<ul>
<li>自己创建的对象，自己持有：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// 作用域内，object负责内存管理</span></div><div class="line">    id __strong object = [[NSObject alloc] init];</div><div class="line">&#125;   <span class="comment">// 出作用域，对象的强引用失效，内存释放</span></div></pre></td></tr></table></figure>
<ul>
<li>非自己创建的对象，自己也能持有：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    id __strong object1 = [[NSObject alloc] init];</div><div class="line">    <span class="comment">// 通过赋值方式，持有别人创建的对象</span></div><div class="line">    id __strong object2 = object1</div><div class="line">&#125;   </div><div class="line"><span class="comment">// 出作用域，object2强引用失效，对象收到release消息；object1强引用也失效，对象收到release消息；最终内存释放</span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// 持有非自己创建的对象</span></div><div class="line">    id __strong object = [NSMutableArray <span class="built_in">array</span>];</div><div class="line">&#125;   <span class="comment">// 出作用域，对象的强引用失效，内存释放</span></div></pre></td></tr></table></figure>
<ul>
<li>当不再需要时，可以释放自己创建的对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    id __strong object = [[NSObject alloc] init];</div><div class="line">    <span class="comment">// 不需要时，直接置为nil或指向其他对象时，原对象收到release消息</span></div><div class="line">    object = nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>无法释放非自己创建的对象<ul>
<li>由于无法调用release方法，无需担心释放问题。</li>
</ul>
</li>
</ul>
<h4 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="__weak修饰符"></a>__weak修饰符</h4><blockquote>
<ul>
<li>与<strong>strong相对，</strong>weak为弱引用，不持有对象；</li>
<li>出作用域后，修饰的指针变量自动置为nil，访问安全；</li>
<li><strong>解决“引用循环”问题；</strong></li>
<li>iOS5以上适用（自动置nil是在运行期实现，故ARC不全是编译器特性）</li>
</ul>
</blockquote>
<h4 id="unsafe-unretained修饰符"><a href="#unsafe-unretained修饰符" class="headerlink" title="__unsafe_unretained修饰符"></a>__unsafe_unretained修饰符</h4><blockquote>
<ul>
<li>作为iOS5以前“__weak”的版本，编译器不对其内存进行管理；</li>
<li>出作用域后，指针变量不会置为nil，访问极其危险</li>
</ul>
</blockquote>
<p><strong>不建议使用。</strong></p>
<h4 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h4><blockquote>
<p>在ARC下，NSAutoreleasePool类的创建使用需要使用@autoreleasepool块来代替，且不能手动调用autorelease方法。</p>
</blockquote>
<ul>
<li>非显示使用的情况（编译器自动将对象标记为__autoreleasing）：</li>
</ul>
<ol>
<li><strong>在@autoreleasepool块中直接使用：</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line">    id obj = [[NSObject alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong>作为函数返回值：</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">+ (MyClass *)myObject &#123;</div><div class="line">    <span class="keyword">return</span> [[MyClass alloc] init];</div><div class="line">    <span class="comment">/** </span></div><div class="line">    * 相当于</div><div class="line">    *   id obj = [[MyClass alloc] init];</div><div class="line">    *   return obj;</div><div class="line">    */</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">隐含创建的obj变量会被赋值__strong修饰符，出作用域后会被释放，但由于对象作为函数返回值，编译器会将其标记为__autoreleasing，加入到最近的autoreleasepool对象中。</div><div class="line">&gt; 注意：对于此种情况，方法命名时需要遵循内存管理规则：即不得使用“alloc、<span class="keyword">new</span>、copy和mutableCopy”作为方法名开头（会将返回对象标记为__strong）。</div><div class="line"></div><div class="line"><span class="number">3.</span> **指向id的指针或指向对象的指针：**</div><div class="line"></div><div class="line">``` c</div><div class="line"><span class="comment">// 指向id的指针</span></div><div class="line">id __autoreleasing *obj;</div><div class="line"><span class="comment">// 指向NSObject对象的指针</span></div><div class="line">NSObject * __autoreleasing *obj;</div></pre></td></tr></table></figure>
<p>举例，API中的error参数，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSError ** 等同于 NSError * __autoreleasing *</span></div><div class="line">- (BOOL)performTaskWithError:(NSError **)error &#123;</div><div class="line">    <span class="keyword">if</span> (出现错误) &#123;</div><div class="line">        &amp;error = [NSError errorWithxxx];</div><div class="line">        <span class="keyword">return</span> NO;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用时：</span></div><div class="line">NSError *error; <span class="comment">// 相当于NSError __strong *error，值为nil（由于对象指针赋值时，二者的所有权修饰符必须一致。实际上这里error在下面赋值时，隐含地生成了__autoreleasing修饰的临时变量）</span></div><div class="line">[obj performTaskWithError:&amp;error];</div></pre></td></tr></table></figure>
<blockquote>
<p>原因：<br>这里其实也遵循了内存管理法则所述的方法命名规范，由于方法名不是由“alloc、new、copy和mutableCopy”开头，error作为返回对象与函数的返回值一样，且接收方相当于持有非自己创建的对象。所以会被编译器自动加入到autoreleasepool中。<br>所以指向对象的指针，会被自动标记为“__autoreleasing”。</p>
</blockquote>
<ul>
<li><strong>对象指针赋值时，二者的所有权修饰符必须一致</strong>。如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSError *error = nil; <span class="comment">// 默认为__strong</span></div><div class="line"><span class="comment">// 由于默认指向对象的指针为__autoreleasing，所以这里需要显示指定为__strong</span></div><div class="line">NSError * __strong *pError = &amp;error;</div></pre></td></tr></table></figure>
<ul>
<li><strong>在访问使用__weak修饰符的变量时，实际上该对象必定会被加到autoreleasepool中</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id __weak obj1 = obj0;</div><div class="line">NSLog(@<span class="string">"class = %@"</span>, [obj1 class]);</div></pre></td></tr></table></figure>
<p>与以下代码等效：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id __weak obj1 = obj0;</div><div class="line">id __autoreleasing tmp = obj1;</div><div class="line">NSLog(@<span class="string">"class = %@"</span>, [tmp class]);</div></pre></td></tr></table></figure>
<blockquote>
<p>原因：<br><strong>weak修饰的变量只是弱引用，其指向的对象随时可能被释放而变为nil；<br>为了保证使用过程中对象的持续存在，ARC会将生成</strong>autorelease修饰的临时变量指向该对象，从而将其加入到autoreleasepool中。</p>
</blockquote>
<ul>
<li>注意：<strong>使用__autoreleasing修饰的变量，必须为自动变量（局部变量、函数或方法参数），不能是其他。</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：-4-ARC的所有权修饰符&quot;&gt;&lt;a href=&quot;#内存管理篇：-4-ARC的所有权修饰符&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇： 4.ARC的所有权修饰符&quot;&gt;&lt;/a&gt;内存管理篇： 4.ARC的所有权修饰符&lt;/h2&gt;&lt;h3 id=&quot;所有权修饰符&quot;&gt;&lt;a href=&quot;#所有权修饰符&quot; class=&quot;headerlink&quot; title=&quot;所有权修饰符&quot;&gt;&lt;/a&gt;所有权修饰符&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在ARC下，对象必须通过所有权修饰符进行修饰，系统会根据不同的所有权修饰符对对象进行相应的内存管理。&lt;/li&gt;
&lt;li&gt;所有权修饰符包括：&lt;strong&gt;strong、&lt;/strong&gt;weak、&lt;strong&gt;unsafe_unretained、&lt;/strong&gt;autoreleasing。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》3</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A%203.autorelease/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇： 3.autorelease/</id>
    <published>2019-01-06T07:43:19.318Z</published>
    <updated>2019-01-06T07:44:11.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：-3-autorelease"><a href="#内存管理篇：-3-autorelease" class="headerlink" title="内存管理篇： 3.autorelease"></a>内存管理篇： 3.autorelease</h2><blockquote>
<p><strong>autorelease的实质：</strong><br><em>将创建的对象加入到NSAutoreleasePool管理“数组”中，并告知ARC系统暂时不要对此对象进行处理。待pool对象在其所属的NSRunLoop循环一次完成，准备释放（drain）时，对“数组”中的所有对象依次调用release方法。此时ARC再对对象进行内存管理。</em></p>
</blockquote>
<a id="more"></a>
<h3 id="GNUstep的实现"><a href="#GNUstep的实现" class="headerlink" title="GNUstep的实现"></a>GNUstep的实现</h3><p>GNUstep的版本使用了同NSMutableArray一样的连接列表，将被标记的对象加入到“正在使用中的”autoreleasePool对象中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSObject.m中：</span></div><div class="line">- (id)autorelease &#123;</div><div class="line">    [NSAutoreleasePool addObject:self];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// NSAutoreleasePool.m中：</span></div><div class="line">+ (<span class="keyword">void</span>)addObject:(id)anObj &#123;</div><div class="line">    NSAutoreleasePool *pool = 获取正在使用中的pool；</div><div class="line">    <span class="keyword">if</span> (pool != nil) &#123;</div><div class="line">        [pool addObject:anObj];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addObject:(id)anObj &#123;</div><div class="line">    <span class="comment">// 加入到内部管理的数组中</span></div><div class="line">    [<span class="built_in">array</span> addObject:anObj];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="方法调用优化：在GNUstep实现的版本中，为了提高autorelease方法执行的速度，使用了“IMP-Caching”的方式，及将函数指针提前缓存，需要时跳过了“objc-msgSend”的过程，直接调用："><a href="#方法调用优化：在GNUstep实现的版本中，为了提高autorelease方法执行的速度，使用了“IMP-Caching”的方式，及将函数指针提前缓存，需要时跳过了“objc-msgSend”的过程，直接调用：" class="headerlink" title="方法调用优化：在GNUstep实现的版本中，为了提高autorelease方法执行的速度，使用了“IMP Caching”的方式，及将函数指针提前缓存，需要时跳过了“objc_msgSend”的过程，直接调用："></a>方法调用优化：在GNUstep实现的版本中，为了提高autorelease方法执行的速度，使用了“IMP Caching”的方式，及将函数指针提前缓存，需要时跳过了“objc_msgSend”的过程，直接调用：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSObject.m中：</span></div><div class="line"></div><div class="line"><span class="comment">// 缓存类名</span></div><div class="line">id autorelease_class = [NSAutoreleasePool class];</div><div class="line"><span class="comment">// 缓存方法名</span></div><div class="line">SEL autorelease_sel = @selector(<span class="string">"addObject:"</span>);</div><div class="line"><span class="comment">// 缓存方法实现（函数指针）</span></div><div class="line">IMP autorelease_imp = [autorelease_class methodForSelector:autorelease_sel];</div><div class="line"></div><div class="line">- (id)autorelease &#123;</div><div class="line">    <span class="comment">// 直接调用</span></div><div class="line">    (*autorelease_imp)(autorelease_class, autorelease_sel, self);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>由于NSAutoreleasePool覆盖了autorelease的方法实现（其他对象执行的是NSObject的实现），对pool对象发送autorelease消息会抛出异常。<br>即<strong>不能对NSAutoreleasePool对象调用autorelease方法。</strong></p>
</blockquote>
<ul>
<li>补充：<strong>无论编译环境是否为ARC有效，都推荐使用@autoreleasepool块作为替代</strong>，以提高代码可读性。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：-3-autorelease&quot;&gt;&lt;a href=&quot;#内存管理篇：-3-autorelease&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇： 3.autorelease&quot;&gt;&lt;/a&gt;内存管理篇： 3.autorelease&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;autorelease的实质：&lt;/strong&gt;&lt;br&gt;&lt;em&gt;将创建的对象加入到NSAutoreleasePool管理“数组”中，并告知ARC系统暂时不要对此对象进行处理。待pool对象在其所属的NSRunLoop循环一次完成，准备释放（drain）时，对“数组”中的所有对象依次调用release方法。此时ARC再对对象进行内存管理。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》2</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A%202.alloc-retain-release-dealloc%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇： 2.alloc-retain-release-dealloc的实现/</id>
    <published>2019-01-06T07:42:32.544Z</published>
    <updated>2019-01-06T07:59:00.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：-2-alloc-retain-release-dealloc的实现"><a href="#内存管理篇：-2-alloc-retain-release-dealloc的实现" class="headerlink" title="内存管理篇： 2.alloc/retain/release/dealloc的实现"></a>内存管理篇： 2.alloc/retain/release/dealloc的实现</h2><h3 id="GNUstep的实现方式"><a href="#GNUstep的实现方式" class="headerlink" title="GNUstep的实现方式"></a>GNUstep的实现方式</h3><p><strong>GNUstep的版本将引用计数与对象的内存组合在一起，方便读写存取。</strong><br><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546151436-GNUstep%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84.jpg" alt="img"><br>如图所示，使用了一个objc_layout结构体来表示引用计数，其大体结构及alloc的简化代码为：</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_layout</span> &#123;</span></div><div class="line">    <span class="comment">// 引用计数</span></div><div class="line">    NSUInteger retained;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (id)alloc &#123;</div><div class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(struct objc_layout) + 对象大小；</div><div class="line">    <span class="comment">// 创建一段大小为size的连续内存，并写入0</span></div><div class="line">    <span class="comment">// 使用结构体指针指向此地址</span></div><div class="line">    struct objc_layout *p = <span class="built_in">calloc</span>(<span class="number">1</span>, size);</div><div class="line">    <span class="comment">// 返回id类型对象（地址+1即为对象的地址）</span></div><div class="line">    <span class="keyword">return</span> (id)(p + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>由此可知，retainCount即返回结构体中retained成员的值即可：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (NSUinteger)retainCount &#123;</div><div class="line">    <span class="keyword">return</span> NSExtraRefCount(self) + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> NSUInteger</span></div><div class="line"><span class="title">NSExtraRefCount</span><span class="params">(id anObject)</span> &#123;</div><div class="line">    <span class="comment">// 由于对象指向的是+1的地址，故-1即为结构体实例的地址</span></div><div class="line">    <span class="keyword">return</span> ((struct objc_layout *)anObject)[<span class="number">-1</span>].retained;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于初始化的内存中填充数据为0，故新对象的引用计数为1（0+1）。</p>
<p><strong>而对于retain和release操作，即对retained变量进行+1和-1操作即可。而且，在release操作时，当retained为0时，运行时系统即调用dealloc方法，将对象的内存释放。</strong></p>
<h3 id="苹果的实现方式"><a href="#苹果的实现方式" class="headerlink" title="苹果的实现方式"></a>苹果的实现方式</h3><p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546151340-Apple%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E8%A1%A8.jpg" alt="img"></p>
<p>直接看图，<strong>苹果使用了单独的引用计数表来存储所有对象的引用计数。且使用了对象内存地址的hash值作为key，将引用计数作为内容进行保存</strong>。简单的实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)retainCount &#123;</div><div class="line">    <span class="keyword">return</span> (NSUInteger)__CFDoExternRefOperation(OPERATION_retainCount, self);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)retain &#123;</div><div class="line">    <span class="keyword">return</span> (id)__CFDoExternRefOperation(OPERATION_retain, self);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)release &#123;</div><div class="line">    <span class="keyword">return</span> (id)__CFDoExternRefOperation(OPERATION_release, self);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所调用的方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __CFDoExternRefOperation(<span class="keyword">unitptr_t</span> op, id obj) &#123;</div><div class="line">    <span class="comment">// 获取引用计数表</span></div><div class="line">    CFBasicHashRef table = 取得对象对应的散列表(obj);</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    </div><div class="line">    <span class="comment">// 根据操作分发给不同函数</span></div><div class="line">    <span class="keyword">switch</span> (op) &#123;</div><div class="line">    <span class="keyword">case</span> OPERATION_retainCount:</div><div class="line">        <span class="comment">// retainCount</span></div><div class="line">        count = CFBasicHashGetCountOfKey(table, obj);</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    <span class="keyword">case</span> OPERATION_retain:</div><div class="line">        <span class="comment">// retain</span></div><div class="line">        CFBasicHashAddValue(table, obj);</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    <span class="keyword">case</span> OPERATION_release:</div><div class="line">        <span class="comment">// release</span></div><div class="line">        count = CFBasicHashRemoveValue(table, obj);</div><div class="line">        <span class="keyword">return</span> (<span class="number">0</span> == count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>苹果的实现虽然看似没有GNUstep的方式简单，实际上其优点也是显而易见：</p>
<ul>
<li>对象创建时，其内存分配无需考虑引用计数相关逻辑，结构纯粹。</li>
<li>引用计数表中，可以根据内存块的地址追溯对象的原始内存，方便调试及内存泄露检测等功能。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：-2-alloc-retain-release-dealloc的实现&quot;&gt;&lt;a href=&quot;#内存管理篇：-2-alloc-retain-release-dealloc的实现&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇： 2.alloc/retain/release/dealloc的实现&quot;&gt;&lt;/a&gt;内存管理篇： 2.alloc/retain/release/dealloc的实现&lt;/h2&gt;&lt;h3 id=&quot;GNUstep的实现方式&quot;&gt;&lt;a href=&quot;#GNUstep的实现方式&quot; class=&quot;headerlink&quot; title=&quot;GNUstep的实现方式&quot;&gt;&lt;/a&gt;GNUstep的实现方式&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;GNUstep的版本将引用计数与对象的内存组合在一起，方便读写存取。&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1546151436-GNUstep%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84.jpg&quot; alt=&quot;img&quot;&gt;&lt;br&gt;如图所示，使用了一个objc_layout结构体来表示引用计数，其大体结构及alloc的简化代码为：&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C高级编程 iOS与OS X多线程与内存管理》1</title>
    <link href="http://yoursite.com/2019/01/06/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87%EF%BC%9A1.%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/01/06/内存管理篇：1.引用计数的思考方式/</id>
    <published>2019-01-06T07:40:57.232Z</published>
    <updated>2019-01-06T07:44:02.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理篇：1-引用计数的思考方式"><a href="#内存管理篇：1-引用计数的思考方式" class="headerlink" title="内存管理篇：1.引用计数的思考方式"></a>内存管理篇：1.引用计数的思考方式</h2><h3 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h3><blockquote>
<p>支持条件：</p>
<ul>
<li>clang（LLVM编译器）3.0版本以上</li>
<li>objc4 OC运行时库 493.9版本以上</li>
<li>编译器设置中置为“ARC有效”</li>
<li>Xcode 4.2版本以上</li>
</ul>
</blockquote>
<a id="more"></a>
<p><strong>简单来说，ARC作为编译器特性（运行时库帮助解决weak自动置nil及autorelease优化等功能），系统在编译期根据情况，为代码自动添加retain、release等内存管理代码</strong>。开发者只需要集中精力在业务实现上即可，无需过多考虑内存问题。</p>
<h3 id="内存管理的思考方式"><a href="#内存管理的思考方式" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h3><p>实际上，<strong>无需过多考虑“引用计数”这个数字</strong>，编码时只需遵循如下四种规则：</p>
<ol>
<li>自己生成的对象，自己持有（alloc/new/copy/mutableCopy）</li>
<li>非自己生成的对象，自己也能持有（retain）</li>
<li>自己不再需要持有的对象，自己释放（release）</li>
<li>非自己持有的对象，自己无法释放（系统自动dealloc）</li>
</ol>
<h4 id="自己生成的对象，自己持有"><a href="#自己生成的对象，自己持有" class="headerlink" title="自己生成的对象，自己持有"></a>自己生成的对象，自己持有</h4><p>除了默认的四种创建对象方法，这里还需注意一点：<br>对于自定义的class，在编写API时，需要遵循“命名法则”：即将创建对象的方法，声明为：</p>
<ul>
<li>allocXXX…</li>
<li>newXXX…</li>
<li>copyXXX…</li>
<li>mutableCopyXXX…</li>
</ul>
<p>ARC环境下，系统会根据方法命名，自动将返回的对象使用__strong修饰，即新对象的内存由创建方负责管理，也就是“自己持有创建的对象”。</p>
<h4 id="非自己生成的对象，自己也能持有"><a href="#非自己生成的对象，自己也能持有" class="headerlink" title="非自己生成的对象，自己也能持有"></a>非自己生成的对象，自己也能持有</h4><ul>
<li>对于其他对象（非自己创建的），如果需要正常使用的话，需要对新对象进行“retain”操作。</li>
<li>对于类方法创建对象的API（如NSMutableArray的array方法），一般来说，内部返回的都是“autorelease”修饰的对象，内存是无需接收方管理的。直接使用即可。</li>
</ul>
<h4 id="自己不再需要持有的对象，自己释放"><a href="#自己不再需要持有的对象，自己释放" class="headerlink" title="自己不再需要持有的对象，自己释放"></a>自己不再需要持有的对象，自己释放</h4><ul>
<li>使用完毕后的对象，无论是否为自己创建，需要持有方对其调用“release”操作，放弃持有。</li>
<li>类方法创建得到的对象，无需释放。</li>
</ul>
<h4 id="非自己持有的对象，自己无法释放"><a href="#非自己持有的对象，自己无法释放" class="headerlink" title="非自己持有的对象，自己无法释放"></a>非自己持有的对象，自己无法释放</h4><p>dealloc为系统在运行期根据对象的引用情况自动调用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理篇：1-引用计数的思考方式&quot;&gt;&lt;a href=&quot;#内存管理篇：1-引用计数的思考方式&quot; class=&quot;headerlink&quot; title=&quot;内存管理篇：1.引用计数的思考方式&quot;&gt;&lt;/a&gt;内存管理篇：1.引用计数的思考方式&lt;/h2&gt;&lt;h3 id=&quot;自动引用计数&quot;&gt;&lt;a href=&quot;#自动引用计数&quot; class=&quot;headerlink&quot; title=&quot;自动引用计数&quot;&gt;&lt;/a&gt;自动引用计数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;支持条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clang（LLVM编译器）3.0版本以上&lt;/li&gt;
&lt;li&gt;objc4 OC运行时库 493.9版本以上&lt;/li&gt;
&lt;li&gt;编译器设置中置为“ARC有效”&lt;/li&gt;
&lt;li&gt;Xcode 4.2版本以上&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Objective-C 20 编写高质量iOS与OS X代码的52个有效方法》读书笔记</title>
    <link href="http://yoursite.com/2018/12/25/%E3%80%8AEffective%20Objective-C%2020%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/25/《Effective Objective-C 20 编写高质量iOS与OS X代码的52个有效方法》读书笔记/</id>
    <published>2018-12-25T02:49:27.623Z</published>
    <updated>2019-01-06T07:41:16.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第1章：熟悉Objective-C"><a href="#第1章：熟悉Objective-C" class="headerlink" title="第1章：熟悉Objective-C"></a>第1章：熟悉Objective-C</h2><h3 id="第4条：多用类型常量，少用-define预处理指令"><a href="#第4条：多用类型常量，少用-define预处理指令" class="headerlink" title="第4条：多用类型常量，少用#define预处理指令"></a>第4条：多用类型常量，少用#define预处理指令</h3><ul>
<li>声明类型常量好处是，编译器可以知道此变量的类型，且可以防止外部随意修改</li>
<li>声明规则：<a id="more"></a>
<ul>
<li><strong>全局常量</strong>：<em>使用extern开头，类名作为常量前缀（OC无命名空间，避免冲突），const修饰常量名，头文件声明，实现文件赋值</em>。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在ViewController.h中声明通知名</span></div><div class="line"><span class="comment">/** ViewController视图已加载通知 */</span></div><div class="line"><span class="keyword">extern</span> NSString * <span class="keyword">const</span> ViewControllerViewDidLoadNotification;</div><div class="line"></div><div class="line"><span class="comment">// 在ViewController.m中赋值通知名</span></div><div class="line">NSString *<span class="keyword">const</span> ViewControllerViewDidLoadNotification = @<span class="string">"ViewControllerViewDidLoadNotification"</span>;</div></pre></td></tr></table></figure>
<pre><code>- **局部常量**（类内使用的）：*使用static开头，“k”作为常量前缀，const修饰常量名，在实现文件中声明及赋值*。这种局部常量（static + const）的优点是：**编译器不会创建符号，会像#define一样，把遇到的所有变量直接替换，但是带有类型信息**。
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 动画时长 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> NSTimeInterval kAnimationDuration = <span class="number">0.3</span>;</div></pre></td></tr></table></figure>
<h3 id="第5条：用枚举表示状态、选项、状态码"><a href="#第5条：用枚举表示状态、选项、状态码" class="headerlink" title="第5条：用枚举表示状态、选项、状态码"></a>第5条：用枚举表示状态、选项、状态码</h3><ul>
<li>如果枚举值的选项可以进行组合，则使用时，用“按位或”操作（“|”）。声明枚举时，使用二进制进行表示。</li>
<li><p>NS_OPTIONS和NS_ENUM其实都是定义的宏，可以向下兼容（编译器支持新枚举特性时生成的enum带有类型声明，否则没有）。</p>
<blockquote>
<p>凡是需要以按位或操作来组合的枚举都应使用NS_OPTIONS定义。若是枚举不需要相互组合，则应使用NS_ENUM来定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_OPTIONS</span><span class="params">(NSUInteger, UIViewAutoresizing)</span> </span>&#123;</div><div class="line">    UIViewAutoresizingNone                 = <span class="number">0</span>,</div><div class="line">    UIViewAutoresizingFlexibleLeftMargin   = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    UIViewAutoresizingFlexibleWidth        = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    UIViewAutoresizingFlexibleRightMargin  = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    UIViewAutoresizingFlexibleTopMargin    = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    UIViewAutoresizingFlexibleHeight       = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    UIViewAutoresizingFlexibleBottomMargin = <span class="number">1</span> &lt;&lt; <span class="number">5</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_ENUM</span><span class="params">(NSInteger, UIViewAnimationTransition)</span> </span>&#123;</div><div class="line">    UIViewAnimationTransitionNone,</div><div class="line">    UIViewAnimationTransitionFlipFromLeft,</div><div class="line">    UIViewAnimationTransitionFlipFromRight,</div><div class="line">    UIViewAnimationTransitionCurlUp,</div><div class="line">    UIViewAnimationTransitionCurlDown,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>在switch语句中，使用枚举变量时，不要加default分支，这样编译器会提示是否还有未枚举的分支。</p>
</li>
</ul>
<h2 id="第2章：对象、消息、运行期"><a href="#第2章：对象、消息、运行期" class="headerlink" title="第2章：对象、消息、运行期"></a>第2章：对象、消息、运行期</h2><h3 id="第7条：在对象内部尽量直接访问实例变量"><a href="#第7条：在对象内部尽量直接访问实例变量" class="headerlink" title="第7条：在对象内部尽量直接访问实例变量"></a>第7条：在对象内部尽量直接访问实例变量</h3><blockquote>
<ul>
<li>在对象内部读取数据时，应该直接通过实例变量来读；而写入数据时，则应通过属性来写。</li>
<li>在初始化和dealloc方法中，总应该直接通过实例变量来读写数据。</li>
<li>有时会使用惰性初始化技术配置某份数据，这种情况下，需要通过属性来读取数据。</li>
</ul>
</blockquote>
<h3 id="第8条：理解“对象等同性”这一概念"><a href="#第8条：理解“对象等同性”这一概念" class="headerlink" title="第8条：理解“对象等同性”这一概念"></a>第8条：理解“对象等同性”这一概念</h3><ul>
<li><p>NSObject协议中用于判定对象相等的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isEqual:(id)object;</div><div class="line">- (NSUInteger)hash;</div><div class="line"><span class="comment">// 协议里hash为只读属性： @property (readonly) NSUInteger hash;</span></div></pre></td></tr></table></figure>
</li>
<li><p><em>如果两个对象相等，则其hash值必然相等；反之则不一定</em>（因为isEqual:方法先回判断两者是否为相同类型）。</p>
</li>
<li>自定义类型中，若提供判定对象相等方法，可以实现上述方法和属性。</li>
</ul>
<h3 id="第11条：理解objc-msgSend的作用"><a href="#第11条：理解objc-msgSend的作用" class="headerlink" title="第11条：理解objc_msgSend的作用"></a>第11条：理解objc_msgSend的作用</h3><ul>
<li><em>objc_msgSend使用了“<strong>尾调用优化</strong>”技术（tail-call optimization），实质上即为<strong>函数调用的栈帧的复用</strong></em>。<ul>
<li>一般来说，函数调用时，会在栈中生成新的栈帧（申请一块新的栈内存），跳转过去进行新函数的调用。当在函数执行过程中，如果再次调用其他函数，会再次压入新的栈帧并跳转，直到依次调用完毕再返回并释放栈帧的内存。</li>
<li>对于OC来说，<strong>当函数调用中，如果返回值“仅仅”是调用其他函数（没有其他任何操作，如进行其他运算等），则会把当前函数调用的栈帧直接交给调用的新函数（自身数据变为新函数的）</strong>。这样即避免了重复申请内存，而且调用地址不必来回跳转，在多个函数调用时对效率的提升和内存控制尤其有效。</li>
<li><a href="https://www.jianshu.com/p/9e3cd9b1095a?from=timeline&amp;isappinstalled=0" target="_blank" rel="external">iOS objc_msgSend尾调用优化机制详解</a></li>
</ul>
</li>
</ul>
<h3 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h3><ul>
<li><strong>动态方法解析</strong>：<em>在方法未找到时执行的第一步操作，即</em>resolveInstanceMethod<em>和</em>resolveClassMethod<em>方法。在此函数中使用class_addMethod可以为当前类添加动态实例方法或类方法（类方法要添加到class的meta class中）</em>。之后，当前实例即会缓存并调用新添加的方法，且以后会在缓存列表内直接调用，不再进行方法解析步骤。一般来说，我们会在存在@dymamic修饰的属性所属的类中通过此方法来提供实现，比如Core Data的数据类中。</li>
<li><strong>备援接收者</strong>：动态解析过程若没有提供方法时，则进入此步骤。<em>在方法</em>forwardingTargetForSelector<em>方法中，运行时系统会将此selector对应的消息原封不动转发给返回的对象</em>。利用<em>此方法可以模拟出”多继承“</em>：即将对应方法转发给可以执行的类实例。</li>
<li><strong>完整的消息转发机制</strong>：上一步只能转发原始消息，如果对方法参数等需要二次修改，则需要通过此步骤（上一步没有成功执行即会进入此步，所以性能代价会大一些）。<em>系统会通过forwardInvocation方法，将原target、selector和parameter等封装为NSInvocation对象。我们需要将此invocation的目标改为对应的接收者，使其执行。也可以对selector进行修改，如增删改参数，甚至改变selector。不能处理时，通过super返回给父类实例进行处理，直到NSObject最终触发doesNotRecognizeSelector方法，抛出异常</em>。</li>
</ul>
<h2 id="接口与API设计"><a href="#接口与API设计" class="headerlink" title="接口与API设计"></a>接口与API设计</h2><h3 id="第15条：用前缀避免命名空间冲突"><a href="#第15条：用前缀避免命名空间冲突" class="headerlink" title="第15条：用前缀避免命名空间冲突"></a>第15条：用前缀避免命名空间冲突</h3><ul>
<li>双字符前缀是苹果官方使用的，自己需要使用至少三字符的前缀，避免冲突。</li>
<li>类的实现文件中定义的c函数在编译后的目标文件（.o）中会成为顶级符号（全局符号），所有也需要添加前缀。</li>
<li>自己封装的库中，若引用了其他第三方库，应对第三方库的类文件分别添加前缀命名。防止其他项目引入本库后，再引入同样的第三方库产生命名冲突。</li>
</ul>
<h3 id="第16条：提供“全能初始化”方法"><a href="#第16条：提供“全能初始化”方法" class="headerlink" title="第16条：提供“全能初始化”方法"></a>第16条：提供“全能初始化”方法</h3><ul>
<li>类中存在多个初始化方法是，需要指定一个作为“全能初始化”方法（designed initializer），使其余方法都通过此方法进行实例的初始化。对后期修改维护有利。</li>
<li><p>子类继承时，<strong>如果子类存在自己独特的“全能初始化”方法，则必须要覆盖父类的全能初始化方法（防止使用父类的方法创建子类实例）</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 父类：矩形类</span></div><div class="line"></div><div class="line"><span class="comment">// EOCRectangle.h</span></div><div class="line">@interface EOCRectangle: NSObject</div><div class="line"></div><div class="line">@property (nonatomic, assign, readonly) <span class="keyword">float</span> width;</div><div class="line">@property (nonatomic, assign, readonly) <span class="keyword">float</span> height;</div><div class="line"></div><div class="line">- (id)initWithWidth:(<span class="keyword">float</span>)width </div><div class="line">         andHeight:(<span class="keyword">float</span>)height;</div><div class="line">         </div><div class="line">@end</div><div class="line"></div><div class="line"><span class="comment">// EOCRectangle.m</span></div><div class="line">@implementation EOCRectangle</div><div class="line"></div><div class="line"><span class="comment">/** designed initializer */</span></div><div class="line">- (id)initWithWidth:(<span class="keyword">float</span>)width </div><div class="line">         andHeight:(<span class="keyword">float</span>)height &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        _width = width;</div><div class="line">        _height = height;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** overrided initializer */</span></div><div class="line">- (id)init &#123;</div><div class="line">    <span class="keyword">return</span> [self initWithWidth:<span class="number">5.0f</span> andHeight:<span class="number">10.0f</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"><span class="comment">// 子类：正方形类</span></div><div class="line"></div><div class="line"><span class="comment">// EOCSquare.h</span></div><div class="line">@interface EOCSquare: EOCRectangle</div><div class="line"></div><div class="line">- (id)initWithDimension:(<span class="keyword">float</span>)dimension;</div><div class="line">         </div><div class="line">@end</div><div class="line"><span class="comment">// EOCSquare.m</span></div><div class="line">@implementation EOCSquare</div><div class="line"><span class="comment">/** designed initializer */</span></div><div class="line">- (id)initWithDimension:(<span class="keyword">float</span>)dimension &#123;</div><div class="line">    <span class="keyword">return</span> [super initWithWidth:dimension height:dimension];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** overrided initializer */</span></div><div class="line">- (id)initWithWidth:(<span class="keyword">float</span>)width </div><div class="line">         andHeight:(<span class="keyword">float</span>)height &#123;</div><div class="line">    <span class="keyword">float</span> dimension = MAX(width, height);</div><div class="line">    <span class="keyword">return</span> [self initWithDimension:dimenson];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
<li><p><em>如果类中存在多种完全不同的初始化方式，则需要多个“全能初始化”方法</em>。如遵循NSCoding协议的类，需要实现<em>initWithCoder</em>方法作为单独的“全能初始化”方法。</p>
</li>
</ul>
<h3 id="第18条：尽量使用不可变对象"><a href="#第18条：尽量使用不可变对象" class="headerlink" title="第18条：尽量使用不可变对象"></a>第18条：尽量使用不可变对象</h3><ul>
<li><p>需要公开的属性，尽量用“readonly”进行语义修饰，防止外部进行修改；内部修改时，在分类中可以修改为“readwrite”</p>
<ol>
<li>由于iOS的属性一般使用“nonatomic”进行修饰，为了防止极端情况下，内部修改属性时，外部读取产生的数据不统一的情况，可以使用GCD的同步操作对读取和修改进行统一处理。</li>
<li>不考虑外部使用“KVC”的方式对只读属性设置，甚至是根据实例内存布局通过内存偏移量对属性进行强制修改的情况，还是应该尽量遵循此属性声明方式。</li>
</ol>
</li>
<li><p>对于可变集合对象，尽量不要作为公开属性。</p>
<ol>
<li>可以声明为分类中的属性，或是类的成员变量。在外部使用不可变的版本进行属性公开。</li>
<li>增删改等方式，提供公开方法用以外部调用。</li>
</ol>
</li>
</ul>
<h3 id="第20条：为私有方法名加前缀"><a href="#第20条：为私有方法名加前缀" class="headerlink" title="第20条：为私有方法名加前缀"></a>第20条：为私有方法名加前缀</h3><ul>
<li>为普通类的私有方法（在实现文件中的声明并只提供内部调用的方法）的方法名前，添加“p_”作为前缀，提高调试效率。</li>
<li>对于自定义的库文件类，甚至可以使用“类名 + _”的方式为私有方法命名，尽量减少命名冲突。</li>
</ul>
<h3 id="第21条：理解Objective-C错误类型"><a href="#第21条：理解Objective-C错误类型" class="headerlink" title="第21条：理解Objective-C错误类型"></a>第21条：理解Objective-C错误类型</h3><ul>
<li>在ARC下，代码不是“异常安全”（exception safe）的：即当抛出异常时，本应该在作用域末尾自动释放的内存，便不会释放了（MRC下，需要开发者在抛出异常之前手动释放所有内存，极易出错）。</li>
</ul>
<h2 id="第4章-协议与分类"><a href="#第4章-协议与分类" class="headerlink" title="第4章 协议与分类"></a>第4章 协议与分类</h2><h3 id="第23条：通过委托与数据源协议进行对象间通信"><a href="#第23条：通过委托与数据源协议进行对象间通信" class="headerlink" title="第23条：通过委托与数据源协议进行对象间通信"></a>第23条：通过委托与数据源协议进行对象间通信</h3><ul>
<li><p>协议分类及数据流向</p>
<ol>
<li><em>若某类实例需要让其他对象代替实现某些逻辑功能，则可以把需要实现逻辑的方法抽象为协议，让“其他对象”成为其“委托对象”，实现协议的方法</em>。此模式即为“<strong>委托模式</strong>”，数据流向为“Class -&gt; Delegate”。如：UITableViewDelegate，tableView实例将处理列表点击等行为委托给代理对象（如UIViewController实例）。 </li>
<li><em>若某类实例需要通过一些方法获取数据，则可以把这些方法抽象为协议，让“其他对象”成为其“委托对象”，实现协议的方法</em>。这种委托模式也称为“<strong>数据源模式</strong>”，数据流向为“Data Source -&gt; Class”。如：UITableViewDataSource，tableView实例从代理对象（如UIViewController实例）中获取列表的数据等。<br><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F.jpg" alt="img"></li>
</ol>
</li>
<li><p>提高协议方法的调用效率</p>
<ol>
<li>众所周知，对于optional的协议方法，调用前需要进行实现判断（使用respondsToSelector方法）。若在委托对象中频繁调用此方法（如下载progress等），每次进行响应判断，意义不大，且效率可能会出现瓶颈。针对此情况，可以使用“位段”方式（bitField）进行优化，对于是否能够响应协议方法调用，只需要一个二进制位（bit）即可进行表示。所以，可以为委托对象所属的类声明一个结构体成员变量。此结构体内部的成员与所有的optional协议方法一一对应，成员值均为0或1。然后，在设置代理对象时，将所有的实现情况进行判断并赋值到此结构体成员变量中。即可在实际回调协议方法是免去每次进行响应判断，提高效率。<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">@porotocol DownloadProtocol: NSObject</div><div class="line">...</div><div class="line">@optional</div><div class="line">- (<span class="keyword">void</span>)onDownloadingProgress:(CGFloat)progress;</div><div class="line">...</div><div class="line">@end</div><div class="line"></div><div class="line">...</div><div class="line"><span class="meta">#import <span class="meta-string">"DownloadProtocol.h"</span></span></div><div class="line"></div><div class="line">@interface MyClass: NSObject</div><div class="line"></div><div class="line">@property (nonatomic, weak) id&lt;DownloadProtocol&gt; delegate;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@<span class="function">interface <span class="title">MyClass</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 声明结构体变量成员</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">        NSInteger onDownloadProgress: <span class="number">0</span></div><div class="line">    &#125; _downloadProtocolFlag;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MyClass: NSObject </div><div class="line"></div><div class="line"><span class="comment">// 手动实现delegate的setter，对代理对象的方法实现情况进行检查并缓存</span></div><div class="line">- (<span class="keyword">void</span>)setDelegate:(id&lt;DownloadProtocol&gt;)delegate &#123;</div><div class="line">    _delegate = delegate;</div><div class="line">    <span class="comment">// 对所有optional方法依次检查，这里只是一个</span></div><div class="line">    _downloadProtocolFlag.onDownloadProgress = [_delegate respondsToSelector:@selector(onDownloadProgress:)]; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实际调用时，即可简化判断，提高效率</span></div><div class="line">- (<span class="keyword">void</span>)testMyDownloadProgress:(CGFloat)progress &#123;</div><div class="line">    <span class="keyword">if</span> (_downloadProtocolFlag.onDownloadProgress) &#123;</div><div class="line">    [self.delegate onDownloadProgress: progress];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="第24条：将类的实现代码分散到便于管理的数个分类之中"><a href="#第24条：将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="第24条：将类的实现代码分散到便于管理的数个分类之中"></a>第24条：将类的实现代码分散到便于管理的数个分类之中</h3><ul>
<li>有时无需继承父类时，可有使用分类（Category）方式扩展类的功能。</li>
<li>使用分类将不同功能的的代码分隔到不同区块中，可以防止原始类过于庞大，代码逻辑清晰，便于调试（调用信息的符号中会显示为不同的分类）。</li>
<li>对于类或模块内部的私有方法，可以创建private分类，且不对外公开。</li>
</ul>
<h3 id="第25条：总是为第三方类的分类名称加前缀"><a href="#第25条：总是为第三方类的分类名称加前缀" class="headerlink" title="第25条：总是为第三方类的分类名称加前缀"></a>第25条：总是为第三方类的分类名称加前缀</h3><ul>
<li>在OC中，由于分类是在运行期进行加载，且各分类的加载顺序依照编译顺序而定（在build phrase中可以手动修改，当然分类的加载是在本类之后），故分类中可以覆盖本类的方法。但是，当多个分类同时覆盖本类方法后，便无法确定调用时的版本了（只能依靠build phrase顺序）【分类的方法在加载时，依照类似链表“头插法”的方式，将方法添加到类的方法列表头部，原始方法则被挤到了后面，所以当调用方法时，系统只找到第一个方法后便直接跳转执行】。所以，为了避免分类异常覆盖本类方法时，需要如下做法进行改进（OC没有命名空间）：<ul>
<li>创建类的分类时，需要为分类名前添加自定义的前缀</li>
<li>创建分类的方法时，需要为各方法名前也添加自定义的前缀</li>
</ul>
</li>
</ul>
<h3 id="第26条：勿在分类中声明属性"><a href="#第26条：勿在分类中声明属性" class="headerlink" title="第26条：勿在分类中声明属性"></a>第26条：勿在分类中声明属性</h3><ul>
<li><strong>“属性”实质上是数据的封装，背后有成员变量作为数据支持，系统只是合成了setter和getter</strong>。</li>
<li>分类中不能生成真正属性的原因：由于编译期，本类的内存布局结构已经确定（实例变量区域的偏移量及大小已经确定），分类在运行期加载时，已经无法在本类的实例变量区域进行操作。</li>
<li><p>分类中声明并实现“属性”的方法：</p>
<ol>
<li>使用正常语法声明，使用相关对象（associate object）实现属性的setter和getter（只是模拟属性，添加了内存管理语义）。</li>
<li>使用@dynamic关键字告知编译器，在运行期再提供实现。可以通过方法转发的方式（如resolveInstanceMethod）提供动态实现。</li>
</ol>
</li>
<li><p>由于属性是实例变量的封装，所以建议属性依照实例变量的方式，在主类的头文件中直接进行声明。</p>
</li>
<li><strong>分类只是用于扩展类的功能，而非提供类的额外存储</strong>。</li>
</ul>
<h3 id="第27条：使用“class-continuation分类”隐藏实现细节"><a href="#第27条：使用“class-continuation分类”隐藏实现细节" class="headerlink" title="第27条：使用“class-continuation分类”隐藏实现细节"></a>第27条：使用“class-continuation分类”隐藏实现细节</h3><ul>
<li>此”class-continuation分类”即为类的扩展（extension）。这是唯一可以在其中同时声明实例变量、属性和方法的匿名“分类”。原因：<strong>类的扩展是与本类源码一起在编译期共同确定类的内存布局</strong>，所以此时会将扩展的实例变量等一同加载到类的对应部分。</li>
<li>可以将不对外公开的方法、属性和实例变量等放在扩展中。</li>
<li>在扩展中引用C++代码，可以只在当前类中引入C++编译器进行混合编译（类实现文件要用“.mm”为后缀），头文件对外仍然只公布简洁的OC风格接口。</li>
<li>可以在头文件中声明只读属性，扩展中重新声明为可读写属性，内部使用setter进行数据修改时，可以正常触发KVO监听回调。</li>
<li>在扩展中遵循只在内部使用的协议。</li>
</ul>
<h3 id="第28条：通过协议提供匿名对象"><a href="#第28条：通过协议提供匿名对象" class="headerlink" title="第28条：通过协议提供匿名对象"></a>第28条：通过协议提供匿名对象</h3><ul>
<li>对于无需外部关心的类（只关心提供的功能），可以将所需功能封装为协议，将类名淡化为遵循此协议的匿名对象（id<myprotocol>）。</myprotocol></li>
<li>此种设计方法可以在后端进行实现替换，而对前端调用方完全透明，增加了编码的灵活程度，也降低了耦合（例如使用不同类数据库进行数据存取，协议中只提供通用的连接、断开、增删改查等方法即可）。</li>
</ul>
<h2 id="第5章-内存管理"><a href="#第5章-内存管理" class="headerlink" title="第5章 内存管理"></a>第5章 内存管理</h2><h3 id="第29条：理解引用计数"><a href="#第29条：理解引用计数" class="headerlink" title="第29条：理解引用计数"></a>第29条：理解引用计数</h3><p>在手动管理内存模式下，内存管理语义为“strong”的属性，其setter一般都是如此实现的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setFoo:(id)foo &#123;</div><div class="line">    <span class="comment">// 1.保留新值</span></div><div class="line">    [foo retain];</div><div class="line">    <span class="comment">// 2.释放原有值</span></div><div class="line">    [_foo release];</div><div class="line">    <span class="comment">// 3.赋值</span></div><div class="line">    _foo = foo</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，为何1和2步骤不能交换呢？<br>因为，当使用重复的foo对象进行设置时（假设foo对象只被本类实例保留），先释放，会导致foo对象内存被系统回收。致使setter失败【使用ARC即可避免此问题发生】。</p>
<h3 id="第30条：以ARC简化引用计数"><a href="#第30条：以ARC简化引用计数" class="headerlink" title="第30条：以ARC简化引用计数"></a>第30条：以ARC简化引用计数</h3><ul>
<li><p>使用ARC时必须遵循的方法命名规则</p>
<ul>
<li>方法名以“alloc、new、copy和mutableCopy”为开头时，其返回对象的内存管理由调用方负责。即在方法中，系统不会自动添加内存管理语句。</li>
<li>方法名以其他方式命名的，其返回对象的内存管理由方法自身负责。即在方法中，系统会自动给返回的对象添加autorelease操作。</li>
<li>ARC对代码的额外优化：<ul>
<li>编译期：对于多次的retain和release操作，ARC会根据情况适当成对的抵消掉此调用操作。</li>
<li>运行期：例如，对于使用方法调用返回autorelease的对象，ARC会使用objc_autoreleaseReturnValue来替代传统的autorelease方法，此时会检查函数返回之后的代码：若调用方需要对此对象进行保留，则不会执行autorelease操作，而是设置全局标志位；调用方retain时，使用objc_retainAutoreleasedReturnValue函数，检查此标志位，若已置位，则不执行retain操作，直接使用。这样，通过检测标志位代替传统的autorelease和retain，优化了执行效率。</li>
</ul>
</li>
</ul>
</li>
<li><p>ARC如何清理实例变量</p>
<ul>
<li>在ARC环境下，系统会利用Objective-C++的清理例程（cleanup routine）特性，待回收的对象会调用所有C++对象的析构函数。ARC借住此特性，会在dealloc中生成清理内存的代码。</li>
<li>对于非OC对象，如CF对象或手动malloc的对象，在dealloc方法中还是需要手动释放这些对象的内存</li>
<li>在deallc中无需调用super方法。</li>
</ul>
</li>
<li><p>覆写内存管理方法</p>
<ul>
<li>不能调用或覆盖release和retain等内存管理方法【单例中尤其注意】：ARC会优化retain、release等相关操作，使其不经过OC的消息派发机制（方法调用），底层使用了c函数版本进行了实现。</li>
</ul>
</li>
</ul>
<h3 id="第31条：在dealloc方法中只释放引用并解除监听"><a href="#第31条：在dealloc方法中只释放引用并解除监听" class="headerlink" title="第31条：在dealloc方法中只释放引用并解除监听"></a>第31条：在dealloc方法中只释放引用并解除监听</h3><ul>
<li>ARC下，dealloc方法会自动释放创建的OC对象的引用，但需要手动释放Core Foundation创建的对象和其他手动申请内存并创建的c对象。</li>
<li>dealloc中尽量不要调用其他方法（如实例方法等）</li>
<li>dealloc过程中，由于实例已经处于“释放状态”，无法确保代码会执行在确定的线程上。故不能在释放是执行异步多线程代码。</li>
<li>dealloc中释放KVO监听和NSNotificationCenter中注册的通知</li>
<li>对于创建和释放开销较大和系统稀缺的资源，一般单独创建自己的清理方法（如数据库对象的“连接”和“关闭”操作等）。使用完成后即提示调用者进行及时的资源清理，而不是在dealloc中释放内存【dealloc中可以检查是否正确清理此对象，没有则自动调用并给出debug提示】。</li>
</ul>
<h3 id="第35条：用“僵尸对象”调试内存管理问题"><a href="#第35条：用“僵尸对象”调试内存管理问题" class="headerlink" title="第35条：用“僵尸对象”调试内存管理问题"></a>第35条：用“僵尸对象”调试内存管理问题</h3><ul>
<li>在“XCode-&gt;Scheme-&gt;Run-&gt;Diagnostics”中，勾选“Enable Zombie Objects”选项，开启功能。</li>
<li>在调试模式中，开启此功能，可以防止已释放对象的内存被覆盖重用，可以帮助追溯调用过程和类型信息等。</li>
<li><p>已释放对象转化为“僵尸对象”的过程（“僵尸模式”开启的情况下，NSObject的dealloc会在运行期swizzle成类似以下代码）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取待释放对象所属的类</span></div><div class="line">Class cls = object_getClass(self);</div><div class="line"></div><div class="line"><span class="comment">// 获取类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *clsName = class_getName(cls);</div><div class="line"></div><div class="line"><span class="comment">// 生成僵尸类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *zombieClsName = <span class="string">"_NSZombie_"</span> + clsName;</div><div class="line"></div><div class="line"><span class="comment">// 查看是否存在此类</span></div><div class="line">Class zombieCls = objc_lookUpClass(zombieClsName);</div><div class="line"></div><div class="line"><span class="comment">// 不存在，则创建此类</span></div><div class="line"><span class="keyword">if</span> (!zombieCls) &#123;</div><div class="line">    <span class="comment">// 获取名为“_NSZombie_”的样板类</span></div><div class="line">    Class baseZombieCls = objc_lookUpClass(<span class="string">"_NSZombie_"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 复制样板类来创建此类</span></div><div class="line">    zombieCls = objc_duplicateClass(baseZombieCls, zombieClsName, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 正常释放实例</span></div><div class="line">objc_destructInstance(self);</div><div class="line"></div><div class="line"><span class="comment">// 将实例所属类指向新的僵尸类（替换isa指向）</span></div><div class="line">objc_setClass(self, zombieCls);</div><div class="line"></div><div class="line"><span class="comment">// 现在，self即为“_NSZombie_原始类名”的实例了</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>“僵尸类“为”根类“，只存在isa指针，没有任何方法实现（样本类的拷贝）。故其实例接收到的所有消息都需要进行完整的消息转发</strong>。被转发的消息响应过程的伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取对象类名</span></div><div class="line">Class cls = objc_getClass(self);</div><div class="line"></div><div class="line"><span class="comment">// 查看是否为”僵尸类“</span></div><div class="line"><span class="keyword">if</span> (String_has_prefix(clsName, <span class="string">"_NSZombie_"</span>)) &#123;</div><div class="line">    <span class="comment">// 是，则对象是”僵尸对象“</span></div><div class="line">    </div><div class="line">    <span class="comment">// 获取原始类名（去掉前缀）</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *originClsName = substring_from(clsName, <span class="number">10</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取消息的选择器名</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *selectorName = sel_getName(_cmd);</div><div class="line">    </div><div class="line">    <span class="comment">// 输出消息</span></div><div class="line">    Log(<span class="string">"*** -[%s %s]: message sent to deallocated instance %p"</span>, originClsName, selectorName, self);</div><div class="line">    </div><div class="line">    <span class="comment">// 结束程序</span></div><div class="line">    <span class="built_in">abort</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="第6章-块与大中枢派发"><a href="#第6章-块与大中枢派发" class="headerlink" title="第6章 块与大中枢派发"></a>第6章 块与大中枢派发</h2><h3 id="第37条：理解“块”这一概念"><a href="#第37条：理解“块”这一概念" class="headerlink" title="第37条：理解“块”这一概念"></a>第37条：理解“块”这一概念</h3><ul>
<li>块的内部结构（内存布局）：</li>
</ul>
<table>
<thead>
<tr>
<th>Block</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>void*</td>
<td>isa</td>
<td>指向Class对象的指针</td>
</tr>
<tr>
<td>int</td>
<td>flags</td>
<td></td>
</tr>
<tr>
<td>int</td>
<td>reserved</td>
<td></td>
</tr>
<tr>
<td>void (<em>)(void </em>, …)</td>
<td>invoke</td>
<td>实现函数的指针</td>
</tr>
<tr>
<td>struct *</td>
<td>descriptor</td>
<td>块的描述信息</td>
</tr>
<tr>
<td>捕获到的外部变量…</td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>isa指针，指向的是Block的类型。Block分为三种类型：_NSConcreteStackBlock，_NSConcreteMallocBlock和_NSConcreteGlobalBlock。其中，_NSConcreteStackBlock分配在占内存上；_NSConcreteMallocBlock分配在堆内存上，有引用计数（即为对象），会捕获外部变量；_NSConcreteGlobalBlock不捕获变量（内部不使用外部变量的Block即为全局Block），内存在编译期即可确定，相当于单例。</li>
<li>其中，<strong>invoke实现函数的参数为Block结构体实例的指针</strong>，使用它<em>可以方便地从内存中读取出捕获到的变量</em>。</li>
<li>捕获到的变量，对于对象，只是拷贝了其指针（对象的引用计数+1）</li>
</ol>
<table>
<thead>
<tr>
<th>descriptor</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>unsigned long int</td>
<td>reserved</td>
<td></td>
</tr>
<tr>
<td>unsigned long int</td>
<td>size</td>
<td></td>
</tr>
<tr>
<td>void (<em>)(void </em>, void *)</td>
<td>copy</td>
<td>拷贝辅助函数</td>
</tr>
<tr>
<td>void (<em>)(void </em>, coid *)</td>
<td>dispose</td>
<td>释放辅助函数</td>
</tr>
</tbody>
</table>
<p>描述结构体中，copy和dispose函数的作用是拷贝和释放Block实例时，对捕获到的变量进行拷贝和释放操作。</p>
<h3 id="第39条：用handler块降低代码分散程度"><a href="#第39条：用handler块降低代码分散程度" class="headerlink" title="第39条：用handler块降低代码分散程度"></a>第39条：用handler块降低代码分散程度</h3><ul>
<li>使用Block代替Delegate，可以使代码分布整体化，降低分散程度。特别是<strong>对于自身实例作为多个不同对象的Delegate时（如多个UITableView实例均使用self作为delegate），由于每个Delegate均存在自己单独的handler回调，省去了对于不同对象判断执行的过程，使代码更加简洁</strong>。</li>
<li>设置带有handler回调的API时，根据需要可以添加执行队列（NSOperation或GCD等）参数。外部调用时，可以根据不同需要灵活配置（如系统添加通知的方法addObserverForName方法）。</li>
</ul>
<h3 id="第41条：多用派发队列，少用同步锁"><a href="#第41条：多用派发队列，少用同步锁" class="headerlink" title="第41条：多用派发队列，少用同步锁"></a>第41条：多用派发队列，少用同步锁</h3><p>我们知道，在iOS端，为了保证性能，类中property的内存语义一般被设置为“nonatomic”。但是极端情况下，为了保证属性的读写为原子操作，需要单独进行处理。一般来说，可以使用synchronized关键字对self进行同步加锁，或者使用NSLock进行锁操作，但是频繁读写时效率会很低。<br>为了保证效率，使用GCD的派发队列进行property的读写操作优化：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TestClass.h</span></div><div class="line">@interface TestClass : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSString *testName;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"><span class="comment">// TestClass.m</span></div><div class="line">@<span class="function">interface <span class="title">TestClass</span> <span class="params">()</span> </span>&#123;</div><div class="line">    NSString *_testName;</div><div class="line">    <span class="keyword">dispatch_queue_t</span> _propertyQueue;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation</div><div class="line">- (instancetype)init &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        <span class="comment">// 创建并发队列</span></div><div class="line">        _propertyQueue = dispatch_queue_create(<span class="string">"com.TestClass.p_queue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div><div class="line">- (NSString *)testName &#123;</div><div class="line">    <span class="comment">// 并发队列读取（使用async是因为需要同步返回函数值，实质上也是并发执行）</span></div><div class="line">    __block NSString *tmpValue;</div><div class="line">    dispatch_sync(_propertyQueue, ^&#123;</div><div class="line">        tmpValue = self-&gt;_testName;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> tmpValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setTestName:(NSString *)testName &#123;</div><div class="line">    <span class="comment">// 使用barrier，可以保证此处为原子操作（其余操作等待完成后才开始执行）</span></div><div class="line">    dispatch_barrier_async(_propertyQueue, ^&#123;</div><div class="line">        self-&gt;_testName = testName;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：</p>
<ul>
<li>使用dispatch_barrier_async或dispatch_barrier_sync方法时，必须保证执行的队列是手动创建的并发队列，不能是串行或者系统的全局队列**。</li>
<li>栅栏方法同步和异步版本的区别是：同步添加Block时，队列会等待Block执行完毕后再返回（继续执行下面的代码）；异步时，则立即返回，可以将后面的任务派发的队列中（但是不会执行），等待栅栏Block执行完毕后，继续执行其他任务。</li>
<li>在property中两种版本均可。但是同步版本的效率更高（异步版本需要拷贝Block）。</li>
</ul>
<p><strong>对于property，getter使用自定义并发队列的async操作，setter使用自定义并发队列的barrier操作。</strong></p>
<h3 id="第42条：多用GCD，少用performSelector系列方法"><a href="#第42条：多用GCD，少用performSelector系列方法" class="headerlink" title="第42条：多用GCD，少用performSelector系列方法"></a>第42条：多用GCD，少用performSelector系列方法</h3><p>除了performSelector系列方法的API局限性以外（不能传多于两个参数、线程相关API参数过少、参数只能为对象类型、不能调用c方法等），最重要的是内存管理方面的缺失。示例如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SEL selector;</div><div class="line"><span class="keyword">if</span> (<span class="comment">/** 条件1 */</span>) &#123;</div><div class="line">    selector = @SEL(newObject);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/** 条件2 */</span>) &#123;</div><div class="line">    selector = @SEL(copy);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    selector = @SEL(someProperty)</div><div class="line">&#125;</div><div class="line"><span class="comment">// object为类实例，包含newObject构造器、copy方法和someProperty属性</span></div><div class="line">id ret = [object performSelector:selector];</div></pre></td></tr></table></figure></p>
<p>在ARC环境下，如果是条件1和2，编译器会将执行后返回对象的内存管理权交给接收者；如果是直接设置属性，则不进行内存管理。由于现在selector的选择是在运行时进行绑定，编译器就无法根据方法签名（名称、参数及返回值类型）使用ARC进行内存管理了（甚至不知道改selector是否存在）。所以，这种写法下，编译器会提示警告，可能会发生内存泄漏。<br>使用Block配合GCD的相关方法可以有效解决这些问题，如参数、线程、内存管理等。</p>
<h3 id="第43条：掌握GCD及操作队列的使用时机"><a href="#第43条：掌握GCD及操作队列的使用时机" class="headerlink" title="第43条：掌握GCD及操作队列的使用时机"></a>第43条：掌握GCD及操作队列的使用时机</h3><ul>
<li>在解决多线程与任务管理的问题时，可以根据需要灵活选用GCD或操作队列（NSOperationQueue）进行处理。</li>
<li>操作队列是Objective-C的API，底层使用GCD进行实现，具备了大多数GCD的功能，其优点如下：<ul>
<li>可以取消尚未执行的任务（NSOperation对象）。</li>
<li>可以对操作的执行状况使用KVO进行监听，如“isCancelled”、“isFinished”等。</li>
<li>可以对单个的操作进行优先级设置（即执行线程的优先级）；GCD只能对并发的派发队列进行优先级设置，颗粒度不够细。</li>
<li>对不同操作之间可以设置依赖关系。通过设置依赖，更容易控制不同任务之间的执行顺序。</li>
<li>可以重用任务对象（NSOperation），系统默认实现了NSBlockOperation子类。由于支持了面向对象，我们可以根据需要对父类进行继承，扩展操作对象的功能。</li>
</ul>
</li>
</ul>
<h3 id="第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务："><a href="#第44条：通过Dispatch-Group机制，根据系统资源状况来执行任务：" class="headerlink" title="第44条：通过Dispatch Group机制，根据系统资源状况来执行任务："></a>第44条：通过Dispatch Group机制，根据系统资源状况来执行任务：</h3><p><strong>在后台自动执行一系列任务，完成后通知主线程</strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对象数组，这里是模拟多个需要执行任务的对象</span></div><div class="line">NSArray *objects = @[...];</div><div class="line"></div><div class="line"><span class="comment">// 后台执行，需要获取并发队列</span></div><div class="line"><span class="keyword">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 一系列任务，可以编写成组</span></div><div class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</div><div class="line"></div><div class="line"><span class="comment">// 自动执行：异步加入组中，不能阻塞执行队列</span></div><div class="line"><span class="keyword">for</span> (id object in objects) &#123;</div><div class="line">    dispatch_group_async(</div><div class="line">        group, </div><div class="line">        globalQueue,</div><div class="line">        ^&#123; [object performTask]; &#125;</div><div class="line">    );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 完成后通知主线程</span></div><div class="line">dispatch_group_notify(</div><div class="line">    group,</div><div class="line">    dispatch_get_main_queue(),</div><div class="line">    ^&#123;</div><div class="line">        <span class="comment">// 主线程执行代码</span></div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>主要是利用了GCD并发队列的强大功能，GCD会根据系统资源占用情况，自动分配CPU核心和不同数量的执行线程去并发执行任务，可以最大限度的优化多线程编程性能。通过dispatch_group_t对象，可以根据需要阻塞（可以使用dispatch_group_wait）执行队列或是监控任务的执行过程。</p>
<h3 id="第46条：不要使用dispatch-get-current-queue"><a href="#第46条：不要使用dispatch-get-current-queue" class="headerlink" title="第46条：不要使用dispatch_get_current_queue"></a>第46条：不要使用dispatch_get_current_queue</h3><blockquote>
<p>首先结论是：<strong>dispatch_get_current_queue对避免代码死锁没有任何作用，因为它返回的只是当前队列的名称，而不是当前执行任务所在的队列！！！</strong></p>
</blockquote>
<p>我们以队列层级的例子一步步进行验证：</p>
<ol>
<li>父队列为串行队列rootQueue；子队列有两个，分别为串行队列serialQueue和并行队列concurrentQueue。我们分别向两个子队列中派发任务，看一下实际的执行情况：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根队列</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">void</span> *rootQueueKey = <span class="string">"com.jiji.rootQueue"</span>;</div><div class="line"><span class="keyword">dispatch_queue_t</span> rootQueue = dispatch_queue_create(rootQueueKey, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line"><span class="comment">// 创建两个队列</span></div><div class="line"><span class="keyword">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.jiji.concurrent1"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="keyword">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.jiji.serial1"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line"><span class="comment">// 设置两个子队列的根队列为rootQueue（串行）</span></div><div class="line">dispatch_set_target_queue(concurrentQueue, rootQueue);</div><div class="line">dispatch_set_target_queue(serialQueue, rootQueue);</div><div class="line"></div><div class="line"><span class="comment">// 配置任务：</span></div><div class="line"><span class="comment">// 并行子队列异步派发两个任务</span></div><div class="line">dispatch_async(concurrentQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task1"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_async(concurrentQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task2"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 串行子队列异步派发两个任务</span></div><div class="line">dispatch_async(serialQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task3"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_async(serialQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task4"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行结果如下：</p>
<blockquote>
<p>TestIos[32776:25904922] task1<br>TestIos[32776:25904922] task2<br>TestIos[32776:25904922] task3<br>TestIos[32776:25904922] task4</p>
</blockquote>
<p>以上情况表明：不管子队列是串行还是并行队列，由于根队列为串行，最终任务的执行情况为串行执行。</p>
<ol>
<li>现在，我的疑问是，由于任务串行执行，是否证明真正执行任务的队列是串行队列（根队列）？带着这个疑问，我们先验证一下：<br>我们修改一下代码，在task1的执行块中，查看一下当前队列：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_async(concurrentQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task1"</span>);</div><div class="line">    NSLog(@<span class="string">"%@"</span>, dispatch_get_current_queue());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>执行结果：</p>
<blockquote>
<p>TestIos[32776:25904922] <os_dispatch_queue: com.jiji.concurrent1=""></os_dispatch_queue:></p>
</blockquote>
<p>看来不是，还是在并发队列这个子队列中。<br>那现在做个假设，如果在此任务中，再向其根队列派发一个同步任务进行验证（如果死锁，证明实际任务运行在根队列中；否则就在当前子队列中）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_async(concurrentQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task1"</span>);</div><div class="line">    NSLog(@<span class="string">"%@"</span>, dispatch_get_current_queue());</div><div class="line">    <span class="comment">// 添加同步任务</span></div><div class="line">    dispatch_sync(rootQueue, ^&#123;</div><div class="line">        NSLog(@<span class="string">"new task!!!"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>结果很显然，发生了死锁，证明实际上此任务是在根队列（target queue）中执行（向serialQueue中派发同步任务也会如此，虽然不会死锁，但线程一直等待，永远不会返回）。</p>
<p><strong>这也就证明了，实际上<em>dispatch_get_current_queue</em>方法并没有返回真正的运行队列</strong>。如果以此API返回值进行判断，则无法保证多线程环境下代码执行的准确性。</p>
<ol>
<li>那若是如此，如何来确保任务执行在正确的队列中？使用<em>dispatch_queue_set_specfic</em>和<em>dispatch_get_specific</em>两个API即可。我们修改一下示例代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根队列</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">void</span> *rootQueueKey = <span class="string">"com.jiji.rootQueue"</span>;</div><div class="line"><span class="keyword">dispatch_queue_t</span> rootQueue = dispatch_queue_create(rootQueueKey, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="comment">// 根队列用指定key进行标记</span></div><div class="line">dispatch_queue_set_specific(rootQueue, rootQueueKey, &amp;rootQueueKey, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建两个队列</span></div><div class="line"><span class="keyword">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.jiji.concurrent1"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="keyword">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.jiji.serial1"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line"><span class="comment">// 设置两个子队列的根队列为rootQueue（串行）</span></div><div class="line">dispatch_set_target_queue(concurrentQueue, rootQueue);</div><div class="line">dispatch_set_target_queue(serialQueue, rootQueue);</div><div class="line"><span class="comment">// 配置任务：</span></div><div class="line">dispatch_async(concurrentQueue, ^&#123;</div><div class="line">    NSLog(@<span class="string">"task1"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 根据key获取队列绑定的值（存在，则当前队列即为key所对应的队列）</span></div><div class="line">    <span class="keyword">void</span> *context = dispatch_get_specific(rootQueueKey);</div><div class="line">    <span class="keyword">if</span> (context) &#123;</div><div class="line">        <span class="comment">// 当前执行在根队列上，不可以向根队列及任何子队列派发同步任务</span></div><div class="line">        NSLog(@<span class="string">"NO!!!!!!"</span>);</div><div class="line">        <span class="comment">// 但是，调用dispatch_get_current_queue()返回的队列，可以让你误以为是在本队列执行，所以可能会向其他队列派发同步任务，继而发生死锁。这也就是绝对不要使用此API的原因。</span></div><div class="line">        NSLog(@<span class="string">"%@"</span>, dispatch_get_current_queue());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 可以派发任意任务</span></div><div class="line">        NSLog(@<span class="string">"OK~"</span>);</div><div class="line">        dispatch_sync(rootQueue, ^&#123;</div><div class="line">            NSLog(@<span class="string">"new task!!!"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如代码所示，<strong>当dispatch_get_specific返回对应的数据时，证明当前运行队列即为检查的目标队列</strong>。如果此时还需要向此队列派发同步任务，只要直接执行任务即可，无需派发。</p>
<ul>
<li>注意：对于实现真正原子操作的property来说，由于实现setter和getter时使用了自定义队列，且setter中使用同步方式返回实例的值。为了防止死锁发生，一定要避免他人使用相同队列对属性进行访问。</li>
</ul>
<h2 id="第7章-系统框架"><a href="#第7章-系统框架" class="headerlink" title="第7章 系统框架"></a>第7章 系统框架</h2><h3 id="第48条：多用块枚举，少用for循环"><a href="#第48条：多用块枚举，少用for循环" class="headerlink" title="第48条：多用块枚举，少用for循环"></a>第48条：多用块枚举，少用for循环</h3><ol>
<li><p>快速枚举（for…in）：</p>
<ul>
<li>比传统for循环更高效，与NSEnumerator一样但语法更简洁。</li>
<li>可以遍历如NSArray、NSDictionary、NSSet及自定义Collection（需遵循NSFastEnumeration协议）。</li>
<li>NSEnumerator由于也遵循NSFastEnumeration协议，所以可以支持用快速枚举对集合进行反向遍历。</li>
<li>缺点是不支持获取对象索引。</li>
</ul>
</li>
<li><p>使用集合带有Block参数的遍历API进行集合遍历：</p>
<ul>
<li>方便获取对象索引及字典键值</li>
<li>可以直接修改Block的参数类型为对象类型，利用编译器特性，省去了进行显示地类型转换</li>
<li>对于可以配置NSEnumerationOptions的版本，可以方便设置如反向遍历、并发遍历（底层使用GCD队列）等功能。</li>
</ul>
</li>
</ol>
<h3 id="第49条：对自定义其内存管理语义的collection使用无缝桥接"><a href="#第49条：对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="第49条：对自定义其内存管理语义的collection使用无缝桥接"></a>第49条：对自定义其内存管理语义的collection使用无缝桥接</h3><ol>
<li><p>主要先说一下OC对象和CF变量指针的转换方式：</p>
<ul>
<li>__bridge: 互相转换均可，不进行内存所有权转换。即转换后仍然使用原系统对对象或变量进行内存管理（OC使用ARC，CF手动使用CFRelease）</li>
<li>__bridge_transfer：一般用于CF-&gt;OC的过程中，转换所有权。转换后的OC对象，系统自动使用ARC对其进行内存管理。</li>
<li>__bridge_retained：一般用于OC-&gt;CF的过程中，转换所有权。转换后的CF变量，其指针的引用计数+1，需要使用CFRelease等函数进行手动内存管理。</li>
</ul>
</li>
<li><p>可以通过CF框架，使用C语言API创建集合对象，之后利用桥接转换为OC对象，即可得到符合自定义内存管理语义的集合对象。</p>
<ul>
<li>如使用NSDictionary时，需要key无需支持NSCopy协议，则可以使用此方法，创建CFDictionaryRef指针（在CFDictionaryRetainCallBack和CFDictionaryReleaseCallBack中进行修改）后，使用__bridge_transfer转换为OC对象并转换所有权。</li>
</ul>
</li>
</ol>
<h3 id="第51条：精简initialize与load的实现代码"><a href="#第51条：精简initialize与load的实现代码" class="headerlink" title="第51条：精简initialize与load的实现代码"></a>第51条：精简initialize与load的实现代码</h3><ol>
<li><strong>+(void)load</strong>:</li>
</ol>
<ul>
<li>运行时系统启动时，加载Class或Category时会调用（只有Class和Category存在此方法，且只执行一次）。</li>
<li>load方法不遵循继承体系，只有对应的Class活Category实现后才会被调用。</li>
<li>系统首先加载所有Class，后加载Category。Class间加载顺序无法确定（不要在Class的load方法中调用其他Class）。</li>
<li>load方法执行时会阻塞程序运行，所以不要执行复杂任务或加锁。<blockquote>
<p>自己只在Category中利用load方法，swizzle过所属Class的方法，在内部实现自定义功能（如记录日志）。</p>
</blockquote>
</li>
</ul>
<ol>
<li><strong>+(void)initialize</strong>:</li>
</ol>
<ul>
<li>被调用时为“懒加载”：运行时系统在首次调用Class时，先调用本方法；不访问不调用。</li>
<li>initialize方法执行时，运行时系统已启动完毕，加载（load）了所有相关类，可以在此调用任意类的任意方法。但是<em>需要注意避免“循环引用”导致的死锁</em>（如ClassA的initialize中调用ClassB，ClassB首次执行，initialize中使用ClassA）。</li>
<li>本方法遵循继承体系，本类未实现时会执行父类的版本。</li>
<li>initialize方法执行时，是“线程安全”的，会阻塞其他类运行，无需加锁。但是，方法无法确定其执行线程，所以仍然不能运行过于复杂的任务（如果是UI线程则会导致APP无响应）。</li>
</ul>
<blockquote>
<p>正确用法举例：</p>
<ol>
<li>在initialize中初始化声明为全局static的OC对象（由于在编译期只能初始化基本数据类型或NSString变量或常量）。</li>
<li>单例类可以用于初始化内部数据。</li>
</ol>
</blockquote>
<h3 id="第52条：别忘了NSTimer会保留其目标对象"><a href="#第52条：别忘了NSTimer会保留其目标对象" class="headerlink" title="第52条：别忘了NSTimer会保留其目标对象"></a>第52条：别忘了NSTimer会保留其目标对象</h3><p>举例来说，以常用的直接在当前runloop中配置计时器“<em>scheduledTimerWithTimeInterval: target: selector: userInfo: repeats:</em>”为例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@interface EOCClass: NSObject &#123;</div><div class="line">    NSTimer *_pollTimer;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)startPolling;</div><div class="line">- (<span class="keyword">void</span>)stopPolling;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClass</div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    [_pollTimer invalidate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)stopPolling &#123;</div><div class="line">    [_pollTimer invalidate];</div><div class="line">    _pollTimer = nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)startPolling &#123;</div><div class="line">    _pollTimer = [NSTimer scheduledTimerWithTimeInterval:<span class="number">5.0</span></div><div class="line">        target:self</div><div class="line">        selector:@selector(p_doPoll)</div><div class="line">        userInfo:nil</div><div class="line">        repeat:YES</div><div class="line">    ];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)p_doPoll &#123;</div><div class="line">    <span class="comment">// ...task</span></div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>以上代码可以很明显地看出，由于_pollTimer的target是self，即NSTimer保留了EOCClass实例，且_pollTimer是EOCClass的实例变量，在ARC下隐含为强引用的内存管理方式，最终导致了引用循环。</p>
<p><strong>解决方法：</strong><br><em>由于类对象本身即为单例，使用类对象作为NSTimer的target即可巧妙“避免”此问题发生。</em></p>
<p>这里使用了NSTimer的Category进行处理，免除使用第三方类或者自定义单例对象：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@interface NSTimer (EOCBlocksSupport)</div><div class="line">+ (NSTimer *)scheduledTimerWithTimerInterval:(NSTimeInterval)interval</div><div class="line">    block:(void (^)())block</div><div class="line">    repeats:(BOOL)repeats;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation NSTimer (EOCBlocksSupport)</div><div class="line"></div><div class="line">+ (NSTimer *)scheduledTimerWithTimerInterval:(NSTimeInterval)interval</div><div class="line">    block:(void (^)())block</div><div class="line">    repeats:(BOOL)repeats &#123;</div><div class="line">    </div><div class="line">    return [self scheduledTimerWithTimerInterval:interval</div><div class="line">        target:self</div><div class="line">        selector:@selector(eoc_blockInvoke:)</div><div class="line">        userInfo:[block copy]</div><div class="line">        repeats:repeats</div><div class="line">    ];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)eoc_blockInvoke:(NSTimer *)timer &#123;</div><div class="line">    // 取出timer中设置的userInfo，并转换为block对象</div><div class="line">    void (^block)() = timer.userInfo;</div><div class="line">    if (block) &#123;</div><div class="line">        // 执行</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>配置定时器时，按如下方式:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)startPolling &#123;</div><div class="line">    <span class="comment">// 声明self的弱引用指针（使Block对象通过弱指针保留对象，引用计数不变）</span></div><div class="line">    __weak EOCClass *weakSelf = self;</div><div class="line">    _pollTimer = [NSTimer scheduledTimerWithTimerInterval:<span class="number">5.0</span></div><div class="line">    block:^&#123;</div><div class="line">        <span class="comment">// 声明强指针指向weakSelf，可防止使用时对象被释放</span></div><div class="line">        __strong EOCClass *strongSelf = weakSelf;</div><div class="line">        [strongSelf p_doPoll];</div><div class="line">    &#125;</div><div class="line">    repeats:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上所示，</p>
<ul>
<li>此时只有EOCClass的实例保留了定时器，定时器对象并不会保留self。完成使用后，self即可被正常释放，同时定时器被取消。</li>
<li>使用<strong>weak指针还可以保证更加安全（相比</strong>unsafe_unretain），因为self实例释放后，若是忘记取消定时器，对weak指针发消息是安全的。</li>
</ul>
<blockquote>
<p><em>注意</em>：NSTimer类在iOS10中新增了带有Block参数的API，不过使用时依然要注意循环引用的问题。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第1章：熟悉Objective-C&quot;&gt;&lt;a href=&quot;#第1章：熟悉Objective-C&quot; class=&quot;headerlink&quot; title=&quot;第1章：熟悉Objective-C&quot;&gt;&lt;/a&gt;第1章：熟悉Objective-C&lt;/h2&gt;&lt;h3 id=&quot;第4条：多用类型常量，少用-define预处理指令&quot;&gt;&lt;a href=&quot;#第4条：多用类型常量，少用-define预处理指令&quot; class=&quot;headerlink&quot; title=&quot;第4条：多用类型常量，少用#define预处理指令&quot;&gt;&lt;/a&gt;第4条：多用类型常量，少用#define预处理指令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;声明类型常量好处是，编译器可以知道此变量的类型，且可以防止外部随意修改&lt;/li&gt;
&lt;li&gt;声明规则：
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mpvue开发微信小程序的准备工作</title>
    <link href="http://yoursite.com/2018/09/29/mpvue%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/09/29/mpvue开发微信小程序的准备工作/</id>
    <published>2018-09-29T09:50:05.106Z</published>
    <updated>2018-09-29T10:02:39.270Z</updated>
    
    <content type="html"><![CDATA[<p>使用Vue.js都可以开发小程序了，喜大普奔啊~</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">方式</th>
<th style="text-align:center">补充</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">新建工程</td>
<td style="text-align:center">官方模板工程</td>
<td style="text-align:center">1. vue init mpvue/mpvue-quickstart myProject 2. cd myProject 3. npm install 4. npm run dev</td>
</tr>
<tr>
<td style="text-align:center">网络请求</td>
<td style="text-align:center">fly.js或自己封装请求方法</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">数据缓存</td>
<td style="text-align:center">vuex</td>
<td style="text-align:center">模板工程中带有配置选项</td>
</tr>
<tr>
<td style="text-align:center">本地存储</td>
<td style="text-align:center">wx.localStorage</td>
<td style="text-align:center">小程序的自带存储模块</td>
</tr>
<tr>
<td style="text-align:center">路由</td>
<td style="text-align:center">mpvue-router-patch</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">第三方UI组件</td>
<td style="text-align:center">MinUI、iView WeApp、WeUI WXSS、ZanUI WeApp、Wux WeApp</td>
<td style="text-align:center">1. 将使用的组件文件拷贝到mpvue工程的static路径下  2. 在需要使用的page文件夹下，新建“main.json”文件，内部的对象中引入：<img src="http://p8r3sk4om.bkt.clouddn.com/mpvue1" alt="img">  3.在vue文件中的template中即可直接使用</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Vue.js都可以开发小程序了，喜大普奔啊~&lt;/p&gt;
    
    </summary>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>NSInvocation的莫名crash</title>
    <link href="http://yoursite.com/2018/09/29/NSInvocation%E7%9A%84%E8%8E%AB%E5%90%8Dcrash/"/>
    <id>http://yoursite.com/2018/09/29/NSInvocation的莫名crash/</id>
    <published>2018-09-29T09:06:39.676Z</published>
    <updated>2018-09-29T09:45:08.620Z</updated>
    
    <content type="html"><![CDATA[<h4 id="NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数："><a href="#NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数：" class="headerlink" title="NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数："></a>NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数：</h4><a id="more"></a>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface NSObject (PerformSelector)</div><div class="line"></div><div class="line">- (id)performSelector:(SEL)aSelector</div><div class="line">        withArguments:(NSArray *)arguments;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#import "NSObject+PerformSelector.h"</div><div class="line"></div><div class="line">@implementation NSObject (PerformSelector)</div><div class="line"></div><div class="line">- (id)performSelector:(SEL)aSelector</div><div class="line">        withArguments:(NSArray *)arguments &#123;</div><div class="line">    if (!aSelector) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    NSMethodSignature *signature = [[self class] instanceMethodSignatureForSelector:aSelector];</div><div class="line">    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];</div><div class="line">    invocation.target = self;</div><div class="line">    invocation.selector = aSelector;</div><div class="line">    </div><div class="line">    if ([arguments isKindOfClass:[NSArray class]]) &#123;</div><div class="line">        // 减2是因为signature的参数包含固定的self和_cmd</div><div class="line">        NSInteger count = MIN(arguments.count, signature.numberOfArguments - 2);</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            // 返回指定index的参数类型</div><div class="line">            const char *type = [signature getArgumentTypeAtIndex:(i + 2)];</div><div class="line">            // 类型是OC对象（本函数的参数为NSArray，所以都是对象）</div><div class="line">            if (strcmp(type, "@") == 0) &#123;</div><div class="line">                // 取出参数</div><div class="line">                id argument = arguments[i];</div><div class="line">                // 设置参数（copy到invocation上）</div><div class="line">                // 【同样，invocation的参数列表中前两个也是self和_cmd】</div><div class="line">                [invocation setArgument:&amp;argument atIndex:(i + 2)];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 调用函数（此时会动态配置返回值）</div><div class="line">    [invocation invoke];</div><div class="line">    </div><div class="line">    // 取回返回值    </div><div class="line">    id returnValue = @1;</div><div class="line">    if (strcmp(signature.methodReturnType, "@") == 0) &#123;</div><div class="line">        // 返回值是OC对象，取回赋值到指针（这里是给野指针赋值，使其存在内容）</div><div class="line">        [invocation getReturnValue:&amp;returnValue];</div><div class="line">    &#125;</div><div class="line">    return returnValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>示例类如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line">@interface TestClass : NSObject</div><div class="line"></div><div class="line">- (NSString *)saySomething:(NSString *)a</div><div class="line">                         b:(NSString *)b</div><div class="line">                         c:(NSString *)c;</div><div class="line">@end</div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"TestClass.h"</span></span></div><div class="line"></div><div class="line">@implementation TestClass</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line">    <span class="keyword">if</span> (self = [super init]) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSDictionary *)saySomething:(NSString *)a</div><div class="line">                             b:(NSString *)b</div><div class="line">                             c:(NSString *)c &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;</div><div class="line">             @<span class="string">"a"</span>: a,</div><div class="line">             @<span class="string">"b"</span>: b,</div><div class="line">             @<span class="string">"c"</span>: c</div><div class="line">             &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>调用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TestClass *tc = [[TestClass alloc] init];</div><div class="line">        result = [tc performSelector:@selector(saySomething:b:c:) withArguments:@[@<span class="string">"Tom"</span>, @<span class="string">"Jim"</span>, @<span class="string">"Li Lei"</span>]];</div><div class="line">        NSLog(@<span class="string">"result = %@"</span>, result);</div></pre></td></tr></table></figure>
<p>以上，解决了使用performSelector调用时只能传递单个参数的尴尬问题。但是，问题来了~~</p>
<p>运行时，会发生crash。try-catch也无法捕获异常，觉得颇为诡异。之后，再打开zombie检测后，发现如下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2018-09-29 17:15:18.926491+0800 InvocationTest1[37029:49376429] *** -[__NSDictionaryI release]: message sent to deallocated instance 0x60000086aec0</div></pre></td></tr></table></figure>
<p>原来是返回值被过渡释放导致。</p>
<p>究其原因，可以在NSInvocation的类文档中查到，主要就一句：</p>
<blockquote>
<p>This class does not retain the arguments for the contained invocation by default. </p>
</blockquote>
<p>即为，本类默认不对参数进行保留操作。</p>
<p>实质上，不仅如此，通过调用<em>getReturnValue:</em>方法并查阅说明可以知道，此方法只是根据给定的指针，创建buffer并将返回值写入其中。并未对其进行内存管理。</p>
<p>现在回到代码。由于performSelector函数中，只是使用了临时变量指向并返回，导致NSInvocation的返回值对象的引用计数实际上是0，即创建完就要被释放。所以，当performSelector函数执行完成后，实际上返回值已经被释放。由于外侧调用者也没有对其进行保留等其他操作，导致调用者的作用域结束后，返回值会再次收到release操作，即发生crash。</p>
<p>那么，如何解决此问题呢？<br>两种方式：</p>
<ol>
<li><strong>在调用NSInvocation对象的<em>getReturnValue:</em>方法时，不要传入OC对象指针，使用C指针（void *），并在最终桥接转换为OC对象。</strong>这种是本人比较推荐的方式，由于此实质上是往buffer内写入内容，使用C指针会更加严谨，而且避免了ARC内存释放导致的crash，返回时桥接转换为对象即可（这种情况也兼容所有数据类型）。</li>
</ol>
<p>将performSelector的代码修正为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *returnValue = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(signature.methodReturnType, <span class="string">"@"</span>) == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// 返回值是OC对象，取回赋值到指针（这里是给野指针赋值，使其存在内容）</span></div><div class="line">    [invocation getReturnValue:&amp;returnValue];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> (__bridge id)returnValue;</div></pre></td></tr></table></figure>
<ol>
<li><strong>使用__unsafe_unretained修饰OC指针，避免ARC对返回值进行内存管理。</strong>使用__weak同样可以达到效果，不过感觉上有点懵，需要继续深入查看内存管理相关的内容了。。。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">id __unsafe_unretained returnValue = @<span class="number">1</span>;</div><div class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(signature.methodReturnType, <span class="string">"@"</span>) == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// 返回值是OC对象，取回赋值到指针（这里是给野指针赋值，使其存在内容）</span></div><div class="line">    [invocation getReturnValue:&amp;returnValue];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> returnValue;</div></pre></td></tr></table></figure>
<p>问题解决。。。</p>
<p>测试程序代码：<a href="https://github.com/Choujiji/NSInvocationTest" target="_blank" rel="external">测试NSInvocation调用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数：&quot;&gt;&lt;a href=&quot;#NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数：&quot; class=&quot;headerlink&quot; title=&quot;NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数：&quot;&gt;&lt;/a&gt;NSInvocation是iOS框架中对命令模式的一种OC封装，使用起来非常方便。在方法调用，或者消息转发中都可以使用到。以下是学着别人demo使用时，封装的多参数调用函数：&lt;/h4&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中“严谨”的单例模式</title>
    <link href="http://yoursite.com/2018/09/07/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/07/单例模式/</id>
    <published>2018-09-07T07:34:18.943Z</published>
    <updated>2018-09-07T08:01:57.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>由于OC中的方法天生就是public的（就算只写到.m中，在运行时也可以调用到。。。），平时使用的单例方法也未必严谨，所以，看了书，受教了~（还好一般老老实实使用类方法创建单例的无所谓）。</p>
</blockquote>
<h4 id="实现一个“严谨”的单例类"><a href="#实现一个“严谨”的单例类" class="headerlink" title="实现一个“严谨”的单例类"></a>实现一个“严谨”的单例类</h4><p>一般来说，提供一个类方法入口，使用dispatch_once_t保护，使用静态类变量保存，即可成功一个创建线程安全的单例对象。</p>
<p>但是，当调用者在不知情的情况下，调用传统的二段式创建、new或者allocWithZone方法分配内存，甚至是调用copy或multableCopy方法时，都可以创建新的实例对象。所以，为了避免，就需要我们对这些方法依次堵住，重写时，直接在方法内部调用单例方法即可。并且，单例方法的实例化对象时，使用[[super allocWithZone:nil] init]来替代默认（自身的方法已经被重写了）。即可得到“严谨”的单例类。</p>
<h4 id="关于单例类的继承"><a href="#关于单例类的继承" class="headerlink" title="关于单例类的继承"></a>关于单例类的继承</h4><p>平时都不这么用啊。。。确实是。。。不过既然书中提到了，也查阅了一下，说一说哇。。。（当前的示例代码中无法实现此功能）</p>
<p>书中说，使用NSAllocateObject()函数手动分配内存，可以实现子类创建自己的单例对象，但是由于现在是ARC环境，此函数早已不可用，需要对单例类单独“-fno-objc-arc”来开后门才行。另一篇博文<a href="https://www.jianshu.com/p/e1a3a5525452" target="_blank" rel="external">IOS单例模式下多线程和继承写法总结</a>里面，也有讨论过，通过查找源码的方式（alloc -&gt; allocWithZone: -&gt; class_createInstance() 的过程），直接使用runtime中的创建实例方法也能达到同样的效果（前提也是MRC环境下），d=====(￣▽￣*)b厉害。</p>
<p>所以，平时不这么用。。。</p>
<blockquote>
<p>示例代码地址：<a href="https://github.com/Choujiji/DesignPatterns_Learning/tree/master/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/%E5%8D%95%E4%BE%8B" target="_blank" rel="external">Singleton</a></p>
</blockquote>
<h4 id="其他资料："><a href="#其他资料：" class="headerlink" title="其他资料："></a>其他资料：</h4><ul>
<li><a href="https://www.jianshu.com/p/d2d33f519764?utm_source=desktop&amp;utm_medium=timeline" target="_blank" rel="external">iOS中的单例模式</a></li>
<li><a href="https://www.jianshu.com/p/a92c0283f243" target="_blank" rel="external">iOS 单例模式</a></li>
<li><a href="https://www.jianshu.com/p/e1a3a5525452" target="_blank" rel="external">IOS单例模式下多线程和继承写法总结</a></li>
<li><a href="http://justinyan.me/post/1306" target="_blank" rel="external">从 Objective-C 里的 Alloc 和 AllocWithZone 谈起</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于OC中的方法天生就是public的（就算只写到.m中，在运行时也可以调用到。。。），平时使用的单例方法也未必严谨，所以，看了书，受教了~（还好一般老老实实使用类方法创建单例的无所谓）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;实现一
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>生成器模式</title>
    <link href="http://yoursite.com/2018/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/05/设计模式之建造者模式/</id>
    <published>2018-09-05T04:03:27.472Z</published>
    <updated>2018-09-06T05:07:49.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图示："><a href="#图示：" class="headerlink" title="图示："></a>图示：</h3><p>以下分别是类图与时序图<br><img src="http://p8r3sk4om.bkt.clouddn.com/374636-20170808225735589-1433194842.jpg" alt="img"><br><img src="http://p8r3sk4om.bkt.clouddn.com/20170503144820580.png" alt="img"><br><a id="more"></a></p>
<h3 id="先举个例子，个人看来，生成器模式的“Client-Director-Builder”相当于小的软件开发公司的“老板-产品经理-程序员”的模式。"><a href="#先举个例子，个人看来，生成器模式的“Client-Director-Builder”相当于小的软件开发公司的“老板-产品经理-程序员”的模式。" class="headerlink" title="先举个例子，个人看来，生成器模式的“Client - Director - Builder”相当于小的软件开发公司的“老板 - 产品经理 - 程序员”的模式。"></a>先举个例子，个人看来，生成器模式的<em>“Client - Director - Builder”</em>相当于小的软件开发公司的<em>“老板 - 产品经理 - 程序员”</em>的模式。</h3><ul>
<li>老板（<em>Client</em>）：</li>
</ul>
<ol>
<li>决定了公司员工的生死去留（管理其他二者角色的生命周期，负责创建、保留和释放）</li>
<li>提需求，公司要做什么项目（调用Director并传递产品需求）</li>
<li>验收项目（获取产品）</li>
</ol>
<ul>
<li>产品经理（<em>Director</em>）：</li>
</ul>
<ol>
<li>知道要做什么项目，依照自定顺序分解成开发模块（从Client获取到产品需求并分解）</li>
<li>管理着程序员（Director中包含Builder成员）</li>
<li>命令程序员按照模块进行开发（按照顺序调用builder的建造方法进行产品生产）</li>
</ol>
<ul>
<li>程序员（<em>Builder</em>）:</li>
</ul>
<ol>
<li>新建工程（初始化产品对象）</li>
<li>按照需求开发编码（根据Director的调用执行各种生产函数，给产品赋值）</li>
<li>开发完毕后提交程序（根据外部调用返回创建完成的产品对象）</li>
</ol>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><p>使用获取并生产电脑作为示例。稍作解释：<br>Computer类为Product；ComputerMaker为抽象Builder，AppleComputerMaker和LenovoComputerMaker为实体Builder；ComputerSeller为Director。</p>
<blockquote>
<p>代码地址：<a href="https://github.com/Choujiji/DesignPatterns_Learning/tree/master/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">ComputerMaker</a></p>
</blockquote>
<h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><ul>
<li>优点：</li>
</ul>
<ol>
<li><em>拆分模块，解耦合</em>：</li>
</ol>
<blockquote>
<ol>
<li>把创建复杂对象的过程拆分为多个子过程，且由Builder模块独立负责；</li>
<li>Director只负责创建顺序等业务逻辑，并调用Builder进行生产，稳定性好；</li>
<li>Client只负责将制定Builder提供给Director，并向Director提出生产要求并获取产品，隐藏了整个生产过程。</li>
</ol>
</blockquote>
<ol>
<li><em>易扩展</em>：</li>
</ol>
<blockquote>
<p>Builder的抽象父类（或协议）制定所有的子过程，并对外提供获取产品接口，子类Builder实现生产过程。所以，添加新产品时，只要子类化Builder并覆盖创建自己的生产过程即可。Director无需修改。</p>
</blockquote>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li><em>使用场景少</em>：</li>
</ol>
<blockquote>
<ol>
<li>所有的Builder都是由统一的抽象Builder类继承而来，只能生产一种类型产品，不同产品之间的差异少。</li>
<li>生产的产品结构复杂，否则没必要引入此模式。</li>
</ol>
</blockquote>
<ol>
<li><em>类结构容易庞大</em>：</li>
</ol>
<blockquote>
<p>生产多个产品时，需要创建多个Builder类，类个数易变多。</p>
</blockquote>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><a href="https://www.cnblogs.com/xcsn/p/7309761.html" target="_blank" rel="external">Head First设计模式之生成器模式</a></li>
<li><a href="https://blog.csdn.net/free1985/article/details/71123618#commentBox" target="_blank" rel="external">设计模式讲解与代码实践（二）——生成器</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;图示：&quot;&gt;&lt;a href=&quot;#图示：&quot; class=&quot;headerlink&quot; title=&quot;图示：&quot;&gt;&lt;/a&gt;图示：&lt;/h3&gt;&lt;p&gt;以下分别是类图与时序图&lt;br&gt;&lt;img src=&quot;http://p8r3sk4om.bkt.clouddn.com/374636-20170808225735589-1433194842.jpg&quot; alt=&quot;img&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://p8r3sk4om.bkt.clouddn.com/20170503144820580.png&quot; alt=&quot;img&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>这只是测试，新的小家（其实是tag）</title>
    <link href="http://yoursite.com/2018/05/15/%E6%B5%8B%E8%AF%95%E4%BA%8C%E4%B8%8B/"/>
    <id>http://yoursite.com/2018/05/15/测试二下/</id>
    <published>2018-05-15T02:24:06.602Z</published>
    <updated>2018-05-15T02:24:06.602Z</updated>
    
    <summary type="html">
    
      真的，里面没有内容
    
    </summary>
    
    
      <category term="react-native" scheme="http://yoursite.com/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>使用代码初始化StoryBoard中的ViewController</title>
    <link href="http://yoursite.com/2018/05/15/%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%9D%E5%A7%8B%E5%8C%96StoryBoard%E4%B8%AD%E7%9A%84ViewController/"/>
    <id>http://yoursite.com/2018/05/15/使用代码初始化StoryBoard中的ViewController/</id>
    <published>2018-05-15T01:49:33.088Z</published>
    <updated>2018-05-15T03:49:55.025Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取StoryBoard对象（这里使用的是默认的主bundle中的文件）</span></div><div class="line">UIStoryboard *storyBoard = [UIStoryboard storyboardWithName:@<span class="string">"Main"</span> bundle:nil];</div><div class="line"><span class="comment">// 使用ID在StoryBoard对象中获取并初始化新的ViewController</span></div><div class="line">BasicKVO_ViewController *vc1 = [storyBoard instantiateViewControllerWithIdentifier:@<span class="string">"BasicKVO_VC"</span>];</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>代码如上面所示，其中，BasicKVO_VC是在StoryBoard文件中对应的UIViewController的“Identity inspector”面板中的“Storyboard ID”。</p>
<p><img src="http://p8r3sk4om.bkt.clouddn.com/blog-image1.png" alt="image"></p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><a href="https://blog.csdn.net/u012449749/article/details/50495202" target="_blank" rel="external">代码获取Storyboard中的ViewController</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 获取StoryBoard对象（这里使用的是默认的主bundle中的文件）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;UIStoryboard *storyBoard = [UIStoryboard storyboardWithName:@&lt;span class=&quot;string&quot;&gt;&quot;Main&quot;&lt;/span&gt; bundle:nil];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用ID在StoryBoard对象中获取并初始化新的ViewController&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;BasicKVO_ViewController *vc1 = [storyBoard instantiateViewControllerWithIdentifier:@&lt;span class=&quot;string&quot;&gt;&quot;BasicKVO_VC&quot;&lt;/span&gt;];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>KVC基础学习总结</title>
    <link href="http://yoursite.com/2018/04/04/KVC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/04/KVC基础学习总结/</id>
    <published>2018-04-04T06:16:30.000Z</published>
    <updated>2018-05-15T02:18:54.524Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li><strong>对象属性值的设置和获取</strong></li>
<li><strong>访问集合属性值的专用API</strong></li>
<li><strong>使用集合操作符</strong></li>
<li><strong>描述非对象的值（基本数据类型和结构体等）</strong></li>
<li><strong>属性类型验证</strong></li>
<li><strong>访问器的搜索方式</strong></li>
</ul>
</blockquote>
<a id="more"></a>
<h3 id="对象属性值的设置和获取"><a href="#对象属性值的设置和获取" class="headerlink" title="对象属性值的设置和获取"></a>对象属性值的设置和获取</h3><ol>
<li><p>KVC的通用API<br> setValueForKey(Path):<br> valueForKey(Path):</p>
</li>
<li><p>一次设置、获取多个属性值<br> setValueForKeysWithDictionary: 对内部的每一个属性均发送setValueForKey消息<br> dictionaryWithValueForKeys:    根据keys数组返回字典</p>
</li>
</ol>
<h3 id="访问集合属性值的专用API"><a href="#访问集合属性值的专用API" class="headerlink" title="访问集合属性值的专用API"></a>访问集合属性值的专用API</h3><table>
<thead>
<tr>
<th style="text-align:center">通过key访问集合</th>
<th style="text-align:center">通过keyPath访问集合</th>
<th style="text-align:center">被代理的类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mutableArrayValueForKey:</td>
<td style="text-align:center">mutableArrayValueForKeyPath:</td>
<td style="text-align:center">NSMutableArray</td>
</tr>
<tr>
<td style="text-align:center">mutableSetValueForKey:</td>
<td style="text-align:center">mutableSetValueForKeyPath:</td>
<td style="text-align:center">NSMutableSet</td>
</tr>
<tr>
<td style="text-align:center">mutableOrderedSetValueForKey:</td>
<td style="text-align:center">mutableOrderedSetValueForKeyPath:</td>
<td style="text-align:center">NSMutableOrderedSet</td>
</tr>
</tbody>
</table>
<p>访问集合属性的值时除了可以直接使用基本valueForKey(Path):方法，还可以使用上述三类专用API进行访问。当你对集合属性进行修改（增、删、改）时，上表的三类方法可以更高效的完成任务，他们分别返回一个类似NSMutableArray、NSMutableSet和NSMutableOrderedSet的代理类的对象，可以在此对象上直接调用任何相关类的api来直接操作属性值。</p>
<p>使用此类api管理集合属性的高效体现在：</p>
<ol>
<li>比类型为不可变集合类型属性，通过valueForKey:取值，转换并修改后，再通过setValueForKey:保存回去效率高</li>
<li>比直接将集合属性类型设置成mutable类修改高效</li>
<li>对KVO有效</li>
</ol>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ------------返回一个可变对象的代理类（这里是仿可变数组类型，可以调用所有NSMutableArray的api）</span></div><div class="line">id mutableTransactions = [account mutableArrayValueForKey:@<span class="string">"transactions"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, mutableTransactions);</div><div class="line"><span class="comment">// 对返回的代理类对象进行操作（添加、删除、修改等），会直接在原属性上进行操作。</span></div><div class="line"><span class="comment">// 这比直接通过valueForKey获取集合对象后，修改，再setValueForKey存储回去效率高；也比直接维护一个可变集合属性效率高。</span></div><div class="line"><span class="comment">// 且这种方法对KVO有帮助（直接操作修改集合属性不会触发KVO）</span></div><div class="line">Transaction *targetTransaction = mutableTransactions[<span class="number">0</span>];</div><div class="line">targetTransaction.work = @<span class="string">"hhhhaaaa"</span>;</div><div class="line"><span class="comment">// 再次取出</span></div><div class="line">transactions = [account valueForKeyPath:@<span class="string">"transactions"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, transactions);</div></pre></td></tr></table></figure>
<h3 id="使用集合操作符"><a href="#使用集合操作符" class="headerlink" title="使用集合操作符"></a>使用集合操作符</h3><p>在使用valueForKeyPath:访问集合属性时，可以在keyPath中使用集合操作符来直接操作返回的值。集合操作符使用“@”字符标识，使用集合操作符的keyPath结构如下：</p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/art/keypath.jpg" alt="img"></p>
<p>如图可知：keyPath分为<em>左keyPath、集合操作符、右keyPath</em>三部分。</p>
<p>集合操作符主要分为三类：</p>
<ul>
<li><strong>聚合操作符</strong>：对集合对象进行操作，返回匹配条件的单一对象作为结果（@count除外，它没有右keyPath，且返回一个NSNumber对象）。</li>
</ul>
<p>主要包括：@sum、@max、@min、@avg、@count等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 聚合操作符（操作集合属性，返回单个对象）</span></div><div class="line"><span class="comment">// @count</span></div><div class="line">NSNumber *count = [account valueForKeyPath:@<span class="string">"transactions.@count"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, count); <span class="comment">// @count，省略右keypath</span></div><div class="line"><span class="comment">// @max</span></div><div class="line">NSNumber *maxMoney = [account valueForKeyPath:@<span class="string">"transactions.@max.money"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, maxMoney);</div><div class="line"><span class="comment">// @min</span></div><div class="line">NSNumber *minMoney = [account.transactions valueForKeyPath:@<span class="string">"@min.money"</span>];  <span class="comment">// 直接对集合属性取值，可省略左keypath</span></div><div class="line">NSLog(@<span class="string">"%@"</span>, minMoney);</div><div class="line"><span class="comment">// @sum</span></div><div class="line">NSNumber *sumMoney = [account valueForKeyPath:@<span class="string">"transactions.@sum.money"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, sumMoney);</div></pre></td></tr></table></figure>
<ul>
<li><strong>数组操作符</strong>：对集合对象进行操作，通过对右keyPath指定的值进行操作，返回特定条件的集合对象。</li>
</ul>
<p>主要包括@unionOfObjects和@distinctUnionOfObjects，二者区别是：前者直接返回指定属性的值的数组，不过滤重复的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组操作符（操作集合属性，返回集合对象）</span></div><div class="line"><span class="comment">// @unionOfObjects 指定对象的集合</span></div><div class="line">id unionOfWorks = [account.transactions valueForKeyPath:@<span class="string">"@unionOfObjects.work"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, unionOfWorks);</div><div class="line"><span class="comment">// @distinctUnionOfObjects 指定对象的不重复集合</span></div><div class="line">id distinctUnionOfWorks = [account.transactions valueForKeyPath:@<span class="string">"@distinctUnionOfObjects.work"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, distinctUnionOfWorks);</div></pre></td></tr></table></figure>
<ul>
<li><strong>嵌套操作符</strong>：对于包含属性对象的集合所组成的集合（如数组内部包含的所有元素都是数组，这些子数组内部都是属性对象），嵌套操作符通过对右keyPath指定的值进行操作，返回特定条件的集合对象。</li>
</ul>
<p>包括@unionOfArrays、@distinctUnionOfArrays和@distinctUnionOfSets，前两者对嵌套数组进行操作、第三个对集合（NSSet）进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 嵌套操作符（操作包括集合属性对象的嵌套对象，返回集合对象）</span></div><div class="line">Transaction *moreWork1 = [[Transaction alloc] init];</div><div class="line">moreWork1.work = @<span class="string">"收入10000"</span>;</div><div class="line">moreWork1.payee = @[@<span class="string">"臭吉吉2"</span>, @<span class="string">"jiji2"</span>];</div><div class="line">moreWork1.money = <span class="number">10000</span>;</div><div class="line">Transaction *moreWork2 = [[Transaction alloc] init];</div><div class="line">moreWork2.work = @<span class="string">"支出2002"</span>;</div><div class="line">moreWork2.payee = @[@<span class="string">"赵吉222"</span>];</div><div class="line">moreWork2.money = <span class="number">2002</span>;</div><div class="line">NSArray *nestedTransactions = @[account.transactions, @[moreWork1, moreWork2]]; <span class="comment">// 所有的最小子元素都是transaction对象</span></div><div class="line"><span class="comment">// 注意：@unionOfArrays和@distinctUnionOfArrays的数据源，必须是数组嵌套成的数组，不能是元素与数组组合成的数据源数组。，如下面就不可以</span></div><div class="line"><span class="comment">//    NSArray *nestedTransactions = @[account.transactions, @[moreWork1, moreWork2], moreWork3];</span></div><div class="line"></div><div class="line"><span class="comment">// @unionOfArrays</span></div><div class="line">id unionOfWorksArray = [nestedTransactions valueForKeyPath:@<span class="string">"@unionOfArrays.work"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, unionOfWorksArray);</div><div class="line"><span class="comment">// @distinctUnionOfArrays</span></div><div class="line">id distinctUnionOfWorksArray = [nestedTransactions valueForKeyPath:@<span class="string">"@distinctUnionOfArrays.work"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, distinctUnionOfWorksArray);</div><div class="line"><span class="comment">// @distinctUnionOfSets</span></div><div class="line">NSSet *nestedTransactionsSet = [NSSet setWithObjects:</div><div class="line">    [NSSet setWithArray:account.transactions],</div><div class="line">    [NSSet setWithObjects:moreWork1, moreWork2, nil],</div><div class="line">    nil</div><div class="line">]; <span class="comment">// 所有的最小子元素都是transaction对象，整体及子集合必须都是set</span></div><div class="line">id distinctUnionOfWorksSet = [nestedTransactionsSet valueForKeyPath:@<span class="string">"@distinctUnionOfSets.work"</span>];</div><div class="line">NSLog(@<span class="string">"%@"</span>, distinctUnionOfWorksSet);</div></pre></td></tr></table></figure>
<h3 id="描述非对象的值（基本数据类型和结构体等）"><a href="#描述非对象的值（基本数据类型和结构体等）" class="headerlink" title="描述非对象的值（基本数据类型和结构体等）"></a>描述非对象的值（基本数据类型和结构体等）</h3><ol>
<li>对于基本数据类型的值，使用KVC进行设置和获取时需要将值进行对NSNumber类的封包和解包。</li>
<li>对于内置的结构体，如NSPoint、NSRange、NSRect和NSSize，需要使用NSValue类对数据进行封包和解包。</li>
<li>对于自定义的结构体，使用NSValue的通用api对数据进行封包和解包。</li>
</ol>
<p>对于自定义结构体的KVC，举例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    float x;</div><div class="line">    float y;</div><div class="line">    float z;</div><div class="line">&#125; ThreeFloats;</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic) ThreeFloats threeFloats;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    // ------自定义的非对象数据KVC测试（自定义结构体转NSValue）</div><div class="line">    // 创建结构体数据</div><div class="line">    ThreeFloats floats = &#123;</div><div class="line">        1., 2., 3.</div><div class="line">    &#125;;</div><div class="line">    // 转化为NSValue</div><div class="line">    NSValue *customStructValue = [NSValue valueWithBytes:&amp;floats objCType:@encode(ThreeFloats)];</div><div class="line">    // KVC保存</div><div class="line">    [self setValue:customStructValue forKey:@"threeFloats"];</div><div class="line">    // 读取值</div><div class="line">    NSValue *propertyValue = [self valueForKey:@"threeFloats"];</div><div class="line">    // 转回结构体值</div><div class="line">    ThreeFloats resultFloats;</div><div class="line">    [propertyValue getValue:&amp;resultFloats size:sizeof(ThreeFloats)];</div><div class="line">    NSLog(@"%f, %f, %f", resultFloats.x, resultFloats.y, resultFloats.z);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="属性类型验证"><a href="#属性类型验证" class="headerlink" title="属性类型验证"></a>属性类型验证</h3><p>KVC协议定义了一些方法用于验证属性。除了使用key或keyPath进行设置和获取值以外，还可以使用它们进行属性验证。当调用validateValue:forKey:error（或者validateValue:forKeyPath:error）方法时，协议方法的默认实现是去查找是否对key存在validate[key]:error:方法。如果没有实现此方法，则验证方法默认通过，返回YES；如果你实现了这个key的方法，则会根据此方法的验证结果来返回原验证结果。</p>
<p>你实现的validate[key]:error:方法根据key的值和error的指针，有三种验证实现方案：</p>
<ol>
<li>判定传入的值符合要求，直接返回YES，且不修改值和错误对象。</li>
<li>判定传入的值不符合，且不对此值进行类型修正（如类型转换等）。这种情况下，方法返回NO，并且对用户传入的错误指针（如果传入了）进行赋值，包含其中的错误信息。</li>
<li>判定传入的值不符合，但是创建个符合要求的新值进行替换。这种情况下，方法返回YES，且把传入的值的指针指向此新值（一定不要直接修改传入的值，就算是个mutable类对象也不行），并且不用处理错误信息。</li>
</ol>
<p>举例来说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line">@interface Transaction : NSObject</div><div class="line"></div><div class="line"><span class="comment">/** 工作内容类型（这里用于验证属性） */</span></div><div class="line">@property (copy, nonatomic) NSString *work;</div><div class="line"></div><div class="line"><span class="comment">/** 收款人数组 一对多 */</span></div><div class="line">@property (nonatomic) NSArray&lt;NSString *&gt; *payee;</div><div class="line"><span class="comment">/** 钱数 */</span></div><div class="line">@property (nonatomic) NSInteger money;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"Transaction.h"</span></span></div><div class="line"></div><div class="line">@implementation Transaction</div><div class="line"></div><div class="line">- (BOOL)validateWork:(id * _Nullable)workValue error:(out NSError * _Nullable *)error &#123;</div><div class="line">    <span class="keyword">if</span> (![*workValue isKindOfClass:[NSString class]]) &#123;</div><div class="line"><span class="comment">//        // 不修改，直接返回错误</span></div><div class="line"><span class="comment">//        if (error) &#123;</span></div><div class="line"><span class="comment">//            *error = [NSError errorWithDomain:@"validate error" code:9999 userInfo:@&#123;@"reason": @"invalid type"&#125;];</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line"><span class="comment">//        return NO;</span></div><div class="line">        <span class="comment">// 将值修改为符合要求的值</span></div><div class="line">        *workValue = [NSString stringWithFormat:@<span class="string">"%@"</span>, *workValue];</div><div class="line">        <span class="keyword">return</span> YES;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"><span class="comment">/** 外部调用 */</span></div><div class="line"></div><div class="line"><span class="comment">// -----------测试属性验证</span></div><div class="line"><span class="comment">// 对应类中如果没有自己实现validate&lt;Key&gt;:error:方法，则验证无效，都返回YES</span></div><div class="line"><span class="comment">// validate&lt;Key&gt;:error:方法中可以对数据进行合法性判断，返回错误；或将不合法数据转化为合法数据（创建个新数据），返回成功。</span></div><div class="line">NSError *error = nil;</div><div class="line">id targetValue = @<span class="number">123</span>;	<span class="comment">// 这里错误传入了NSNumber对象，用以进行验证</span></div><div class="line">BOOL isValid = [targetTransaction validateValue:&amp;targetValue forKey:@<span class="string">"work"</span> error:&amp;error];</div><div class="line">NSLog(@<span class="string">"%d"</span>, isValid);</div></pre></td></tr></table></figure>
<h3 id="访问器的搜索方式"><a href="#访问器的搜索方式" class="headerlink" title="访问器的搜索方式"></a>访问器的搜索方式</h3><p><strong>NSObject提供给NSKeyValueCoding协议的默认实现，是使用基于键（key）的访问器，根据一系列规则来调用对象的属性。</strong>这些协议方法使用一个键（key）参数来搜索对象实例的访问器（accessor）、实例变量和一些遵循确定命名规范的方法。了解搜索的工作原理，不仅有助于追踪KVC对象的行为，还可以帮助编写自己的兼容对象（类似KVC）。</p>
<ul>
<li><strong>基本getter的搜索模式（valueForKey:的工作模式）：</strong></li>
</ul>
<ol>
<li><strong>首先依次查找访问方法set[Key]、[key]、is[Key]、_[key]。</strong>找到则跳到【5】中处理结果，否则进入下一步。</li>
<li><strong>若没有找到访问器方法，则搜索匹配名为countOf[Key]和objectIn[Key]AtIndex:的实例方法（与NSArray中定义的原方法一致），还有[key]AtIndexes:方法（与NSArray中的objectsAtIndexes:一致）。如果找到了第一个方法和后两者之一，则创建并返回一个集合代理对象来响应所有的NSArray的方法（给代理对象发送NSArray方法时会自动组合调用以上实现的方法）。</strong>不满足则进入下一步【3】。<br> 代理对象会把收到的所有的NSArray的消息（即API调用）转化成给KVC相关对象（即类实例对象）组合发送countOf[Key]、objectIn[Key]AtIndex:和[key]AtIndexes:消息。如果原类中额外实现了get[Key]:range:方法，此代理对象也会适时使用，以提高性能。实际上，代理对象会和原实例对象一起工作，让它看起来就像是一个NSArray对象（虽然不是）。</li>
<li><strong>当没有找到访问器方法和数组的访问方法时，系统再继续查找一组三个名为countOf[Key]、enumeratorOf[Key]和memberOf[Key]:的实例方法(都是NSSet类中的方法)。三个方法都找到，则创建一个集合代理对象来响应所有的NSSet方法并返回。</strong>不满足则进入下一步【4】。<br> 与NSArray的情况一样，系统会根据实现的方法生成并返回一个NSSet的代理对象，与原对象一起工作，来使其看起来像是一个NSSet对象（与上面一样，给返回的代理集合对象调用NSSet的api，你实现的countOf[Key]、enumeratorOf[Key]和memberOf[Key]:方法就会被组合调用。）。</li>
<li><strong>访问器方法和集合访问方法组都没有找到，系统会查看类中是否实现了accessInstanceVariablesDirectly，如果该方法返回YES，则进入成员列表中进行进一步查找。依次查找名为_[key]、_is[Key]、[key]和is[Key]的成员变量。</strong>找到则跳到【5】中处理结果，否则进入下一步。</li>
<li>如果得到的属性值是对象指针，直接返回结果。如果值是一个支持NSNumber转换的基本数据类型值，则封包成NSNumber对象返回。如果是一个不支持NSNumber转换的基本数据类型值（如结构体），则封包成NSValue对象返回。</li>
<li>若以上查找均失败，则触发valueForUndefinedKey:方法，默认抛出异常。子类可以覆盖此方法。</li>
</ol>
<ul>
<li><strong>基本setter的搜索模式（setValue:forKey:的工作模式）：</strong></li>
</ul>
<p>默认实现是，给定key和value参数作为输入，试图把key设置为value（对于非对象属性，要先解包成相应值）。被调用的对象依照下面的程序进行查找：</p>
<ol>
<li><strong>依次查找名为set[Key]:或_set[Key]的访问器方法，找到后，使用输入值触发该方法并完成（依照需要先解包值）。</strong></li>
<li><strong>没找到访问器时，查看类方法accessInstanceVariablesDirectly，如果返回YES，依次查找成员变量中的类似_[key]、_is[Key]或is[Key]。找到，使用输入值触发该方法并完成（依照需要先解包值）。</strong></li>
<li><strong>以上都没找到，则触发setValue:forUndefinedKey:方法。默认抛出异常，子类可以覆盖并提供其他行为（如赋值给其他属性等）。</strong></li>
</ol>
<ul>
<li><strong>可变数组的搜索模式：</strong></li>
</ul>
<p>mutableArrayValueForKey:方法默认实现是输入key，返回调用对象的以key命名的属性（要求此属性是数组或可变数组类型，不可变数组无法实现步骤【1】）。此访问器的调用程序如下：</p>
<ol>
<li>查找一组方法命名如insertObject:in[Key]AtIndex:和removeObjectFrom[Key]AtIndex:（与NSMutableArray中的insertObject:atIndex和removeObjectAtIndex:一致），或者名为insert[Key]:atIndexed:和removeObjectsAtIndexes:（与NSMutableArray的insertObjects:atIndexes:和removeObjectsAtIndexesL:一致）。<br> 如果调用对象至少包含一个插入方法和一个删除方法，就返回一个可变代理对象。以后通过给此代理对象发送NSMutableArray的所有消息，都会通过组合调用insertObject:in[Key]AtIndex:、removeObjectFrom[Key]AtIndex:、insert[Key]:atIndexed:和removeObjectsAtIndexes:方法的形式来进行响应（或者可以直接将这些方法声明在.h文件中，外部类实例直接调用此方法也可以直接触发KVO机制）。<br> 如果原类的对象还实现了可选的替换方法，如replaceObjectIn[Key]AtIndex:withObject:或replace[Key]AtIndexes:with[Key]:，代理对象也会适时调用此方法来提高效率。</li>
<li><p>如果类的实例对象没有这些可变的数组方法，就查找名字如set[Key]:的访问方法进行匹配。在这种情况下，返回的代理对象都是通过调用原始对象的set[Key]:方法来间接响应NSMutableArray的消息。</p>
<blockquote>
<p>注意：<br>步骤【2】中的机制由于需要每次创建新的集合对象（set[Key]:，setter方法设置，而不是修改已存在的对象），导致性能要比步骤【1】中要差了不少。所以自己设计KVC相关对象时要避免这种代码。</p>
</blockquote>
</li>
<li><p>既没有找到可变数组方法，也没有找到访问器，查看类的accessInstanceVariablesDirectly方法是否返回YES，是则依次去类的成员变量中查询是否存在如_[key]或[key]。若存在，则返回一个代理对象，系统会把代理对象收到的每个NSMutableArray的消息都转发给这个成员变量，这个变量的类型需要是NSMutableArray或其子类。</p>
</li>
<li>如果上面所有的步骤都失败了，就返回一个可变的集合代理对象，作为参数，来触发setValue:forUndefinedKey:方法。默认在内部抛出NSUndefinedKeyException异常，子类可以覆盖进行其他处理。</li>
</ol>
<blockquote>
<p>查了好多东西，发现只有在KVO时，使用此可变容器的api进行KVC属性设置。由于调用此api返回的是可变集合对象，且是系统在运行时动态生成的，内部已经包含了KVO使用的isa指针等。当对此代理对象调用NSMutableArray方法时，会自动触发KVO机制。</p>
</blockquote>
<p>其他如可变无序集合和可变有序集合的搜索模式与此类似，不再细说。</p>
<h3 id="参考内容："><a href="#参考内容：" class="headerlink" title="参考内容："></a>参考内容：</h3><ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/BasicPrinciples.html#//apple_ref/doc/uid/20002170-BAJEAIEE" target="_blank" rel="external">Key-Value Coding Fundamentals</a></li>
<li><a href="https://www.jianshu.com/p/45cbd324ea65" target="_blank" rel="external">iOS开发技巧系列—详解KVC(我告诉你KVC的一切)</a></li>
<li><a href="http://liumh.com/2015/08/22/ios-nsmutablearray-kvo/" target="_blank" rel="external">iOS如何为NSMutableArray添加KVO</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对象属性值的设置和获取&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问集合属性值的专用API&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用集合操作符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;描述非对象的值（基本数据类型和结构体等）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;属性类型验证&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问器的搜索方式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS Protocol（协议）的简单总结</title>
    <link href="http://yoursite.com/2018/04/03/iOS%20Protocol%EF%BC%88%E5%8D%8F%E8%AE%AE%EF%BC%89%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/03/iOS Protocol（协议）的简单总结/</id>
    <published>2018-04-03T02:50:26.000Z</published>
    <updated>2018-05-15T02:18:57.631Z</updated>
    
    <content type="html"><![CDATA[<p>协议保存在类结构的协议表中，我们可以使用runtime的相关api查看指定类遵循的协议，或动态修改遵循的协议等。</p>
<a id="more"></a>
<h3 id="语法总结："><a href="#语法总结：" class="headerlink" title="语法总结："></a>语法总结：</h3><ol>
<li>协议中可以声明<strong>方法、属性</strong></li>
<li>协议方法分为可选可必选</li>
<li><strong>协议属性不会自动合成</strong>（与@dynamic的property一样）</li>
<li>协议可继承（通过xcode创建的protocol文件，默认继承了NSObject协议），且为单继承，子协议默认继承了父协议的所有内容</li>
</ol>
<h3 id="使用建议："><a href="#使用建议：" class="headerlink" title="使用建议："></a>使用建议：</h3><ol>
<li>当主类遵循多个协议时，可以使用category将主类分开，防止代码量过大且过于复杂</li>
<li>协议可以让使用类匿名（即对外返回id<xxx>的对象），公开的api放到protocol中，一般用于设计framework等。可以参见NSFetchResultController类的设计。</xxx></li>
</ol>
<h3 id="参考内容："><a href="#参考内容：" class="headerlink" title="参考内容："></a>参考内容：</h3><ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithProtocols/WorkingwithProtocols.html#//apple_ref/doc/uid/TP40011210-CH11-SW1" target="_blank" rel="external">Working with Protocols</a></li>
<li></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;协议保存在类结构的协议表中，我们可以使用runtime的相关api查看指定类遵循的协议，或动态修改遵循的协议等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 2.0 方法调用中的动态绑定和消息转发</title>
    <link href="http://yoursite.com/2018/03/30/Objective-C%202.0%20%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>http://yoursite.com/2018/03/30/Objective-C 2.0 动态绑定和消息转发/</id>
    <published>2018-03-30T06:06:41.000Z</published>
    <updated>2018-05-15T02:19:01.521Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li><strong>OC方法调用的实质</strong></li>
<li><strong>动态绑定和消息转发的流程</strong></li>
<li><strong>动态绑定实例（添加实例方法、添加类方法）</strong></li>
<li><strong>消息转发实例</strong></li>
<li><strong>消息转发模拟“多继承”以及二者的区别</strong></li>
<li><strong>使用消息转发代替继承</strong></li>
</ul>
</blockquote>
<a id="more"></a>
<h3 id="OC方法调用的实质"><a href="#OC方法调用的实质" class="headerlink" title="OC方法调用的实质"></a>OC方法调用的实质</h3><p>我们都知道，OC是C语言的超集，赋予了C强大的动态特性，其功劳主要归功于OC的运行时系统（runtime）。OC调用方法的实质是发送消息（即objc_msgSend函数）。在编译期，对象理论上可以调用任何方法，即使此方法并没有实现。直到运行期，系统才会根据方法名（SEL）去class的数据结构中查找对应方法进行方法调用。</p>
<h3 id="动态绑定和消息转发的流程"><a href="#动态绑定和消息转发的流程" class="headerlink" title="动态绑定和消息转发的流程"></a>动态绑定和消息转发的流程</h3><p>给对象（类的实例）发送消息（即调用方法）的大致流程如下：</p>
<ol>
<li>根据实例的isa指针确定所属class</li>
<li>在class的缓存表中查看是否存在此方法。若存在，加入缓存表后，找到对应IMP直接调用</li>
<li>不存在缓存时，在class的方法表中查找。若存在，加入缓存表后，找到对应IMP直接调用</li>
<li>方法表不存在时，根据class的super_class指针，在父类的方法表中继续查找。若存在，加入缓存表后，找到对应IMP直接调用</li>
<li>都没有查找到时，runtime会启动动态绑定，调用resolveInstanceMethod方法，此时，可以动态添加此方法到class中。如已添加，加入缓存表后，找到对应IMP直接调用</li>
<li>若没有动态添加方法，runtime会启动快速消息转发机制，即调用forwardTargetForSelector方法。我们可以直接返回一个类实例，指定其为调用者的代理对象，直接执行其对应的方法</li>
<li>如果没有指定代理对象，runtime会启动完整的消息转发机制（forwardInvocation）：首先，调用methodSignatureForSelector方法，返回一个包含此方法实例对象的方法签名；接着，系统会根据此方法签名，生成一个NSInvacation对象（包含着方法选择器等信息），带有此参数并调用forwardInvocation方法。我们在forwardInvocation中，使用invacation对象调用invokeWithTarget方法，传入需要转发的实例对象。即完成了消息转发，系统会自动调用转发对象的对应方法，并将结果返回给最初的调用者。</li>
<li>如果我们没有把消息转发给任何对象，最后系统会调用doesNotRecognizeMethod方法，并在其内部抛出异常，即表示无法处理此消息，最终默认crash掉APP。</li>
</ol>
<blockquote>
<p>以上步骤中，1~4为方法的正常调用流程，5为动态绑定流程，6~8为消息转发流程。</p>
</blockquote>
<p>转发一张动态绑定和消息转发的流程图（上面的步骤5~8）：<br><img src="https://upload-images.jianshu.io/upload_images/1457495-8ee6afef466e6177.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<h3 id="动态绑定实例"><a href="#动态绑定实例" class="headerlink" title="动态绑定实例"></a>动态绑定实例</h3><ul>
<li>添加实例方法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    [self performSelector:@selector(missingMethod:) withObject:@<span class="string">"haha"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    <span class="keyword">if</span> (NSSelectorFromString(@<span class="string">"missingMethod:"</span>) == sel) &#123;</div><div class="line">        <span class="comment">// 是我们调用的方法，使用runtime添加实现</span></div><div class="line">        <span class="comment">// 方法描述中，v--void；@--id；:--SEL</span></div><div class="line">        class_addMethod([self class], sel, (IMP)missingMethodIMP, <span class="string">"v@:@\"NSString\""</span>);</div><div class="line">        <span class="keyword">return</span> YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 返回默认实现</span></div><div class="line">    <span class="keyword">return</span> [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">missingMethodIMP</span><span class="params">(id self, SEL _cmd, NSString *param)</span> </span>&#123;</div><div class="line">    NSLog(@<span class="string">"calling missingMethodIMP with: %@"</span>, param);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>添加类方法：</li>
</ul>
<p>我们知道，与实例方法不同，类方法是保存在类所属元类的方法表中（即class -&gt; isa -&gt; meta class -&gt; method list）。所以给类动态绑定类方法，需要绑定到元类中，通过resolveClassMethod进行添加：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    [[self <span class="class"><span class="keyword">class</span>] <span class="title">performSelector</span>:</span>@selector(missingClassMethod:) withObject:@<span class="string">"haha"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel &#123;</div><div class="line">    <span class="keyword">if</span> (NSSelectorFromString(@<span class="string">"missingClassMethod:"</span>) == sel) &#123;</div><div class="line">        <span class="comment">// 是我们调用的方法，使用runtime添加实现</span></div><div class="line">        <span class="comment">// 获取meta class</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *className = class_getName(self);</div><div class="line">        id metaClass = objc_getMetaClass(className);</div><div class="line">        <span class="comment">// 添加方法</span></div><div class="line">        <span class="keyword">return</span> class_addMethod(metaClass, sel, (IMP)missingClassMethodIMP, <span class="string">"v@:@\"NSString\""</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [super resolveClassMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">missingClassMethodIMP</span><span class="params">(id self, SEL _cmd, NSString *param)</span> </span>&#123;</div><div class="line">    NSLog(@<span class="string">"calling missingClassMethodIMP with: %@"</span>, param);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="消息转发实例"><a href="#消息转发实例" class="headerlink" title="消息转发实例"></a>消息转发实例</h3><p>这里只列举了实例方法的消息转发。对于类方法的消息转发，只需将对应的“-”改为“+”即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line">@interface ClassAForForward : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"ClassAForForward.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"ClassBForForward.h"</span></span></div><div class="line"></div><div class="line">@implementation ClassAForForward</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    <span class="comment">// 这里只是演示一下，首先会进入动态绑定过程</span></div><div class="line">    <span class="comment">// 由于没有任何作用，会进入消息转发流程</span></div><div class="line">    <span class="keyword">return</span> [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="comment">// 此方法可以直接指定转发的对象</span></div><div class="line">    <span class="comment">// 省略了获取方法签名和生成转发对象组合的方式</span></div><div class="line">    <span class="comment">// 效率高</span></div><div class="line">    <span class="keyword">if</span> (aSelector == NSSelectorFromString(@<span class="string">"methodB"</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> [[ClassBForForward alloc] init];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 直接返回，则会触发完整的消息转发机制</span></div><div class="line">    <span class="keyword">return</span> [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</div><div class="line">    <span class="keyword">if</span> (!signature) &#123;</div><div class="line">        <span class="comment">// 找不到SEL对应的方法签名，</span></div><div class="line">        <span class="comment">// 提供一个自定义的方法签名，返回给本类用于转发调用（forwardInvocation）</span></div><div class="line">        ClassBForForward *bInstance = [[ClassBForForward alloc] init];</div><div class="line">        <span class="comment">// 将带有此selector的类的方法签名返回给本类</span></div><div class="line">        <span class="comment">// 使本类调用“转发调用”方法（forwardInvocation）【即runtime会生成一个invocation传入到转发方法中并调用】</span></div><div class="line">        <span class="comment">// 相当于带有selector的类实例“代理”了本类执行selector</span></div><div class="line">        signature = [bInstance methodSignatureForSelector:aSelector];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> signature;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(NSInvocation *)anInvocation &#123;</div><div class="line">    SEL aSelector = [anInvocation selector];</div><div class="line">    <span class="keyword">if</span> (aSelector) &#123;</div><div class="line">        <span class="comment">// 本类实例指定代理对象来调用selector</span></div><div class="line">        <span class="comment">// 转发给代理对象</span></div><div class="line">        ClassBForForward *bInstance = [[ClassBForForward alloc] init];</div><div class="line">        [anInvocation invokeWithTarget:bInstance];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 返回给系统继续调用（调用doesNotRecognizeSelector方法）</span></div><div class="line">        [super forwardInvocation:anInvocation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)doesNotRecognizeSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="comment">// 最终无法转发的方法，会执行这里，之后默认crash</span></div><div class="line">    [super doesNotRecognizeSelector:aSelector];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="消息转发模拟“多继承”以及二者的区别"><a href="#消息转发模拟“多继承”以及二者的区别" class="headerlink" title="消息转发模拟“多继承”以及二者的区别"></a>消息转发模拟“多继承”以及二者的区别</h3><p>面向对象编程，其实根本目的就是为了代码复用。面向对象的方式之一就是继承，但由于OC只支持单继承，一定程度上减少了很多代码复用的机会，而且并不是所有的类都可以直接继承（如OC的类簇）。而消息转发机制可以在一定程度上解决这个问题。</p>
<p>个人理解，消息转发实际上与代理模式一样，调用者本身不具备指定功能，通过代理对象调用方法来间接实现自己的功能。外部看起来与本身直接调用一样。当把多个功能分别转发给多个对象后，调用者本身就具备了多个类的多种功能，看起来就像是多继承一样。这也就赋予了OC“多继承”的功能，而且实现了代码复用（功能复用）。</p>
<p>但是消息转发和真正的多继承还是存在明显区别的：</p>
<ul>
<li>多继承是“多合一”：多个父类的功能组合生成子类，子类的功能及结构会变多且复杂。</li>
<li>消息转发是“一分多”：通过代理对象，将多个功能分发到多个类中进行实现，本类的实际结构和功能则相对简单，且对外部透明。</li>
</ul>
<h3 id="使用消息转发代替继承"><a href="#使用消息转发代替继承" class="headerlink" title="使用消息转发代替继承"></a>使用消息转发代替继承</h3><p>虽然消息转发隐藏了细节，在外部看起来像是调用类存在某种功能（实现了这个方法），或者是你认为调用类“继承”了转发类。但实际上，通过诸如respondsToSelector、isKindOfClass等函数还是可以识别出真相（此类函数只会查看本身的继承链，不会查看转发链）。如果你想要完全模拟“继承”，则需要覆盖此类方法才行。<br><em>官方文档有说过，一定要慎用消息转发，在没有彻底弄清转发机制和本类及转发类的功能时，不要乱用这个机制。</em></p>
<p>参考内容：</p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1" target="_blank" rel="external">Message Forwarding</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html#//apple_ref/doc/uid/TP40008048-CH102-SW1" target="_blank" rel="external">Dynamic Method Resolution</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;OC方法调用的实质&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态绑定和消息转发的流程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态绑定实例（添加实例方法、添加类方法）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息转发实例&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息转发模拟“多继承”以及二者的区别&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用消息转发代替继承&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 2.0的category</title>
    <link href="http://yoursite.com/2018/03/26/Objective-C%202.0%20category/"/>
    <id>http://yoursite.com/2018/03/26/Objective-C 2.0 category/</id>
    <published>2018-03-26T14:40:03.000Z</published>
    <updated>2018-05-15T02:18:58.508Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li><strong>class和category的数据结构</strong></li>
<li><strong>为什么category只能添加方法，不能添加属性？</strong></li>
<li><strong>category为何不要覆盖父类方法？</strong></li>
<li><strong>多个category覆盖同名方法的执行顺序</strong></li>
<li><strong>category与extension的区别</strong></li>
<li><strong>关联对象和其他补充</strong></li>
</ul>
</blockquote>
<a id="more"></a>
<h3 id="class和category的数据结构"><a href="#class和category的数据结构" class="headerlink" title="class和category的数据结构"></a>class和category的数据结构</h3><p>在学习runtime时，可以知道，<em>OC的所有数据结构，包括对象、类、方法、协议等等，都是C的结构体</em>。<br>类的实例，即对象，主要只包含了一个isa指针，指向其所属的class。而class的isa指针则指向其元类（meta class），元类的isa指向根原类，根元类isa指向自身。</p>
<p>来一张转烂了的图，顺便说明isa和super指针的指向关系：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3270116-4fef3651af3f80d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="img"></p>
<p>class的主要数据结构（元类与其相同）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></div><div class="line">	Class isa    OBJC_ISA_AVAILABILITY;</div><div class="line">	</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">	Class super_class;    <span class="comment">// 父类</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">// 类名</span></div><div class="line">	<span class="keyword">long</span> version;    <span class="comment">// 类版本信息，默认0</span></div><div class="line">	<span class="keyword">long</span> info;    <span class="comment">// 类信息</span></div><div class="line">	<span class="keyword">long</span> instance_size;    <span class="comment">// 类实例变量大小</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>;</span>    <span class="comment">// 成员变量链表</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodlists</span>;</span>    <span class="comment">// 方法链表</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>;</span>    <span class="comment">// 方法缓存</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>;</span>    <span class="comment">// 遵循的协议链表</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>简要说明下：</p>
<ul>
<li>根据class的数据结构，即可了解runtime的主要功能：可以在运行时获取类的相关信息，包括实例变量、方法列表、协议列表等，且可以通过相关api对各部分进行增删改查等操作（甚至是修改method的实现）。</li>
<li>OC中的方法调用，并非在编译期确定调用地址，而是在运行时才会确定调用方法的真正地址（通过objc_msgsend函数进行方法调用）。子类的方法调用，会在methodlist中查找，未找到后，会在父类的methodlist中继续查找，直到找到后调用（未找到后进入消息转发）。找到后，会将此method的地址放入cache中，以加快访问。</li>
</ul>
<p>我们主要讨论的category，其结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">// 类名</span></div><div class="line">	<span class="keyword">classref_t</span> cls;    <span class="comment">// 类</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span>    <span class="comment">// 保存添加的实例方法的链表</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>    <span class="comment">// 保存添加的类方法的链表</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>    <span class="comment">// 保存实现的协议方法的链表</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span>    <span class="comment">// 保存所有添加的属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="为什么category只能添加方法，不能添加属性？"><a href="#为什么category只能添加方法，不能添加属性？" class="headerlink" title="为什么category只能添加方法，不能添加属性？"></a>为什么category只能添加方法，不能添加属性？</h3><p>从category的结构中可以看出，<strong>由于内部只保存了属性，并不包含ivar（成员变量才能保存属性的值），即只生成了setter和getter方法的声明，没有对应实现，更没有对应的成员变量保存</strong>。所以在category中添加属性，需要使用runtime的相关对象（associate_object）进行。<br>而且对于category来说，<strong>添加的方法会在编译后添加到主类的方法列表中（实例方法添加到主类，类方法添加到主类所属的元类中）</strong>。</p>
<h3 id="category为何不要覆盖父类方法？"><a href="#category为何不要覆盖父类方法？" class="headerlink" title="category为何不要覆盖父类方法？"></a>category为何不要覆盖父类方法？</h3><p>我们都知道，在category中覆盖父类方法时，系统会弹出警告（主类也实现了此方法），且调用原方法时，系统会执行category的实现，从而导致原始方法实现被覆盖。这里是为什么？<br>我们知道，由于category的方法在runtime加载后会添加到本类的方法表中，方法表保存的是方法的SEL，可以推测：</p>
<ol>
<li>原SEL被覆盖</li>
<li>两个同名方法都被加入到方法表中，调用时只执行了category的</li>
</ol>
<p>另一个问题是，runtime在加载时，对于本类和category的加载顺序是什么。</p>
<p>参照以下代码可以验证：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">// 主类</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface TestClassForCategory : NSObject</div><div class="line"></div><div class="line">- (void)testMethod;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#import "TestClassForCategory.h"</div><div class="line"></div><div class="line">@implementation TestClassForCategory</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@"load === TestClassForCategory");</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)testMethod &#123;</div><div class="line">    NSLog(@"instance method~~~~");</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">// 分类（category）</div><div class="line">#import "TestClassForCategory.h"</div><div class="line"></div><div class="line">@interface TestClassForCategory (Category1)</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#import "TestClassForCategory+Category1.h"</div><div class="line"></div><div class="line">@implementation TestClassForCategory (Category1)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@"load === TestClassForCategory+Category1");</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)testMethod &#123;</div><div class="line">    // category的方法会添加到</div><div class="line">    NSLog(@"category1----");</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我们可以在自己的测试类中，实例化TestClassForCategory并调用testMethod方法，可以看到输出结果：</p>
<blockquote>
<p>2018-03-27 07:55:10.278999+0800 Runtime_Learning2[3506:4499896] load === TestClassForCategory<br>2018-03-27 07:55:10.280645+0800 Runtime_Learning2[3506:4499896] load === TestClassForCategory+Category1<br>2018-03-27 07:55:14.702309+0800 Runtime_Learning2[3506:4499896] category1—-</p>
</blockquote>
<p>由此可以证明，<strong>runtime加载时，首先加载主类，然后加载category。</strong></p>
<p>我们通过runtime的api来获取一下TestClassForCategory的方法表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 打印TestClassForCategory的methodlist</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> methodlistCount;</div><div class="line">Method *methodlist =  class_copyMethodList([TestClassForCategory class], &amp;methodlistCount);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodlistCount; i++) &#123;</div><div class="line">    Method method = methodlist[i];</div><div class="line">    SEL sel = method_getName(method);</div><div class="line">    IMP imp = method_getImplementation(method);</div><div class="line">    NSLog(@<span class="string">"method - %@"</span>, NSStringFromSelector(sel));</div><div class="line">    imp();</div><div class="line">&#125;</div><div class="line"><span class="built_in">free</span>(methodlist);</div></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<blockquote>
<p>2018-03-27 07:55:10.683704+0800 Runtime_Learning2[3506:4499896] method - testMethod<br>2018-03-27 07:55:10.683855+0800<br>Runtime_Learning2[3506:4499896] category1—-<br>2018-03-27 07:55:10.683965+0800 Runtime_Learning2[3506:4499896] method - testMethod<br>2018-03-27 07:55:10.684055+0800 Runtime_Learning2[3506:4499896] instance method<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&gt; </div><div class="line"></div><div class="line">可以看到，**在主类的方法表中，果然保存了主类和分类两个SEL，且方法实现均可以被调用**。联系着load方法的执行顺序，我们可以知道，**class在方法列表中添加方法时，是依照“头部插入”的方式（“头插法”）来修改链表的**。</div><div class="line">原理如下（转自[iOS OC中分类Category实现原理](http://blog.sina.com.cn/s/blog_14679a7d20102xae4.html)）：</div><div class="line"></div><div class="line">![img](http://img.blog.csdn.net/20180131104524542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hpaHVib2tl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</div><div class="line"></div><div class="line">由此可见，当分类中覆盖了主类的方法后，**由于分类的方法在原方法前部，导致调用方法时，系统查找到第一个方法后，直接返回执行，本类方法不会执行**。所以一般不建议在分类中覆盖主类方法。特别是给系统类添加分类时，由于本类或其父类可能会有相同的方法声明，导致被分类覆盖。</div><div class="line"></div><div class="line">为避免此类问题的出现，可以在分类中声明方法时，添加自定义的方法前缀。</div><div class="line"></div><div class="line">### 多个category覆盖同名方法的执行顺序</div><div class="line"></div><div class="line">我们知道，在类的方法表中添加方法使用的是“头插法”，但当给主类添加多个分类时，分类方法的加载顺序又是如何呢？</div><div class="line">根据代码来看：</div><div class="line"></div><div class="line">``` C</div><div class="line">// 在以上代码的基础上再添加第二个category</div><div class="line">#import &quot;TestClassForCategory.h&quot;</div><div class="line"></div><div class="line">@interface TestClassForCategory (Category2)</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#import &quot;TestClassForCategory+Category2.h&quot;</div><div class="line"></div><div class="line">@implementation TestClassForCategory (Category2)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;load === TestClassForCategory+Category2&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)testMethod &#123;</div><div class="line">    // category的方法会添加到</div><div class="line">    NSLog(@&quot;category2----&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line">```</div><div class="line">执行结果如下：</div><div class="line">&gt; </div><div class="line">&gt; 2018-03-27 10:58:50.708610+0800 Runtime_Learning2[4434:4568830] load === TestClassForCategory</div><div class="line">&gt; 2018-03-27 10:58:50.711459+0800 Runtime_Learning2[4434:4568830] load === TestClassForCategory+Category1</div><div class="line">&gt; 2018-03-27 10:58:50.712078+0800 Runtime_Learning2[4434:4568830] load === TestClassForCategory+Category2</div><div class="line">&gt; 2018-03-27 10:58:50.927215+0800 Runtime_Learning2[4434:4568830] method - testMethod</div><div class="line">&gt; 2018-03-27 10:58:50.927375+0800 Runtime_Learning2[4434:4568830] category2----</div><div class="line">&gt; 2018-03-27 10:58:50.927585+0800 Runtime_Learning2[4434:4568830] method - testMethod</div><div class="line">&gt; 2018-03-27 10:58:50.928280+0800 Runtime_Learning2[4434:4568830] category1----</div><div class="line">&gt; 2018-03-27 10:58:50.928472+0800 Runtime_Learning2[4434:4568830] method - testMethod</div><div class="line">&gt; 2018-03-27 10:58:50.928653+0800 Runtime_Learning2[4434:4568830] instance method</div></pre></td></tr></table></figure></p>
<p>2018-03-27 10:58:53.851391+0800 Runtime_Learning2[4434:4568830] category2—-</p>
</blockquote>
<p>可以看到，最后加载的category2，则执行方法指向的是category2的方法。原因在哪呢？</p>
<p>在工程TARGETS -&gt; Build Phases -&gt; Compile Sources中，我们可以看到，自上而下，编译资源的顺序是：Category1.m、Category2.m，我们可以自己上下调整编译顺序并执行，结果显而易见：</p>
<p><strong>多个category的加载顺序（也是方法的覆盖顺序）是依照Compile Sources的顺序自上而下确定的。</strong></p>
<p><em>注意，返回值不同的方法也会覆盖，因为SEL与返回值无关。</em></p>
<p>所以，多个分类同时覆盖主类的方法时，执行结果无法直接确定，可能会出现不可预估的问题。</p>
<h3 id="category与extension的区别"><a href="#category与extension的区别" class="headerlink" title="category与extension的区别"></a>category与extension的区别</h3><p>一般来说，我们都会认为class extension（类的扩展）是匿名的category，因为语法详尽，且功能相似，但实际上来说，二者可以说是<em>完全不同</em>。</p>
<ul>
<li><p>extension: </p>
<ol>
<li>它是class的一部分，与interface、implementation三者共同组成class，声明周期与class相同。</li>
<li>分类是在编译期确定的，内部声明的属性和方法在编译期直接组成class结构体的数据（属性会自动生成ivar并合成setter和getter，分别添加到class的ivar_list和method_list中）。</li>
<li>分类声明的方法，实现必须在class的implementation中，所以没有本类的源代码无法添加extension。</li>
</ol>
</li>
<li><p>category:</p>
<ol>
<li>与class本体无关，可以单独存在。</li>
<li>扩展是在编译期编译，在运行时加载到类中。category由于其数据结构所限，只能添加方法实现、属性声明和协议实现，内部不包含ivar成员变量，所以无法保存数据（声明的属性不能生成对应的ivar，也不能合成出setter和getter的实现）。</li>
<li>编译期由于class结构布局和数据已经确定，在运行时，category只能将方法添加到class的方法链表中，其他东西无法修改（class的实例大小等在编译期已确定，无法修改）。</li>
</ol>
</li>
</ul>
<h3 id="关联对象和其他补充"><a href="#关联对象和其他补充" class="headerlink" title="关联对象和其他补充"></a>关联对象和其他补充</h3><ul>
<li><p>由于在category中添加属性，需要使用关联对象（associate object）进行添加和访问，那关联对象的数据保存在哪里呢？</p>
<p>  所有的关联对象都由AssociationsManager进行统一管理（添加、删除等），保存在全局map中，其中key是这个相关对象的指针地址，value则是单独的一个AssociationsHashMap，里面保存着key-value对。</p>
</li>
<li><p>提问：在class的load方法中，可以调用Category的方法吗？<br>  答：可以。runtime加载class和category等是在load方法调用前执行的，此时Category的方法已经加载到class的方法列表中，可以直接调用。</p>
</li>
<li><p>提问：当Category已经覆盖了Class中的方法时，如何调用Class中的原方法？<br>  答：由于使用“头插法”，Category的方法已经在Class的方法列表头部。系统调用方法时是从头开始检索，查到对应Method后即跳转IMP进行调用。我们可以使用runtime的api手动遍历Class的方法表，找到最后一个同名方法，直接调用IMP。</p>
</li>
<li><p>扩展一个类的方式：</p>
<ol>
<li>子类化</li>
<li>使用category</li>
<li>使用协议抽象（如UITableView的delegate和data source，可以给具有显示功能的类进行扩展）</li>
</ol>
</li>
</ul>
<p>参考内容：</p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="external">Customizing Existing Classes
</a></li>
<li><a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">深入理解Objective-C：Category
</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_14679a7d20102xae4.html" target="_blank" rel="external">iOS OC中分类Category实现原理</a></li>
<li><a href="https://www.jianshu.com/p/87cfbdda0a68" target="_blank" rel="external">【iOS】category 重写方法的调用</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;class和category的数据结构&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为什么category只能添加方法，不能添加属性？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;category为何不要覆盖父类方法？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多个category覆盖同名方法的执行顺序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;category与extension的区别&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关联对象和其他补充&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
