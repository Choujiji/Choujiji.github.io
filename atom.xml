<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭吉吉的瞎记空间</title>
  <subtitle>技术的，瞎说的，啥都有吧。。。希望。。。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-13T06:11:30.189Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>臭吉吉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>弱指针weak的实现学习</title>
    <link href="http://yoursite.com/2019/08/13/%E5%BC%B1%E6%8C%87%E9%92%88weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/08/13/弱指针weak的实现学习/</id>
    <published>2019-08-12T16:16:12.823Z</published>
    <updated>2019-08-13T06:11:30.189Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-weak对象的实现函数"><a href="#1-weak对象的实现函数" class="headerlink" title="1. weak对象的实现函数"></a>1. weak对象的实现函数</h4><p>首先，看个例子（<em>取自《Objective-C高级编程 iOS与OS X多线程和内存管理》的第一部分</em>）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> weakObj = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure>
<p>其模拟代码为</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj;</div><div class="line"></div><div class="line"><span class="comment">// 创建临时对象tmp</span></div><div class="line"><span class="keyword">id</span> tmp = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(tmp, <span class="keyword">@selector</span>(init));</div><div class="line"></div><div class="line"><span class="comment">// 使用tmp创建weak对象obj</span></div><div class="line">objc_initWeak(&amp;obj, tmp);</div><div class="line"></div><div class="line"><span class="comment">// 作用域结束，tmp释放</span></div><div class="line">objc_release(tmp);</div><div class="line"></div><div class="line"><span class="comment">// 释放weak对象obj</span></div><div class="line">objc_destroyWeak(&amp;obj);</div></pre></td></tr></table></figure>
<p>通过代码可以看到，<strong>weak指针（weak对象）的创建及释放，实际上是通过<em>objc_initWeak()</em> 和 <em>objc_destroyWeak()</em> 函数实现的</strong>。现在，就需要查看一下iOS的运行时系统是如何实现weak的功能的。</p>
<blockquote>
<p>注：源代码采用objc.723版本</p>
</blockquote>
<p>objc_initWeak的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span></div><div class="line">objc_initWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!newObj) &#123;</div><div class="line">        *location = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</div><div class="line">        (location, (objc_object*)newObj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>objc_destroyWeak的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span></div><div class="line">objc_destroyWeak(<span class="keyword">id</span> *location)</div><div class="line">&#123;</div><div class="line">    (<span class="keyword">void</span>)storeWeak&lt;DoHaveOld, DontHaveNew, DontCrashIfDeallocating&gt;</div><div class="line">        (location, <span class="literal">nil</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>补充一下，修改weak对象的函数objc_storeWeak的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span></div><div class="line">objc_storeWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> storeWeak&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</div><div class="line">        (location, (objc_object *)newObj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，<strong>weak的相关功能，都是通过<em>storeWeak</em>函数进行实现的。通过不同的参数及条件设置实现weak对象的创建、修改和删除的</strong>。</p>
<h4 id="2-storeWeak的实现"><a href="#2-storeWeak的实现" class="headerlink" title="2. storeWeak的实现"></a>2. storeWeak的实现</h4><p>还是不废话，直接贴出实现源码（删除了部分无关代码）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> 更新weak变量。</div><div class="line"> </div><div class="line"> HaveOld为true时，即weak变量本身已经指向一个即将被清空的对象。这个值可以是nil。</div><div class="line"> HaveNew为true时，即有个新对象需要赋值给weak指针。这个值可以为nil。</div><div class="line"> CrashIfDeallocating为true时，如果newObj正在释放、或者newObj所属的类不支持弱引用，则进程就要中断（崩溃）；如果CrashIfDeallocating为false，则意味着将nil存储到变量中。</div><div class="line"> </div><div class="line"> @param location __weak指针地址</div><div class="line"> @param newObj  真正指向的对象</div><div class="line"> */</div><div class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</div><div class="line">          CrashIfDeallocating crashIfDeallocating&gt;</div><div class="line"><span class="keyword">static</span> <span class="keyword">id</span> </div><div class="line">storeWeak(<span class="keyword">id</span> *location, objc_object *newObj)</div><div class="line">&#123;</div><div class="line">    assert(haveOld  ||  haveNew); <span class="comment">// 至少一个为true</span></div><div class="line">    <span class="keyword">if</span> (!haveNew) assert(newObj == <span class="literal">nil</span>); <span class="comment">// 无新值时，newObj必须为nil</span></div><div class="line"></div><div class="line">    <span class="keyword">id</span> oldObj;</div><div class="line">    <span class="comment">// SideTable即为内存管理的数据结构。内部包含：引用计数表、弱引用表、自旋锁及相关方法。</span></div><div class="line">    SideTable *oldTable; <span class="comment">// 旧表（SideTable结构体指针）</span></div><div class="line">    SideTable *newTable; <span class="comment">// 新表（SideTable结构体指针）</span></div><div class="line"></div><div class="line">    <span class="comment">// Acquire locks for old and new values.</span></div><div class="line">    <span class="comment">// Order by lock address to prevent lock ordering problems. </span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (haveOld) &#123;</div><div class="line">        <span class="comment">// 若存在旧值</span></div><div class="line">        </div><div class="line">        <span class="comment">// 从weak地址中取出旧对象</span></div><div class="line">        oldObj = *location;</div><div class="line">        <span class="comment">// 使用旧对象获取到旧表实例</span></div><div class="line">        oldTable = &amp;SideTables()[oldObj];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 若不存在旧值</span></div><div class="line">        </div><div class="line">        <span class="comment">// 旧表直接置为nil</span></div><div class="line">        oldTable = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (haveNew) &#123;</div><div class="line">        <span class="comment">// 若存在新值</span></div><div class="line">        </div><div class="line">        <span class="comment">// 使用新值初始化得到新表实例</span></div><div class="line">        newTable = &amp;SideTables()[newObj];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 若不存在新值</span></div><div class="line">        </div><div class="line">        <span class="comment">// 新表直接置为nil</span></div><div class="line">        newTable = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据haveOld和haveNew状态，给两张SideTable表进行对应加锁（自旋锁）</span></div><div class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// Clean up old value, if any.</span></div><div class="line">    <span class="keyword">if</span> (haveOld) &#123;</div><div class="line">        <span class="comment">// 若存在旧值</span></div><div class="line">        </div><div class="line">        <span class="comment">// 在旧表中的weak表中清除相关信息（旧对象和weak指针的关联）</span></div><div class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Assign new value, if any.</span></div><div class="line">    <span class="keyword">if</span> (haveNew) &#123;</div><div class="line">        <span class="comment">// 若存在新值</span></div><div class="line">        </div><div class="line">        <span class="comment">// 在新表的weak表中存储相关信息（使用newObj的地址作为key，location地址，即weak指针作为value）</span></div><div class="line">        newObj = (objc_object *)</div><div class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (<span class="keyword">id</span>)newObj, location, </div><div class="line">                                  crashIfDeallocating);</div><div class="line">        <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></div><div class="line">        <span class="comment">// 如果被打断（如此时正在释放对象），则newObj就为nil了【注：crash的已经在上一步中进行处理了，这里是不crash的情况】</span></div><div class="line"></div><div class="line">        <span class="comment">// Set is-weakly-referenced bit in refcount table.</span></div><div class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</div><div class="line">            <span class="comment">// 若已经绑定成功，且newObj不是taggedPointer</span></div><div class="line">            </div><div class="line">            <span class="comment">// 将newObj的对应位标记为weak</span></div><div class="line">            newObj-&gt;setWeaklyReferenced_nolock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span></div><div class="line">        <span class="comment">// 确保weak指针指向newObj</span></div><div class="line">        *location = (<span class="keyword">id</span>)newObj;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// No new value. The storage is not changed.</span></div><div class="line">        <span class="comment">// 若没有新值，原存储信息不变</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 解锁相关表</span></div><div class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</div><div class="line"></div><div class="line">    <span class="comment">// 返回newObj对象</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)newObj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在以上代码中可以看到，我们所有的操作（注册weak、移除weak等）都是发生在<strong>SideTable</strong>实例中的。且在操作时需要在有锁的条件下执行。我们看一下SideTable到底是何方神圣：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> SideTable &#123;</div><div class="line">    <span class="comment">/** 自旋锁 */</span></div><div class="line">    spinlock_t slock;</div><div class="line">    <span class="comment">/** 引用计数表（散列表） */</span></div><div class="line">    RefcountMap refcnts;</div><div class="line">    <span class="comment">/** weak表（内部使用数组或二级表实现） */</span></div><div class="line">    weak_table_t weak_table;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，SideTable即为内存管理的精髓。其内部<strong>包含的就是引用计数表和weak弱引用表</strong>。</p>
<p>SideTable是全局对象（不支持析构，会crash），是由分离锁进行管理的StripedMap对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取oldTable对象（根据oldObj对象）</span></div><div class="line">oldTable = &amp;SideTables()[oldObj];</div></pre></td></tr></table></figure>
<p>其中，SideTables函数的实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在StripedMap模板类中，我们可以找到获取SideTable的相关实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StripedMap</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="keyword">enum</span> &#123; CacheLineSize = <span class="number">64</span> &#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_EMBEDDED</span></div><div class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PaddedT</span> &#123;</span></div><div class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    PaddedT <span class="built_in">array</span>[StripeCount];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span>&#123;</div><div class="line">        <span class="keyword">uintptr_t</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(p);</div><div class="line">        </div><div class="line">        <span class="comment">// hash算法（64位系统下得到的是0~63）</span></div><div class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % Stripe Count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) &#123; </div><div class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[indexForPointer(p)].value; </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，public方法中的实现即说明了一切：通过对象地址得到的hash值，取出数组中保存的值（这里即为SideTable对象）。且通过hash算法还可知道，一个StripedMap对象在64位系统下包含64个子单元。可以理解为一个分离锁管理着64个对象的SideTable对象。</p>
<p>由于本篇学习的是weak的实现，故我们暂时只讨论<em>weak_table_t</em>这个结构（这个还凑合，引用计数还根本不懂…）。</p>
<h4 id="3-weak弱引用表"><a href="#3-weak弱引用表" class="headerlink" title="3. weak弱引用表"></a>3. weak弱引用表</h4><p>首先看一下<em>weak_table_t</em>的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 全局弱引用表。</div><div class="line"> * weak_entry_t内部使用原始对象作为key，</div><div class="line"> * weak指针的地址的数组作为value</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_table_t</span> &#123;</span></div><div class="line">    <span class="comment">/** 弱引用键值数据数组的起始地址 */</span></div><div class="line">    <span class="keyword">weak_entry_t</span> *weak_entries;</div><div class="line">    <span class="comment">/** weak_entry_t数组的元素个数 */</span></div><div class="line">    <span class="keyword">size_t</span>    num_entries;</div><div class="line">    <span class="comment">/** weak_entry_t数组的大小 */</span></div><div class="line">    <span class="keyword">uintptr_t</span> mask;</div><div class="line">    <span class="comment">/** hash查找最大偏移量 */</span></div><div class="line">    <span class="keyword">uintptr_t</span> max_hash_displacement;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>weak_table_t内部保存着由week_entry_t实例组成的数组</strong>。</p>
<p>内部的<strong>weak_entry_t即为真正的键值对：key为引用的对象，value为weak指针组成的数组</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义的结构体内部对于weak指针个数的储存上线</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WEAK_INLINE_COUNT 4</span></div><div class="line"></div><div class="line"><span class="comment">// out_of_line_ness成员占用了inline_referrers数组index为1空间中的低2位。</span></div><div class="line"><span class="comment">// inline_referrers[1]是一个指针对齐的DisguisedPtr的对象。</span></div><div class="line"><span class="comment">// 一个指针对齐的DisguisedPtr的最低两位永远是0b00。</span></div><div class="line"><span class="comment">// 因此，在out_of_line_ness == 0b10，就被用于标记out-of-line动态数组的状态。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REFERRERS_OUT_OF_LINE 2</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_entry_t</span> &#123;</span></div><div class="line">    <span class="comment">/** 指向的对象 */</span></div><div class="line">    DisguisedPtr&lt;objc_object&gt; referent;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">            <span class="comment">/** 存储weak指针的动态数组的起始地址 */</span></div><div class="line">            <span class="keyword">weak_referrer_t</span> *referrers;</div><div class="line">            <span class="comment">/** 标识是否使用了动态数组：占2位 */</span></div><div class="line">            <span class="keyword">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>;</div><div class="line">            <span class="comment">/** 已存的weak指针个数：占62位 */</span></div><div class="line">            <span class="keyword">uintptr_t</span>        num_refs : PTR_MINUS_2;</div><div class="line">            <span class="comment">/** 动态数组的总大小 */</span></div><div class="line">            <span class="keyword">uintptr_t</span>        mask;</div><div class="line">            <span class="comment">/** hash查找最大偏移量 */</span></div><div class="line">            <span class="keyword">uintptr_t</span>        max_hash_displacement;</div><div class="line">        &#125;; <span class="comment">// 五个成员，共32字节</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">            <span class="comment">// 结构体中自带的可以存储4个weak指针的静态数组</span></div><div class="line">            <span class="comment">// 注：out_of_line_ness域使用了索引为1的位置的最低2位</span></div><div class="line">            <span class="keyword">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];</div><div class="line">        &#125;; <span class="comment">// 32字节</span></div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="comment">/** 判定是否使用了动态数组存储weak指针 */</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">out_of_line</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">weak_entry_t</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">weak_entry_t</span>&amp; other) &#123;</div><div class="line">        <span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;other, <span class="keyword">sizeof</span>(other));</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** 创建新的weak键值对实例（以前没有） */</span></div><div class="line">    <span class="keyword">weak_entry_t</span>(objc_object *newReferent, objc_object **newReferrer)</div><div class="line">        : referent(newReferent)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 使用静态数组存储weak指针</span></div><div class="line">        inline_referrers[<span class="number">0</span>] = newReferrer;</div><div class="line">        <span class="comment">// 将数组的其他位置数据置为nil</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</div><div class="line">            inline_referrers[i] = nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>weak_entry_t结构体固定为40字节大小。<br>其中，为了快速访问weak指针，weak_entry_t中直接设置了一个包含4个元素的静态数组。当指向对象的weak指针超过上限时，就使用动态数组进行存储（将静态数组中的weak指针copy到动态数组中，之后再存入新的weak指针）。<br>weak_entry_t提供给外部用于识别自身正在使用哪种存储数组的函数。</p>
<p>有了以上这些知识，我们就可以解释SideTable中的weak表是如何注册weak对象并如何清除weak对象的过程了。</p>
<h4 id="4-在weak引用表中注册weak对象"><a href="#4-在weak引用表中注册weak对象" class="headerlink" title="4. 在weak引用表中注册weak对象"></a>4. 在weak引用表中注册weak对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 如果不存在，注册一个新的（对象，弱指针）键值对（entry对象）。</div><div class="line"> * </div><div class="line"> * @param weak_table 全局弱引用表</div><div class="line"> * @param referent 弱指针要指向的对象</div><div class="line"> * @param referrer 弱指针的地址</div><div class="line"> */</div><div class="line"><span class="keyword">id</span> </div><div class="line">weak_register_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id, </div><div class="line">                      <span class="keyword">id</span> *referrer_id, <span class="keyword">bool</span> crashIfDeallocating)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 指向的原对象</span></div><div class="line">    objc_object *referent = (objc_object *)referent_id;</div><div class="line">    <span class="comment">// weak指针</span></div><div class="line">    objc_object **referrer = (objc_object **)referrer_id;</div><div class="line"></div><div class="line">    <span class="comment">// 原对象为nil，或者原对象是taggedPointer，直接返回原对象</span></div><div class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</div><div class="line"></div><div class="line">    <span class="comment">// ensure that the referenced object is viable</span></div><div class="line">    <span class="keyword">bool</span> deallocating;</div><div class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</div><div class="line">        <span class="comment">// 若原始对象的类，没有实现内存管理的相关方法</span></div><div class="line">        </div><div class="line">        <span class="comment">// 直接以SideTable的释放状态作为标识</span></div><div class="line">        deallocating = referent-&gt;rootIsDeallocating();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 若原始对象的类，实现了内存管理的相关方法</span></div><div class="line"></div><div class="line">        </div><div class="line">        <span class="built_in">BOOL</span> (*allowsWeakReference)(objc_object *, SEL) = </div><div class="line">            (<span class="built_in">BOOL</span>(*)(objc_object *, SEL))</div><div class="line">            object_getMethodImplementation((<span class="keyword">id</span>)referent, </div><div class="line">                                           SEL_allowsWeakReference);</div><div class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</div><div class="line">            <span class="comment">// 若allowsWeakReference的实现为消息转发函数，则证明调研对象不支持weak，直接返回nil</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 若allowsWeakReference的实现正常，执行此IMP，返回值取反作为释放的标识（即：自定义为不支持weak，则认为正在释放）</span></div><div class="line">        deallocating =</div><div class="line">            ! (*allowsWeakReference)(referent, SEL_allowsWeakReference);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (deallocating) &#123;</div><div class="line">        <span class="comment">// 根据释放标识，进行处理</span></div><div class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</div><div class="line">            <span class="comment">// crash</span></div><div class="line">            _objc_fatal(<span class="string">"Cannot form weak reference to instance (%p) of "</span></div><div class="line">                        <span class="string">"class %s. It is possible that this object was "</span></div><div class="line">                        <span class="string">"over-released, or is in the process of deallocation."</span>,</div><div class="line">                        (<span class="keyword">void</span>*)referent, object_getClassName((<span class="keyword">id</span>)referent));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 返回nil</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// now remember it and where it is being stored</span></div><div class="line">    weak_entry_t *entry;</div><div class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</div><div class="line">        <span class="comment">// 在weak表中，使用原始对象获取生成入口信息，若存在（证明原始对象子表中已经存储了其他weak指针了）</span></div><div class="line">        </div><div class="line">        <span class="comment">// 将weak指针插入到子表中</span></div><div class="line">        append_referrer(entry, referrer);</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 没有entry对象</span></div><div class="line">        </div><div class="line">        <span class="comment">// 使用原始对象创建新的entry对象（绑定好key和value）</span></div><div class="line">        weak_entry_t new_entry(referent, referrer);</div><div class="line">        </div><div class="line">        <span class="comment">// 检查是否需要扩充weak表（扩充后，原始数据均插入了新weak表中）</span></div><div class="line">        weak_grow_maybe(weak_table);</div><div class="line">        </div><div class="line">        <span class="comment">// 将新的入口信息插入到weak表中</span></div><div class="line">        weak_entry_insert(weak_table, &amp;new_entry);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 这里不要修改referrer的指向（也就是weak指针的指向不能变）</span></div><div class="line"></div><div class="line">    <span class="comment">// 返回原对象</span></div><div class="line">    <span class="keyword">return</span> referent_id;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，通过原始对象，在weak表中查找对应entry的过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 根据给定的对象，返回弱引用表中对应的entry。</div><div class="line"> * 如果没有对应的entry，返回NULL。</div><div class="line"> * 执行了一次循环查找。</div><div class="line"> *</div><div class="line"> * @param weak_table </div><div class="line"> * @param referent The object. Must not be nil.</div><div class="line"> * </div><div class="line"> * @return The table of weak referrers to this object. </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> weak_entry_t *</span></div><div class="line"><span class="title">weak_entry_for_referent</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, objc_object *referent)</span></div><div class="line">&#123;</div><div class="line">    assert(referent);</div><div class="line"></div><div class="line">    <span class="comment">// 从表中取出weak_entry_t指针（weak数据表的起始地址）</span></div><div class="line">    <span class="keyword">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!weak_entries) <span class="keyword">return</span> nil;</div><div class="line"></div><div class="line">    <span class="comment">// 根据对象地址的hash与weak表的mask与运算得到遍历的起始index</span></div><div class="line">    <span class="keyword">size_t</span> begin = hash_pointer(referent) &amp; weak_table-&gt;mask;</div><div class="line">    <span class="keyword">size_t</span> index = begin;</div><div class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 依次查看weak_entry_t对象中的referent是否为指向的对象</span></div><div class="line">    <span class="keyword">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;</div><div class="line">        <span class="comment">// 不是，索引后移</span></div><div class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</div><div class="line">        </div><div class="line">        <span class="comment">// 索引又变为begin了，直接crash（hash冲突且没有空余位置了）</span></div><div class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(weak_table-&gt;weak_entries);</div><div class="line">        hash_displacement++;</div><div class="line">        <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</div><div class="line">            <span class="comment">// 超出最大偏移范围，返回</span></div><div class="line">            <span class="keyword">return</span> nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 此时，通过index取到weak_entry_t对象，返回地址</span></div><div class="line">    <span class="keyword">return</span> &amp;weak_table-&gt;weak_entries[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注</strong>：</p>
<p>在查找遍历索引begin时，系统使用的方式是<strong>通过对象的hash值和weak_table的mask值进行<em>按位与</em>运算</strong>。<br>其中mask是num_entries-1，即如果此弱引用表的weak_entries个数是4，mask即为3，也就是0b11。<br>对象地址hash之后，通过mask进行<em>按位与</em>运算得到的，就只有mask值对应的范围，即0b00~0b11，故index取值范围是0~3。系统巧妙地将对象地址转化为索引，在数组中查找对应位置的数据。<br>后面使用while循环的原因是，<strong>由于hash值可能会重复，得到的index位置可能已经存在其他数据，故对index进行偏移处理，待新位置的元素符合要求，再进行操作</strong>。其中hash_displacement就是标记偏移量的。如果超过最大偏移量max_hash_displacement，则数组中没有符合要求的位置索引。</p>
</blockquote>
<p>向已经存在的weak_entry_t中插入新的weak指针，操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">append_referrer</span><span class="params">(<span class="keyword">weak_entry_t</span> *entry, objc_object **new_referrer)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</div><div class="line">        <span class="comment">// 若使用的内部数组存储weak指针，则直接遍历，将空的赋值为weak指针地址</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == nil) &#123;</div><div class="line">                entry-&gt;inline_referrers[i] = new_referrer;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 内部数组已满，此时需要使用动态数组存储（先初始化4个地址空间）</span></div><div class="line">        <span class="keyword">weak_referrer_t</span> *new_referrers = (<span class="keyword">weak_referrer_t</span> *)</div><div class="line">            <span class="built_in">calloc</span>(WEAK_INLINE_COUNT, <span class="keyword">sizeof</span>(<span class="keyword">weak_referrer_t</span>));</div><div class="line">        <span class="comment">// 将内部数组的四个weak指针copy到动态数组中</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</div><div class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 更新相关信息，以后使用动态数组存储</span></div><div class="line">        entry-&gt;referrers = new_referrers;</div><div class="line">        entry-&gt;num_refs = WEAK_INLINE_COUNT;</div><div class="line">        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;</div><div class="line">        entry-&gt;mask = WEAK_INLINE_COUNT<span class="number">-1</span>;</div><div class="line">        entry-&gt;max_hash_displacement = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 本来就在使用动态数组存储的情况</span></div><div class="line">    assert(entry-&gt;out_of_line());</div><div class="line"></div><div class="line">    <span class="comment">// 占用空间超过 3/4，扩容并插入新weak指针</span></div><div class="line">    <span class="keyword">if</span> (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123;</div><div class="line">        <span class="keyword">return</span> grow_refs_and_insert(entry, new_referrer);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 空间正常，可以插入</span></div><div class="line">    <span class="keyword">size_t</span> begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);</div><div class="line">    <span class="keyword">size_t</span> index = begin;</div><div class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 遍历找到待插入的索引位置</span></div><div class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != nil) &#123;</div><div class="line">        hash_displacement++;</div><div class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</div><div class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</div><div class="line">        entry-&gt;max_hash_displacement = hash_displacement;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 取出数组对应位置的地址，赋值weak指针</span></div><div class="line">    <span class="keyword">weak_referrer_t</span> &amp;ref = entry-&gt;referrers[index];</div><div class="line">    ref = new_referrer;</div><div class="line">    <span class="comment">// 计数+1</span></div><div class="line">    entry-&gt;num_refs++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而对于weak_table_t弱引用表中，没有引用对象指向的weak_entry_t对象时，直接创建新entry，将weak指针写入后，直接将此entry加入到弱引用表中。此过程与查询entry的过程非常相似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weak_entry_insert</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, <span class="keyword">weak_entry_t</span> *new_entry)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</div><div class="line">    assert(weak_entries != nil);</div><div class="line"></div><div class="line">    <span class="keyword">size_t</span> begin = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);</div><div class="line">    <span class="keyword">size_t</span> index = begin;</div><div class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (weak_entries[index].referent != nil) &#123;</div><div class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</div><div class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(weak_entries);</div><div class="line">        hash_displacement++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    weak_entries[index] = *new_entry;</div><div class="line">    weak_table-&gt;num_entries++;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</div><div class="line">        weak_table-&gt;max_hash_displacement = hash_displacement;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-在weak弱引用表中移除weak对象"><a href="#5-在weak弱引用表中移除weak对象" class="headerlink" title="5. 在weak弱引用表中移除weak对象"></a>5. 在weak弱引用表中移除weak对象</h4><p>相对的，当指向的对象将要释放时，运行时系统会将注册到weak表中的原始对象相关的所有weak指针信息移除。也就实现了weak自动置为nil的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">weak_unregister_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent_id, </span></div><div class="line">                        id *referrer_id)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 指向的对象</span></div><div class="line">    objc_object *referent = (objc_object *)referent_id;</div><div class="line">    <span class="comment">// weak指针的地址</span></div><div class="line">    objc_object **referrer = (objc_object **)referrer_id;</div><div class="line"></div><div class="line">    <span class="keyword">weak_entry_t</span> *entry;</div><div class="line"></div><div class="line">    <span class="comment">// 指向对象不存在，直接返回（用指向对象的地址作为key进行保存）</span></div><div class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</div><div class="line">        <span class="comment">// 使用指向的对象在weak表中查找，获取entry，如果存在</span></div><div class="line">        </div><div class="line">        <span class="comment">// 在entry中移除weak指针的地址存储</span></div><div class="line">        remove_referrer(entry, referrer);</div><div class="line">        </div><div class="line">        <span class="comment">// 查看入口信息子表中是否还有其他weak指针存储</span></div><div class="line">        <span class="keyword">bool</span> empty = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 使用了动态数组存储weak指针，且num_refs不为0，证明还有</span></div><div class="line">            empty = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 内部数组存储，只要数组不为空，就还有</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</div><div class="line">                    empty = <span class="literal">false</span>; </div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (empty) &#123;</div><div class="line">            <span class="comment">// 若子表中没有其他的weak指针地址存储了</span></div><div class="line">            </div><div class="line">            <span class="comment">// 在weak表中移除entry信息</span></div><div class="line">            weak_entry_remove(weak_table, entry);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这里不要清除weak指针的地址，objc_storeWeak函数不允许他人更改</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整体过程与注册weak指针的流程非常相似。查询到weak_entry_t对象后，移除内部的weak指针，最后清除此entry对象即可。</p>
<p>移除entry中指定的weak指针的过程如下（与插入weak指针非常相似）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove_referrer</span><span class="params">(<span class="keyword">weak_entry_t</span> *entry, objc_object **old_referrer)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</div><div class="line">        <span class="comment">// 没有使用外部动态数组，即weak直接存储在内部静态数组中</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</div><div class="line">            <span class="comment">// 查找到weak指针所在的对象</span></div><div class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == old_referrer) &#123;</div><div class="line">                <span class="comment">// 置为nil，完成清除（weak指针自动置nil的功能）</span></div><div class="line">                entry-&gt;inline_referrers[i] = nil;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 未找到，出现内部错误</span></div><div class="line">        _objc_inform(<span class="string">"Attempted to unregister unknown __weak variable "</span></div><div class="line">                     <span class="string">"at %p. This is probably incorrect use of "</span></div><div class="line">                     <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></div><div class="line">                     <span class="string">"Break on objc_weak_error to debug.\n"</span>, </div><div class="line">                     old_referrer);</div><div class="line">        objc_weak_error();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// weak指针存储超过了4个，使用了外部的动态数组</span></div><div class="line">    </div><div class="line">    <span class="comment">// 得到遍历的起始索引</span></div><div class="line">    <span class="keyword">size_t</span> begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);</div><div class="line">    <span class="keyword">size_t</span> index = begin;</div><div class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 在动态数组中依次查看，直到找到weak指针存储的位置</span></div><div class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != old_referrer) &#123;</div><div class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</div><div class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry); <span class="comment">// 出错crash</span></div><div class="line">        hash_displacement++;</div><div class="line">        <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</div><div class="line">            _objc_inform(<span class="string">"Attempted to unregister unknown __weak variable "</span></div><div class="line">                         <span class="string">"at %p. This is probably incorrect use of "</span></div><div class="line">                         <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></div><div class="line">                         <span class="string">"Break on objc_weak_error to debug.\n"</span>, </div><div class="line">                         old_referrer);</div><div class="line">            objc_weak_error();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 此时index所在位置即为weak指针存储的位置，置为nil清除</span></div><div class="line">    entry-&gt;referrers[index] = nil;</div><div class="line">    <span class="comment">// 将索引个数-1</span></div><div class="line">    entry-&gt;num_refs--;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在weak_table_t中移除weak_entry_t对象就比较简单了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weak_entry_remove</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, <span class="keyword">weak_entry_t</span> *entry)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 使用了动态数组存储weak指针，则直接从起始地址进行释放即完成清除（动态数组通过calloc申请的连续地址空间）</span></div><div class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) <span class="built_in">free</span>(entry-&gt;referrers);</div><div class="line">    </div><div class="line">    <span class="comment">// 将entry的整个存储空间清零</span></div><div class="line">    bzero(entry, <span class="keyword">sizeof</span>(*entry));</div><div class="line"></div><div class="line">    <span class="comment">// 整体weak表的num_entries计数 - 1</span></div><div class="line">    weak_table-&gt;num_entries--;</div><div class="line"></div><div class="line">    <span class="comment">// 检查缩小weak表的容量</span></div><div class="line">    weak_compact_maybe(weak_table);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，weak_compact_maybe函数会检查weak表中entry的存储占用率，根据实际情况释放相应空间。</p>
<blockquote>
<p>不仅如此，weak_grow_maybe函数也如此，会根据占用率动态扩大存储空间。其内部实现都是通过<em>weak_resize</em>函数实现的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TABLE_SIZE(entry) (entry-&gt;mask ? entry-&gt;mask + 1 : 0)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weak_resize</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, <span class="keyword">size_t</span> new_size)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> old_size = TABLE_SIZE(weak_table);</div><div class="line"></div><div class="line">    <span class="keyword">weak_entry_t</span> *old_entries = weak_table-&gt;weak_entries;</div><div class="line">    </div><div class="line">    <span class="comment">// 分配内存，new_size * sizeof(weak_entry_t) 个字节（new_size * 40）</span></div><div class="line">    <span class="keyword">weak_entry_t</span> *new_entries = (<span class="keyword">weak_entry_t</span> *)</div><div class="line">        <span class="built_in">calloc</span>(new_size, <span class="keyword">sizeof</span>(<span class="keyword">weak_entry_t</span>));</div><div class="line"></div><div class="line">    weak_table-&gt;mask = new_size - <span class="number">1</span>; <span class="comment">// 记录下尺寸</span></div><div class="line">    weak_table-&gt;weak_entries = new_entries; <span class="comment">// 数组起始地址</span></div><div class="line">    weak_table-&gt;max_hash_displacement = <span class="number">0</span>;</div><div class="line">    weak_table-&gt;num_entries = <span class="number">0</span>;  <span class="comment">// restored by weak_entry_insert below</span></div><div class="line">    </div><div class="line">    <span class="comment">// 将原始数据copy到新weak表中</span></div><div class="line">    <span class="keyword">if</span> (old_entries) &#123;</div><div class="line">        <span class="keyword">weak_entry_t</span> *entry;</div><div class="line">        <span class="keyword">weak_entry_t</span> *end = old_entries + old_size;</div><div class="line">        <span class="keyword">for</span> (entry = old_entries; entry &lt; end; entry++) &#123;</div><div class="line">            <span class="keyword">if</span> (entry-&gt;referent) &#123;</div><div class="line">                <span class="comment">// 将原始数据插入到weak表中</span></div><div class="line">                weak_entry_insert(weak_table, entry);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">free</span>(old_entries);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，我们就知道了，weak_table_t中的weak_entries成员实际上是weak_entry_t组成的数组（calloc创建的连续内存空间）。</p>
<h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><p>至此，我们基本了解了创建和释放一个weak弱指针对象所需要做的主要工作。也明白了weak指针在原对象释放后自动置为nil的实现方式。</p>
<p>此外，我们还了解了：</p>
<ol>
<li>苹果对于将hash值转化为数组索引index的转换方式及冲突后的索引偏移的操作。</li>
<li>对于weak_entry_t数据结构中，存储weak指针的两种方式（快速量少用静态数组，量大使用动态数组的可伸缩方式）的分段式存储思想。</li>
</ol>
<h4 id="7-参考资料："><a href="#7-参考资料：" class="headerlink" title="7. 参考资料："></a>7. 参考资料：</h4><ul>
<li><a href="https://www.jianshu.com/p/ed43b17c8a72" target="_blank" rel="external">读读objc源码(二)：weak类型指针的实现</a></li>
<li><a href="https://www.jianshu.com/p/ef6d9bf8fe59" target="_blank" rel="external">iOS管理对象内存的数据结构以及操作算法–SideTables、RefcountMap、weak_table_t-一</a></li>
<li><a href="https://blog.csdn.net/iJason92/article/details/72808387" target="_blank" rel="external">ObjC Runtime 中 Weak 属性的实现 (上)</a></li>
<li><a href="https://blog.csdn.net/iJason92/article/details/72863699" target="_blank" rel="external">ObjC Runtime 中 Weak 属性的实现 (中)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-weak对象的实现函数&quot;&gt;&lt;a href=&quot;#1-weak对象的实现函数&quot; class=&quot;headerlink&quot; title=&quot;1. weak对象的实现函数&quot;&gt;&lt;/a&gt;1. weak对象的实现函数&lt;/h4&gt;&lt;p&gt;首先，看个例子（&lt;em&gt;取自《Objective
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>GCD的串行队列同步死锁问题</title>
    <link href="http://yoursite.com/2019/08/08/GCD%E7%9A%84%E4%B8%B2%E8%A1%8C%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/08/08/GCD的串行队列同步死锁问题/</id>
    <published>2019-08-08T03:38:49.480Z</published>
    <updated>2019-08-08T03:38:49.480Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>《Effective Objective-C 2.0》中“第46条：<em>不要使用dispatch_get_current_queue</em>”笔记</p>
</blockquote>
<p>我们都知道，<strong>在串行队列的同步任务中，再次向其中派发同步任务会造成死锁</strong>（向主队列派发同步任务的死锁就是这样）。但是，如果是下面这样呢？</p>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queueA = dispatch_queue_create(<span class="string">"com.jiji.serialQueueA"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="built_in">dispatch_queue_t</span> queueB = dispatch_queue_create(<span class="string">"com.jiji.serialQueueB"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_sync</span>(queueA, ^&#123;</div><div class="line">    <span class="comment">// 向queueB中派发同步任务</span></div><div class="line">    <span class="built_in">dispatch_sync</span>(queueB, ^&#123;</div><div class="line">        <span class="comment">// 向queueA中派发同步任务</span></div><div class="line">        <span class="built_in">dispatch_sync</span>(queueA, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"inner----"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"outer-=-=-=-=-=-="</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>结果<strong>同样死锁</strong>。这是因为最内部派发到queueA中的任务需要按队列的方式，等待先入队的最外层任务执行完成，但最外层任务被最内部的任务阻塞无法继续执行，故导致死锁。这在道理上与最简单的死锁没有区别。</p>
<p>但是，当我们想要使用<em>dispatch_get_current_queue</em>函数，对内部执行队列进行区分，防止死锁时，可以发现此方法早已被标记为了<em>deprecated</em>。也就是说，此函数返回的队列不能作为任务执行队列的判断依据。</p>
<p>故数组建议我们<strong>使用<em>dispatch_queue_set_specific</em>函数，对队列绑定相关数据。在派发的任务执行时，动态取出绑定数据来判定当前的执行队列</strong>。</p>
<p>直接看对比示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将queueB的目标队列设置为queueA，即queueB中的任务被派发到queueA中执行</span></div><div class="line">dispatch_set_target_queue(queueB, queueA);</div><div class="line"></div><div class="line"><span class="comment">// 给指定队列绑定相关数据（使用键值对的方式）</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> kQueueSpecific;</div><div class="line"><span class="built_in">CFStringRef</span> queueSpecificValue = <span class="built_in">CFSTR</span>(<span class="string">"queueA"</span>);</div><div class="line">dispatch_queue_set_specific(queueA,</div><div class="line">                            &amp;kQueueSpecific,</div><div class="line">                            (<span class="keyword">void</span> *)queueSpecificValue,</div><div class="line">                            (dispatch_function_t)<span class="built_in">CFRelease</span>);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_sync</span>(queueB, ^&#123;</div><div class="line">    dispatch_block_t block = ^ &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"hahahahaha~~"</span>);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_queue_t</span> currentQueue = dispatch_get_current_queue();</div><div class="line">    <span class="keyword">if</span> (currentQueue == queueA) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"currentQueue == queueA"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"currentQueue == queueB"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 在当前队列中取出绑定的相关数据</span></div><div class="line">    <span class="built_in">CFStringRef</span> retrievedValue = dispatch_get_specific(&amp;kQueueSpecific);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (retrievedValue) &#123;</div><div class="line">        <span class="comment">// 存在相关值，即当前就在绑定的队列中执行，不要再向那个队列派发同步任务，会死锁</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"in queueA"</span>);</div><div class="line">        block();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 不存在，证明执行不在指定的那个队列中，可以派发同步任务</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NOT in queueA"</span>);</div><div class="line">        <span class="built_in">dispatch_sync</span>(queueA, block);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"finish!!!!"</span>);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<blockquote>
<p>LockTest[19151:825723] currentQueue == queueB<br>LockTest[19151:825723] in queueA<br>LockTest[19151:825723] hahahahaha~~<br>LockTest[19151:825723] finish!!!!</p>
</blockquote>
<p>可以看出，由于设置了目标队列，实际上是有queueA执行派发任务。但是<em>dispatch_get_current_queue</em>只能反映出原始派发任务的队列，而通过<em>dispatch_get_specific</em>函数取到的绑定数据却是根据真实执行任务的队列获取到。故<strong>在同步派发任务时，为了防止死锁，可以使用<em>dispatch_queue_set_specific</em>和<em>dispatch_get_specific</em>配对，来识别当前执行任务的队列</strong>。</p>
<p>这就是<strong>不要使用dispatch_get_current_queue</strong>的原因。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;《Effective Objective-C 2.0》中“第46条：&lt;em&gt;不要使用dispatch_get_current_queue&lt;/em&gt;”笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们都知道，&lt;strong&gt;在串行队列的同步任务中，再次向其中派发同步任务会造成死锁&lt;/strong&gt;（向主队列派发同步任务的死锁就是这样）。但是，如果是下面这样呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>相关对象（AssociateObject）实现学习</title>
    <link href="http://yoursite.com/2019/08/05/%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1%EF%BC%88AssociateObject%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/08/05/相关对象（AssociateObject）实现学习/</id>
    <published>2019-08-05T15:20:11.312Z</published>
    <updated>2019-08-05T15:20:11.312Z</updated>
    
    <content type="html"><![CDATA[<h4 id="源代码copy"><a href="#源代码copy" class="headerlink" title="源代码copy"></a>源代码copy</h4><p>不废话，直接附上实现的源代码：</p>
<blockquote>
<p>相关API声明在objc-runtime.mm中</p>
</blockquote>
<a id="more"></a>
<h5 id="1-设置相关对象的值"><a href="#1-设置相关对象的值" class="headerlink" title="1. 设置相关对象的值"></a>1. 设置相关对象的值</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 为类的实例对象设置相关对象 */</span></div><div class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy) &#123;</div><div class="line">    _object_set_associative_reference(object, (<span class="keyword">void</span> *)key, value, policy);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 实现</span></div><div class="line"><span class="keyword">void</span> _object_set_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, uintptr_t policy) &#123;</div><div class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></div><div class="line">    <span class="comment">// 初始化ObjcAssociation结构实例</span></div><div class="line">    ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>);</div><div class="line">    <span class="comment">// 对传入的新值value根据policy进行内存处理，并返回对象地址</span></div><div class="line">    <span class="keyword">id</span> new_value = value ? acquireValue(value, policy) : <span class="literal">nil</span>;</div><div class="line">    &#123;</div><div class="line">        AssociationsManager manager;</div><div class="line">        <span class="comment">// 获取全局相关对象hashmap的起始地址</span></div><div class="line">        AssociationsHashMap &amp;associations(manager.associations());</div><div class="line">        <span class="comment">// object地址转换为查询地址</span></div><div class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</div><div class="line">        <span class="keyword">if</span> (new_value) &#123;</div><div class="line">            <span class="comment">// break any existing association.</span></div><div class="line">            <span class="comment">// 查询全局哈希表中是否存在object的相关对象信息的容器</span></div><div class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;</div><div class="line">                <span class="comment">// secondary table exists</span></div><div class="line">                <span class="comment">// 存在object的相关对象信息容器（也是一张子哈希表）</span></div><div class="line">                </div><div class="line">                <span class="comment">// 获取字表的起始地址</span></div><div class="line">                ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">                </div><div class="line">                <span class="comment">// 查找是否存在key（即新加的属性）的相关信息</span></div><div class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</div><div class="line">                    <span class="comment">// 存在相同的相关信息（以前存储过了），直接修改</span></div><div class="line">                    </div><div class="line">                    <span class="comment">// 将以前的值缓存给old_assosiation</span></div><div class="line">                    old_association = j-&gt;second;</div><div class="line">                    </div><div class="line">                    <span class="comment">// 在原地址中存入新值（ObjcAssociation结构体实例，成员为policy和new_value）</span></div><div class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 在该object中没有此属性key的相关信息保存，创建新的，直接存储</span></div><div class="line">                    </div><div class="line">                    <span class="comment">// 在该地址下，存入键值对：键名为属性名key，值为ObjcAssociation结构体实例</span></div><div class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// create the new association (first time).</span></div><div class="line">                <span class="comment">// 全局哈希表中没有存储object的相关对象容器，创建新的容器（ObjectAssociationMap对象，也是个哈希表）</span></div><div class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</div><div class="line">                </div><div class="line">                <span class="comment">// 将新创建的容器指针存储到全局哈希表中，键名为object的地址</span></div><div class="line">                associations[disguised_object] = refs;</div><div class="line">                </div><div class="line">                <span class="comment">// 在容器中存入相关对象值（ObjcAssociation结构体实例），键名为属性名key</span></div><div class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class="line">                </div><div class="line">                <span class="comment">// 标记object为存在相关对象信息（修改isa联合体实例中的相关位的值）</span></div><div class="line">                object-&gt;setHasAssociatedObjects();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// setting the association to nil breaks the association.</span></div><div class="line">            <span class="comment">// 传入的相关值是nil，则清除该相关对象的信息（清除属性的值）</span></div><div class="line">            </div><div class="line">            <span class="comment">// 使用object地址再全局哈希表中查找，试图找到object的相关对象容器</span></div><div class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</div><div class="line">                <span class="comment">// 已找到此容器（子哈希表，ObjectAssociationMap对象）</span></div><div class="line">                ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">                </div><div class="line">                <span class="comment">// 查找此属性名key存储的信息</span></div><div class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">// 查找到相关对象信息，缓存给old_association</span></div><div class="line">                    old_association = j-&gt;second;</div><div class="line">                    </div><div class="line">                    <span class="comment">// 清除此ObjectAssociationMap对象（相关对象实例）</span></div><div class="line">                    refs-&gt;erase(j);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// release the old value (outside of the lock).</span></div><div class="line">    <span class="comment">// 缓存的old_association中存在值，释放内存，清除缓存</span></div><div class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出，<strong>所有的相关对象信息实际上是保存在全局的一个哈希表中</strong>。其中，<strong>以实例对象的地址（ <em>DISGUISE(object)</em> ）为键名，对应的值为另一张哈希表。此子哈希表中，以设置的属性名为键名，对应的值为相关值value和内存管理方式policy组成的结构体实例</strong>。</p>
<p>而保存相关对象的值的操作中，系统：</p>
<blockquote>
<ol>
<li>首先查看是否已经存储过此object对应的子哈希表，不存在则创建；</li>
<li>查看子哈希表中，是否已经存储过此属性名key对应的结构体信息，存在即修改为新值，不存在则创建新的保存；</li>
<li>对与传入的value为nil时，清除子哈希表中属性名key对应的结构体信息，以达到清除相关值的目的（<em>系统没有提供单独清空相关值属性的API</em> ）。</li>
<li>替换下来的相关值信息，抹掉并释放内存。</li>
</ol>
</blockquote>
<h5 id="2-获取相关对象的值"><a href="#2-获取相关对象的值" class="headerlink" title="2. 获取相关对象的值"></a>2. 获取相关对象的值</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 为类的实例对象获取相关对象的值 */</span></div><div class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key) &#123;</div><div class="line">    <span class="keyword">return</span> _object_get_associative_reference(object, (<span class="keyword">void</span> *)key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 实现</span></div><div class="line"><span class="keyword">id</span> _object_get_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key) &#123;</div><div class="line">    <span class="keyword">id</span> value = <span class="literal">nil</span>;</div><div class="line">    <span class="comment">// 声明内存管理方式指针变量（默认为assign）</span></div><div class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</div><div class="line">    </div><div class="line">    &#123;</div><div class="line">        AssociationsManager manager;</div><div class="line">        <span class="comment">// 获取全局相关对象哈希表（起始地址）【由于associations得到的是指向AssociationsHashMap的指针，故使用取地址符返回AssociationsHashMap的起始地址】</span></div><div class="line">        AssociationsHashMap &amp;associations(manager.associations());</div><div class="line">    </div><div class="line">        <span class="comment">// 将object地址转换为查询地址（保存地址）</span></div><div class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</div><div class="line">    </div><div class="line">        <span class="comment">// 视图查找到object对应的相关对象信息容器（AssociationsHashMap对象）</span></div><div class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</div><div class="line">            <span class="comment">// 已找到，获取入口地址（ObjectAssociationMap对象地址）</span></div><div class="line">            ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">            </div><div class="line">            <span class="comment">// 查找ObjectAssociationMap中，是否存在属性名key对应的相关信息实例</span></div><div class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</div><div class="line">                <span class="comment">// 已找到，记录入口地址（ObjcAssociation结构体实例的指针）</span></div><div class="line">                ObjcAssociation &amp;entry = j-&gt;second;</div><div class="line">                <span class="comment">// 取出对应的值和内存管理方式</span></div><div class="line">                value = entry.value();</div><div class="line">                policy = entry.policy();</div><div class="line">                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;</div><div class="line">                    <span class="comment">// 通过按位与运算，对需要retain的值，进行retain操作</span></div><div class="line">                    objc_retain(value);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</div><div class="line">        <span class="comment">// 存在相关值，且内存管理方式为autorelease，进行autorelease操作</span></div><div class="line">        objc_autorelease(value);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 返回相关值</span></div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-为实例对象清除所有的相关对象"><a href="#3-为实例对象清除所有的相关对象" class="headerlink" title="3. 为实例对象清除所有的相关对象"></a>3. 为实例对象清除所有的相关对象</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 清除类的实例对象的所有相关对象 */</span></div><div class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object) </div><div class="line">&#123;</div><div class="line">    <span class="comment">// 查看对象isa联合体中has_assoc位的值来确定是否存在相关对象</span></div><div class="line">    <span class="keyword">if</span> (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;</div><div class="line">        _object_remove_assocations(object);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 实现</span></div><div class="line"><span class="keyword">void</span> _object_remove_assocations(<span class="keyword">id</span> object) &#123;</div><div class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</div><div class="line">    </div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 获取全局相关对象的整体哈希表</span></div><div class="line">        AssociationsManager manager;</div><div class="line">        AssociationsHashMap &amp;associations(manager.associations());</div><div class="line">    </div><div class="line">        <span class="comment">// 本身没有存储任何信息，直接返回</span></div><div class="line">        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">        <span class="comment">// 将object指针转换为查询的指针</span></div><div class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</div><div class="line">        <span class="comment">// 试图查询是否存在object的相关对象容器信息</span></div><div class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</div><div class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></div><div class="line">            <span class="comment">// 已查到，获取入口地址</span></div><div class="line">            ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">            </div><div class="line">            <span class="comment">// 依次遍历子哈希表（ObjectAssociationMap对象的键值对信息）</span></div><div class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</div><div class="line">                <span class="comment">// 头插法插入到向量对象中</span></div><div class="line">                elements.push_back(j-&gt;second);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// remove the secondary table.</span></div><div class="line">            <span class="comment">// 删除入口地址信息</span></div><div class="line">            delete refs;</div><div class="line">            <span class="comment">// 清除子表（object容器中存储的所有信息，即ObjectAssociationMap对象）</span></div><div class="line">            associations.erase(i);</div><div class="line">            <span class="comment">// 清除之后，object便没有任何相关对象保存</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></div><div class="line">    <span class="comment">// 对向量中存储的所有相关对象信息，依次释放内存</span></div><div class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><h5 id="1-在Category中添加的property属性，系统为什么不会自动合成setter和getter？"><a href="#1-在Category中添加的property属性，系统为什么不会自动合成setter和getter？" class="headerlink" title="1. 在Category中添加的property属性，系统为什么不会自动合成setter和getter？"></a>1. 在Category中添加的property属性，系统为什么不会自动合成setter和getter？</h5><ol>
<li>在编译期，类的内存布局已经确定，在Class的结构中，并没有专门存储Category相关信息的位置。</li>
<li>Category是在APP启动时，在运行期才进行加载的，且是在对应的类加载完毕后才进行。最重要的，加载Category时，系统只是将内部声明的方法附加到Class的对应方法列表中，并不会对类的ivar列表进行操作。</li>
<li>最重要的，objc_category_t结构体中，根本没有变量成员，故自身也不能存储任何变量的值。</li>
</ol>
<h5 id="2-相关对象是针对类的还是实例对象的？"><a href="#2-相关对象是针对类的还是实例对象的？" class="headerlink" title="2. 相关对象是针对类的还是实例对象的？"></a>2. 相关对象是针对类的还是实例对象的？</h5><p>显而易见，由API的实现，可以看到，所有的相关对象是与object参数，即类的实例对象进行绑定关联，并存储到全局哈希表中的。故<strong>设置的相关对象只对当前的调用者对象有效</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;源代码copy&quot;&gt;&lt;a href=&quot;#源代码copy&quot; class=&quot;headerlink&quot; title=&quot;源代码copy&quot;&gt;&lt;/a&gt;源代码copy&lt;/h4&gt;&lt;p&gt;不废话，直接附上实现的源代码：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相关API声明在objc-runtime.mm中&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>union 联合体</title>
    <link href="http://yoursite.com/2019/08/02/union%20%E8%81%94%E5%90%88%E4%BD%93/"/>
    <id>http://yoursite.com/2019/08/02/union 联合体/</id>
    <published>2019-08-02T06:25:30.791Z</published>
    <updated>2019-08-02T06:25:49.841Z</updated>
    
    <content type="html"><![CDATA[<p>基本声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明联合体并创建testUnion实例</span></div><div class="line"><span class="keyword">union</span> U &#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">double</span> d;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line">    <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">9</span>];</div><div class="line">&#125; testUnion;</div></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>union是所有内部成员共用同一块内存，所有成员的内存地址相同，与union的起始地址相同。故修改任意成员，会导致其他成员的值都会变化（共享同一块内存）。<br>union的大小（sizeOf）需要可以装下最大尺寸的成员。且由于内存对齐，大小是所有成员尺寸的整数倍。</p>
</blockquote>
<p>故testUnion的大小为：<br>i = 4; d = 8; c = 1; array = 9 <em> 1;<br>sizeOf(testUnion) = 16; （最大是double成员的8字节，由于array总共9字节，故需要扩展为2倍，8 </em> 2 = 16字节）。</p>
<blockquote>
<p>union与struct的区别：</p>
<ol>
<li>struct的大小是所有成员尺寸之和，union是不小于最大成员尺寸。因此union内存使用更加灵活。</li>
<li>union同时只能保存一个成员的值，struct每个成员的值独立（有独立的内存地址）。</li>
</ol>
</blockquote>
<p>union可以用于数据类型转换（如union实例包含int和array，传入array可以得到int数据）。</p>
<hr>
<blockquote>
<p>相关资料：</p>
<ul>
<li><a href="https://www.jianshu.com/p/ac81470365ef" target="_blank" rel="external">union联合体与内存对齐</a></li>
<li><a href="https://www.jianshu.com/p/0355f83ff557" target="_blank" rel="external">内存对齐，大端字节 序小端字节序验证</a></li>
<li><a href="https://blog.csdn.net/microsues/article/details/6140329" target="_blank" rel="external">struct/class/union内存对齐原则</a></li>
<li><a href="https://www.jianshu.com/p/3366f8d7cb2b" target="_blank" rel="external">2018-08-27 C语言union 联合体 复习</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本声明：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 声明联合体并创建testUnion实例&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt; U &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; d;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; c;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; testUnion;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的锁 笔记</title>
    <link href="http://yoursite.com/2019/08/02/iOS%E4%B8%AD%E7%9A%84%E9%94%81%20%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/08/02/iOS中的锁 笔记/</id>
    <published>2019-08-02T03:17:16.608Z</published>
    <updated>2019-08-02T03:17:28.411Z</updated>
    
    <content type="html"><![CDATA[<p><strong><u>会阻塞线程的锁，都属于互斥锁</u></strong></p>
<a id="more"></a>
<h4 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h4><p>NSLock的<em>lock</em>方法和<em>lockBeforeDate:</em> 方法会阻塞线程；<em>tryLock</em>方法不会阻塞线程。<br>多个线程同时加锁时，其他请求锁的线程按照先进先出执行。</p>
<h4 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h4><p>NSConditionLock与NSLock行为相似，只不过可以设置条件（condition整数），可以设置为在满足condition时才进行<em>lockWithCondition:</em>、<em>unlockWithCondition:</em>、<em>tryLockWithCondition:</em> 等操作（当然也可以不设置条件）。</p>
<p>故<strong>可以使用NSConditionLock设置线程（任务）间的依赖关系，用GCD可以结合着使用进行实现</strong>。</p>
<h4 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a>NSRecursiveLock</h4><p>递归锁。可以在单个线程中返回加锁或解锁，其自身会记录加锁和解锁的次数，只有次数匹配时，才会真正的解锁，其他线程才可以加锁成功。</p>
<blockquote>
<p>NSLock、NSConditionLock和NSRecursiveLock是先轮询，之后再进入waiting状态。</p>
</blockquote>
<h4 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h4><p>NSCondition由 一个锁 + 条件检查器 组成。在每个线程中，都可以对condition对象单独进行<em>lock</em>和<em>unlock</em>，不影响其他线程再次加锁或解锁。</p>
<p>condition对象调用<em>wait</em>后，直接进入waiting状态，阻塞当前线程执行。等待其他线程对condition调用<em>signal</em> 或 <em>broadcast</em> 后，唤醒1个或所有的waiting线程，继续向下执行。</p>
<blockquote>
<p>以上四种锁都是遵循<em>NSLocking</em>协议。</p>
</blockquote>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h4><p>@synchronized同步锁会将指定的参数对象进行加锁。只有对相同对象进行加锁时，后加锁的线程才会被阻塞。否则无效。</p>
<h4 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h4><p>信号量是GCD进行同步的一种方式。<br>通过<em>dispatch_semaphore_create</em>创建信号量（指定信号值，即同时执行的任务数）。<em>dispatch_semaphore_wait</em>函数会对信号值进行检测：当信号值大于1时，信号值减1，继续向下执行任务，在信号值是1的信号量中，相当于加锁操作；当信号值为0时，调用线程被阻塞。只有当其他线程调用<em>dispatch_semaphpre_signal</em>进行信号恢复后（保证信号值重新大于0），被阻塞的线程继续向下执行。</p>
<blockquote>
<p>**dispatch_semaphore与NSCondition都是基于信号的锁，区别是信号量会保存发送的信号，NSCondition则不可以（只能signal）。</p>
</blockquote>
<h4 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h4><p>自旋锁现在已经不建议使用了，具体原因见上面（优先级反转造成死锁）。<br>苹果推荐使用<os lock.h="">中的<em>os_unfair_lock()</em> 锁替代。</os></p>
<blockquote>
<p>自旋锁与互斥锁都是抢占式，任何时候都只能有一个保持者。区别是：互斥锁中，调用者在别的运算单元抢占锁后进入睡眠，等待结束后被唤醒进行抢占；自旋锁，调用者在被运算单元抢占锁后不睡眠，循环查看自旋锁是否被释放。<br>故自旋锁适合保持锁时间较短的情况，这种情况下其效率远高于互斥锁。</p>
</blockquote>
<p>缺点：需要获取锁的线程优先级相同。如果低优先级的线程获得锁后，高优先级线程会处于busy-wait状态，占用大量CPU。而低优先级线程无法获取CPU时间，导致任务无法完成，也就无法释放锁。造成死锁（优先级反转）。</p>
<blockquote>
<p>参考资料：</p>
<ul>
<li><a href="https://www.jianshu.com/p/ddbe44064ca4" target="_blank" rel="external">iOS 常见知识点（三）：Lock</a></li>
<li><a href="https://www.jianshu.com/p/a321377c5639" target="_blank" rel="external">线程安全: 互斥锁和自旋锁(10种)</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;u&gt;会阻塞线程的锁，都属于互斥锁&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Aspects源码学习笔记</title>
    <link href="http://yoursite.com/2019/07/30/Aspects%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/07/30/Aspects源码学习笔记/</id>
    <published>2019-07-30T09:33:09.262Z</published>
    <updated>2019-08-02T03:16:17.202Z</updated>
    
    <content type="html"><![CDATA[<p>Aspects是一个可以动态hook指定方法的轻量级的库，AOP思想非常棒的体现。</p>
<a id="more"></a>
<h4 id="1-相关结构说明"><a href="#1-相关结构说明" class="headerlink" title="1. 相关结构说明"></a>1. 相关结构说明</h4><blockquote>
<p>Aspects.h</p>
</blockquote>
<h5 id="AspectOptions"><a href="#AspectOptions" class="headerlink" title="AspectOptions"></a>AspectOptions</h5><p>切片位置，用于指定hook后自定义block执行的时机。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>AspectPositionAfter</td>
<td>原始IMP执行之后执行</td>
</tr>
<tr>
<td>AspectPositionInstead</td>
<td>替换原始IMP</td>
</tr>
<tr>
<td>AspectPositionBefore</td>
<td>原始IMP执行之前执行</td>
</tr>
<tr>
<td>AspectOptionAutomaticRemoval</td>
<td>执行一次后直接移除</td>
</tr>
</tbody>
</table>
<h5 id="AspectToken协议"><a href="#AspectToken协议" class="headerlink" title="AspectToken协议"></a>AspectToken协议</h5><p>用于注销hook使用。使用其中的<em>remove</em>方法进行注销。</p>
<h5 id="AspectInfo协议"><a href="#AspectInfo协议" class="headerlink" title="AspectInfo协议"></a>AspectInfo协议</h5><p>作为插入的block的第一个参数出现。<br>对外公开为协议，内部则使用类实现。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>instance</td>
<td>被hook的实例对象</td>
</tr>
<tr>
<td>originalInvocation</td>
<td>原始的NSInvocation对象</td>
</tr>
<tr>
<td>arguments</td>
<td>原始参数数组</td>
</tr>
</tbody>
</table>
<h5 id="Aspects，NSObject的分类"><a href="#Aspects，NSObject的分类" class="headerlink" title="Aspects，NSObject的分类"></a>Aspects，NSObject的分类</h5><p>Aspects的公开API核心。<br>分为两个版本：实例方法版本和类方法版本。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</div><div class="line">                      withOptions:(AspectOptions)options</div><div class="line">                       usingBlock:(<span class="keyword">id</span>)block</div><div class="line">                            error:(<span class="built_in">NSError</span> **)error;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>调用者为类对象</strong>，对指定类的<em>selector</em>进行hook，执行时机为<em>options</em>，插入的执行任务为<em>block</em>。可以监控错误，返回值为遵循<em>AspectToken</em>的对象，用它可以实现注销hook操作。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</div><div class="line">                      withOptions:(AspectOptions)options</div><div class="line">                       usingBlock:(<span class="keyword">id</span>)block</div><div class="line">                            error:(<span class="built_in">NSError</span> **)error;</div></pre></td></tr></table></figure>
<blockquote>
<p>作用与类方法版本相同，但<strong>调用者为类的实例对象</strong>，即hook的方法只对本实例有效，其他实例无效。</p>
</blockquote>
<h5 id="AspectErrorCode"><a href="#AspectErrorCode" class="headerlink" title="AspectErrorCode"></a>AspectErrorCode</h5><p>错误信息说明。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>AspectErrorSelectorBlacklisted</td>
<td>黑名单（不允许hook的情况）</td>
</tr>
<tr>
<td>AspectErrorDoesNotRespondToSelector</td>
<td>找不到SEL的实现</td>
</tr>
<tr>
<td>AspectErrorSelectorDeallocPosition</td>
<td>hook到delloc方法的时机错误（只允许before情况）</td>
</tr>
<tr>
<td>AspectErrorSelectorAlreadyHookedInClassHierarchy</td>
<td>类继承体系中已经hook过该方法</td>
</tr>
<tr>
<td>AspectErrorFailedToAllocateClassPair</td>
<td>创建类失败（实例对象hook时可能发生）</td>
</tr>
<tr>
<td>AspectErrorMissingBlockSignature</td>
<td>block的签名错误（编译期签名无效，无法读取使用）</td>
</tr>
<tr>
<td>AspectErrorIncompatibleBlockSignature</td>
<td>block签名与原始方法签名不匹配</td>
</tr>
<tr>
<td>AspectErrorRemoveObjectAlreadyDeallocated</td>
<td>重复移除hook对象</td>
</tr>
</tbody>
</table>
<hr>
<blockquote>
<p>Aspect.m</p>
</blockquote>
<h5 id="AspectBlockFlags"><a href="#AspectBlockFlags" class="headerlink" title="AspectBlockFlags"></a>AspectBlockFlags</h5><p>切片block结构体中的位标识</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>AspectBlockFlagsHasCopyDisposeHelpers</td>
<td>标识copy函数位（第25位）</td>
</tr>
<tr>
<td>AspectBlockFlagsHasSignature</td>
<td>标识签名位（第30位）</td>
</tr>
</tbody>
</table>
<h5 id="AspectBlockRef"><a href="#AspectBlockRef" class="headerlink" title="AspectBlockRef"></a>AspectBlockRef</h5><p>_AspectBlock结构体指针，结构与block结构体相似。</p>
<h5 id="AspectInfo"><a href="#AspectInfo" class="headerlink" title="AspectInfo"></a>AspectInfo</h5><p><strong>主要用于包装NSInvocation对象</strong>。</p>
<p>遵循了<em>AspectInfo</em>协议，作为内部实现（外部只公开为协议，隐藏真正的类）。</p>
<p>将协议方法实现为三个只读属性，使用指定方法进行初始化：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithInstance:(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>)instance invocation:(<span class="built_in">NSInvocation</span> *)invocation;</div></pre></td></tr></table></figure>
<h5 id="AspectIdentifier"><a href="#AspectIdentifier" class="headerlink" title="AspectIdentifier"></a>AspectIdentifier</h5><p><strong>保存切片的相关信息（如receiver、selector、block和error信息）</strong>。作为数据模型类。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 初始化方法，传入配置信息</span></div><div class="line">+ (<span class="keyword">instancetype</span>)identifierWithSelector:(SEL)selector object:(<span class="keyword">id</span>)object options:(AspectOptions)options block:(<span class="keyword">id</span>)block error:(<span class="built_in">NSError</span> **)error;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用AspectInfo对象（NSInvocation封装类）执行方法，执行block任务</span></div><div class="line">- (<span class="built_in">BOOL</span>)invokeWithInfo:(<span class="keyword">id</span>&lt;AspectInfo&gt;)info;</div></pre></td></tr></table></figure>
<h5 id="AspectsContainer"><a href="#AspectsContainer" class="headerlink" title="AspectsContainer"></a>AspectsContainer</h5><p><strong>作为AspectIdentifier的容器，负责管理内部的AspectIdentifier对象</strong>。提供添加、删除、检查等功能。<br>根据options将AspectIdentifier对象分别存储在不同的类别数组中。</p>
<p>在Aspects中，根据调用者（实例对象或类对象）实现了两个container。</p>
<h5 id="AspectTracker"><a href="#AspectTracker" class="headerlink" title="AspectTracker"></a>AspectTracker</h5><p>切片追踪者，<strong>保存着追踪的相关信息</strong>，方便查询。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>trackedClass</td>
<td>追踪的类</td>
</tr>
<tr>
<td>selectorNames</td>
<td>集合，保存着追踪的选择器名</td>
</tr>
<tr>
<td>parentEntry</td>
<td>自身实例的指针，根据类继承体系指向子类对象</td>
</tr>
</tbody>
</table>
<h5 id="NSInvocation-Aspects"><a href="#NSInvocation-Aspects" class="headerlink" title="NSInvocation + Aspects"></a>NSInvocation + Aspects</h5><p>NSInvocation的分类，提供了方法：直接返回切片的所有参数。</p>
<hr>
<h4 id="2-实现源代码学习"><a href="#2-实现源代码学习" class="headerlink" title="2. 实现源代码学习"></a>2. 实现源代码学习</h4><h5 id="Aspects是线程安全的"><a href="#Aspects是线程安全的" class="headerlink" title="Aspects是线程安全的"></a><u>Aspects是线程安全的</u></h5><p>可以在三个方面验证此结论：</p>
<h6 id="1-使用自旋锁进行整体hook"><a href="#1-使用自旋锁进行整体hook" class="headerlink" title="1. 使用自旋锁进行整体hook"></a>1. 使用自旋锁进行整体hook</h6><p>我们知道，在公共API中，实现都是通过调用c函数<em>aspect_add</em>来完成的，而其中的执行环境是通过锁机制来保证线程安全的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_performLocked(dispatch_block_t block) &#123;</div><div class="line">    <span class="comment">// 创建自旋锁</span></div><div class="line">    <span class="keyword">static</span> OSSpinLock aspect_lock = OS_SPINLOCK_INIT;</div><div class="line">    OSSpinLockLock(&amp;aspect_lock);</div><div class="line">    block();</div><div class="line">    OSSpinLockUnlock(&amp;aspect_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用自旋锁可以保证同时只执行一个运算任务，且其他运算单元不会因锁被他人保持而进入睡眠状态。自旋锁适合运算量不大的任务。在这种情况下，其效率要明显高于同步锁 <em>@synchronized</em>。</p>
<h6 id="2-AspectContainer中使用原子性数组"><a href="#2-AspectContainer中使用原子性数组" class="headerlink" title="2. AspectContainer中使用原子性数组"></a>2. AspectContainer中使用原子性数组</h6><p>在类AspectContainer中，保存AspectIdentifier实例的数组属性（<em>beforeAspects</em>、<em>insteadAspects</em>、<em>afterAspects</em>）的特性为atomic，保证在多线程环境下，访问该容器是安全的。</p>
<h6 id="3-使用dispatch-once来保证共享数据只有一份"><a href="#3-使用dispatch-once来保证共享数据只有一份" class="headerlink" title="3. 使用dispatch_once来保证共享数据只有一份"></a>3. 使用<em>dispatch_once</em>来保证共享数据只有一份</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 获取修改的类的集合（线程安全） */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _aspect_modifySwizzledClasses(<span class="keyword">void</span> (^block)(<span class="built_in">NSMutableSet</span> *swizzledClasses)) &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSMutableSet</span> *swizzledClasses;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</div><div class="line">        swizzledClasses = [<span class="built_in">NSMutableSet</span> new];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">@synchronized</span>(swizzledClasses) &#123;</div><div class="line">        block(swizzledClasses);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用<em>dispatch_once</em>保证集合创建为线程安全且只有一份。同时，执行block时也通过同步锁保证线程安全。</p>
<h5 id="Aspects的hook方法不可高频次调用"><a href="#Aspects的hook方法不可高频次调用" class="headerlink" title="Aspects的hook方法不可高频次调用"></a><u>Aspects的hook方法不可高频次调用</u></h5><p>作者说，hook的方法一般只可以是view或ViewController等方法，调用频次不要超过每秒1000次。<strong>这是由于Aspects的hook方法调用实际是在方法转发流程中进行的</strong>。</p>
<p>Aspects中所有的真正方法调用都是通过NSInvocation对象进行的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)invoke;</div><div class="line">- (<span class="keyword">void</span>)invokeWithTarget:(<span class="keyword">id</span>)target;</div></pre></td></tr></table></figure>
<p>我们知道，完整的消息转发流程是在方法调用的最后一步才进行，苹果明确说明这是比较耗费性能的（需要通过获取方法签名NSMethodSignature对象，封装生成NSInvocation对象，然后在forwardInvocation:方法中执行invoke方法）。故作者添加了此说明。</p>
<h5 id="Aspects对实例hook方法和类hook方法使用不同实现方案"><a href="#Aspects对实例hook方法和类hook方法使用不同实现方案" class="headerlink" title="Aspects对实例hook方法和类hook方法使用不同实现方案"></a><u>Aspects对实例hook方法和类hook方法使用不同实现方案</u></h5><blockquote>
<p>对于类的实例来说，使用Aspects对某方法进行hook只是对本实例有效；<br>而对于类对象来说，对某方法进行hook，即对本类的所有实例都有效。</p>
</blockquote>
<p>我们在<em>aspect_hookClass</em>的实现中，可以一探究竟</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Class aspect_hookClass(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</div><div class="line">	Class statedClass = <span class="keyword">self</span>.class; <span class="comment">// 得到self所属的类（实例返回class，类对象返回自身）</span></div><div class="line">	Class baseClass = object_getClass(<span class="keyword">self</span>); <span class="comment">// 获取self的class（获取isa：实例返回class对象，类对象返回metaClass）</span></div><div class="line">	<span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(baseClass);</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们看一下，对于<em>class</em>方法和<em>objc_getClass</em>函数的区别：</p>
<blockquote>
<p><u><em>class方法</em></u>： 对于类，返回自身；对于实例对象，返回所属Class<br><u><em>objc_getClass函数</em></u>： 其实现都是返回调用者的isa。也就是说，对于实例对象，得到的是所属Class；对于类，得到的是metaClass。</p>
</blockquote>
<h6 id="1-类实例hook的实现"><a href="#1-类实例hook的实现" class="headerlink" title="1. 类实例hook的实现"></a>1. 类实例hook的实现</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Class aspect_hookClass(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">// Already subclassed</span></div><div class="line">	<span class="keyword">if</span> ([className hasSuffix:AspectsSubclassSuffix]) &#123;</div><div class="line">		<span class="keyword">return</span> baseClass; <span class="comment">// 包含后缀，即hook过，直接返回class</span></div><div class="line">	&#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// self是类的实例对象，正常情况</span></div><div class="line">    <span class="comment">// 动态创建一个类（添加后缀作为类名）</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;</div><div class="line">    </div><div class="line">    <span class="comment">// 懒加载方式创建</span></div><div class="line">	Class subclass = objc_getClass(subclassName);</div><div class="line">	<span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="comment">// 新类作为原类的子类</span></div><div class="line">		subclass = objc_allocateClassPair(baseClass, subclassName, <span class="number">0</span>);</div><div class="line">		<span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="built_in">NSString</span> *errrorDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"objc_allocateClassPair failed to allocate class %s."</span>, subclassName];</div><div class="line">            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">		aspect_swizzleForwardInvocation(subclass); <span class="comment">// 给这个新类交换forwardInvocation方法</span></div><div class="line">		aspect_hookedGetClass(subclass, statedClass); <span class="comment">// 新类的class方法，返回的是原class（瞒天过海，自己的类名还是原来的类）</span></div><div class="line">		aspect_hookedGetClass(object_getClass(subclass), statedClass); <span class="comment">// metaClass的class也指向原来的类</span></div><div class="line">        <span class="comment">// 注册此类</span></div><div class="line">		objc_registerClassPair(subclass);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将self实例设置为此动态子类的实例</span></div><div class="line">	object_setClass(<span class="keyword">self</span>, subclass);</div><div class="line">	<span class="keyword">return</span> subclass;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里我们可以看到，对于实例hook，Aspects使用动态类的方式进行实现：<strong>创建一个继承于原类的子类，对该子类的NSInvocation进行hook，然后通过<em>object_setClass</em>将调用者的类指定为新子类</strong>。</p>
<p>下面我们依次查看方法实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> AspectsForwardInvocationSelectorName = <span class="string">@"__aspects_forwardInvocation:"</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_swizzleForwardInvocation(Class klass) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(klass);</div><div class="line">    <span class="comment">// 替换原始类的forwardInvocation方法IMP（kclass没实现则自动添加），返回值是原IMP</span></div><div class="line">    IMP originalImplementation = class_replaceMethod(klass, <span class="keyword">@selector</span>(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, <span class="string">"v@:@"</span>);</div><div class="line">    <span class="keyword">if</span> (originalImplementation) &#123;</div><div class="line">        <span class="comment">// 存在原IMP（即klass自己实现了forwardInvocation方法），则新SEL(hook版本的forwardInvocation)的IMP为原始IMP（即存储了原IMP）</span></div><div class="line">        class_addMethod(klass, <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName), originalImplementation, <span class="string">"v@:@"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 完成了klass</span></div><div class="line">    AspectLog(<span class="string">@"Aspects: %@ is now aspect aware."</span>, <span class="built_in">NSStringFromClass</span>(klass));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<em>class_replaceMethod</em>，替换了klass的<em>fowardInvocation:</em> 方法实现（替换IMP为 <em><strong>ASPECTS_ARE_BEING_CALLED</strong></em>），klass没有实现此方法，则直接将此方法及实现添加到类中。<br>当klass实现了原方法，则Aspects将原IMP保存到klass的<em>AspectsForwardInvocationSelectorName</em>方法中，相当于完成了<em>forwardInvocation:</em> 的方法交换。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_hookedGetClass(Class <span class="keyword">class</span>, Class statedClass) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">class</span>);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(statedClass);</div><div class="line">	Method method = class_getInstanceMethod(<span class="keyword">class</span>, <span class="keyword">@selector</span>(<span class="keyword">class</span>));</div><div class="line">	IMP newIMP = imp_implementationWithBlock(^(<span class="keyword">id</span> <span class="keyword">self</span>) &#123;</div><div class="line">		<span class="keyword">return</span> statedClass;</div><div class="line">	&#125;);</div><div class="line">    <span class="comment">// 将class的class实例方法的IMP替换为IMP的block实现（返回的是statedClass）</span></div><div class="line">	class_replaceMethod(<span class="keyword">class</span>, <span class="keyword">@selector</span>(<span class="keyword">class</span>), newIMP, method_getTypeEncoding(method));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理，此方法是将Class的<em>class</em>实例方法IMP进行替换，改为了statedClass。在调用时，即将新子类的Class及MetaClass均指向原类。这样原实例则根本不知道自己的实例已经被“偷梁换柱”了。</p>
<h6 id="2-类对象hook的实现"><a href="#2-类对象hook的实现" class="headerlink" title="2. 类对象hook的实现"></a>2. 类对象hook的实现</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Class aspect_hookClass(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (class_isMetaClass(baseClass)) &#123;</div><div class="line">        <span class="comment">// 是metaClass，即self是class。需要swizzle这个class对象（Class）</span></div><div class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace((Class)<span class="keyword">self</span>);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (statedClass != baseClass) &#123;</div><div class="line">        <span class="comment">// statedClass与baseClass不同，即self也是class，若self是一个KVO的类，也需要swizzle这个class对象（metaClass：baseClass即KVO之前的原始类，防止KVO使用完毕后，Class释放导致hook失效）</span></div><div class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace(baseClass);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>class_isMetaClass</em>判断当前类是否为metaClass，通过这种情况，可以判定调用Aspects的hook方法的是类对象。所以调用者的目的是将所有的类实例的指定方法都进行hook。故Aspects直接对该类进行操作。</p>
<blockquote>
<p><strong>注意</strong>：<br>由于KVO也是通过创建动态类的方式实现（创建子类后修改isa指向），故hook的应当是KVO之前的原始类。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Class aspect_swizzleClassInPlace(Class klass) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(klass);</div><div class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(klass);</div><div class="line"></div><div class="line">    _aspect_modifySwizzledClasses(^(<span class="built_in">NSMutableSet</span> *swizzledClasses) &#123;</div><div class="line">        <span class="comment">// 在线程安全的情况下，将class加入到修改的类列表中</span></div><div class="line">        <span class="keyword">if</span> (![swizzledClasses containsObject:className]) &#123;</div><div class="line">            <span class="comment">// 交换forwardInvocation方法</span></div><div class="line">            aspect_swizzleForwardInvocation(klass);</div><div class="line">            [swizzledClasses addObject:className];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> klass;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里直接对klass的<em>forwardInvocation:</em> 方法进行了替换，只不过需要在线程安全的前提下进行，且swizzledClasses是全局共享的。</p>
<h5 id="Aspects对指定selector的替换过程"><a href="#Aspects对指定selector的替换过程" class="headerlink" title="Aspects对指定selector的替换过程"></a><u>Aspects对指定selector的替换过程</u></h5><p>对于selector的处理过程，实例对象和类对象的处理方法是一致的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_prepareClassAndHookSelector(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</div><div class="line">    Class klass = aspect_hookClass(<span class="keyword">self</span>, error); <span class="comment">// 已经hook过forwardInvocation方法的类</span></div><div class="line">    </div><div class="line">    <span class="comment">// 准备检查hook对应的SEL</span></div><div class="line">    Method targetMethod = class_getInstanceMethod(klass, selector); <span class="comment">// 取出待hook的method</span></div><div class="line">    IMP targetMethodIMP = method_getImplementation(targetMethod);</div><div class="line">    <span class="comment">// 查看SEL的IMP是否是已替换的</span></div><div class="line">    <span class="keyword">if</span> (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;</div><div class="line">        <span class="comment">// 创建Hook版本的SEL名称及类型编码</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *typeEncoding = method_getTypeEncoding(targetMethod);</div><div class="line">        SEL aliasSelector = aspect_aliasForSelector(selector);</div><div class="line">        <span class="keyword">if</span> (![klass instancesRespondToSelector:aliasSelector]) &#123;</div><div class="line">            <span class="comment">// 类没有实现此hook的方法，则添加上（使用原始IMP）</span></div><div class="line">            __unused <span class="built_in">BOOL</span> addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);</div><div class="line">            <span class="built_in">NSCAssert</span>(addedAlias, <span class="string">@"Original implementation for %@ is already copied to %@ on %@"</span>, <span class="built_in">NSStringFromSelector</span>(selector), <span class="built_in">NSStringFromSelector</span>(aliasSelector), klass);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 给原SEL的实现修改为objc_msgForward函数</span></div><div class="line">        <span class="comment">// We use forwardInvocation to hook in.</span></div><div class="line">        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(<span class="keyword">self</span>, selector), typeEncoding);</div><div class="line">        AspectLog(<span class="string">@"Aspects: Installed hook for -[%@ %@]."</span>, klass, <span class="built_in">NSStringFromSelector</span>(selector));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于原始方法，Aspects将其实现IMP保存至aliasSelector中，而原始方法则直接指向 <em>_objc_msgForward</em>函数。</p>
<blockquote>
<p><em>_objc_msgForward</em> 是方法调用过程中的一步，在objc_msgSend流程中，当方法未找到IMP时，且未能动态添加方法IMP，<em>_objc_msgForward</em>则开始执行。也就是说 <em>_objc_msgForward</em>是消息转发的起点。</p>
</blockquote>
<p>交换成功后，调用者执行原方法时，则会直接进入消息转发阶段。</p>
<h5 id="Aspects对待hook的selector进行检测，符合要求才允许进行"><a href="#Aspects对待hook的selector进行检测，符合要求才允许进行" class="headerlink" title="Aspects对待hook的selector进行检测，符合要求才允许进行"></a><u>Aspects对待hook的selector进行检测，符合要求才允许进行</u></h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> aspect_isSelectorAllowedAndTrack(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSSet</span> *disallowedSelectorList;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</div><div class="line">        disallowedSelectorList = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"retain"</span>, <span class="string">@"release"</span>, <span class="string">@"autorelease"</span>, <span class="string">@"forwardInvocation:"</span>, <span class="literal">nil</span>];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// 黑名单不能被hook</span></div><div class="line">    <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(selector);</div><div class="line">    <span class="keyword">if</span> ([disallowedSelectorList containsObject:selectorName]) &#123;</div><div class="line">        <span class="built_in">NSString</span> *errorDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Selector %@ is blacklisted."</span>, selectorName];</div><div class="line">        AspectError(AspectErrorSelectorBlacklisted, errorDescription);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// dealloc 只能在before时hook</span></div><div class="line">    AspectOptions position = options&amp;AspectPositionFilter;</div><div class="line">    <span class="keyword">if</span> ([selectorName isEqualToString:<span class="string">@"dealloc"</span>] &amp;&amp; position != AspectPositionBefore) &#123;</div><div class="line">        <span class="built_in">NSString</span> *errorDesc = <span class="string">@"AspectPositionBefore is the only valid position when hooking dealloc."</span>;</div><div class="line">        AspectError(AspectErrorSelectorDeallocPosition, errorDesc);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 没有原始实现也不行</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> respondsToSelector:selector] &amp;&amp; ![<span class="keyword">self</span>.class instancesRespondToSelector:selector]) &#123;</div><div class="line">        <span class="built_in">NSString</span> *errorDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Unable to find selector -[%@ %@]."</span>, <span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>.class), selectorName];</div><div class="line">        AspectError(AspectErrorDoesNotRespondToSelector, errorDesc);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 类对象处理</span></div><div class="line">    <span class="keyword">if</span> (class_isMetaClass(object_getClass(<span class="keyword">self</span>))) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 实例对象，直接允许</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于实例对象，只要待hook的selector符合上述要求，即可准备进行hook。<br>而对于类而言，由于类存在继承体系，需要对hook的唯一性进行检测：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> aspect_isSelectorAllowedAndTrack(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// 类对象</span></div><div class="line">    <span class="keyword">if</span> (class_isMetaClass(object_getClass(<span class="keyword">self</span>))) &#123;</div><div class="line">        Class klass = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">        <span class="comment">// 获取交换class的字典</span></div><div class="line">        <span class="built_in">NSMutableDictionary</span> *swizzledClassesDict = aspect_getSwizzledClassesDict();</div><div class="line">        Class currentClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="comment">// 获取当前类的追踪者对象</span></div><div class="line">            AspectTracker *tracker = swizzledClassesDict[currentClass];</div><div class="line">            <span class="comment">// 查看追踪者的SEL列表中是否存在当前SEL</span></div><div class="line">            <span class="keyword">if</span> ([tracker.selectorNames containsObject:selectorName]) &#123;</div><div class="line">                </div><div class="line">                <span class="comment">// 已经追踪过当前SEL，查看追踪者的子类追踪者中，是否追踪过当前SEL</span></div><div class="line">                <span class="comment">// Find the topmost class for the log.</span></div><div class="line">                <span class="keyword">if</span> (tracker.parentEntry) &#123;</div><div class="line">                    <span class="comment">// 追踪过当前SEL，报错（即父类要hook的SEL在子类中已经hook过了）</span></div><div class="line">                    AspectTracker *topmostEntry = tracker.parentEntry;</div><div class="line">                    <span class="keyword">while</span> (topmostEntry.parentEntry) &#123;</div><div class="line">                        topmostEntry = topmostEntry.parentEntry;</div><div class="line">                    &#125;</div><div class="line">                    <span class="built_in">NSString</span> *errorDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Error: %@ already hooked in %@. A method can only be hooked once per class hierarchy."</span>, selectorName, <span class="built_in">NSStringFromClass</span>(topmostEntry.trackedClass)];</div><div class="line">                    AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription);</div><div class="line">                    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (klass == currentClass) &#123;</div><div class="line">                    <span class="comment">// 只是自己的类追踪过，才可以</span></div><div class="line">                    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">while</span> ((currentClass = class_getSuperclass(currentClass)));</div><div class="line"></div><div class="line">        <span class="comment">// 没有追踪过该类，则只设置从当前类开始hook</span></div><div class="line">        currentClass = klass;</div><div class="line">        AspectTracker *parentTracker = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="comment">// 只要子类hook该SEL，就将所有的父类也标识上（即从根类到当前类这个继承链都标记了hook当前SEL）</span></div><div class="line">            <span class="comment">// 懒加载追踪者对象，将SEL加入到追踪SEL列表中进行标记</span></div><div class="line">            AspectTracker *tracker = swizzledClassesDict[currentClass];</div><div class="line">            <span class="keyword">if</span> (!tracker) &#123;</div><div class="line">                tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass parent:parentTracker];</div><div class="line">                swizzledClassesDict[(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)currentClass] = tracker;</div><div class="line">            &#125;</div><div class="line">            [tracker.selectorNames addObject:selectorName];</div><div class="line">            parentTracker = tracker;</div><div class="line">        &#125;<span class="keyword">while</span> ((currentClass = class_getSuperclass(currentClass)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于类对象来说，当类的指定selector准备hook之前，先要检测其继承体系中是否已经hook过此selector。<br>其方法是：<br>通过AspectTracker对象，对其内部的selectorNames数组进行检测，依照parentEntry向下依次查找（parentEntry存储的是子类对象），<br>如果存在parentEntry的selectorNames已经包含selector，且该parentEntry类不是当前类，则证明selector已经在继承体系中（确切地说是子类中）已经hook过，不可以重复hook。</p>
<h5 id="AspectIdentifier，切面信息的生成"><a href="#AspectIdentifier，切面信息的生成" class="headerlink" title="AspectIdentifier，切面信息的生成"></a><u>AspectIdentifier，切面信息的生成</u></h5><p>我们回到最初，在aspect_add方法中可以看到，切面信息AspectIdentifier对象，是在开始hook操作之前，便生成添加到AspectsContainer容器中的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">id</span> aspect_add(<span class="keyword">id</span> <span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="keyword">id</span> block, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(block);</div><div class="line"></div><div class="line">    __block AspectIdentifier *identifier = <span class="literal">nil</span>;</div><div class="line">    <span class="comment">// 自旋锁的方式进行（安全）</span></div><div class="line">    aspect_performLocked(^&#123;</div><div class="line">        <span class="comment">// SEL是否允许hook</span></div><div class="line">        <span class="keyword">if</span> (aspect_isSelectorAllowedAndTrack(<span class="keyword">self</span>, selector, options, error)) &#123;</div><div class="line">            <span class="comment">// 获取容器对象</span></div><div class="line">            AspectsContainer *aspectContainer = aspect_getContainerForObject(<span class="keyword">self</span>, selector);</div><div class="line">            <span class="comment">// 生成得到AspectIdentifier对象</span></div><div class="line">            identifier = [AspectIdentifier identifierWithSelector:selector object:<span class="keyword">self</span> options:options block:block error:error];</div><div class="line">            <span class="keyword">if</span> (identifier) &#123;</div><div class="line">                <span class="comment">// 存在，即加入到容器中</span></div><div class="line">                [aspectContainer addAspect:identifier withOptions:options];</div><div class="line"></div><div class="line">                <span class="comment">// 将self所属的class配置为，运行hook的版本</span></div><div class="line">                <span class="comment">// （实例为创建动态类，交换消息转发实现；类为直接修改该lmetaClass，交换消息转发实现）</span></div><div class="line">                <span class="comment">// Modify the class to allow message interception.</span></div><div class="line">                aspect_prepareClassAndHookSelector(<span class="keyword">self</span>, selector, error);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> identifier;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，我们看一下如何得到保存AspectIdentifier对象的容器对象AspectContainer：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取SEL对应self所在的容器对象（内部加入的是带有前缀的SEL）</span></div><div class="line"><span class="keyword">static</span> AspectsContainer *aspect_getContainerForObject(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</div><div class="line">    <span class="comment">// 获取别名SEL（用于hook原SEL）</span></div><div class="line">    SEL aliasSelector = aspect_aliasForSelector(selector);</div><div class="line">    <span class="comment">// 获取self存储的切片容器对象【注意：由于self可以为实例对象或类对象，故NSObject中包含了两种AspectContainer属性：一个保存hook的实例方法identifier，一个保存hook的类方法identifier】</span></div><div class="line">    AspectsContainer *aspectContainer = objc_getAssociatedObject(<span class="keyword">self</span>, aliasSelector);</div><div class="line">    <span class="keyword">if</span> (!aspectContainer) &#123;</div><div class="line">        aspectContainer = [AspectsContainer new];</div><div class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, aliasSelector, aspectContainer, OBJC_ASSOCIATION_RETAIN);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> aspectContainer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码可以看出，AspectsContainer对象是通过关联对象的方式存储到<em>NSObject+Aspects</em>分类中的，其属性名称是使用hook版本的selector名称动态确定的。即每当我们hook一个selector后，NSObject类中即增加了一个名为“aspects_xxx”的属性，其类型为AspectsContainer。 对于加入其内部的AspectIdentifier对象，则根据options保存到不同的内部数组中。</p>
<p>对于AspectIdentifier的生成过程，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 根据信息生成切面识别对象 */</span></div><div class="line">+ (<span class="keyword">instancetype</span>)identifierWithSelector:(SEL)selector object:(<span class="keyword">id</span>)object options:(AspectOptions)options block:(<span class="keyword">id</span>)block error:(<span class="built_in">NSError</span> **)error &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(block);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</div><div class="line">    <span class="comment">// 获取block的签名对象</span></div><div class="line">    <span class="built_in">NSMethodSignature</span> *blockSignature = aspect_blockMethodSignature(block, error);</div><div class="line">    <span class="comment">// 检查得到的签名对象是否符合要求</span></div><div class="line">    <span class="keyword">if</span> (!aspect_isCompatibleBlockSignature(blockSignature, object, selector, error)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 使用block签名的对象信息创建AspectIdentifier对象</span></div><div class="line">    AspectIdentifier *identifier = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> (blockSignature) &#123;</div><div class="line">        identifier = [AspectIdentifier new];</div><div class="line">        identifier.selector = selector;</div><div class="line">        identifier.block = block;</div><div class="line">        identifier.blockSignature = blockSignature;</div><div class="line">        identifier.options = options;</div><div class="line">        identifier.object = object; <span class="comment">// weak</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> identifier;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即只有当block对象包含完整的签名时，才可以生成AspectIdentifier对象。<br>结合<em>AspectBlockRef</em>的结构数据，其生成过程如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Block内部定义的flag值.</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="keyword">int</span>, AspectBlockFlags) &#123;</div><div class="line">	AspectBlockFlagsHasCopyDisposeHelpers = (<span class="number">1</span> &lt;&lt; <span class="number">25</span>),</div><div class="line">	AspectBlockFlagsHasSignature          = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// AspectBlockRef数据结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _AspectBlock &#123;</div><div class="line">	__unused Class isa;</div><div class="line">	AspectBlockFlags flags;</div><div class="line">	__unused <span class="keyword">int</span> reserved;</div><div class="line">	<span class="keyword">void</span> (__unused *invoke)(<span class="keyword">struct</span> _AspectBlock *block, ...);</div><div class="line">	<span class="keyword">struct</span> &#123;</div><div class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</div><div class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</div><div class="line">		<span class="comment">// requires AspectBlockFlagsHasCopyDisposeHelpers</span></div><div class="line">		<span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src);</div><div class="line">		<span class="keyword">void</span> (*dispose)(<span class="keyword">const</span> <span class="keyword">void</span> *);</div><div class="line">		<span class="comment">// requires AspectBlockFlagsHasSignature</span></div><div class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *signature;</div><div class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *layout;</div><div class="line">	&#125; *descriptor;</div><div class="line">	<span class="comment">// imported variables</span></div><div class="line">&#125; *AspectBlockRef;</div><div class="line"></div><div class="line"><span class="comment">// 获取方法签名对象</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSMethodSignature</span> *aspect_blockMethodSignature(<span class="keyword">id</span> block, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    <span class="comment">// 转换为AspectBlockRef类型</span></div><div class="line">    AspectBlockRef layout = (__bridge <span class="keyword">void</span> *)block;</div><div class="line">    </div><div class="line">    <span class="comment">// flags的值不是AspectBlockFlagsHasSignature，直接报错</span></div><div class="line">	<span class="keyword">if</span> (!(layout-&gt;flags &amp; AspectBlockFlagsHasSignature)) &#123;</div><div class="line">        <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"The block %@ doesn't contain a type signature."</span>, block];</div><div class="line">        AspectError(AspectErrorMissingBlockSignature, description);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 在descriptor结构数据中</span></div><div class="line">	<span class="keyword">void</span> *desc = layout-&gt;descriptor;</div><div class="line">    </div><div class="line">    <span class="comment">// 跳过reserved和size</span></div><div class="line">	desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>);</div><div class="line">    <span class="comment">// 存在copy和dispose指针，跳过</span></div><div class="line">	<span class="keyword">if</span> (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) &#123;</div><div class="line">		desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 此时desc直接指向signature，没有值则认为没有签名</span></div><div class="line">	<span class="keyword">if</span> (!desc) &#123;</div><div class="line">        <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"The block %@ doesn't has a type signature."</span>, block];</div><div class="line">        AspectError(AspectErrorMissingBlockSignature, description);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 取出signature的值，转换生成NSMethodSignature对象</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *signature = (*(<span class="keyword">const</span> <span class="keyword">char</span> **)desc);</div><div class="line">	<span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:signature];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检查生成的block的签名对象是否正确的方法，就是与原始selector的签名对象进行直接比较（比较每个参数是否相同）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> aspect_isCompatibleBlockSignature(<span class="built_in">NSMethodSignature</span> *blockSignature, <span class="keyword">id</span> object, SEL selector, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(blockSignature);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(object);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</div><div class="line"></div><div class="line">    <span class="built_in">BOOL</span> signaturesMatch = <span class="literal">YES</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 通过selector和object得到原始的方法签名</span></div><div class="line">    <span class="built_in">NSMethodSignature</span> *methodSignature = [[object <span class="keyword">class</span>] instanceMethodSignatureForSelector:selector];</div><div class="line">    </div><div class="line">    <span class="comment">// 与生成block签名比较参数个数</span></div><div class="line">    <span class="keyword">if</span> (blockSignature.numberOfArguments &gt; methodSignature.numberOfArguments) &#123;</div><div class="line">        <span class="comment">// block签名参数更多，错误</span></div><div class="line">        signaturesMatch = <span class="literal">NO</span>;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// block签名参数大于1时，查看第二个参数是否为对象（实质是AspectInfo实例）</span></div><div class="line">        <span class="keyword">if</span> (blockSignature.numberOfArguments &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *blockType = [blockSignature getArgumentTypeAtIndex:<span class="number">1</span>];</div><div class="line">            <span class="keyword">if</span> (blockType[<span class="number">0</span>] != <span class="string">'@'</span>) &#123;</div><div class="line">                <span class="comment">// 不是，错误</span></div><div class="line">                signaturesMatch = <span class="literal">NO</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 由于标准方法签名的前两个参数为id和SEL，blockSignature对象的前两个参数为self和AspectInfo对象（执行时候是，现在只是id），故从第三个开始比较</span></div><div class="line">        <span class="keyword">if</span> (signaturesMatch) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> idx = <span class="number">2</span>; idx &lt; blockSignature.numberOfArguments; idx++) &#123;</div><div class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *methodType = [methodSignature getArgumentTypeAtIndex:idx];</div><div class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *blockType = [blockSignature getArgumentTypeAtIndex:idx];</div><div class="line">                <span class="comment">// Only compare parameter, not the optional type data.</span></div><div class="line">                <span class="keyword">if</span> (!methodType || !blockType || methodType[<span class="number">0</span>] != blockType[<span class="number">0</span>]) &#123;</div><div class="line">                    signaturesMatch = <span class="literal">NO</span>; <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!signaturesMatch) &#123;</div><div class="line">        <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Blog signature %@ doesn't match %@."</span>, blockSignature, methodSignature];</div><div class="line">        AspectError(AspectErrorIncompatibleBlockSignature, description);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Aspects中hook完成后，方法的执行过程"><a href="#Aspects中hook完成后，方法的执行过程" class="headerlink" title="Aspects中hook完成后，方法的执行过程"></a><u>Aspects中hook完成后，方法的执行过程</u></h5><p>方法的执行过程，即hook版本的<em>forwardInvocation:</em> 方法的执行过程，也就是 <em><strong>ASPECTS_ARE_BEING_CALLED</strong></em> 的实现过程：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** swizzled的forwardInvocation:方法 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ASPECTS_ARE_BEING_CALLED__(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSInvocation</span> *invocation) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(invocation);</div><div class="line">    SEL originalSelector = invocation.selector;</div><div class="line">	SEL aliasSelector = aspect_aliasForSelector(invocation.selector);</div><div class="line">    invocation.selector = aliasSelector; <span class="comment">// 将invocation的selector替换为hook的版本</span></div><div class="line">    AspectsContainer *objectContainer = objc_getAssociatedObject(<span class="keyword">self</span>, aliasSelector); <span class="comment">// 实例的切片信息容器</span></div><div class="line">    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(<span class="keyword">self</span>), aliasSelector); <span class="comment">// 类的切片信息容器</span></div><div class="line">    AspectInfo *info = [[AspectInfo alloc] initWithInstance:<span class="keyword">self</span> invocation:invocation]; <span class="comment">// 将invocation封装为AspectInfo对象</span></div><div class="line">    <span class="built_in">NSArray</span> *aspectsToRemove = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Before hooks.</span></div><div class="line">    <span class="comment">// 依次使用类切片信息容器内的切片信息对象（AspectIdentifier）执行方法，传入info对象</span></div><div class="line">    aspect_invoke(classContainer.beforeAspects, info);</div><div class="line">    <span class="comment">// 依次使用实例切片信息容器内的切片信息对象（AspectIdentifier）执行方法，传入info对象</span></div><div class="line">    aspect_invoke(objectContainer.beforeAspects, info);</div><div class="line"></div><div class="line">    <span class="comment">// Instead hooks.</span></div><div class="line">    <span class="built_in">BOOL</span> respondsToAlias = <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">if</span> (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123;</div><div class="line">        <span class="comment">// 使用替换的AspectIdentifier执行</span></div><div class="line">        aspect_invoke(classContainer.insteadAspects, info);</div><div class="line">        aspect_invoke(objectContainer.insteadAspects, info);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 原始调用者的类</span></div><div class="line">        Class klass = object_getClass(invocation.target);</div><div class="line">        <span class="comment">// 找到可以执行hook版本的SEL的类，然后执行</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="keyword">if</span> ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123;</div><div class="line">                [invocation invoke]; <span class="comment">// 直接执行，aliasSelector对应的IMP原始IMP，也就是原始方法执行</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">while</span> (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// After hooks.</span></div><div class="line">    aspect_invoke(classContainer.afterAspects, info);</div><div class="line">    aspect_invoke(objectContainer.afterAspects, info);</div><div class="line"></div><div class="line">    <span class="comment">// If no hooks are installed, call original implementation (usually to throw an exception)</span></div><div class="line">    <span class="comment">// 没有找到类实现了hook的SEL</span></div><div class="line">    <span class="keyword">if</span> (!respondsToAlias) &#123;</div><div class="line">        <span class="comment">// 将invocation恢复为原始SEL</span></div><div class="line">        invocation.selector = originalSelector;</div><div class="line">        <span class="comment">// 获取原始forwardInvocation方法SEL（本来已经交换了）</span></div><div class="line">        SEL originalForwardInvocationSEL = <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName);</div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:originalForwardInvocationSEL]) &#123;</div><div class="line">            <span class="comment">// 原始实例可以响应（实现过forwardInvocation方法），则指向原始的消息转发流程</span></div><div class="line">            ((<span class="keyword">void</span>( *)(<span class="keyword">id</span>, SEL, <span class="built_in">NSInvocation</span> *))objc_msgSend)(<span class="keyword">self</span>, originalForwardInvocationSEL, invocation);</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 不能响应，则直接抛异常</span></div><div class="line">            [<span class="keyword">self</span> doesNotRecognizeSelector:invocation.selector];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 让需要移除的AspectIdentifier对象，依次执行remove方法，清除对应方法的hook状态</span></div><div class="line">    [aspectsToRemove makeObjectsPerformSelector:<span class="keyword">@selector</span>(remove)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个流程主要是：</p>
<ol>
<li>beforeBlock执行（如果有） -&gt; 原始方法执行 -&gt; afterBlock执行（如果有） -&gt; 清除方法的hook状态（如果有）</li>
<li>原始方法实现如果不存在：如果原始类实现了<em>forwardInvocation:</em> 方法，则直接执行，走原始的消息转发流程了；如果没有实现，则直接抛异常（因为Aspects的流程已经走完）。其实整体来看，也是遵循原始类的方法调用过程。</li>
</ol>
<p>这里，需要看一下<em>aspect_invoke</em>函数的执行过程：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义成宏是为了可以得到调用栈的说明</span></div><div class="line"><span class="meta">#define aspect_invoke(aspects, info) \</span></div><div class="line"><span class="keyword">for</span> (AspectIdentifier *aspect <span class="keyword">in</span> aspects) &#123;\</div><div class="line">    [aspect invokeWithInfo:info];\</div><div class="line">    <span class="keyword">if</span> (aspect.options &amp; AspectOptionAutomaticRemoval) &#123; \</div><div class="line">        aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \</div><div class="line">    &#125; \</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此函数的作用是：</p>
<ol>
<li>依次使用AspectIdentifier对象进行block调用，传入AspectInfo信息。</li>
<li>如果执行后需要移除此AspectIdentifier对象（清除hook状态），直接插入到数组中，最后统一清理。</li>
</ol>
<p>最后我们看一下，AspectIdentifier的<em>invokeWithInfo</em>方法是如何执行的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)invokeWithInfo:(<span class="keyword">id</span>&lt;AspectInfo&gt;)info &#123;</div><div class="line">    <span class="comment">// 使用block签名对象生成NSInvocation对象</span></div><div class="line">    <span class="built_in">NSInvocation</span> *blockInvocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:<span class="keyword">self</span>.blockSignature];</div><div class="line">    <span class="comment">// 取出AspectInfo中原始类的invocation</span></div><div class="line">    <span class="built_in">NSInvocation</span> *originalInvocation = info.originalInvocation;</div><div class="line">    </div><div class="line">    <span class="comment">// block签名中的参数个数</span></div><div class="line">    <span class="built_in">NSUInteger</span> numberOfArguments = <span class="keyword">self</span>.blockSignature.numberOfArguments;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123;</div><div class="line">        <span class="comment">// 参数个数不匹配（block中的参数过多）</span></div><div class="line">        AspectLogError(<span class="string">@"Block has too many arguments. Not calling %@"</span>, info);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (numberOfArguments &gt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// block签名的参数个数大于1时，将AspectInfo对象设置在index为1的位置（这样block中的第一个参数即为AspectInfo对象）</span></div><div class="line">        [blockInvocation setArgument:&amp;info atIndex:<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 将原始invocation中的其他参数（除去原始的self和_cmd两个参数外的）copy到block的invocation中</span></div><div class="line">	<span class="keyword">void</span> *argBuf = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> idx = <span class="number">2</span>; idx &lt; numberOfArguments; idx++) &#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];</div><div class="line">		<span class="built_in">NSUInteger</span> argSize;</div><div class="line">		<span class="built_in">NSGetSizeAndAlignment</span>(type, &amp;argSize, <span class="literal">NULL</span>);</div><div class="line">        </div><div class="line">		<span class="keyword">if</span> (!(argBuf = reallocf(argBuf, argSize))) &#123;</div><div class="line">            AspectLogError(<span class="string">@"Failed to allocate memory for block invocation."</span>);</div><div class="line">			<span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">		&#125;</div><div class="line">        </div><div class="line">		[originalInvocation getArgument:argBuf atIndex:idx];</div><div class="line">		[blockInvocation setArgument:argBuf atIndex:idx];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// blockInvocation执行（block执行）</span></div><div class="line">    [blockInvocation invokeWithTarget:<span class="keyword">self</span>.block];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (argBuf != <span class="literal">NULL</span>) &#123;</div><div class="line">        free(argBuf);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Aspects清除方法的hook状态，恢复原始实例-类"><a href="#Aspects清除方法的hook状态，恢复原始实例-类" class="headerlink" title="Aspects清除方法的hook状态，恢复原始实例/类"></a><u>Aspects清除方法的hook状态，恢复原始实例/类</u></h5><p>在外部，调用Aspects的API，hook完成相关方法后，得到的返回值为遵循AspectToken协议的对象。在内部，实际上是AspectIdentifier作为此协议的代理进行实现。故清除hook状态的实现即为AspectIdentifier的remove实现，也就是<em>aspect_remove</em>函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> aspect_remove(AspectIdentifier *aspect, <span class="built_in">NSError</span> **error) &#123;</div><div class="line">    <span class="built_in">NSCAssert</span>([aspect isKindOfClass:AspectIdentifier.class], <span class="string">@"Must have correct type."</span>);</div><div class="line"></div><div class="line">    __block <span class="built_in">BOOL</span> success = <span class="literal">NO</span>;</div><div class="line">    aspect_performLocked(^&#123;</div><div class="line">        <span class="keyword">id</span> <span class="keyword">self</span> = aspect.object; <span class="comment">// 强引用，防止释放过程中object被释放</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">            <span class="comment">// 从容器中移除AspectIdentifier对象</span></div><div class="line">            AspectsContainer *aspectContainer = aspect_getContainerForObject(<span class="keyword">self</span>, aspect.selector);</div><div class="line">            success = [aspectContainer removeAspect:aspect];</div><div class="line">            </div><div class="line">            <span class="comment">// 清除调用者的hook状态，恢复selector和forwardInvocation的原始实现</span></div><div class="line">            aspect_cleanupHookedClassAndSelector(<span class="keyword">self</span>, aspect.selector);</div><div class="line">            </div><div class="line">            <span class="comment">// 清理信息</span></div><div class="line">            aspect.object = <span class="literal">nil</span>;</div><div class="line">            aspect.block = <span class="literal">nil</span>;</div><div class="line">            aspect.selector = <span class="literal">NULL</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSString</span> *errrorDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Unable to deregister hook. Object already deallocated: %@"</span>, aspect];</div><div class="line">            AspectError(AspectErrorRemoveObjectAlreadyDeallocated, errrorDesc);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> success;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，从hook状态恢复过程如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_cleanupHookedClassAndSelector(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</div><div class="line"></div><div class="line">	Class klass = object_getClass(<span class="keyword">self</span>); <span class="comment">// 调用者的类（instance-&gt;Class；Class-&gt;MetaClass）</span></div><div class="line">    <span class="built_in">BOOL</span> isMetaClass = class_isMetaClass(klass); <span class="comment">// 判定是否为MetaClass</span></div><div class="line">    <span class="keyword">if</span> (isMetaClass) &#123;</div><div class="line">        <span class="comment">// 即调用者为Class，klass设置为Class自身，以便统一处理，恢复selector（从这里可以看出，Aspects并不支持静态方法的hook，因为都是在Class上进行的事务）</span></div><div class="line">        klass = (Class)<span class="keyword">self</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Method targetMethod = class_getInstanceMethod(klass, selector);</div><div class="line">    IMP targetMethodIMP = method_getImplementation(targetMethod);</div><div class="line">    <span class="keyword">if</span> (aspect_isMsgForwardIMP(targetMethodIMP)) &#123;</div><div class="line">        <span class="comment">// IMP是_objc_msgForward函数，证明hook过，需要恢复</span></div><div class="line">        </div><div class="line">        <span class="comment">// 得到hook版本selector（其对应的IMP为原始IMP）</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *typeEncoding = method_getTypeEncoding(targetMethod);</div><div class="line">        SEL aliasSelector = aspect_aliasForSelector(selector);</div><div class="line">        Method originalMethod = class_getInstanceMethod(klass, aliasSelector);</div><div class="line">        <span class="comment">// 取出原始IMP</span></div><div class="line">        IMP originalIMP = method_getImplementation(originalMethod);</div><div class="line">        <span class="built_in">NSCAssert</span>(originalMethod, <span class="string">@"Original implementation for %@ not found %@ on %@"</span>, <span class="built_in">NSStringFromSelector</span>(selector), <span class="built_in">NSStringFromSelector</span>(aliasSelector), klass);</div><div class="line">        </div><div class="line">        <span class="comment">// 替换回原始IMP</span></div><div class="line">        class_replaceMethod(klass, selector, originalIMP, typeEncoding);</div><div class="line">        AspectLog(<span class="string">@"Aspects: Removed hook for -[%@ %@]."</span>, klass, <span class="built_in">NSStringFromSelector</span>(selector));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 从全局追踪字典中移除本类（只对Class调用者有效）</span></div><div class="line">    aspect_deregisterTrackedSelector(<span class="keyword">self</span>, selector);</div><div class="line"></div><div class="line">    <span class="comment">// 查看AspectIdentifier的容器中是否还有其他对象</span></div><div class="line">    AspectsContainer *container = aspect_getContainerForObject(<span class="keyword">self</span>, selector);</div><div class="line">    <span class="keyword">if</span> (!container.hasAspects) &#123;</div><div class="line">        <span class="comment">// AspectIdentifier容器空了（没有任何hook信息保存）</span></div><div class="line">        </div><div class="line">        <span class="comment">// 清除此动态属性（间接删除了容器对象）</span></div><div class="line">        aspect_destroyContainerForObject(<span class="keyword">self</span>, selector);</div><div class="line"></div><div class="line">        <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(klass);</div><div class="line">        <span class="keyword">if</span> ([className hasSuffix:AspectsSubclassSuffix]) &#123;</div><div class="line">            <span class="comment">// 包含子类后缀，证明调用者为实例，该类为动态创建的子类</span></div><div class="line">            Class originalClass = <span class="built_in">NSClassFromString</span>([className stringByReplacingOccurrencesOfString:AspectsSubclassSuffix withString:<span class="string">@""</span>]); <span class="comment">// 得到原始类名</span></div><div class="line">            <span class="built_in">NSCAssert</span>(originalClass != <span class="literal">nil</span>, <span class="string">@"Original class must exist"</span>);</div><div class="line">            object_setClass(<span class="keyword">self</span>, originalClass); <span class="comment">// 将调用者的类重新设置为原始类</span></div><div class="line">            AspectLog(<span class="string">@"Aspects: %@ has been restored."</span>, <span class="built_in">NSStringFromClass</span>(originalClass));</div><div class="line">            </div><div class="line">            <span class="comment">// 这里并没有在runtime系统中移除该类</span></div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 调用者为类，将其复原（恢复forwardInvocation实现）</span></div><div class="line">            <span class="keyword">if</span> (isMetaClass) &#123;</div><div class="line">                aspect_undoSwizzleClassInPlace((Class)<span class="keyword">self</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，统一将selector的IMP替换回来。</p>
<p>对于instance调用者，清除hook状态，只要将其isa指回到原来的类即可。</p>
<p>对于Class调用者来说，则稍微麻烦一些：<br>首先需要移除全局标记的方法信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_deregisterTrackedSelector(<span class="keyword">id</span> <span class="keyword">self</span>, SEL selector) &#123;</div><div class="line">    <span class="comment">// 只对类调用者有效</span></div><div class="line">    <span class="keyword">if</span> (!class_isMetaClass(object_getClass(<span class="keyword">self</span>))) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 取出全局swizzled的类字典</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span> *swizzledClassesDict = aspect_getSwizzledClassesDict();</div><div class="line">    <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(selector);</div><div class="line">    </div><div class="line">    <span class="comment">// 依次从当前向父类查询，移除追踪方法标记</span></div><div class="line">    Class currentClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        AspectTracker *tracker = swizzledClassesDict[currentClass];</div><div class="line">        <span class="keyword">if</span> (tracker) &#123;</div><div class="line">            [tracker.selectorNames removeObject:selectorName];</div><div class="line">            <span class="keyword">if</span> (tracker.selectorNames.count == <span class="number">0</span>) &#123;</div><div class="line">                [swizzledClassesDict removeObjectForKey:tracker];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">while</span> ((currentClass = class_getSuperclass(currentClass)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于关联对象，这里正好有个知识点：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_destroyContainerForObject(<span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt; <span class="keyword">self</span>, SEL selector) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</div><div class="line">    SEL aliasSelector = aspect_aliasForSelector(selector);</div><div class="line">    <span class="comment">// 清除关联对象的值（给属性值清零）</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, aliasSelector, <span class="literal">nil</span>, OBJC_ASSOCIATION_RETAIN);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>由于关联对象并没有提供单独清除某一个属性的值的方法（只有全部清除），故Aspects使用设置相关对象值为nil的方式进行了清零</strong>。<br>顺便移除了AspectIdentifier的容器对象。</p>
<p>对于复原类hook的forwardInvocation方法，也比较直接：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_undoSwizzleClassInPlace(Class klass) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(klass);</div><div class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(klass);</div><div class="line"></div><div class="line">    _aspect_modifySwizzledClasses(^(<span class="built_in">NSMutableSet</span> *swizzledClasses) &#123;</div><div class="line">        <span class="comment">// 在线程安全的情况下，从修改的类列表中移除该类</span></div><div class="line">        <span class="keyword">if</span> ([swizzledClasses containsObject:className]) &#123;</div><div class="line">            <span class="comment">// 恢复原始forwardInvocation方法</span></div><div class="line">            aspect_undoSwizzleForwardInvocation(klass);</div><div class="line">            [swizzledClasses removeObject:className];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_undoSwizzleForwardInvocation(Class klass) &#123;</div><div class="line">    <span class="built_in">NSCParameterAssert</span>(klass);</div><div class="line">    </div><div class="line">    <span class="comment">// 得到hook版本的方法（对应的IMP即为备份的原始IMP）</span></div><div class="line">    Method originalMethod = class_getInstanceMethod(klass, <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName));</div><div class="line">    <span class="comment">// NSObject原版方法</span></div><div class="line">    Method objectMethod = class_getInstanceMethod(<span class="built_in">NSObject</span>.class, <span class="keyword">@selector</span>(forwardInvocation:));</div><div class="line"></div><div class="line">    <span class="comment">// 如果klass没有实现forwardInvocation，则直接用NSObject的默认实现代替</span></div><div class="line">    IMP originalImplementation = method_getImplementation(originalMethod ?: objectMethod);</div><div class="line">    </div><div class="line">    <span class="comment">// 替换回原始实现</span></div><div class="line">    class_replaceMethod(klass, <span class="keyword">@selector</span>(forwardInvocation:), originalImplementation, <span class="string">"v@:@"</span>);</div><div class="line"></div><div class="line">    AspectLog(<span class="string">@"Aspects: %@ has been restored."</span>, <span class="built_in">NSStringFromClass</span>(klass));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<ul>
<li><a href="https://github.com/steipete/Aspects" target="_blank" rel="external">Aspects</a></li>
<li><a href="https://www.jianshu.com/p/2c93446d86bd?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends" target="_blank" rel="external">Aspects源码解析</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Aspects是一个可以动态hook指定方法的轻量级的库，AOP思想非常棒的体现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime编程指南之消息转发</title>
    <link href="http://yoursite.com/2019/07/18/Objective-C%20Runtime%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E4%B9%8B%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>http://yoursite.com/2019/07/18/Objective-C Runtime编程指南之消息转发/</id>
    <published>2019-07-18T03:28:28.431Z</published>
    <updated>2019-07-18T03:28:39.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html" target="_blank" rel="external">Message Forwarding</a></p>
</blockquote>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>给一个对象发送其不能处理的消息会产生错误。可是，在发生错误之前，运行时系统给接收对象一个二次机会来处理这个消息。</p>
<a id="more"></a>
<h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>如果你给一个对象发送其不能处理的消息时，在产生错误之前，运行时会发送给对象一个<em>forwardInvocation:</em> 消息，此消息包含一个<em>NSInvocation</em>对象作为唯一参数—-这个<em>NSInvocation</em>对象中包含了之前的原始消息和参数。</p>
<p>你可以实现<em>forwardInvocation:</em> 方法来提供一个默认消息响应，或者用某种其他方式来避免错误。就像名称所说那样，<em>forwardInvocation:</em> 一般用于将消息转发给其他对象。</p>
<p>要了解转发的适用范围和目的，设想下面的场景：首先，假设你正在设计一个对象，它可以响应一个叫<em>negotiate</em>的消息，并且你想要它的响应中包含其他种类对象的响应。你可以很容易地完成它：只需要在你的<em>negotiate</em>方法体中，给其他对象再发送一个<em>negotiate</em>消息。</p>
<p>再想深一点，设想你想要你的对象能够响应<em>negotiate</em>消息，但是其实现却其他类中。完成它的一种方法就是让你的类继承于其他类。可是，这种情况有可能做不到。也许有很多原因导致你的类和实现了<em>negotiate</em>方法的类在不同的继承体系中。</p>
<p>即使你的类不能继承到<em>negotiate</em>方法，你还可以通过”借“的方式来实现一个特别的版本，就是将这个消息直接传递给一个其他类的实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (id)negotiate</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ( [someOtherObject respondsTo:@selector(negotiate)] )</div><div class="line">        <span class="keyword">return</span> [someOtherObject negotiate];</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式可能有一点笨，特别是当你想把许多消息都赚给其他对象时。你必须把从其他类借到的方法依次实现。此外，有时候你不太可能处理到那些你不知道的情况，因为你只是写了那些你当时准备转发的消息代码。这一些消息可能取决于运行时，并且很有可能在未来变成一些新的方法和类。</p>
<p>通过<em>forwardInvocation:</em> 消息提供的第二次机会是一个不太特别的解决方案，而且是个动态方案。其工作过程如下：当一个对象不能响应一个消息时（因为它没有一个可以匹配消息中选择器的方法），运行时系统会给对象发送一个<em>forwardInvocation:</em> 消息。每一个对象都从<em>NSObject</em>类中继承了<em>forwardInvocation:</em> 方法。可是，<em>NSObject</em>的实现版本仅仅调用了<em>doesNotRecognizeSelector:</em> 方法。通过覆盖<em>NSObject</em>的版本并进行你自身的实现，你可以利用这次机会通过<em>forwardInvocation:</em> 将消息转发给其他对象。</p>
<p>要转发一个消息，所有的<em>forwardInvocation:</em> 方法需要按下面的方式去做：</p>
<ul>
<li>决定这个消息要去哪，并且</li>
<li>带着原始参数给它发送过去</li>
</ul>
<p>这个消息可以通过<em>invokeWithTarget:</em> 方法进行发送：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([someOtherObject respondsToSelector:</div><div class="line">            [anInvocation selector]])</div><div class="line">        [anInvocation invokeWithTarget:someOtherObject];</div><div class="line">    <span class="keyword">else</span></div><div class="line">        [super forwardInvocation:anInvocation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转发出的消息的返回值会被返回给原始的接收者。所有类型的返回值都可以被传递给接收者，包括id、结构体和双精度浮点数等。</p>
<p><em>forwardInvocation:</em> 方法对于不能识别的消息扮演着一个分发中心的角色，给这些消息打包发送给不同的接收者。或者它也可以当做一个中转站，发送所有消息到同一个目的地。它可以将一个消息转换为另一个，或者直接”吞掉“某些消息使其不产生响应或错误。一个<em>forwardInvocation:</em> 方法还可以将多个消息合并到一个响应中。<em>forwardInvocation:</em> 方法所做的事情都由实现者决定。可是，它提供的一种将对象链接到到转发链中的机会为程序设计提供了新的可能性。</p>
<blockquote>
<p>注意：</p>
<p><strong>只有当正常的接收者不能调用一个存在的方法时，<em>forwardInvocation:</em> 方法才会收到待处理消息</strong>。例如，如果你想要你的对象转发<em>negotiate</em>消息给另一个对象，那么它自己就不能包含<em>negotiate</em>方法。如果存在此方法，消息就绝不会到达<em>forwardInvocation:</em> 中。</p>
</blockquote>
<p>查看更多关于转发和调用的信息，请在Foundation框架参考中查看<em>NSInvocation</em>类的说明。</p>
<h4 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h4><p>转发模拟了继承，并且可以被用于在Objective-C程序中实现出一些多继承的效果。如<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-87317" target="_blank" rel="external">图表5-1</a>所示，通过转发来响应消息的对象就好像是从另一个类中”继承“了方法实现一样。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/forwarding.gif" alt="图表5-1"></p>
<p>在这个插图中，一个Warrior类的实例转发<em>negotiate</em>消息给了一个Diplomat类的实例。Warrior看起来就好像是一个Diplomat一样。就好像它响应了<em>negotiate</em>消息，并且从实际上看，它确实响应了（虽然是一个Diplomat完成的工作）。</p>
<p>转发消息的对象从而通过两个继承体系的分支中“继承”了方法—-它自己的分支和响应消息的那个对象的分支。在上面的例子中，和自己的父类一样，看起来就好像Warrior类也继承于Diplomat类。</p>
<p>转发提供了大多数的多继承特性。可是，在二者之间还是存在一点重要的不同：多继承将不同的能力合并在了一个对象中。而转发，却将不同的功能分配给了不同的对象。它将问题分解到小的对象中，却用一种对消息发送者透明的方式将这些对象联系起来。</p>
<h4 id="替代者对象"><a href="#替代者对象" class="headerlink" title="替代者对象"></a>替代者对象</h4><p>转发不仅模拟了多继承，它还使开发一个可以代表或者“隐藏”大量对象的轻量级对象成为可能。替代者替代了其他对象并且将消息过滤给它们。</p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163" target="_blank" rel="external">The Objective-C Programming Language</a>中的“Remote Messaging”中讨论的代理就是这样一个替代者。代理负责了将消息转发给远程接收者的所有管理细节，确保参数值通在连接中被拷贝和取回，等等。但是它并没有做更多工作；代理并没有复制远程对象的功能，只是简单地给远程对象一个本地地址，即一个可以从其他应用程序中接收消息的位置。</p>
<p>其他种类的替代者对象也可以做到这些。假设，你有一个可以操作许多数据的对象—-也许它创建了一个复杂的图片或者从磁盘上的文件中读取了内容。创建这个对象也许会非常耗时，所以你更想进行懒加载—-当真的需要时或者是系统资源空闲时。同时，你至少需要一个占位对象来保证应用程序中的其他对象可以正常工作。</p>
<p>在这种情况下，你并不需要创建一个完整的对象，而是一个轻量级的替代者。此对象可以做一些自己的事情，比如回答关于数据的问题，但多数情况下，它只是为那个大对象占用一个位置，当真的需要时，就转发消息给它。当替代者的<em>forwardInvocation:</em> 收到消息并指向其他对象时，它可以确保改对象存在或者当不存在时可以创建出来。大对象的所有消息都会通过替代者传送过来，因此，无论程序的其他部分如何关心，替代者和大对象都是相同的。</p>
<h4 id="转发和继承"><a href="#转发和继承" class="headerlink" title="转发和继承"></a>转发和继承</h4><p>虽然转发模拟了继承，但<em>NSObject</em>类从不会将二者弄混。<strong>像<em>respondsToSelector:</em> 和 <em>isKindOfClass:</em> 的这种方法只会在继承体系中查找，而绝不会在转发链中查找</strong>。例如，如果一个Warrior对象被询问是否可以响应<em>negotiate</em>消息时，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( [aWarrior respondsToSelector:@selector(negotiate)] )</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>答案是NO，尽管它可以接收<em>negotiate</em>消息，不发生错误并能够进行响应，在某种意义上，通过转发消息给Diplomat对象（见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-87317" target="_blank" rel="external">图表5-1</a>）。</p>
<p>在许多情况下，NO就是正确答案。但也可能不是。如果你通过转发来创建一个替代者对象或者扩展类的能力，转发机制应该和继承一样透明。如果你想让你的对象看起来就像真的继承于转发消息的对象，你就需要重新实现<em>respondsToSelector:</em> 和<em>isKindOfClass:</em> 方法，以便包含你的转发规则。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (BOOL)respondsToSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ( [super respondsToSelector:aSelector] )</div><div class="line">        <span class="keyword">return</span> YES;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* Here, test whether the aSelector message can     *</span></div><div class="line">         * be forwarded to another object and whether that  *</div><div class="line">         * object can respond to it. Return YES if it can.  */</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了<em>respondsToSelector:</em> 和<em>isKindOfClass:</em> 方法之外，<em>instancesRespondToSelector:</em> 方法也应该模拟转发规则。如果协议被使用了，<em>conformsToProtocol:</em> 方法也应该加到修改列表中。相似地，如果一个对象转发了任何它收到的远程消息，它应该包含一个<em>methodSignatureForSelector:</em> 方法的版本，它可以返回最终要响应的转发消息的准确描述。例如，如果一个对象正要转发消息给它的替代者，你可以向下面这样实现<em>methodSignatureForSelector:</em> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector</div><div class="line">&#123;</div><div class="line">    NSMethodSignature* signature = [super methodSignatureForSelector:selector];</div><div class="line">    <span class="keyword">if</span> (!signature) &#123;</div><div class="line">       signature = [surrogate methodSignatureForSelector:selector];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> signature;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你还可以考虑将转发规则放到一些私有代码中，并且让所有的待转发方法都调用它（包括<em>forwardInvocation:</em>）。</p>
<blockquote>
<p>注意：</p>
<p>这是一项高级技术，只适合那些没有其他解决方案时的场景。不能用它来代替继承。如果你必须使用此项技术，确保你完整地理解了使用转发的类和转发到的类的所有行为。</p>
</blockquote>
<p>在本节中提到的方法都在Foundation框架指南的<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/cl/NSObject" target="_blank" rel="external">NSObject</a>类的说明中都有描述。要查看<em>invokeWithTarget:</em> 的更多信息，请查看Foundation框架指南的<a href="https://developer.apple.com/documentation/foundation/nsinvocation" target="_blank" rel="external">NSInvocation</a>类的说明。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Message Forwarding&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;消息转发&quot;&gt;&lt;a href=&quot;#消息转发&quot; class=&quot;headerlink&quot; title=&quot;消息转发&quot;&gt;&lt;/a&gt;消息转发&lt;/h3&gt;&lt;p&gt;给一个对象发送其不能处理的消息会产生错误。可是，在发生错误之前，运行时系统给接收对象一个二次机会来处理这个消息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime编程指南之动态方法解析</title>
    <link href="http://yoursite.com/2019/07/18/Objective-C%20Runtime%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E4%B9%8B%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/07/18/Objective-C Runtime编程指南之动态方法解析/</id>
    <published>2019-07-18T03:27:44.799Z</published>
    <updated>2019-07-18T03:28:10.383Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html#//apple_ref/doc/uid/TP40008048-CH102-SW1" target="_blank" rel="external">Dynamic Method Resolution</a></p>
</blockquote>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>本章节描述了如何动态地为方法提供实现。</p>
<a id="more"></a>
<h4 id="动态方法解析-1"><a href="#动态方法解析-1" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>有一些情况下，你可能想要为方法动态地提供实现。比如，声明的Objective-C属性的特性（在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163" target="_blank" rel="external">The Objective-C Programming Language</a>中查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17" target="_blank" rel="external">Declared Properties</a>）中包含了 <em>@dynamic</em> 关键字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@dynamic propertyName;</div></pre></td></tr></table></figure>
<p>它告诉了编译器与属性相关的方法需要动态提供。</p>
<p>你分别可以通过实现<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418500-resolveinstancemethod" target="_blank" rel="external">resolveInstanceMethod:</a>和<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418889-resolveclassmethod" target="_blank" rel="external">resolveClassMethod:</a>方法为指定的实例方法或类方法的选择器动态地提供实现。</p>
<p>一个Objective-C方法就是一个至少包含了两个参数的C函数—-<em>self</em> 和 <em>_cmd</em> 。你可以通过使用<a href="https://developer.apple.com/documentation/objectivec/1418901-class_addmethod" target="_blank" rel="external">class_addMethod</a>函数给类添加一个函数。因此，给定了如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamicMethodIMP</span><span class="params">(id self, SEL _cmd)</span> </span>&#123;</div><div class="line">    <span class="comment">// implementation ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像下面这样，你可以使用<em>resolveInstanceMethod:</em> 方法来给类动态添加一个方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@implementation MyClass</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (aSEL == @selector(resolveThisMethodDynamically)) &#123;</div><div class="line">          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, <span class="string">"v@:"</span>);</div><div class="line">          <span class="keyword">return</span> YES;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [super resolveInstanceMethod:aSEL];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>转发方法（在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1" target="_blank" rel="external">Message Forwarding</a>中描述的那样）和动态方法解析是在对立面的。一个类在转发机制进入之前，有机会动态解析出一个方法。如果<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Protocols/NSObject/Description.html#//apple_ref/occ/intfm/NSObject/respondsToSelector:" target="_blank" rel="external">respondsToSelector:</a>或<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/clm/NSObject/instancesRespondToSelector:" target="_blank" rel="external">instancesRespondToSelector:</a>被调用，动态方法解析器就会首先给机会让选择器提供一个<em>IMP</em>。如果你实现了<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418500-resolveinstancemethod" target="_blank" rel="external">resolveInstanceMethod:</a>方法，但是想要指定选择器通过转发机制转发走，你可以在那些选择器中返回NO。</p>
<h4 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h4><p>一个Objective-C程序可以在运行的过程中加载和链接新的类和分类。新的代码被添加到程序中并且与在程序开始时加载的类和分类同等对待。</p>
<p>动态加载可以被用于做许多不同的事情。比如，在系统偏好设置程序中，各种模块都是动态加载的。</p>
<p>在Cocoa环境中，动态加载普遍用于允许程序的自定义上。第三方可以编写一些在运行时加载的模块—-就像Interface Builder加载自定义调色板或者是OS X系统偏好设置加载自定义设置模块一样。可加载的模块扩展了应用程序的功能。这个功能可以在你允许但是可能没有想到的方式上给应用程序提供帮助。你提供了框架，第三方可以提供代码。</p>
<p>虽然在Mach-O文件中，有一个运行时函数可以执行Objective-C模块的动态加载（<em>objc_loadModules</em>，定义在<em>objc/objc-load.h</em>文件中），Cocoa的<em>NSBundle</em>类提供了一个更加方便的接口用于动态加载—-一个面向对象的并且与相关服务结合到一起的接口。在Foundation框架参考中查看<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSBundle/Description.html#//apple_ref/occ/cl/NSBundle" target="_blank" rel="external">NSBundle</a>类的相关说明及使用方法。在OS X的ABI Mach-O文件格式参考中查看Mach-O文件的相关信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html#//apple_ref/doc/uid/TP40008048-CH102-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dynamic Method Resolution&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;动态方法解析&quot;&gt;&lt;a href=&quot;#动态方法解析&quot; class=&quot;headerlink&quot; title=&quot;动态方法解析&quot;&gt;&lt;/a&gt;动态方法解析&lt;/h3&gt;&lt;p&gt;本章节描述了如何动态地为方法提供实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime编程指南之发送消息</title>
    <link href="http://yoursite.com/2019/07/18/Objective-C%20Runtime%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E4%B9%8B%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2019/07/18/Objective-C Runtime编程指南之发送消息/</id>
    <published>2019-07-18T03:27:18.831Z</published>
    <updated>2019-07-18T03:27:18.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html" target="_blank" rel="external">Messaging</a></p>
</blockquote>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>本章描述了消息表达式如何被转化为<a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend" target="_blank" rel="external">objc_msgSend</a>函数调用，还有如何通过名字索引到方法。之后解释了你如何利用<em>objc_msgSend</em>，还有—-如果需要—-如何规避动态绑定过程。</p>
<a id="more"></a>
<h4 id="objc-msgSend函数"><a href="#objc-msgSend函数" class="headerlink" title="objc_msgSend函数"></a>objc_msgSend函数</h4><p>在Objective-C中，消息直到运行时才会被绑定到方法实现上。编译器将消息表达式进行转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[receiver message]</div></pre></td></tr></table></figure>
<p>转换为消息函数的调用，<a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend" target="_blank" rel="external">objc_msgSend</a>。此函数携带着消息中的<strong>接受者</strong>和<strong>方法名</strong>（即选择器）作为函数的两个必要参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector)</div></pre></td></tr></table></figure>
<p>消息中传入的其他参数也会被<em>objc_msgSend</em>进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure>
<p>这个消息函数为动态绑定做了所有必要的事情：</p>
<ul>
<li>首先，消息函数查找选择器指向的程序（即方法实现）。由于在不同的类中，相同的方法可以有不同的实现，因此确定的实现取决于查找的接收者的类。</li>
<li>之后要调用此实现程序，传入接收对象（其数据的指针），方法指定的其他参数也一同传入。</li>
<li>最后，消息函数将实现程序调用后的返回值传回来，就好像自己的返回值一样。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：</p>
<p>编译器会自动调用此消息函数。你一定不要在代码中直接调用它。</p>
</blockquote>
<p>发送消息的关键在于编译器为每个类和对象构建的结构体。每个类的结构体包含以下两个必要的元素：</p>
<ul>
<li><strong>一个指向父类的指针</strong></li>
<li><strong>一个类的<em>分发表</em>。此表包含一个入口，可以把方法选择器和指定类的方法地址连接在一起</strong>。<em>setOrigin::</em> 方法的选择器和 <em>setOrigin::</em> 的地址（实现程序）连接在了一起，<em>display</em> 方法的选择器和 <em>display</em> 的地址连接在了一起，等等。</li>
</ul>
<p>当一个新对象被创建出来时，其内存已经被分配好，其实例变量也已经初始化。此对象中的第一个变量是一个指向它所属类结构体的指针。这个指针，叫做<strong>isa</strong>，给予此对象访问其所属类的能力，并且通过这个类，还可以访问到所有其继承到的类。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<p>虽然不能严格算是编程语言的一部分，但对于一个对象来说，在与Objective-C运行时系统协同工作时，isa指针却是十分必要的。一个对象”等价于“一个包含了定义的所有字段的<strong>objc_object结构体</strong>（定义在<em>objc/objc.h</em>中）。可是，你几乎用不到自己来创建根对象，继承了NSObject和NSProxy类的对象早已自动包含了isa指针。</p>
</blockquote>
<p>这些类的元素和对象结构体如插图3-1中所示：</p>
<p><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt="发送消息框架"></p>
<p>当消息发送给某个对象时，发送消息函数会沿着对象的isa指针找到该类的结构体，在其中的分发表中查找方法的选择器。如果在这里找不到选择器，<em>objc_msgSend</em>会沿着其父类的指针继续，并试图在父类的分发表中查找该选择器。连续的失败会导致<em>objc_msgSend</em>会沿着类的层级一直向上爬，直到到达<em>NSObject</em>类。一旦锁定了选择器，此函数就会在分发表中进入此方法中进行调用，并且传入接收者对象的数据结构。</p>
<p>以上就是方法实现在运行时被查找的方式—-或者，用面向对象的行话来说，那个方法被动态绑定到了消息上。</p>
<p>为了加速消息发送过程，一旦被使用，运行时系统会缓存该方法的选择器和地址。在每个类中都包含一个独立的缓存区域，并且它同样可以包含继承来的方法选择器。在查找分发表之前，消息发送程序会首先检查接收者类中的缓存（理论上来说，一个方法只要被用过一次就极有可能再次被使用）。如果方法选择器在缓存中，消息发送过程就只会比直接的函数调用稍慢一些。一旦程序已经运行足够的时间来给缓存”热身“，几乎所有发送的消息就都可以找到对应的缓存方法。随着程序的运行，缓存会动态增长空间来缓存新保存的消息。</p>
<h4 id="使用隐藏参数"><a href="#使用隐藏参数" class="headerlink" title="使用隐藏参数"></a>使用隐藏参数</h4><p>当<a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend" target="_blank" rel="external">objc_msgSend</a>找到了方法的实现程序后，它便调用此程序且将消息中包含的所有参数传递进去。它还会传入两个隐藏参数：</p>
<ul>
<li>接收者对象</li>
<li>方法的选择器</li>
</ul>
<p>这些参数给每一个方法实现提供了代码调用时方法表达式中的两个明确信息。它们被叫做”隐藏“，是因为在定义的方法中没有声明二者。它们只在代码编译时被插入到实现中。</p>
<p>虽然这些参数没有明确声明，源码还是可以索引到它们（就像源码可以索引到接收者内部的实例变量一样）。<strong>一个方法把接收者对象称作<em>self</em>，把其自身的选择器称作 <em>_cmd</em></strong>。在下面的例子中，<em>_cmd</em>代表了<em>strange</em>方法的选择器，<em>self</em>则代表了接收<em>strange</em>消息的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- strange</div><div class="line">&#123;</div><div class="line">    id  target = getTheReceiver();</div><div class="line">    SEL method = getTheMethod();</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> ( target == self || method == _cmd )</div><div class="line">        <span class="keyword">return</span> nil;</div><div class="line">    <span class="keyword">return</span> [target performSelector:method];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这两个参数中，<em>self</em>更为有用。实际上，对于方法定义来说，<em>self</em>才是将接收者对象的实例变量变为可用的方式。</p>
<h4 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h4><p><strong>规避动态绑定过程的唯一方法，就是获取方法的地址，然后直接进行函数调用</strong>。这种情况也许非常罕见，也许只有当某个指定方法要连续执行许多次，并且你希望避免每次执行之前进行的消息发送过程。</p>
<p>有一个定义在NSObject类中的方法，名为<em>methodForSelector:</em>，你可以设置一个指向方法实现程序的指针，之后使用这个指针来调用程序。<em>methodForSelector:</em> 返回的指针必须被转换成合适的函数类型，返回值和参数类型都必须包含在类型转换中。</p>
<p>下面的例子展示了<em>setFilled:</em> 方法的实现程序如何是被调用的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (*setter)(id, SEL, BOOL);</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"> </div><div class="line">setter = (<span class="keyword">void</span> (*)(id, SEL, BOOL))[target</div><div class="line">    methodForSelector:@selector(setFilled:)];</div><div class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++ )</div><div class="line">    setter(targetList[i], @selector(setFilled:), YES);</div></pre></td></tr></table></figure>
<p>传入程序中的前两个参数是接收者对象（self）和方法选择器（_cmd）。这些参数被隐藏在方法的语法中，但在方法被作为函数调用时必须明确声明。</p>
<p>使用<em>methodForSelector:</em> 来规避动态绑定过程可以节约消息发送过程中的大部分时间。可是，这种时间节约只有在特定的消息被重复执行许多次时才有意义，就像上面的for循环一样。</p>
<p>注意，<em>methodForSelector:</em> 方法是由Cocoa的运行时系统提供；它并不是Objective-C语言本身的特性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Messaging&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;发送消息&quot;&gt;&lt;a href=&quot;#发送消息&quot; class=&quot;headerlink&quot; title=&quot;发送消息&quot;&gt;&lt;/a&gt;发送消息&lt;/h3&gt;&lt;p&gt;本章描述了消息表达式如何被转化为&lt;a href=&quot;https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;objc_msgSend&lt;/a&gt;函数调用，还有如何通过名字索引到方法。之后解释了你如何利用&lt;em&gt;objc_msgSend&lt;/em&gt;，还有—-如果需要—-如何规避动态绑定过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime编程指南之与运行时系统进行交互</title>
    <link href="http://yoursite.com/2019/07/18/Objective-C%20Runtime%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E4%B9%8B%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B3%BB%E7%BB%9F%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92/"/>
    <id>http://yoursite.com/2019/07/18/Objective-C Runtime编程指南之与运行时系统进行交互/</id>
    <published>2019-07-18T03:26:14.107Z</published>
    <updated>2019-07-18T03:26:37.012Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtInteracting.html" target="_blank" rel="external">Interacting with the Runtime
</a></p>
</blockquote>
<h3 id="与运行时系统进行交互"><a href="#与运行时系统进行交互" class="headerlink" title="与运行时系统进行交互"></a>与运行时系统进行交互</h3><p>Objective-C程序通过三种不同方式与运行时系统进行交互：通过Objective-C代码；通过<em>Foundation</em>框架中定义在<em>NSObject</em>类中的方法；还有通过直接调用运行时的函数。</p>
<a id="more"></a>
<h4 id="Objective-C代码"><a href="#Objective-C代码" class="headerlink" title="Objective-C代码"></a>Objective-C代码</h4><p>对于绝大多数场景下，运行时系统会自动在幕后工作。你需要做的仅仅是编写和编译Objective-C代码即可。</p>
<p>当你编译包含Objective-C类和方法的代码时，编译器会创建对应的数据结构和方法调用来体现语言的动态性。这些数据结构会捕获到类、分类和协议声明中的相关信息；它们包含着在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163" target="_blank" rel="external">The Objective-C Programming Language</a>中<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocDefiningClasses.html#//apple_ref/doc/uid/TP30001163-CH12" target="_blank" rel="external">Defining a Class</a>和<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15" target="_blank" rel="external">Protocols</a>描述的类和协议对象，还有方法选择器、实例变量模板，还有从源代码中提取的其他信息等。最重要的运行时函数就是那个可以发送消息的对象，就像<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html#//apple_ref/doc/uid/TP40008048-CH104-SW1" target="_blank" rel="external">Messaging</a>中描述的一样。它通过源代码消息表达式进行调用。</p>
<h4 id="NSObject的方法"><a href="#NSObject的方法" class="headerlink" title="NSObject的方法"></a>NSObject的方法</h4><p>大多数Cocoa中的对象都是NSObject类的子类，因此大多数对象都继承了其中的方法（例外的是<em>NSProxy</em>类；更多信息请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1" target="_blank" rel="external">Message Forwarding</a>）。因此它的方法会表现出继承的实例和类的默认行为。可是，在某些情况下，NSObject类仅仅是定义了某些事如何做的一个模板；它自身并没有提供所有必要的代码。</p>
<p>例如，NSObject类定义了<em>description</em>实例方法来返回描述类内容的字符串。这个主要用于调试过程—-GDB对象打印命令打印出此方法返回的字符串。NSObject中此方法的实现并不知道本类包含的内容，因此该方法只返回了包含对象名称和内存地址的字符串。NSObject的子类可以实现此方法来返回更多信息。比如，Foundation的<em>NSArray</em>类会返回其包含的所有对象的描述信息。</p>
<p>一些NSObject中的方法只是向运行时系统查询信息。这些方法允许对象来进行”自省“（即查看自身的某些信息）。比如这些方法中的<em>class</em>方法，它让对象来识别出自身的类；<em>isKindOfClass:</em>和<em>isMemberOfClass:</em>，可以检测对象在继承链中的位置；<em>respondsToSelector:</em> 可以判定某对象是否可以接收指定消息；<em>conformsToProtocol:</em> 判定某对象是否声明已经实现了指定协议中的方法（即该类是否遵循了协议）；<em>methodForSelector:</em> 提供了方法实现的地址。形如这些方法都给予了对象检查自身的能力。</p>
<h4 id="运行时的函数"><a href="#运行时的函数" class="headerlink" title="运行时的函数"></a>运行时的函数</h4><p>运行时系统是一个带有公共接口的动态共享库，其内部由一系列函数和数据结构组成，公共接口定义在 <em>/usr/include/objc</em> 目录的头文件中。这些函数中的许多都允许你使用纯C语言来做那些编译器为Objective-C代码所做的事。其他一些则输出形成了NSObject类的基本功能。这些函数使为运行时系统开发其他接口或者为增强开发环境制作工具成为了可能；因为它们无需使用Objective-C进行编码。可是，一小部分的运行时函数也会在编写Objective-C代码时非常有用。所有这些函数都被记录在了<a href="https://developer.apple.com/documentation/objectivec/objective_c_runtime" target="_blank" rel="external">Objective-C Runtime Reference</a>中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtInteracting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Interacting with the Runtime
&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;与运行时系统进行交互&quot;&gt;&lt;a href=&quot;#与运行时系统进行交互&quot; class=&quot;headerlink&quot; title=&quot;与运行时系统进行交互&quot;&gt;&lt;/a&gt;与运行时系统进行交互&lt;/h3&gt;&lt;p&gt;Objective-C程序通过三种不同方式与运行时系统进行交互：通过Objective-C代码；通过&lt;em&gt;Foundation&lt;/em&gt;框架中定义在&lt;em&gt;NSObject&lt;/em&gt;类中的方法；还有通过直接调用运行时的函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》之树</title>
    <link href="http://yoursite.com/2019/04/12/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E4%B9%8B%E6%A0%91/"/>
    <id>http://yoursite.com/2019/04/12/《大话数据结构》之树/</id>
    <published>2019-04-12T15:10:28.591Z</published>
    <updated>2019-04-12T15:10:28.591Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>与线性结构的“一对一”不同，<strong>树是“一对多”的数据结构</strong>。</p>
<blockquote>
<p><strong>树是有限个结点n（n &gt;= 0）的集合</strong>。</p>
<ul>
<li>n为0时称为空树；</li>
<li>不为0时，<strong>有且只有一个结点作为树的根结点</strong>。</li>
<li>n大于1时，除根结点外的其他结点可以分为m（m &gt; 0）个互不相交的有限集合T1…Tm，每个子集合又是一棵树，称为子树。</li>
</ul>
</blockquote>
<a id="more"></a>
<p>下图即为一棵树：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554708278-%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5.jpg" alt="树"></p>
<h4 id="1-1-树的“度”"><a href="#1-1-树的“度”" class="headerlink" title="1.1 树的“度”"></a>1.1 树的“度”</h4><p><strong>每个结点包含的子结点的个数称为结点的“度”（degree）</strong>。<br>度为0的结点为“<em>叶子结点</em>”或“<em>终端结点</em>”；度不为0的结点称为“<em>分支结点</em>”或“<em>非终端结点</em>”。</p>
<p>我们将一棵树中所有子结点的“度”中的最大值称作<strong>树的度</strong>。</p>
<p>示意图中树的度为3（结点D的度最大，是3）。</p>
<h4 id="1-2-结点间的关系"><a href="#1-2-结点间的关系" class="headerlink" title="1.2 结点间的关系"></a>1.2 结点间的关系</h4><p>结点的子树中的根结点叫做该结点的<strong>孩子（Child）结点</strong>；该结点称为孩子的<strong>双亲（Parent）结点</strong>；同一双亲结点的子结点互为<strong>兄弟（Sibling）结点</strong>。</p>
<p>例如，在示意图中，结点D是B的孩子结点，C是B的兄弟结点，A是B的双亲结点。</p>
<blockquote>
<p>注：以下将双亲结点简称为“父结点”，孩子结点称为“子结点”。</p>
</blockquote>
<h4 id="1-3-树的“深度”"><a href="#1-3-树的“深度”" class="headerlink" title="1.3 树的“深度”"></a>1.3 树的“深度”</h4><p>从根结点开始，作为树的第一<strong>层（Level）</strong>；其子结点作为第二层，以此类推。</p>
<p><strong>树的最大层数称为该树的“深度”（Depth）</strong>。</p>
<p>由于示意图中的树分为四层，故其深度为4。其中，同一层的结点互为<strong>堂兄弟结点</strong>。如第三层的D、E和F结点。</p>
<h4 id="1-4-其他概念"><a href="#1-4-其他概念" class="headerlink" title="1.4 其他概念"></a>1.4 其他概念</h4><ol>
<li>若树从左至右为有序，且各子结点的顺序不可调换，则此树可以称为“<strong>有序树</strong>”。</li>
<li><strong>森林</strong>（Forest）是m（m &gt;= 0）棵互不相交的树的集合。</li>
</ol>
<h4 id="1-5-结构对比"><a href="#1-5-结构对比" class="headerlink" title="1.5 结构对比"></a>1.5 结构对比</h4><p>与线性结构的对比如下：</p>
<blockquote>
<p>线性结构：</p>
<ul>
<li>头元素：无前驱结点</li>
<li>尾元素：无后继结点</li>
<li>中间元素：一个前驱结点，一个后继结点</li>
</ul>
<p>树结构：</p>
<ul>
<li>根结点：无父结点，唯一</li>
<li>叶子结点：无子结点，自身可以有多个</li>
<li>分支结点：有父结点，存在1个或多个子结点</li>
</ul>
</blockquote>
<h3 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2. 存储结构"></a>2. 存储结构</h3><p>利用顺序和链式存储方式，我们可以将树的存储方式简单介绍三种：</p>
<ol>
<li>双亲表示法</li>
<li>孩子表示法</li>
<li>孩子兄弟表示法（二叉树）</li>
</ol>
<h4 id="2-1-双亲表示法"><a href="#2-1-双亲表示法" class="headerlink" title="2.1 双亲表示法"></a>2.1 双亲表示法</h4><p>双亲表示法使用顺序存储结构，将所有结点依次存储在连续的空间中。<br>最简单的就是使用一个parent域来标明自身的父结点。其结构如下：</p>
<table>
<thead>
<tr>
<th>data</th>
<th>parent</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据域</td>
<td>父结点索引（数组下标）</td>
</tr>
</tbody>
</table>
<p>以示意图为例，使用双亲表示法可以表示为：</p>
<table>
<thead>
<tr>
<th>下标</th>
<th>data</th>
<th>parent</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>A</td>
<td>-1</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>3</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>3</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>根据此存储方式，可以直接<strong>查询出每个子结点的父结点，其时间复杂度固定为O(1)</strong>。</p>
<p>可以根据需要，对结点的数据结构进行扩展：如添加指向第一个孩子结点的索引域firstChild；添加指向兄弟结点的索引域rightSib等。这种方式可以适时通过扩展并添加存储空间来提高访问效率。</p>
<h4 id="2-2-孩子表示法"><a href="#2-2-孩子表示法" class="headerlink" title="2.2 孩子表示法"></a>2.2 孩子表示法</h4><p>由于每个结点的子结点个数不确定，可以通过链表来表示每个结点下的子树。且由于我们在需要时可以方便地遍历树中的所有结点，可以考虑将所有结点保存在顺序存储结构中。故<strong>孩子表示法的具体方法为：把每个结点的孩子结点排列起来，以单链表为存储结构，则n个结点有n个孩子链表，如果该结点是叶子结点，则此单链表为空表。然后，将n个头指针又组成一个线性表，以顺序存储结构存储在一个一维数组中</strong>。</p>
<p>故示意图中的树，使用孩子表示法可以表示为：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554713216-%E6%A0%91--%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg" alt="树--孩子表示法"></p>
<p>其中结点分为两种：</p>
<ul>
<li>孩子链表中的孩子结点：</li>
</ul>
<table>
<thead>
<tr>
<th>child</th>
<th>next</th>
</tr>
</thead>
<tbody>
<tr>
<td>结点索引（顺序数组的下标）</td>
<td>兄弟结点索引</td>
</tr>
</tbody>
</table>
<ul>
<li>表头数组的表头结点</li>
</ul>
<table>
<thead>
<tr>
<th>data</th>
<th>firstChild</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据域</td>
<td>头指针域（存储对应孩子链表的头指针）</td>
</tr>
</tbody>
</table>
<p>对于此存储结构，要查找某结点的孩子结点，或查找某结点的兄弟结点，只要查找对应的孩子结点单链表即可。</p>
<h4 id="2-3-孩子兄弟表示法"><a href="#2-3-孩子兄弟表示法" class="headerlink" title="2.3 孩子兄弟表示法"></a>2.3 孩子兄弟表示法</h4><p><strong>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的</strong>。因此此节点包括两个指针域，分别指向该结点的第一个孩子结点和此结点的右兄弟结点。</p>
<table>
<thead>
<tr>
<th>data</th>
<th>firstChild</th>
<th>rightSib</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据域</td>
<td>第一个孩子结点的存储地址</td>
<td>右兄弟结点的存储地址</td>
</tr>
</tbody>
</table>
<p>故示意图中的树，使用孩子兄弟表示法可以表示为：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554728801-%E6%A0%91--%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg" alt="树--孩子兄弟表示法"></p>
<p>使用此方式，可以很方便地查找某结点的第几个子结点：只要找到该结点的第一个孩子结点后，依次查找其兄弟结点即可。</p>
<p>通过此种表示方法，我们可以发现，标准的树被转换成了<em>二叉树</em>表示（每个结点最多只有两个子结点）。</p>
<h3 id="3-二叉树"><a href="#3-二叉树" class="headerlink" title="3. 二叉树"></a>3. 二叉树</h3><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h4><ul>
<li><strong>每个结点最多有两棵子树（子结点），故二叉树的度不超过2</strong>。</li>
<li><strong>左右子树有序，不能颠倒</strong>。</li>
<li><strong>结点若只有一棵子树，也要区分是左还是右子树</strong>。</li>
</ul>
<p>如下图，二者是两棵不同的二叉树：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554791292-%E6%A0%91--%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8C%BA%E5%88%86.jpg" alt="树--二叉树区分"></p>
<h4 id="3-2-存储结构"><a href="#3-2-存储结构" class="headerlink" title="3.2 存储结构"></a>3.2 存储结构</h4><h5 id="3-2-1-顺序存储结构"><a href="#3-2-1-顺序存储结构" class="headerlink" title="3.2.1 顺序存储结构"></a>3.2.1 顺序存储结构</h5><p><strong>二叉树的顺序存储结构一般只适用于<em>完全二叉树</em></strong>。</p>
<blockquote>
<p>完全二叉树：</p>
<ul>
<li>叶子结点只出现在二叉树的最后两层</li>
<li>最后一层的叶子结点都是左结点；倒数第二层的叶子结点都是右结点</li>
<li>满二叉树（只有最后一层存在，且全都是叶子结点的二叉树）属于完全二叉树</li>
</ul>
</blockquote>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554792962-%E6%A0%91--%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.jpg" alt="树--二叉树的顺序存储"></p>
<p>如图所示，用一维数组存储二叉树的所有结点，通过数组下标来提现二叉树中结点间的关系。<br>但是，当二叉树中有过多空余结点（如图中的黄色不存在结点）时会导致空间浪费，故一般只使用顺序结构存储完全二叉树。</p>
<h5 id="3-2-2-链式存储结构–二叉链表"><a href="#3-2-2-链式存储结构–二叉链表" class="headerlink" title="3.2.2 链式存储结构–二叉链表"></a>3.2.2 链式存储结构–二叉链表</h5><p>二叉链表：<strong>每个数据节点包含本身的数据域和两个指针域</strong>，分别指向两个可能的孩子结点，这种结点组成的链表称为二叉链表。</p>
<p>结点结构如下：</p>
<table>
<thead>
<tr>
<th>lchild</th>
<th>data</th>
<th>rchild</th>
</tr>
</thead>
<tbody>
<tr>
<td>左孩子结点的存储地址</td>
<td>数据域</td>
<td>右孩子结点的存储地址</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 二叉链表的结点结构体 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></div><div class="line">    TElemType data; <span class="comment">// 数据域</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>;</span> <span class="comment">// 左孩子结点指针</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">rchild</span>;</span> <span class="comment">// 右孩子结点指针</span></div><div class="line">&#125; BiTNode, *BiTree;</div></pre></td></tr></table></figure>
<p>下图为二叉链表的表述示意图：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554794334-%E6%A0%91--%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.jpg" alt="树--二叉链表"></p>
<h4 id="3-3-二叉树的遍历"><a href="#3-3-二叉树的遍历" class="headerlink" title="3.3 二叉树的遍历"></a>3.3 二叉树的遍历</h4><blockquote>
<p>二叉树的遍历（traversing binary tree）是指从根结点出发，<strong>按照某种次序依次访问</strong>二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。</p>
</blockquote>
<p>若以从左到右方向限定，主要的遍历方式分为以下四种：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历</li>
</ul>
<p>与定义<strong>二叉树</strong>的方式一样，其遍历也是以<strong>递归</strong>的方式进行。</p>
<h5 id="3-3-1-前序遍历"><a href="#3-3-1-前序遍历" class="headerlink" title="3.3.1 前序遍历"></a>3.3.1 前序遍历</h5><p>遍历方式：<strong>先访问根节点，然后前序遍历左子树，再前序遍历右子树</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 访问根节点</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</div><div class="line">    <span class="comment">// 遍历左子树</span></div><div class="line">    PreOrderTraverse(T-&gt;lchild);</div><div class="line">    <span class="comment">// 遍历右子树</span></div><div class="line">    PreOrderTraverse(T-&gt;rchild);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-3-2-中序遍历"><a href="#3-3-2-中序遍历" class="headerlink" title="3.3.2 中序遍历"></a>3.3.2 中序遍历</h5><p>遍历方式：<strong>先中序遍历根节点的左子树，然后是根节点，再中序遍历右子树</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 遍历左子树</span></div><div class="line">    InOrderTraverse(T-&gt;lchild);</div><div class="line">    <span class="comment">// 访问根节点</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</div><div class="line">    <span class="comment">// 遍历右子树</span></div><div class="line">    InOrderTraverse(T-&gt;rchild);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-3-3-后续遍历"><a href="#3-3-3-后续遍历" class="headerlink" title="3.3.3 后续遍历"></a>3.3.3 后续遍历</h5><p>遍历方式：<strong>从左到右，先叶子后结点，全部访问完左右子树后，最后访问根结点</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 遍历左子树</span></div><div class="line">    PostOrderTraverse(T-&gt;lchild);</div><div class="line">    <span class="comment">// 遍历右子树</span></div><div class="line">    PostOrderTraverse(T-&gt;rchild);</div><div class="line">    <span class="comment">// 访问根节点</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-4-二叉树的创建"><a href="#3-4-二叉树的创建" class="headerlink" title="3.4 二叉树的创建"></a>3.4 二叉树的创建</h4><p>这里以前序方式创建。与前序遍历相同，创建时按照前序遍历的方式依次递归输入结点数据即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 创建二叉树【前序遍历法创建：根--左--右】 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span> </span>&#123;</div><div class="line">    TElemType ch;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</div><div class="line">    <span class="keyword">if</span> (ch == <span class="string">'#'</span>) &#123;</div><div class="line">        *T = <span class="literal">NULL</span>; <span class="comment">// 代表此结点位置无数据（数据为空）</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 分配空间，创建新结点</span></div><div class="line">        *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</div><div class="line">        <span class="comment">// 内存分配失败，退出</span></div><div class="line">        <span class="keyword">if</span> (!*T) &#123;</div><div class="line">            <span class="built_in">exit</span>(OVERFLOW);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 前序遍历方式赋值</span></div><div class="line">        </div><div class="line">        <span class="comment">// 1. 赋值根节点</span></div><div class="line">        (*T)-&gt;data = ch;</div><div class="line">        <span class="comment">// 2. 左孩子结点递归</span></div><div class="line">        CreateBiTree(&amp;((*T)-&gt;lchild));</div><div class="line">        <span class="comment">// 3. 右孩子结点递归</span></div><div class="line">        CreateBiTree(&amp;((*T)-&gt;rchild));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下图所示，依照代码，先<strong>将给定的二叉树转化为<em>扩展二叉树</em></strong>。</p>
<blockquote>
<p>扩展二叉树：<br>将给定的二叉树的每个结点的空指针设置一个虚拟结点，并指定一个特殊值（这里定义为“#”）。</p>
</blockquote>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554827002-%E6%A0%91--%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA.jpg" alt="树--二叉树的创建"></p>
<blockquote>
<p>二叉树的创建与三种遍历方式，可查看此示例：<a href="https://github.com/Choujiji/PlayWithDataStructure-Code/tree/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="external">项目地址</a></p>
</blockquote>
<h4 id="3-5-线索二叉树"><a href="#3-5-线索二叉树" class="headerlink" title="3.5 线索二叉树"></a>3.5 线索二叉树</h4><h5 id="3-5-1-线索化过程"><a href="#3-5-1-线索化过程" class="headerlink" title="3.5.1 线索化过程"></a>3.5.1 线索化过程</h5><p>此二叉链表虽然功能强大，但弱点显而易见：就是<strong>每次只能通过指定方式的遍历，才可以确定每个结点的前趋结点和后缀结点</strong>。而且我们可以发现，在下面的二叉链表示意图中，有n+1（即2n个总lchild和rchild指针个数 与 n-1个连线 的差）个空余指针域（存储的是“^”），随着二叉树的增长，浪费的空间会越来越多。</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554794334-%E6%A0%91--%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.jpg" alt="树--二叉链表"></p>
<p>因此，<strong>我们可以使用这些空余空间来保存每个结点的前趋和后继结点的信息，以解决上述问题。而解决此问题的过程，叫做线索化，线索化后的二叉链表叫做线索链表，对应的树叫做线索二叉树</strong>。</p>
<p>具体做法是：<strong>在使用某种顺序遍历每个结点时，若没有左孩子结点，其lchild保存的是前趋结点的指针；若没有右孩子结点，其rchild保存的是后继结点的指针</strong>。</p>
<p>如上图中的二叉树，其中序遍历后的结果为HDIBJEAFCG，根据遍历结果对该二叉链表进行线索化的结果如下：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554880420-%E6%A0%91--%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%911.jpg" alt="树--线索二叉树1"></p>
<p>可以看到，通过线索化，不仅解决了空间浪费问题，还解决了前趋和后继结点的记录问题，提高了访问效率。</p>
<h5 id="3-5-2-区分结点类型"><a href="#3-5-2-区分结点类型" class="headerlink" title="3.5.2 区分结点类型"></a>3.5.2 区分结点类型</h5><p>此时线索二叉树还存在一个问题：我们<strong>无法区分lchild指向的结点是前趋结点还是左孩子节点</strong>，对于rchild也是如此。</p>
<p>此时，<strong>需要针对每个指针域分别设置一个布尔类型的数据域，在线索化的过程中，根据实际情况进行区分（是前趋或后继结点时为1，是孩子结点时为0）</strong>。</p>
<p>结点结构如下：</p>
<table>
<thead>
<tr>
<th>左孩子结点地址</th>
<th>左标识符</th>
<th>数据域</th>
<th>右标识符</th>
<th>右孩子结点地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>lchild</td>
<td>ltag</td>
<td>data</td>
<td>rtag</td>
<td>rchild</td>
</tr>
</tbody>
</table>
<p>对应实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 枚举变量，用于标识符赋值 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</div><div class="line">    <span class="comment">/** 是孩子结点 */</span></div><div class="line">    Link,</div><div class="line">    <span class="comment">/** 是前趋或后缀结点 */</span></div><div class="line">    Thread</div><div class="line">&#125; PointerTag;</div><div class="line"></div><div class="line"><span class="comment">/** 线索二叉树结点结构 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> &#123;</span></div><div class="line">    <span class="comment">/** 数据域 */</span></div><div class="line">    TElemType data;</div><div class="line">    <span class="comment">/** 左结点指针 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>;</span></div><div class="line">    <span class="comment">/** 左结点标识符 */</span></div><div class="line">    PointerTag LTag;</div><div class="line">    <span class="comment">/** 右结点指针 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">rchild</span>;</span></div><div class="line">    <span class="comment">/** 右结点标识符 */</span></div><div class="line">    PointerTag RTag;</div><div class="line">&#125; BiThrNode, *BiThrTree; <span class="comment">// 定义为线索二叉树结点及线索二叉树指针</span></div></pre></td></tr></table></figure>
<p>添加结点类型区分后的线索二叉树如下：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554886236-%E6%A0%91--%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%912.jpg" alt="树--线索二叉树2"></p>
<p>这样在访问指定节点时，根据ltag和rtag的值即可区分相邻结点是前趋后继结点或是孩子结点了。</p>
<p>线索化过程的代码如下（这里使用中序遍历方式）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 当前访问节点 */</span></div><div class="line">BiThrTree currentP = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="comment">/** 中序遍历线索化 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!p) &#123;</div><div class="line">        <span class="comment">// 结点不存在，返回</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!p-&gt;lchild &amp;&amp; !p-&gt;rchild) &#123;</div><div class="line">        <span class="comment">// 左右子结点均不存在，即是叶子结点【防止最后一个结点无修改RTag】</span></div><div class="line">        p-&gt;LTag = Thread;</div><div class="line">        p-&gt;RTag = Thread;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 递归线索化左结点</span></div><div class="line">    InThreading(p-&gt;lchild);</div><div class="line">    </div><div class="line">    <span class="comment">// 自身数据线索化（由于是中序遍历【左--中--右】，此时右结点还没有访问到，故只处理当前和前一个结点即可）</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!(p-&gt;lchild)) &#123;</div><div class="line">        <span class="comment">// 左结点为空，即没有左孩子，故当前指向前趋结点</span></div><div class="line">        p-&gt;LTag = Thread;</div><div class="line">        p-&gt;lchild = currentP;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 包含左孩子</span></div><div class="line">        p-&gt;LTag = Link;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (currentP) &#123;</div><div class="line">        <span class="keyword">if</span> (!(currentP-&gt;rchild)) &#123;</div><div class="line">            <span class="comment">// 前一个结点的右结点指针为空，即没有右孩子，故指向后继结点（当前结点）</span></div><div class="line">            currentP-&gt;RTag = Thread;</div><div class="line">            currentP-&gt;rchild = p;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 包含右孩子</span></div><div class="line">            currentP-&gt;RTag = Link;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 记录当前结点</span></div><div class="line">    currentP = p;</div><div class="line">    </div><div class="line">    <span class="comment">// 递归线索化右结点</span></div><div class="line">    InThreading(p-&gt;rchild);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由上图即可看出，如果在二叉树的根结点之前再插入一个头结点，此时的<strong>线索二叉树实际上就是一个双向链表结构</strong>。其结构示意图如下：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554973426-%E6%A0%91--%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%913.jpg" alt="树--线索二叉树3"></p>
<p>插入头结点的简单方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 向线索二叉树中插入头结点 */</span></div><div class="line"><span class="function">BiThrTree <span class="title">insertHeadNodeToBiThrTree</span><span class="params">(BiThrTree biTree)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (biTree == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建头节点</span></div><div class="line">    BiThrTree headNode = (BiThrTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode));</div><div class="line">    <span class="comment">// 左孩子指向线索二叉树的根结点</span></div><div class="line">    headNode-&gt;lchild = biTree;</div><div class="line">    headNode-&gt;LTag = Link;</div><div class="line">    <span class="comment">// 右孩子指向中序遍历的最后一个结点</span></div><div class="line">    BiThrTree inOrderTailNode = biTree;</div><div class="line">    <span class="keyword">while</span> (inOrderTailNode-&gt;RTag == Link) &#123;</div><div class="line">        inOrderTailNode = inOrderTailNode-&gt;rchild;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 此时inOrderTailNode即为最后一个结点</span></div><div class="line">    headNode-&gt;rchild = inOrderTailNode;</div><div class="line">    headNode-&gt;RTag = Thread; <span class="comment">// 并不是右孩子</span></div><div class="line">    </div><div class="line">    <span class="comment">// targetNode的后继结点指向头结点</span></div><div class="line">    inOrderTailNode-&gt;rchild = headNode;</div><div class="line">    </div><div class="line">    <span class="comment">// 中序遍历的第一个结点的前趋结点指向头结点</span></div><div class="line">    BiThrTree inOrderFirstNode = biTree;</div><div class="line">    <span class="keyword">while</span> (inOrderFirstNode-&gt;LTag == Link) &#123;</div><div class="line">        inOrderFirstNode = inOrderFirstNode-&gt;lchild;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 此时inOrderFirstNode即为第一个结点</span></div><div class="line">    inOrderFirstNode-&gt;lchild = headNode;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> headNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终，通过访问双向链表的方式，中序遍历输出此二叉树的方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 中序遍历【扫描二叉链表方式】 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span> </span>&#123;</div><div class="line">    <span class="comment">// 中序遍历，即从头结点开始扫描，</span></div><div class="line">    <span class="comment">// 1. 首先找到最左边的结点（没有左孩子的），</span></div><div class="line">    <span class="comment">// 2. 然后找其后继结点（子树的根），</span></div><div class="line">    <span class="comment">// 3. 最后是其右结点（右孩子或后继）</span></div><div class="line">    <span class="comment">// 直到扫描到的结点是头结点，结束</span></div><div class="line">    </div><div class="line">    <span class="comment">// 指向根结点（从根结点开始）</span></div><div class="line">    BiThrTree currentNode = T-&gt;lchild;</div><div class="line">    </div><div class="line">    <span class="comment">// 遍历结束时，指向头结点</span></div><div class="line">    <span class="keyword">while</span> (currentNode != T) &#123;</div><div class="line">        <span class="comment">// 1. 找到当前子树最左边的结点（没有左孩子的）</span></div><div class="line">        <span class="keyword">while</span> (currentNode-&gt;LTag == Link) &#123;</div><div class="line">            <span class="comment">// 有左孩子，继续查找</span></div><div class="line">            currentNode = currentNode-&gt;lchild;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 找到了最左边的结点，输出</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%hhd "</span>, currentNode-&gt;data);</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 一直向后找到所有后继结点（即对应子树的根）</span></div><div class="line">        <span class="keyword">while</span> (currentNode-&gt;RTag == Thread &amp;&amp; currentNode-&gt;rchild != T) &#123;</div><div class="line">            currentNode = currentNode-&gt;rchild;</div><div class="line">            <span class="comment">// 找到了后继结点，输出</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%hhd "</span>, currentNode-&gt;data);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 3. 指向右结点（下一个结点，不管结点类型，准备下次循环）</span></div><div class="line">        currentNode = currentNode-&gt;rchild;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>线索化及遍历的完整过程，可查看此示例：<a href="https://github.com/Choujiji/PlayWithDataStructure-Code/tree/master/%E6%A0%91/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/ThreadedBinaryTree" target="_blank" rel="external">项目地址</a></p>
</blockquote>
<h4 id="3-6-树、森林转换为二叉树"><a href="#3-6-树、森林转换为二叉树" class="headerlink" title="3.6 树、森林转换为二叉树"></a>3.6 树、森林转换为二叉树</h4><p>由于二叉树的结构稳定（每个结点只有左右两个孩子），其性质也容易研究，故在某些情况下，将普通的树甚至森林转换为二叉树即可对它们进行问题的研究（如遍历等）。</p>
<h5 id="3-6-1-树-gt-二叉树"><a href="#3-6-1-树-gt-二叉树" class="headerlink" title="3.6.1 树 =&gt; 二叉树"></a>3.6.1 树 =&gt; 二叉树</h5><p>转换规则：</p>
<ol>
<li><strong>在兄弟结点与其左方的结点之间添加连接线</strong>。</li>
<li><strong>在结点的所有子孩子中，除了左边第一个孩子结点外，其他所有兄弟孩子结点与父结点间的连线去除</strong>。</li>
<li><strong>调整层次，结点的第一个子孩子作为二叉的左孩子，兄弟孩子作为“前一个”结点的右孩子</strong>。</li>
</ol>
<p>示例：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555052420-%E6%A0%91--%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="树--树转换二叉树"></p>
<p>转换过程：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555052792-%E6%A0%91--%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%912.jpg" alt="树--树转换二叉树2"></p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555052889-%E6%A0%91--%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%913.jpg" alt="树--树转换二叉树3"></p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555053130-%E6%A0%91--%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%914.jpg" alt="树--树转换二叉树4"></p>
<h5 id="3-6-2-森林-gt-二叉树"><a href="#3-6-2-森林-gt-二叉树" class="headerlink" title="3.6.2 森林 =&gt; 二叉树"></a>3.6.2 森林 =&gt; 二叉树</h5><p>可以将森林中的每一棵树看做是兄弟，利用兄弟结点的合并方式（作为前一个结点的右孩子）进行合并，最终合成一棵二叉树：</p>
<ol>
<li><strong>把每一棵树转换为二叉树</strong>。</li>
<li><strong>依次将后一棵树的根结点作为前一棵树的根结点的右孩子。连线完成后，即可得到合成的二叉树</strong>。</li>
</ol>
<p>示例：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555054041-%E6%A0%91--%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="树--森林转二叉树"></p>
<p>转换过程：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555054266-%E6%A0%91--%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%912.jpg" alt="树--森林转二叉树2"></p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555054387-%E6%A0%91--%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%913.jpg" alt="树--森林转二叉树3"></p>
<h4 id="3-7-赫夫曼树及霍夫曼编码"><a href="#3-7-赫夫曼树及霍夫曼编码" class="headerlink" title="3.7 赫夫曼树及霍夫曼编码"></a>3.7 赫夫曼树及霍夫曼编码</h4><h5 id="3-7-1-概念介绍"><a href="#3-7-1-概念介绍" class="headerlink" title="3.7.1 概念介绍"></a>3.7.1 概念介绍</h5><p>赫夫曼树是在二叉树的基础上设计而来。赫夫曼树的每个叶子结点都包含对应的权值（Weight）。<em>两个结点之间经过的所有分支叫做路径，路径上分支的个数叫做路径长度</em>。<strong>树的路径长度就是从<em>根结点</em>到<em>每个叶子结点</em>的路径长度的总和</strong>。</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555056066-%E6%A0%91--%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91.jpg" alt="树--赫夫曼树"></p>
<p>图中的二叉树的路径长度为（以A-E的顺序）：3 + 3 + 2 + 2 + 2 = 12。</p>
<p>霍夫曼树需要引入权的概念，故我们得到了带权路径的算法：<br><strong>结点的带权路径 = 结点从根到自身的路径长度 * 自身权重</strong></p>
<p>因此<strong>树的带权路径长度即为所有叶子结点带权路径的总和</strong>，称作<strong>WPL</strong>。</p>
<p>图中二叉树的WPL为：3 <em> 5 + 3 </em> 15 + 2 <em> 40 + 2 </em> 30 + 2 * 10 = 220。</p>
<p><strong>在带有权重的一组叶子结点所组成的二叉树中，WPL最小的可称作霍夫曼树</strong>。</p>
<h5 id="3-7-2-生成方法"><a href="#3-7-2-生成方法" class="headerlink" title="3.7.2 生成方法"></a>3.7.2 生成方法</h5><ol>
<li>将所有结点按照权值升序排列，生成有序树集合（每棵树即为单独的叶子结点）。</li>
<li>取前两棵树（权值最小）作为左右子树，生成新二叉树，其根结点的权值为原两树权值之和。</li>
<li>在集合中使用新的二叉树替换原始的两棵树并重新排序。</li>
<li>重复步骤2和3，直到序列只剩下一棵树为止，此树即为霍夫曼树。</li>
</ol>
<p>示例：</p>
<table>
<thead>
<tr>
<th>结点</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>权值</td>
<td>5</td>
<td>15</td>
<td>40</td>
<td>30</td>
<td>10</td>
</tr>
</tbody>
</table>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555062192-%E6%A0%91--%E7%94%9F%E6%88%90%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91.jpg" alt="树--生成霍夫曼树"></p>
<h5 id="3-7-3-霍夫曼编码"><a href="#3-7-3-霍夫曼编码" class="headerlink" title="3.7.3 霍夫曼编码"></a>3.7.3 霍夫曼编码</h5><p><strong>将霍夫曼树中所有结点（包括合成结点）的权值改为0和1（左分支权值为0，右分支权值为1），这样从根结点到指定叶子结点所生成的0和1序列即为霍夫曼编码</strong>。</p>
<p>上面的霍夫曼树转换后的结果为：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555066450-%E6%A0%91--%E8%BD%AC%E5%8C%96%E5%90%8E%E7%9A%84%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91.jpg" alt="树--转化后的霍夫曼树"></p>
<p>因此，图中每个字符所生成的霍夫曼编码如下：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>霍夫曼编码</td>
<td>1000</td>
<td>101</td>
<td>0</td>
<td>11</td>
<td>1001</td>
</tr>
</tbody>
</table>
<p><strong>霍夫曼编码可以用来压缩数据，进而提高了传输效率</strong>。</p>
<p>假设传输”BADBEC“这个字符串，使用传统的等长编码，可能会使用如下方式：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>等长编码</td>
<td>100</td>
<td>101</td>
<td>010</td>
<td>011</td>
<td>110</td>
</tr>
</tbody>
</table>
<p>故在此方式下，编码后的数据为”101100011101110010“，长度为18位；而使用霍夫曼编码，编码后的数据为”1011000101101110“，长度仅为16位，故数据得到了压缩。且随着编码字符的增多，霍夫曼编码的数据优势会越来越大。</p>
<p>像霍夫曼编码这样<strong>长短不一的编码方式，由于容易混淆，故必须设计成任一字符的编码都不是其他字符编码的前缀（否则解码时无法区分），这种编码方式叫做前缀编码</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h3&gt;&lt;p&gt;与线性结构的“一对一”不同，&lt;strong&gt;树是“一对多”的数据结构&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;树是有限个结点n（n &amp;gt;= 0）的集合&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n为0时称为空树；&lt;/li&gt;
&lt;li&gt;不为0时，&lt;strong&gt;有且只有一个结点作为树的根结点&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;n大于1时，除根结点外的其他结点可以分为m（m &amp;gt; 0）个互不相交的有限集合T1…Tm，每个子集合又是一棵树，称为子树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>STMAssembleView源码学习</title>
    <link href="http://yoursite.com/2019/03/24/STMAssembleView%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/03/24/STMAssembleView源码学习/</id>
    <published>2019-03-24T05:33:40.517Z</published>
    <updated>2019-03-24T05:33:53.681Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目地址：<a href="https://github.com/ming1016/STMAssembleView" target="_blank" rel="external">STMAssembleView</a></p>
</blockquote>
<h4 id="1-结构设计简洁"><a href="#1-结构设计简洁" class="headerlink" title="1. 结构设计简洁"></a>1. 结构设计简洁</h4><ul>
<li><strong>只公开最外层的STMAssembleView类，调用者只需引入一个类即可使用</strong>。</li>
<li><strong>将业务与功能解耦，生成对应的类：“View”视图类（STMAssembleView、STMPartView）与“Maker”类（STMAssemvleMaker、STMPartMaker）</strong>。“Maker”类负责抽象出支持的功能属性，“View”类通过使用Maker，将子功能进行组合并实现最终业务功能（视图配置）。</li>
</ul>
<a id="more"></a>
<h4 id="2-代码设计巧妙"><a href="#2-代码设计巧妙" class="headerlink" title="2. 代码设计巧妙"></a>2. 代码设计巧妙</h4><ul>
<li>对于“Maker”类，属性用于提供给调用者进行配置调用（即只使用getter），而<strong>属性的setter则另提供配套的设置方法，且设置方法返回的是对应“Maker”类型的Block对象，以实现链式调用</strong>。例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// STMAssembleMaker.m</span></div><div class="line"></div><div class="line">- (STMAssembleMaker *(^)(STMAssembleAlignment))alignmentEqualTo &#123;</div><div class="line">    <span class="keyword">return</span> ^STMAssembleMaker *(STMAssembleAlignment alignment) &#123;</div><div class="line">        <span class="comment">// jiji - 设置对齐方式</span></div><div class="line">        self.alignment = alignment;</div><div class="line">        <span class="keyword">return</span> self;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// 调用时</span></div><div class="line">make.alignmentEqualTo(STMAssembleAlignmentCenter);</div></pre></td></tr></table></figure>
<blockquote>
<p>如代码所示：</p>
<p>由于方法<em>alignmentEqualTo</em>返回的是Block对象，调用方法时，通过添加()即直接隐含执行了Block。且由于Block执行后返回的仍然为make自身，可以在后面继续连续调用其他实例方法，实现了链式调用。</p>
</blockquote>
<ul>
<li><strong>使用__weak指针，防止Block对象导致的内存引用循环</strong>。如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// STMAssembleMaker.m</span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)fsAsync:(NSString *)<span class="built_in">string</span> objects:(NSDictionary *)objs completion:(ParsingFormatStringCompleteBlock)completeBlock&#123;</div><div class="line">    __weak __typeof(<span class="built_in">string</span>) weakString = <span class="built_in">string</span>; <span class="comment">// 弱指针，防止Block执行时对该对象强引用</span></div><div class="line">    __weak __typeof(objs) weakObjs = objs;</div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), ^&#123;</div><div class="line">        __strong __typeof(weakString) strongString = weakString; <span class="comment">// 声明临时的__strong指针并指向__weak指向的对象，可以保证在Block执行过程中该对象不被释放。</span></div><div class="line">        __strong __typeof(weakObjs) strongObjs = weakObjs;</div><div class="line">        <span class="keyword">if</span> (strongString) &#123;</div><div class="line">            [STMAssembleView createViewWithFormatString:strongString objects:strongObjs completion:completeBlock];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如代码所示：</p>
<p>使用<strong>weak和</strong>strong指针的情况在Block声明时具有统一性，可以很好地避免引用循环的产生，且能保证在Block执行时捕获对象的有效性。</p>
<p>注：在单独使用GCD时，由于dispatch_async的Block会在执行后进行release，理论上可以不必担心循环引用的问题。这里铭神这样做的目的是保证自身不会保留传入的对象，需要调用者自己负责参数的生命周期。</p>
</blockquote>
<h4 id="3-知识点："><a href="#3-知识点：" class="headerlink" title="3. 知识点："></a>3. 知识点：</h4><h5 id="3-1-字符串的扫描处理"><a href="#3-1-字符串的扫描处理" class="headerlink" title="3.1 字符串的扫描处理"></a>3.1 字符串的扫描处理</h5><p>使用了<em>NSScanner</em>类对字符串进行扫描，按需将扫描结果进行归类，完成描述字符串的解析（后面根据解析结果调用对应的“View”类进行处理，生成页面）。</p>
<h5 id="3-2-使用变参合成字符串"><a href="#3-2-使用变参合成字符串" class="headerlink" title="3.2 使用变参合成字符串"></a>3.2 使用变参合成字符串</h5><p>使用va_list指向变参列表的第一个参数地址，通过NSString合成出完整字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//宏</span></div><div class="line"><span class="function">NSString *<span class="title">ASS</span><span class="params">(NSString *format, ...)</span> </span>&#123;</div><div class="line">    <span class="comment">// jiji - 声明变参指针</span></div><div class="line">    va_list args;</div><div class="line">    <span class="keyword">if</span> (format) &#123;</div><div class="line">        <span class="comment">// jiji - 初始化变参指针（指向第一个参数的地址，如这里的format的地址）</span></div><div class="line">        va_start(args, format);</div><div class="line">        </div><div class="line">        <span class="comment">// jiji - NSString直接通过变参指针读取并生成字符串</span></div><div class="line">        NSString *str = [[NSString alloc] initWithFormat:format arguments:args];</div><div class="line">        </div><div class="line">        <span class="comment">// jiji - 清除变参指针对象</span></div><div class="line">        va_end(args);</div><div class="line">        <span class="keyword">return</span> str;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> @<span class="string">""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/ming1016/STMAssembleView&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;STMAssembleView&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-结构设计简洁&quot;&gt;&lt;a href=&quot;#1-结构设计简洁&quot; class=&quot;headerlink&quot; title=&quot;1. 结构设计简洁&quot;&gt;&lt;/a&gt;1. 结构设计简洁&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;只公开最外层的STMAssembleView类，调用者只需引入一个类即可使用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将业务与功能解耦，生成对应的类：“View”视图类（STMAssembleView、STMPartView）与“Maker”类（STMAssemvleMaker、STMPartMaker）&lt;/strong&gt;。“Maker”类负责抽象出支持的功能属性，“View”类通过使用Maker，将子功能进行组合并实现最终业务功能（视图配置）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>出现“ld：library not found for -lPods”的解决办法</title>
    <link href="http://yoursite.com/2019/03/20/%E5%B7%A5%E7%A8%8B%E5%AE%89%E8%A3%85CocoaPods%E5%90%8E%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/20/工程安装CocoaPods后错误的解决办法/</id>
    <published>2019-03-20T02:57:18.103Z</published>
    <updated>2019-03-20T03:01:20.946Z</updated>
    
    <content type="html"><![CDATA[<p>有的时候，下载的使用CocoaPods配置的工程时，使用“pod install”后，编译时会遇到“<strong>ld: library not found for -lPods</strong>”错误。可以按如下方式试着解决：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/450996-85fee0ff00dcf0b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ld- library not found for -lPods.jpg"></p>
<a id="more"></a>
<p>如图所示，在当前<strong>Target</strong>的<strong>Build Phrase</strong>选项视图中，编辑<strong>Link Binary With Libraries</strong>选项。<strong>移除其中的“libPods.a”</strong>，只保留对应Target打包出的.a文件（添加.a文件时，主工程目录中Frameworks下回自动引入libPods.a依赖，如下图所示）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/450996-24c7e3e8e4d6a410.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Frameworks目录.jpg"></p>
<p>再进行编译一般就会解决问题。</p>
<blockquote>
<p>注：<br>此问题一般来说是由于原工程使用的是老版本的CocoaPods，通过新版CocoaPods安装配置后出现的问题。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有的时候，下载的使用CocoaPods配置的工程时，使用“pod install”后，编译时会遇到“&lt;strong&gt;ld: library not found for -lPods&lt;/strong&gt;”错误。可以按如下方式试着解决：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/450996-85fee0ff00dcf0b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ld- library not found for -lPods.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout的生命周期</title>
    <link href="http://yoursite.com/2019/03/19/Autolayout%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/03/19/Autolayout的生命周期/</id>
    <published>2019-03-19T08:37:21.285Z</published>
    <updated>2019-03-19T08:38:38.827Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/450996-247348e79ae353ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Autolayout生命周期.jpg"></p>
<p>上图即为Autolayout的生命周期过程（截取自<a href="https://developer.apple.com/videos/play/wwdc2015/219/" target="_blank" rel="external">219_mysteries_of_auto_layout_part_2</a>）。</p>
<a id="more"></a>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ol>
<li>APP启动后，随着<strong>RunLoop</strong>的运行，系统<strong>在其内部监听着约束变化（Constraints Change）</strong>：如激活或失效约束、修改优先级、修改常量值等任意造成约束方程式修改的操作，甚至是直接添加或删除视图等操作，都可以导致约束发生变化。</li>
<li>在接收到布局变化后，Layout Engine会根据变化的约束重新计算布局，并将需要更新布局的视图进行标记（<strong>对其父视图调用setNeedsLayout方法</strong>），之后便进入延迟布局阶段（Deffered Layout Pass）。<blockquote>
<p>注意：</p>
<p>在进入延迟布局阶段之前，Layout Engine已经将更新的约束计算完毕并将视图的新frame求出。但并不在此时更新视图。</p>
</blockquote>
</li>
<li>延迟布局阶段：此阶段的主要作用是将错误位置的视图重新定位（Reposition misplaced views）。其在视图层级中执行，分为两步：<ul>
<li>更新约束：<strong>从下往上（子视图到父视图），依次遍历视图层级，调用View的updateConstraints方法（或ViewController的updateViewConstraints方法）来更新约束</strong>（你可以在此覆盖本方法来设置自定义约束，且在此设置时，执行效率最高。记得最后调用父类实现）。</li>
<li>给视图及子视图重新设定位置（给view的frame赋值）：<strong>从上到下依次调用View的layoutSubViews方法（或ViewController的viewLayoutSubViews方法），从Layout Engine中取出预算好的frame进行赋值</strong>（你可以覆盖此方法实现自定义布局，不过此刻不是稳态，需要在适合时候调用父类实现）。</li>
</ul>
</li>
</ol>
<h4 id="延迟布局阶段的触发条件"><a href="#延迟布局阶段的触发条件" class="headerlink" title="延迟布局阶段的触发条件"></a>延迟布局阶段的触发条件</h4><table>
<thead>
<tr>
<th>调用方法</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>setNeedsUpdateConstraints</td>
<td>下一次loop执行updateConstraints</td>
</tr>
<tr>
<td>updateConstraintsIfNeeded</td>
<td>立即执行updateConstraints</td>
</tr>
<tr>
<td>setNeedsLayout</td>
<td>下一次loop执行layoutSubViews</td>
</tr>
<tr>
<td>layoutIfNeeded</td>
<td>立即执行layoutSubViews</td>
</tr>
<tr>
<td>setNeedDisplay</td>
<td>下一次loop执行draw</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/450996-247348e79ae353ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Autolayout生命周期.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图即为Autolayout的生命周期过程（截取自&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/219/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;219_mysteries_of_auto_layout_part_2&lt;/a&gt;）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》之串</title>
    <link href="http://yoursite.com/2019/03/17/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E4%B9%8B%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/03/17/《大话数据结构》之串/</id>
    <published>2019-03-17T10:10:44.688Z</published>
    <updated>2019-03-17T15:47:25.356Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-朴素的字符串匹配方法"><a href="#1-朴素的字符串匹配方法" class="headerlink" title="1. 朴素的字符串匹配方法"></a>1. 朴素的字符串匹配方法</h3><h4 id="1-1-比较过程"><a href="#1-1-比较过程" class="headerlink" title="1.1 比较过程"></a>1.1 比较过程</h4><p>以主串T为基础，根据索引i对每个字符进行遍历，依次与目标串P的每个索引j的字符进行匹配。若字符相同，则两索引均后移，继续匹配；若不相同，则j恢复为0，从头开始，i回溯到开始成功匹配时索引的下一位。</p>
<a id="more"></a>
<h4 id="1-2-比较结果"><a href="#1-2-比较结果" class="headerlink" title="1.2 比较结果"></a>1.2 比较结果</h4><p>遍历索引i结束之后，若此时j已经达到目标串P的最后，则证明目标串的所有字符均匹配成功，目标串在主串中的位置即length(T) - j；否则匹配失败，P不是T的子串。</p>
<h4 id="1-3-主要实现"><a href="#1-3-主要实现" class="headerlink" title="1.3 主要实现"></a>1.3 主要实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSInteger <span class="title">findIndex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sourceStr, <span class="keyword">const</span> <span class="keyword">char</span> *targetStr)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取二者长度</span></div><div class="line">    NSInteger sourceLength = <span class="built_in">strlen</span>(sourceStr);</div><div class="line">    NSInteger targetLength = <span class="built_in">strlen</span>(targetStr);</div><div class="line">    </div><div class="line">    NSInteger i = <span class="number">0</span>; <span class="comment">// 主串索引</span></div><div class="line">    NSInteger j = <span class="number">0</span>; <span class="comment">// 目标串索引</span></div><div class="line">    </div><div class="line">    <span class="keyword">while</span> ((i &lt; sourceLength) &amp;&amp; (j &lt; targetLength)) &#123;</div><div class="line">        <span class="keyword">if</span> (sourceStr[i] == targetStr[j]) &#123;</div><div class="line">            <span class="comment">// 字符相同，继续向后</span></div><div class="line">            i += <span class="number">1</span>;</div><div class="line">            j += <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 字符不同</span></div><div class="line">            <span class="comment">// 主串索引恢复到开始成功匹配时的下一位</span></div><div class="line">            i = i - j + <span class="number">1</span>;</div><div class="line">            <span class="comment">// 目标串索引恢复到头</span></div><div class="line">            j = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 注：这里的大于只是防止最后一位匹配成功后的+1操作</span></div><div class="line">    <span class="keyword">if</span> (j &gt;= targetLength) &#123;</div><div class="line">        <span class="comment">// 主串的最终遍历索引 前移 目标串长度，即为子串的起始位置</span></div><div class="line">        <span class="keyword">return</span> i - targetLength;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> NSNotFound;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-KMP的字符串匹配方法"><a href="#2-KMP的字符串匹配方法" class="headerlink" title="2. KMP的字符串匹配方法"></a>2. KMP的字符串匹配方法</h3><p>KMP方法的作用主要是去掉了一些可避免的比较，提高了匹配效率。</p>
<h4 id="2-1-匹配过程"><a href="#2-1-匹配过程" class="headerlink" title="2.1 匹配过程"></a>2.1 匹配过程</h4><p>KMP的主要匹配过程与朴素一致，都是字符依次比较。优化点是在字符匹配失败时，尽量让主串T的索引i不回溯，目标串的索引j回溯到需要的位置（而不是直接到0）。从而达到减少比较次数的目的。</p>
<p>如上所述，KMP的核心就是<strong>在任意位置匹配失败时，目标串的索引j回溯到的位置</strong>。</p>
<p>我们将所有回溯位置的信息保存到数组next中，故最终目的就是计算出next数组的完整信息。</p>
<h5 id="2-1-1-匹配表（Partial-Match-Table）"><a href="#2-1-1-匹配表（Partial-Match-Table）" class="headerlink" title="2.1.1 匹配表（Partial Match Table）"></a>2.1.1 匹配表（Partial Match Table）</h5><p>要说next数组，就先要了解<strong>匹配表PMT</strong>的含义。以字符串“abababca”为例，其匹配表如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/450996-925461fd2eb0fd34.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>其中，value行即为PMT的值。其意义是什么呢？</p>
<p>value的值是子串中<strong>前缀与后缀集合中，最长的公共子串的长度</strong>。例如，下表分别为当index为2和5时，value的得出过程：</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>子串</th>
<th>前缀集合</th>
<th>后缀集合</th>
<th>交集</th>
<th>最长子串长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>“aba”</td>
<td>{“a”，“ab”}</td>
<td>{“ba”，“a”}</td>
<td>{“a”}</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>“ababab”</td>
<td>{“a”，“ab”，“aba”，“abab”，“ababa”}</td>
<td>{“b”，“ab”，“bab”，“abab”，“babab”}</td>
<td>{“ab”，“abab”}</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>故目标字符串有几位，就会有几个PMT中对应的值。</p>
<h5 id="2-1-2-next表（PMT表的修改形式）"><a href="#2-1-2-next表（PMT表的修改形式）" class="headerlink" title="2.1.2 next表（PMT表的修改形式）"></a>2.1.2 next表（PMT表的修改形式）</h5><p>先抛图（主串“ababababca”和子串“abababca”进行匹配的过程之一）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/450996-996f2e16ee46bf0d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>如图所示，当在主串的i处匹配失败，其之前长度为6的字符串“ababab”均已匹配成功。此时，由PMT表我们可知，子串“ababab”的value为4，即其四位前缀与四位后缀是一致的。又因为在主串中，i之前的四位与j之前的四位字符均一致。故，目标串的四位前缀与主串中i之前的四位字符一致。我们可以省略对该子串的比较，直接在目标串的j=4的位置与主串的当前位置i继续比较。</p>
<p>在上面是叙述中，我们发现，匹配失败，并不会导致主串索引i改变，只会影响目标串索引j出现变化。并且，有趣的是，以图中的过程为例，<strong>当j=6时，匹配失败，即最后一个成功匹配的j是5。之后j回溯的位置4正好是PMT表中index为5时的value值</strong>。根据这个原理，我们就可以跳过不需要的比较，只通过修改目标串索引的位置即可进行快速匹配。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/450996-6082a942ee67f143.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>那么，我们引入next表的目的是什么呢？由于在某一位置匹配失败时，都要查看其前一个位置对应的PMT值，故我们将PMT数据均偏移一位，直接对应于当前位置，以便在快速查找下一步时，可以直接得到目标串索引j的位置。因此，我们<strong>把PMT值偏移后的数据叫做next数据</strong>，为了补位，next的首位赋值为-1。</p>
<p>因此，有了next的方式，我们就可以对朴素匹配法进行优化了。</p>
<h4 id="2-2-匹配过程"><a href="#2-2-匹配过程" class="headerlink" title="2.2 匹配过程"></a>2.2 匹配过程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSInteger <span class="title">KMPFindIndex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sourceStr, <span class="keyword">const</span> <span class="keyword">char</span> *targetStr)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取目标串的next信息，以备匹配时进行回溯（KMP算法核心）</span></div><div class="line">    NSArray *nextInfo = getNextInfo(targetStr);</div><div class="line">    NSLog(@<span class="string">"next - %@"</span>, nextInfo);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取两串长度</span></div><div class="line">    NSInteger sourceLength = <span class="built_in">strlen</span>(sourceStr);</div><div class="line">    NSInteger targetLength = <span class="built_in">strlen</span>(targetStr);</div><div class="line">    </div><div class="line">    <span class="comment">// 主串索引</span></div><div class="line">    NSInteger i = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 目标串索引</span></div><div class="line">    NSInteger j = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 均在范围内查找</span></div><div class="line">    <span class="keyword">while</span> ((i &lt; sourceLength)</div><div class="line">           &amp;&amp; (j &lt; targetLength)) &#123;</div><div class="line">        <span class="keyword">if</span> ((j == <span class="number">-1</span>) </div><div class="line">            || (sourceStr[i] == targetStr[j])) &#123;</div><div class="line">                <span class="comment">// 字符匹配时，索引均后移，准备下一次匹配(j为-1即为了防止出现next[0] = -1的情况出现)</span></div><div class="line">                i += <span class="number">1</span>;</div><div class="line">                j += <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 字符不匹配，i不变，j回溯为next中对应的位置，作为下次匹配的起点</span></div><div class="line">                j = [nextInfo[j] integerValue];</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (j == tragetLength) &#123;</div><div class="line">        <span class="keyword">return</span> i - j;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> NSNotFound;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-3-生成Next数组的过程"><a href="#2-3-生成Next数组的过程" class="headerlink" title="2.3 生成Next数组的过程"></a>2.3 生成Next数组的过程</h4><p>我们知道，生成Next数据的过程，即<strong>在每一个位置上，获取前面子串里，前后缀集合中最长的公共子串的长度</strong>。</p>
<p>如目标字符串“ABCDABDE”，我们以k作为前缀索引，j为后缀索引。如下图，当在字符索引在“D”时（即j为6时），其子串“ABCDAB”的最长前后缀公共子串长度为2（子串“AB”的长度），故next[6] = 2。我们还可知，在j为5时，next[5] = 1，即在j = 5时，公共子串最大长度为1（子串“A”的长度）。故我们可以得到：<strong>在当前字符存在有效next值时（Pk == Pj时），下一个字符的next即为之前next位置的下一个，即next[j + 1] = next[j] + 1 = k + 1</strong>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/450996-b06de1c2fa5c7f75?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>若Pk与Pj不相等，如图中k为2，j为6时。按照KMP的思想，<strong>后缀j不变，需要更新前缀k，以便找到另一个字符与Pj相同</strong>。故<strong>将前缀索引k修改为next[k]以继续进行比较（缩小前缀查找范围）</strong>，直到找到相同的字符“D”或没有相同字符为止。</p>
<p>按照这个思想，生成next数据的实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSArray *<span class="title">getNextInfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *targetStr)</span> </span>&#123;</div><div class="line">    <span class="comment">// 创建返回的next数组</span></div><div class="line">    NSMutableArray *nextInfo = [[NSMutableArray alloc] initWithCapacity:<span class="number">10</span>];</div><div class="line">    nextInfo[<span class="number">0</span>] = @(<span class="number">-1</span>); <span class="comment">// 人为指定首位的next值为-1（首位无法回溯，故此值只是占位用）</span></div><div class="line">    </div><div class="line">    <span class="comment">// 获取字符串长度</span></div><div class="line">    NSInteger strLength = strLen(targetStr);</div><div class="line">    </div><div class="line">    NSInteger k = <span class="number">-1</span>; <span class="comment">// 前缀索引初始值</span></div><div class="line">    NSInteger j = <span class="number">0</span>; <span class="comment">// 后缀索引初始值（后缀必须大于前缀才有效）</span></div><div class="line">    </div><div class="line">    <span class="comment">// 以后缀索引作为遍历范围（-1为了防止最后无效的自加1）</span></div><div class="line">    <span class="keyword">while</span> (j &lt; strLength - <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((k == <span class="number">-1</span>)</div><div class="line">            || (targetStr[k] == targetStr[j])) &#123;</div><div class="line">                <span class="comment">// 前缀为初值索引时，无条件后移并记录（即没有有效前后缀公共串）</span></div><div class="line">                <span class="comment">// 当前位置的字符相同，即找到了公共前后缀字符串，记录下一个位置的next值</span></div><div class="line">                </div><div class="line">                <span class="comment">// 下一位置的next值即为当前next的索引值k再加1</span></div><div class="line">                k += <span class="number">1</span>;</div><div class="line">                j += <span class="number">1</span>;</div><div class="line">                </div><div class="line">                nextInfo[j] = @(k);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 当前位置字符不同</span></div><div class="line">                <span class="comment">// 按照KMP思想，j不回溯，k回溯为下一次的查找索引</span></div><div class="line">                k = [next[k] integerValue];</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [nextInfo copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Objective-C实现的代码地址：<a href="https://github.com/Choujiji/PlayWithDataStructure-Code/tree/master/%E4%B8%B2/KMP%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/SimplyStringCompare" target="_blank" rel="external">点击查看</a></p>
</blockquote>
<h4 id="2-4-Next数组的优化"><a href="#2-4-Next数组的优化" class="headerlink" title="2.4 Next数组的优化"></a>2.4 Next数组的优化</h4><p>我们设想一下这种情况：目标串为“abcabc”，主串为“abacababc”，其中一种比较情况如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/450996-037df26c5e3b176f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>即此时，第四位比较失败（“c”与“b”不同）。我们知道，此时目标串下一次比较的索引j为next[j]，即第二位。也就是目标串右移j-next[j]位（2位）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/450996-a8288306a47b5796.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>如图所示，由于移动后，第二位的字符仍然为“b”，显然比较失败。在这种情况下，本次比较实际上是没有意义的。那么应该如何避免这种比较呢？</p>
<p>其实，在正常情况下，当匹配失败时，我们还会进一步缩小匹配范围（j = next[j]），故<strong>在这种情况下（next[j]指向的字符与当前字符相同时），我们只需再次递归next[j]，跳过相同字符即可</strong>。</p>
<p>因此，解决办法就是，<strong>在生成next数组时，在当前Pk和Pj相同的情况下，若下一位的j与k指向的字符相同，直接设置该位置的next为next[k]即可</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSArray *<span class="title">getNextInfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *targetStr)</span> </span>&#123;</div><div class="line">    NSMutableArray *nextInfo = [[NSMutableArray alloc] initWithCapacity:<span class="number">10</span>];</div><div class="line">    nextInfo[<span class="number">0</span>] = @(<span class="number">-1</span>); </div><div class="line">    </div><div class="line">    NSInteger strLength = strLen(targetStr);</div><div class="line">    </div><div class="line">    NSInteger k = <span class="number">-1</span>; <span class="comment">// 前缀索引初始值</span></div><div class="line">    NSInteger j = <span class="number">0</span>; <span class="comment">// 后缀索引初始值（后缀必须大于前缀才有效）</span></div><div class="line">    </div><div class="line">    <span class="comment">// 以后缀索引作为遍历范围</span></div><div class="line">    <span class="keyword">while</span> (j &lt; strLength - <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((k == <span class="number">-1</span>)</div><div class="line">            || (targetStr[k] == targetStr[j])) &#123;</div><div class="line">                <span class="comment">// 前缀为初值索引时，无条件后移并记录（即没有有效前后缀公共串）</span></div><div class="line">                <span class="comment">// 当前位置的字符相同，即找到了公共前后缀字符串，记录下一个位置的next值</span></div><div class="line">                </div><div class="line">                k += <span class="number">1</span>;</div><div class="line">                j += <span class="number">1</span>;</div><div class="line">                </div><div class="line">                <span class="comment">// nextInfo[j] = @(k); // 修改</span></div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (targetStr[k] == targetStr[j]) &#123;</div><div class="line">                    <span class="comment">// 下一位的前后缀字符相同</span></div><div class="line">                    nextInfo[j] = @(nextInfo[k]); <span class="comment">// next跳过当前的前缀位置，直接指向前缀位置的next位置</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 下一位的前后缀字符不同（正常情况）</span></div><div class="line">                    nextInfo[j] = @(k); <span class="comment">// 原始匹配，next指向前缀后面的位置</span></div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                </div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 当前位置字符不同</span></div><div class="line">                k = [next[k] integerValue];</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [nextInfo copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终，优化后的next数组信息如下表所示（以目标串“abab”为例）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/450996-daddb3d9b0bbd0b0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>使用优化后的next数组，可以再次减少一些不必要的比较。</p>
<h4 id="2-5-时间复杂度"><a href="#2-5-时间复杂度" class="headerlink" title="2.5 时间复杂度"></a>2.5 时间复杂度</h4><p>KMP方式的运算次数为<em>计算next数组的次数</em>与<em>匹配主串的次数</em>之和，即O(m + n)。</p>
<blockquote>
<p>参考引用：</p>
<ul>
<li><a href="https://www.zhihu.com/question/21923021/answer/281346746" target="_blank" rel="external">如何更好的理解和掌握 KMP 算法?</a></li>
<li><a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html" target="_blank" rel="external">很详尽KMP算法（厉害）</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-朴素的字符串匹配方法&quot;&gt;&lt;a href=&quot;#1-朴素的字符串匹配方法&quot; class=&quot;headerlink&quot; title=&quot;1. 朴素的字符串匹配方法&quot;&gt;&lt;/a&gt;1. 朴素的字符串匹配方法&lt;/h3&gt;&lt;h4 id=&quot;1-1-比较过程&quot;&gt;&lt;a href=&quot;#1-1-比较过程&quot; class=&quot;headerlink&quot; title=&quot;1.1 比较过程&quot;&gt;&lt;/a&gt;1.1 比较过程&lt;/h4&gt;&lt;p&gt;以主串T为基础，根据索引i对每个字符进行遍历，依次与目标串P的每个索引j的字符进行匹配。若字符相同，则两索引均后移，继续匹配；若不相同，则j恢复为0，从头开始，i回溯到开始成功匹配时索引的下一位。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》之栈与队列</title>
    <link href="http://yoursite.com/2019/03/11/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E4%B9%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/03/11/《大话数据结构》之栈与队列/</id>
    <published>2019-03-11T14:54:44.101Z</published>
    <updated>2019-03-11T14:55:05.041Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p><strong>栈，即只能在表尾进行插入或删除操作的线性表。</strong></p>
<p>其中，“表尾”称为“<strong>栈顶</strong>”，另一端则为“栈底”。栈是“<strong>后进先出</strong>”（LIFO）的线性表。</p>
<a id="more"></a>
<h4 id="1-2-栈的顺序存储结构"><a href="#1-2-栈的顺序存储结构" class="headerlink" title="1.2 栈的顺序存储结构"></a>1.2 栈的顺序存储结构</h4><p>我们使用数组来描述栈的顺序存储结构。使用指针top来定义栈顶指针，其一直指向数组的最后一个元素的索引。<strong>空栈即top为-1</strong>。由于使用数组实现，故顺序栈在初始化时需要指定最大存储容量。</p>
<h5 id="1-2-1-入栈"><a href="#1-2-1-入栈" class="headerlink" title="1.2.1 入栈"></a>1.2.1 入栈</h5><p>取出数组下一位置的索引（同时更新栈顶top指针），插入数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// S为栈（data为保存的数据，top为栈顶指针），e为插入数据，下同</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (S-&gt;top == MAX_SIZE - <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> False;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 栈顶指针后移</span></div><div class="line">S-&gt;top += <span class="number">1</span>;</div><div class="line"><span class="comment">// 在数组的该位置插入数据</span></div><div class="line">S-&gt;data[S-&gt;top] = e;</div><div class="line"></div><div class="line"><span class="keyword">return</span> True;</div></pre></td></tr></table></figure>
<h6 id="1-2-2-出栈"><a href="#1-2-2-出栈" class="headerlink" title="1.2.2 出栈"></a>1.2.2 出栈</h6><p>取出栈顶top指针指向的数据，之后top指针前移。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>) &#123;</div><div class="line">    <span class="comment">// 空栈</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 取出待返回数据</span></div><div class="line">result = S-&gt;data[S-&gt;top];</div><div class="line"></div><div class="line"><span class="comment">// 栈顶指针前移</span></div><div class="line">S-&gt;top -= <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">return</span> result;</div></pre></td></tr></table></figure>
<p><strong>入栈、出栈操作的时间复杂度均为O(1)</strong>。</p>
<h4 id="1-3-栈的链式存储结构"><a href="#1-3-栈的链式存储结构" class="headerlink" title="1.3 栈的链式存储结构"></a>1.3 栈的链式存储结构</h4><p>由于顺序栈仍然需要提前考虑空间的存储问题，我们可以使用“单链表”来实现栈结构。</p>
<p>使用“头插法”实现链栈的“入栈”和“出栈”操作，可以有效降低时间复杂度。</p>
<p>对于链栈来说，<strong>空栈即栈顶指针top=NULL</strong>。</p>
<h5 id="1-3-1-入栈"><a href="#1-3-1-入栈" class="headerlink" title="1.3.1 入栈"></a>1.3.1 入栈</h5><p>入栈操作，类似于单链表的插入操作，直接在链表头部进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// S为栈（top为栈顶指针，count为元素数量），e为插入数据结点（data为数据域，next为指针域），下同</span></div><div class="line"></div><div class="line"><span class="comment">// 新数据的next指向原top指针的节点，并将top指针指向新数据，更新表长</span></div><div class="line"></div><div class="line">node = ...; <span class="comment">// 创建新结点</span></div><div class="line">node-&gt;data = e;</div><div class="line">node-&gt;next = S-&gt;top;</div><div class="line">S-&gt;top = node;</div><div class="line">S-&gt;count += <span class="number">1</span>;</div></pre></td></tr></table></figure>
<h5 id="1-3-2-出栈"><a href="#1-3-2-出栈" class="headerlink" title="1.3.2 出栈"></a>1.3.2 出栈</h5><p>出栈操作，类似于单链表的删除操作，直接在链表头部进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (S-&gt;count == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// 空栈</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 取出待返回的结点</span></div><div class="line">p = S-&gt;top; </div><div class="line"><span class="comment">// 取出待返回数据</span></div><div class="line">result = p-&gt;data;</div><div class="line"><span class="comment">// 栈顶指针指向后一个结点</span></div><div class="line">S-&gt;top = S-&gt;top-&gt;next;</div><div class="line"><span class="comment">// 更新表长</span></div><div class="line">S-&gt;count -= <span class="number">1</span>;</div><div class="line"><span class="comment">// 释放对象</span></div><div class="line"><span class="built_in">free</span>(p);</div><div class="line"></div><div class="line"><span class="keyword">return</span> result;</div></pre></td></tr></table></figure>
<p><strong>链栈操作的时间复杂度仍然为O(1)</strong>。但由于其实际占用的存储空间会大于顺序栈（单链表结点额外包含指针域数据），故可以依情况自行决定使用哪种结构对栈进行实现。</p>
<h4 id="1-4-栈的应用：使用栈进行四则运算"><a href="#1-4-栈的应用：使用栈进行四则运算" class="headerlink" title="1.4 栈的应用：使用栈进行四则运算"></a>1.4 栈的应用：使用栈进行四则运算</h4><p>这里我们使用栈（demo中使用链栈进行实现）进行四则运算表达式的求值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">9</span> + ( <span class="number">3</span> - <span class="number">1</span> ) * <span class="number">3</span> + <span class="number">10</span> / <span class="number">2</span></div></pre></td></tr></table></figure>
<p>其中，主要步骤分为两步：</p>
<ol>
<li>将（操作符）中缀表达式转换为后缀表达式（<em>栈用来进出操作符</em>）：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">9</span> <span class="number">3</span> <span class="number">1</span> - <span class="number">3</span> * + <span class="number">10</span> <span class="number">2</span> / +</div></pre></td></tr></table></figure>
<ol>
<li>使用后缀表达式计算结果（<em>栈用来进出操作数</em>）。</li>
</ol>
<blockquote>
<p>Objective-C版本实现：<a href="https://github.com/Choujiji/PlayWithDataStructure-Code/tree/master/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%A0%88" target="_blank" rel="external">代码地址</a>。</p>
</blockquote>
<h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p><strong>队列，即只能在一端进行插入操作，在另一端进行删除操作的线性表。</strong></p>
<p>插入的一端叫做<strong>队尾</strong>，删除的一端叫做<strong>队头</strong>。队列是<strong>先进先出</strong>（FIFO）的线性表。</p>
<h4 id="2-2-队列的顺序存储结构"><a href="#2-2-队列的顺序存储结构" class="headerlink" title="2.2 队列的顺序存储结构"></a>2.2 队列的顺序存储结构</h4><p>仍然使用数组对队列进行描述。我们<strong>使用两个指针</strong>（front和rear）<strong>分别指向队头</strong>（首个元素）<strong>和队尾</strong>（末尾元素的下一个索引）。故初始时，front=rear。</p>
<h5 id="2-2-1-顺序队列的入队"><a href="#2-2-1-顺序队列的入队" class="headerlink" title="2.2.1 顺序队列的入队"></a>2.2.1 顺序队列的入队</h5><p>入队，即rear指针位置插入新数据，之后rear指针后移。<strong>时间复杂度为O(1)</strong>。</p>
<h5 id="2-2-2-顺序队列的出队"><a href="#2-2-2-顺序队列的出队" class="headerlink" title="2.2.2 顺序队列的出队"></a>2.2.2 顺序队列的出队</h5><p>出队，按标准数组的删除数据逻辑可知，front指针位置数据移除，之后<strong>后面的所有数据依次前移</strong>。此时<strong>算法的时间复杂度为O(n)</strong>。</p>
<p>若是不考虑移动元素的问题，则可以在front指向的数据移除后，front指针后移，达到目的且<strong>复杂度仍然为O(1)</strong>。但此时会造成数据的“假溢出”：在队列存储已满的情况下，插入新数据时无法插入，但队列头部明明有剩余空间却无法使用。</p>
<h4 id="2-3-循环队列"><a href="#2-3-循环队列" class="headerlink" title="2.3 循环队列"></a>2.3 循环队列</h4><p>为了解决上述“假溢出”的问题，引入了<strong>循环队列</strong>这个特殊的顺序存储队列。</p>
<h5 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h5><p><strong>队列中，头尾相接的顺序存储结构叫做循环队列。</strong></p>
<p>利用循环队列，在尾部存满之后，如果头部存在剩余空间，可以从头开始继续存储。</p>
<h5 id="2-3-2-循环队列的问题"><a href="#2-3-2-循环队列的问题" class="headerlink" title="2.3.2 循环队列的问题"></a>2.3.2 循环队列的问题</h5><p>队列为空时，front=rear。但当队列存满时，仍旧为front=rear。故在使用循环队列时，需要区分开这两种情况。</p>
<ol>
<li>设置标志位flag：当队列为空时，flag=0；当队列占满时，flag=1。</li>
<li>少存一个数据。即当rear与front差1时，就认为队列已满。</li>
</ol>
<p>故循环队列最大的问题是<strong>如何处理入队与出队操作时的溢出问题</strong>。</p>
<h5 id="2-3-3-循环队列的满队及长度判定"><a href="#2-3-3-循环队列的满队及长度判定" class="headerlink" title="2.3.3 循环队列的满队及长度判定"></a>2.3.3 循环队列的满队及长度判定</h5><p>对于上面的第二种情况，由于在队列已满时，rear与front的大小不确定（绝对值差1），故可以使用“取模”的方式确定队列是否已满：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((rear + <span class="number">1</span>) % MaxSize == front) &#123;</div><div class="line">    <span class="comment">// 队列已满</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而计算队列数据个数时，当rear &gt; front时，队列长度即为rear - front；当rear &lt; front时，队列为两部分：右半部分为QueueSize - front，左半部分为 rear - 0，故总长度为 rear - front + QueueSize。仍旧使用“取模”的方式，故最终队列长度为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 队列总长度</span></div><div class="line">QueueLength = (rear - front + MaxSize) % MaxSize;</div></pre></td></tr></table></figure>
<h5 id="2-3-3-循环队列的入队操作"><a href="#2-3-3-循环队列的入队操作" class="headerlink" title="2.3.3 循环队列的入队操作"></a>2.3.3 循环队列的入队操作</h5><p>按照循环存储的方式，当队尾已满，但仍有空间可用时，将新元素重新放入到队列头部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Q为队列（data为数据数组，rear和front为其头尾指针），e为将入队的新元素，下同</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MaxSize == Q-&gt;front) &#123;</div><div class="line">    <span class="comment">// 队列已满，不可入队</span></div><div class="line">    <span class="keyword">return</span> False;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 队尾设置数据</span></div><div class="line">Q-&gt;data[Q-&gt;rear] = e;</div><div class="line"><span class="comment">// 队尾指针后移（取模，填满后可从头赋值）</span></div><div class="line">Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MaxSize;</div><div class="line"></div><div class="line"><span class="keyword">return</span> True;</div></pre></td></tr></table></figure>
<h5 id="2-3-4-循环队列的出队操作"><a href="#2-3-4-循环队列的出队操作" class="headerlink" title="2.3.4 循环队列的出队操作"></a>2.3.4 循环队列的出队操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Q-&gt;rear == Q-&gt;front) &#123;</div><div class="line">    <span class="comment">// 空队列，不可出队</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// e为出队对象</span></div><div class="line">Element e = Q-&gt;front;</div><div class="line"><span class="comment">// 对首指针后移（取模，填满后可从头赋值）</span></div><div class="line">Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MaxSize;</div><div class="line"></div><div class="line"><span class="keyword">return</span> e;</div></pre></td></tr></table></figure>
<h4 id="2-4-队列的链式存储结构"><a href="#2-4-队列的链式存储结构" class="headerlink" title="2.4 队列的链式存储结构"></a>2.4 队列的链式存储结构</h4><p><strong>队列的链式存储结构，本质上就是使用链表实现的队列</strong>。最简单的实现就是“单链表”。队首指针front指向链表的头结点，队尾指针rear指向链表的尾部结点。</p>
<h5 id="2-4-1-链式队列的入队"><a href="#2-4-1-链式队列的入队" class="headerlink" title="2.4.1 链式队列的入队"></a>2.4.1 链式队列的入队</h5><p>链式队列的入队操作，实质上就是“尾插法”插入结点到单链表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Q为队列（front和rear分别为队列的头尾指针），s为待插入结点（data为数据域，next为指针域），下同</span></div><div class="line"></div><div class="line"><span class="comment">// 创建新结点s</span></div><div class="line">s = ...;</div><div class="line">s-&gt;data = e;</div><div class="line">s-&gt;next = <span class="literal">NULL</span>;</div><div class="line"><span class="comment">// 原尾部结点的next指向新结点</span></div><div class="line">Q-&gt;rear-&gt;next = s;</div><div class="line"><span class="comment">// 队尾指针指向新结点</span></div><div class="line">Q-&gt;rear = s;</div></pre></td></tr></table></figure>
<h5 id="2-4-2-链式队列的入队"><a href="#2-4-2-链式队列的入队" class="headerlink" title="2.4.2 链式队列的入队"></a>2.4.2 链式队列的入队</h5><p>链式队列的出队操作，实质上就是在链表头部移除首个结点。注意，出队后，若得到空队列，队尾指针rear也应指向链表的头结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) &#123;</div><div class="line">    <span class="comment">// 空队列，不可出队</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 得到当前待出队结点p</span></div><div class="line">p = Q-&gt;front-&gt;next;</div><div class="line"><span class="comment">// 获取出队元素</span></div><div class="line">e = p-&gt;data;</div><div class="line"><span class="comment">// 队首指针指向出队结点的下一个结点</span></div><div class="line">Q-&gt;front-&gt;next = p-&gt;next;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (Q-&gt;rear == p) &#123;</div><div class="line">    <span class="comment">// 判空，若出队后为空队列，则更新队尾指针（均指向单链表的头结点）</span></div><div class="line">    Q-&gt;rear = Q-&gt;front;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">free</span>(p);</div><div class="line"></div><div class="line"><span class="keyword">return</span> e;</div></pre></td></tr></table></figure>
<h4 id="2-5-两种存储结构队列的比较"><a href="#2-5-两种存储结构队列的比较" class="headerlink" title="2.5 两种存储结构队列的比较"></a>2.5 两种存储结构队列的比较</h4><p>比较两种存储结构的队列的异同，如同比较顺序存储和链式存储的优劣。首先，对于灵活程度来说，链式队列由于无需考虑存储空间的大小，且无需担心数据溢出或空间浪费，而显得更加灵活。但是，由于其单个数据占用空间略大，且创建和释放存在部分消耗，在纯性能上略差于顺序队列。</p>
<p>还是那句话，<strong>确定存储空间大小时，使用顺序队列；否则使用链式队列</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-栈&quot;&gt;&lt;a href=&quot;#1-栈&quot; class=&quot;headerlink&quot; title=&quot;1. 栈&quot;&gt;&lt;/a&gt;1. 栈&lt;/h3&gt;&lt;h4 id=&quot;1-1-定义&quot;&gt;&lt;a href=&quot;#1-1-定义&quot; class=&quot;headerlink&quot; title=&quot;1.1 定义&quot;&gt;&lt;/a&gt;1.1 定义&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;栈，即只能在表尾进行插入或删除操作的线性表。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中，“表尾”称为“&lt;strong&gt;栈顶&lt;/strong&gt;”，另一端则为“栈底”。栈是“&lt;strong&gt;后进先出&lt;/strong&gt;”（LIFO）的线性表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》之线性表</title>
    <link href="http://yoursite.com/2019/03/06/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/03/06/《大话数据结构》之线性表/</id>
    <published>2019-03-06T10:55:37.657Z</published>
    <updated>2019-03-07T05:45:22.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-线性表的主要类型"><a href="#1-线性表的主要类型" class="headerlink" title="1. 线性表的主要类型"></a>1. 线性表的主要类型</h3><p>线性表在存储方式上划分，可分为：</p>
<ul>
<li><strong>顺序存储结构</strong>，如标准数组</li>
<li><strong>链式存储结构</strong>，如单链表</li>
</ul>
<a id="more"></a>
<h3 id="2-顺序存储结构"><a href="#2-顺序存储结构" class="headerlink" title="2. 顺序存储结构"></a>2. 顺序存储结构</h3><p>所谓顺序存储结构，即使用一段地址连续的存储单依次存储线性表的数据元素。</p>
<p>我们可以使用数组来描述线性表的顺序存储结构。</p>
<h4 id="2-1-地址计算方法（读取数据）"><a href="#2-1-地址计算方法（读取数据）" class="headerlink" title="2.1 地址计算方法（读取数据）"></a>2.1 地址计算方法（读取数据）</h4><p>通俗地讲，与数据下标访问的方式类似，后一个数据的地址是前一个地址加上数据大小。对于第i个数据的储存位置，即可使用以下方式得出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LOC(a(i + <span class="number">1</span>)) = LOC(a(i)) + (i - <span class="number">1</span>) * c</div></pre></td></tr></table></figure>
<p>由于任意地址的数据均可以由以上公式一步得出，故<strong>顺序存储结构的存储时间为O(1)，即时间复杂度为常数阶</strong>。</p>
<h4 id="2-2-插入数据"><a href="#2-2-插入数据" class="headerlink" title="2.2 插入数据"></a>2.2 插入数据</h4><p>主要步骤为：</p>
<ol>
<li>查找到要插入的位置i</li>
<li>将i之后的数据依次后移一个位置</li>
<li>在i的位置上插入数据e</li>
<li>表长加1</li>
</ol>
<p>总的执行次数为 1 + n + 1 + 1，故<strong>插入操作的时间复杂度为O(n)</strong>。</p>
<h4 id="2-3-删除数据"><a href="#2-3-删除数据" class="headerlink" title="2.3 删除数据"></a>2.3 删除数据</h4><p>主要步骤为：</p>
<ol>
<li>查找到要删除的位置i</li>
<li>在i的位置上取出数据e</li>
<li>将i之后的数据依次前移一个位置</li>
<li>表长减1</li>
</ol>
<p>总的执行次数为 1 + 1 + n + 1，故<strong>删除操作的时间复杂度为O(n)</strong>。</p>
<h4 id="2-4-顺序存储结构的优缺点"><a href="#2-4-顺序存储结构的优缺点" class="headerlink" title="2.4 顺序存储结构的优缺点"></a>2.4 顺序存储结构的优缺点</h4><p>优点：</p>
<ul>
<li>无需为数据元素之间的逻辑关系增加额外存储空间</li>
<li>可以快速读取任一位置的元素</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入和删除数据需要移动大量元素</li>
<li>当线性表长度变化较大时，难以确定存储空间的长度</li>
<li>造成存储空间的”碎片“</li>
</ul>
<h3 id="3-链式存储结构（以单链表为例）"><a href="#3-链式存储结构（以单链表为例）" class="headerlink" title="3. 链式存储结构（以单链表为例）"></a>3. 链式存储结构（以单链表为例）</h3><p>链式存储结构的特点，是使用一组任意的存储单元存储线性表的数据元素。这些存储单元可以是不连续的，任意位置均可。</p>
<p>链式存储结构中的数据结点（Node），除了包含自身数据（数据域），还需要存储一个后继结点的地址（指针域）。</p>
<p>当n个数据结点组成一个链表，其中每一个结点都只包含一个指针域时，这种链式结构称为<strong>单链表</strong>。</p>
<p>我们这里使用单链表来描述线性表的链式存储结构。</p>
<h4 id="3-1-单链表的基本描述"><a href="#3-1-单链表的基本描述" class="headerlink" title="3.1 单链表的基本描述"></a>3.1 单链表的基本描述</h4><ul>
<li><strong>头指针</strong>：指向单链表第一个结点存储位置（即第一个结点的地址）的指针。</li>
<li><strong>头结点</strong>：在第一个结点前设置的一个结点，其指针域为头指针地址。</li>
<li>线性表最后一个结点的指针域为NULL或^。</li>
</ul>
<h4 id="3-2-头指针与头结点的异同"><a href="#3-2-头指针与头结点的异同" class="headerlink" title="3.2 头指针与头结点的异同"></a>3.2 头指针与头结点的异同</h4><p>头指针：</p>
<ul>
<li>指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。</li>
<li>有标识作用，常用头指针冠以链表的名字。</li>
<li>无论链表是否为空，头指针均不为空。<strong>头指针是链表的必要元素</strong>。</li>
</ul>
<p>头结点：</p>
<ul>
<li>为了操作统一和方便而设置，放在第一个结点之前，其数据域一般无意义（可以存放链表长度）。</li>
<li>有了头结点，对在第一个结点前插入结点或删除第一结点，其操作与其他结点完成统一。</li>
<li><strong>头结点不一定是链表的必须要素</strong>。</li>
</ul>
<h4 id="3-3-单链表的读取"><a href="#3-3-单链表的读取" class="headerlink" title="3.3 单链表的读取"></a>3.3 单链表的读取</h4><p>由于每一个结点的存储位置都在前一个结点的指针域中保存，故获取指定位置的结点数据，需要从单链表的头结点开始，依次查找。故其<strong>查找的时间复杂度为O(n)</strong>。</p>
<p>查找方式，即循环”指针后移“。</p>
<h4 id="3-4-单链表的插入"><a href="#3-4-单链表的插入" class="headerlink" title="3.4 单链表的插入"></a>3.4 单链表的插入</h4><p>单链表的插入过程，如下图所示：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1551764374-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5.jpg" alt="单链表的插入"></p>
<p>其中，待插入的结点s（数据e），插入到结点p和p-&gt;next之间（数据a(i)和数据a(i+1)）之间。其关键操作为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将插入结点s的指针域指向原后结点p-&gt;next</span></div><div class="line">s-&gt;next = p-&gt;next;</div><div class="line"><span class="comment">// 原结点p的指针域指向插入结点s</span></div><div class="line">p-&gt;next = s;</div></pre></td></tr></table></figure>
<p>故此插入行为的复杂度为O(1)。</p>
<p>不过，由于查找插入位置结点的复杂度为O(n)，故最终<strong>单链表插入操作的时间复杂度为O(n)</strong>。</p>
<h4 id="3-5-单链表的删除"><a href="#3-5-单链表的删除" class="headerlink" title="3.5 单链表的删除"></a>3.5 单链表的删除</h4><p>单链表的删除过程，如下图所示：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1551764879-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4.jpg" alt="单链表的删除"></p>
<p>其中，a(i)为待删除元素，即p-&gt;next结点。删除后即将结点p的指针域指向a(i+1)元素的结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 待删除结点的前一个结点的指针域 指向 待删除结点的后一个结点</span></div><div class="line">p-&gt;next = p-&gt;next-&gt;next;</div><div class="line"></div><div class="line"><span class="comment">// 或</span></div><div class="line"></div><div class="line">q = p-&gt;next;</div><div class="line">p-&gt;next = q-&gt;next;</div><div class="line"></div><div class="line"><span class="comment">// 最后，释放删除结点的内存</span></div><div class="line"><span class="built_in">free</span>(q);</div></pre></td></tr></table></figure>
<p>故此删除行为的复杂度为O(1)。</p>
<p>不过，由于查找删除位置结点的复杂度为O(n)，故最终<strong>单链表删除操作的时间复杂度为O(n)</strong>。</p>
<h4 id="3-6-单链表的整表创建"><a href="#3-6-单链表的整表创建" class="headerlink" title="3.6 单链表的整表创建"></a>3.6 单链表的整表创建</h4><ul>
<li><strong>头插法</strong>：每次均从头指针插入新结点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建单链表L(空表)</span></div><div class="line">*L = (LinkList)<span class="built_in">malloc</span>(sizeOf(Node));</div><div class="line">(*L-&gt;next) = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">    <span class="comment">// L为单链表的头结点，p为待插入结点</span></div><div class="line">    p-&gt;next = (*L)-&gt;next;</div><div class="line">    (*L)-&gt;next = p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>尾插法</strong>：每次均插入到尾结点的后面。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建单链表L(空表)</span></div><div class="line">*L = (LinkList)<span class="built_in">malloc</span>(sizeOf(Node));</div><div class="line">(*L-&gt;next) = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="comment">// r为指向尾部的结点</span></div><div class="line">r = *L;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">    <span class="comment">// p为待插入结点，插入到尾结点后面</span></div><div class="line">    r-&gt;next = p;</div><div class="line">    <span class="comment">// 新加入结点作为新的尾结点</span></div><div class="line">    r = p;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 尾结点指针域赋值</span></div><div class="line">r-&gt;next = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure>
<h4 id="3-7-单链表的整表删除"><a href="#3-7-单链表的整表删除" class="headerlink" title="3.7 单链表的整表删除"></a>3.7 单链表的整表删除</h4><p>做法：依次边遍历边删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// L为待删除链表，p和q分别指向当前结点</span></div><div class="line"></div><div class="line"><span class="comment">// p指向第一个结点</span></div><div class="line">p = (*L)-&gt;next;</div><div class="line"></div><div class="line"><span class="keyword">while</span>(p) &#123;</div><div class="line">    <span class="comment">// q指向后继结点</span></div><div class="line">    q = p-&gt;next;</div><div class="line">    <span class="comment">// 删除当前结点</span></div><div class="line">    <span class="built_in">free</span>(p);</div><div class="line">    <span class="comment">// p指向后继结点</span></div><div class="line">    p = q;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 循环结束后，p结点已经不存在</span></div><div class="line"><span class="comment">// 置为空表，让头结点的头指针为空</span></div><div class="line">(*L)-&gt;next = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure>
<h4 id="3-8-单链表与顺序存储结构实用性对比"><a href="#3-8-单链表与顺序存储结构实用性对比" class="headerlink" title="3.8 单链表与顺序存储结构实用性对比"></a>3.8 单链表与顺序存储结构实用性对比</h4><ul>
<li>在频繁查找，且很少进行插入和删除操作时，可以考虑使用顺序存储结构。若频繁插入或删除，则考虑使用单链表。</li>
<li>在不确定线性表的元素个数时，可以考虑使用单链表，忽略存储空间的需求问题。</li>
</ul>
<h3 id="4-其他类型链表结构"><a href="#4-其他类型链表结构" class="headerlink" title="4. 其他类型链表结构"></a>4. 其他类型链表结构</h3><h4 id="4-1-静态链表"><a href="#4-1-静态链表" class="headerlink" title="4.1 静态链表"></a>4.1 静态链表</h4><p>静态链表是在没有指针的情况下实现的“模拟”单链表，本质上是使用数组进行描述并实现。</p>
<p>其结构如下所示：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1551867514-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8.jpg" alt="静态链表"></p>
<p>其中，数组分为两部分结构：</p>
<ol>
<li>以数组的末尾元素为头结点，根据游标（cur）索引，直到元素的游标为0为止，连接而成的结构，也就是真正的<strong>单链表</strong>。</li>
<li>以数组第一个元素为头结点，根据游标索引，直到元素的游标为末尾元素的下标为止，作为<strong>备用链表</strong>，用于动态分配数据（插入、移除数据使用）。</li>
</ol>
<p>主要结构：</p>
<ul>
<li>数组的末尾元素：初始状态下，末尾元素的游标指向首元素，即为空表。当插入数据后，其游标永远指向链表第一个数据。</li>
<li>数组的首元素：初始状态下，其游标指向数组的下一个元素。当插入数据后，其游标总是指向备用链表的第一个数据。</li>
<li>数组的其他元素：默认情况下，当前元素的游标指向下一个元素。当插入数据后，数据的游标即保存的是下一个插入数据所在数组的下标。单链表最后一个数据的游标保存的是0，即数组首元素下标，标识单链表已结束。</li>
</ul>
<blockquote>
<p><strong>静态链表的优缺点</strong>：</p>
<p>优点：<br>避免了插入和删除数据时对大量数据的移动，只要修改游标即可实现。</p>
<p>缺点：</p>
<ul>
<li>由于使用数组进行实现，依然无法避免对内存空间进行考虑。</li>
<li>失去了顺序存储结构随机存取的特性。</li>
</ul>
<p>备注：</p>
<p>静态链表的创建、插入和删除等操作的Objective-C版本实现：<a href="https://github.com/Choujiji/PlayWithDataStructure-Code/tree/master/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8" target="_blank" rel="external">项目地址</a></p>
</blockquote>
<h4 id="4-2-循环链表"><a href="#4-2-循环链表" class="headerlink" title="4.2 循环链表"></a>4.2 循环链表</h4><p>循环链表作为单链表的扩展，在链表尾部定义了尾指针，指向最后一个结点rear。其指针域next指向链表的头结点。</p>
<p>同时，判定链表结束的条件变为了rear-&gt;next == 头指针p。</p>
<h4 id="4-3-双向链表"><a href="#4-3-双向链表" class="headerlink" title="4.3 双向链表"></a>4.3 双向链表</h4><p>双向链表作为单链表的扩展，在结点的头部和尾部均设有指针域（prior和next），分别指向前驱结点和后继结点。可以双向访问链表的元素。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-线性表的主要类型&quot;&gt;&lt;a href=&quot;#1-线性表的主要类型&quot; class=&quot;headerlink&quot; title=&quot;1. 线性表的主要类型&quot;&gt;&lt;/a&gt;1. 线性表的主要类型&lt;/h3&gt;&lt;p&gt;线性表在存储方式上划分，可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顺序存储结构&lt;/strong&gt;，如标准数组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链式存储结构&lt;/strong&gt;，如单链表&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之可视化语言（Visual Format Language）</title>
    <link href="http://yoursite.com/2019/03/05/Autolayout%E4%B9%8B%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AF%AD%E8%A8%80%EF%BC%88Visual%20Format%20Language%EF%BC%89/"/>
    <id>http://yoursite.com/2019/03/05/Autolayout之可视化语言（Visual Format Language）/</id>
    <published>2019-03-05T09:08:02.615Z</published>
    <updated>2019-03-05T09:08:32.238Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1" target="_blank" rel="external">Visual Format Language</a></p>
</blockquote>
<p>这篇附录阐述了如何使用Auto Layout可视化语言来设定普通约束，包括标准间距、尺寸、垂直布局和带有不同优先级的约束等。此外，本附录还包含了一个完整的语法说明。</p>
<a id="more"></a>
<h4 id="可视化句法"><a href="#可视化句法" class="headerlink" title="可视化句法"></a>可视化句法</h4><p>以下是一些通过可视化格式指定的约束示例。请注意其中文字是如何匹配示意图的。</p>
<ul>
<li>标准间距</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[button]-[textField]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/standardSpace.png" alt="img"></p>
<ul>
<li>宽度约束</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[button(&gt;=<span class="number">50</span>)]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/widthConstraint.png" alt="img"></p>
<ul>
<li>连接到父视图</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">|<span class="number">-50</span>-[purpleBox]<span class="number">-50</span>-|</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/connectionToSuperview.png" alt="img"></p>
<ul>
<li>垂直布局</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">V:[topField]<span class="number">-10</span>-[bottomField]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/verticalLayout.png" alt="img"></p>
<ul>
<li>对齐的视图</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[maroonView][blueView]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/flushViews.png" alt="img"></p>
<ul>
<li>优先级</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[button(<span class="number">100</span>@<span class="number">20</span>)] <span class="comment">// 这里优先级为20</span></div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/priority.png" alt="img"></p>
<ul>
<li>等宽</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[button1(==button2)]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/equalWidths.png" alt="img"></p>
<ul>
<li>多项描述</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[flexibleButton(&gt;=<span class="number">70</span>,&lt;=<span class="number">100</span>)]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/multiplePredicates.png" alt="img"></p>
<ul>
<li>完整的一行布局</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">|-[find]-[findNext]-[findField(&gt;=<span class="number">20</span>)]-|</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/completeLayout.png" alt="img"></p>
<p>这种表示法通过完整的表达式提高了可读性。大多数的可用约束都可以通过可视化格式句法在用户界面中表示出来，但是还是有一些不可以。一种不能表示的约束即指定的宽高比（例如，<em>imageView.width = 2 </em> imageView.height*）。要创建这个约束，你必须使用<a href="https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init" target="_blank" rel="external">constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:</a>方法。</p>
<h4 id="可视化格式字符串语法"><a href="#可视化格式字符串语法" class="headerlink" title="可视化格式字符串语法"></a>可视化格式字符串语法</h4><p>可视化格式字符串语法的定义如下（字面量使用<em>代码字体</em>表示，<strong>e</strong>代表空字符串）。</p>
<blockquote>
<p>译者注：</p>
<ul>
<li>表中的“?”代表修饰项为可选的，</li>
<li>“*”代表前面的修饰项的个数是任意的</li>
<li>“替换规则”中的每一项“&lt;…&gt;”可当做变量在“符号”中查找替换</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>符号</th>
<th>替换规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;可视化格式字符串&gt;</td>
<td>(&lt;方向&gt;:)?(&lt;父视图&gt;&lt;连接&gt;)?&lt;视图&gt;(&lt;连接&gt;&lt;视图&gt;)*(&lt;连接&gt;&lt;父视图&gt;)?</td>
</tr>
<tr>
<td>&lt;方向&gt;</td>
<td><em>H</em> 或 <em>V</em></td>
</tr>
<tr>
<td>&lt;父视图&gt;</td>
<td>&#124;</td>
</tr>
<tr>
<td>&lt;视图&gt;</td>
<td><em>[</em> &lt;视图名&gt;(&lt;带括号的描述列表&gt;)? <em>]</em></td>
</tr>
<tr>
<td>&lt;连接&gt;</td>
<td><strong>e</strong> 或 <em>-</em>&lt;描述列表&gt;<em>-</em> 或 <em>-</em></td>
</tr>
<tr>
<td>&lt;描述列表&gt;</td>
<td>&lt;简单描述&gt; 或 &lt;带括号的描述列表&gt;</td>
</tr>
<tr>
<td>&lt;简单描述&gt;</td>
<td>&lt;度量名称&gt; 或 &lt;确定数字&gt;</td>
</tr>
<tr>
<td>&lt;带括号的描述列表&gt;</td>
<td><em>(</em> &lt;描述&gt;(,&lt;描述&gt;)<em> </em>)*</td>
</tr>
<tr>
<td>&lt;描述&gt;</td>
<td>(&lt;关系&gt;)?(&lt;描述的对象&gt;)(<em>@</em>&lt;优先级&gt;)?</td>
</tr>
<tr>
<td>&lt;关系&gt;</td>
<td><em>==</em> 或 <em>&lt;=</em> 或 <em>&gt;=</em></td>
</tr>
<tr>
<td>&lt;描述的对象&gt;</td>
<td>&lt;常量值&gt; 或 &lt;视图名称&gt; <em>（见说明）</em></td>
</tr>
<tr>
<td>&lt;优先级&gt;</td>
<td>&lt;度量名称&gt; 或 &lt;数字&gt;</td>
</tr>
<tr>
<td>&lt;常量值&gt;</td>
<td>&lt;度量名称&gt; 或 &lt;数字&gt;</td>
</tr>
<tr>
<td>&lt;视图名称&gt;</td>
<td>解析为C语言符号。此对象必须是传入的视图字典中，一个UIView实例对应的key值。</td>
</tr>
<tr>
<td>&lt;度量名称&gt;</td>
<td>解析为C语言符号。此对象必须是传入的度量字典中，一个NSNumber实例对应的key值。</td>
</tr>
<tr>
<td>&lt;数字&gt;</td>
<td>通过<em>strtod_l</em>解析（注：解析成浮点数），使用C语言格式</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>说明</strong></p>
<p>在<em>描述的对象</em>的生成方式中，只有当描述的对象是<em>视图</em>的宽或高时，<em>视图名称</em>才可以作为其中的一部分。也就是说，你可以使用 <em>[view1(==view2)]</em> 的方式来指定<em>view1</em>和<em>view2</em>拥有相同宽度。</p>
</blockquote>
<p>如果你产生了句法错误，系统会抛出异常并带有诊断信息。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Expected <span class="string">':'</span> after <span class="string">'V'</span> to specify vertical arrangement</div><div class="line">V|[backgroundBox]|</div><div class="line"> ^</div><div class="line"> </div><div class="line">A predicate on a view's thickness must end with <span class="string">')'</span> <span class="keyword">and</span> the view must end with <span class="string">']'</span></div><div class="line">|[whiteBox1][blackBox4(blackWidth][redBox]|</div><div class="line">                                 ^</div><div class="line"> </div><div class="line">Unable to find view with name blackBox</div><div class="line">|[whiteBox2][blackBox]</div><div class="line">                     ^</div><div class="line"> </div><div class="line">Unknown relation. Must be ==, &gt;=, <span class="keyword">or</span> &lt;=</div><div class="line">V:|[blackBox4(&gt;<span class="number">30</span>)]|</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Visual Format Language&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇附录阐述了如何使用Auto Layout可视化语言来设定普通约束，包括标准间距、尺寸、垂直布局和带有不同优先级的约束等。此外，本附录还包含了一个完整的语法说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》之算法的时间复杂度</title>
    <link href="http://yoursite.com/2019/03/05/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E4%B9%8B%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://yoursite.com/2019/03/05/《大话数据结构》之算法的时间复杂度/</id>
    <published>2019-03-05T07:23:16.914Z</published>
    <updated>2019-03-05T07:23:38.227Z</updated>
    
    <content type="html"><![CDATA[<p>算法的时间复杂度一般是指算法的最坏执行情况（最大执行次数）。</p>
<h4 id="1-大O表示法"><a href="#1-大O表示法" class="headerlink" title="1. 大O表示法"></a>1. 大O表示法</h4><p>衡量算法的复杂度（一般指时间复杂度）通常使用大O表示法，其推导的一般方式为：</p>
<ol>
<li>用常数1取代运行时间中的所有加法常数。</li>
<li>在修改后的运行次数函数中，只保留最高阶项。</li>
<li>如果最高阶项存在且不是1，则去除与这个项乘积的常数。</li>
</ol>
<p>最终得到的结果就是大O阶。</p>
<a id="more"></a>
<h4 id="2-常用的大O阶"><a href="#2-常用的大O阶" class="headerlink" title="2. 常用的大O阶"></a>2. 常用的大O阶</h4><ul>
<li>常数阶<br>  O(1)：如顺序结构的复杂度或是分支结构（if–else–），执行次数恒定，不会随n变化而变化。</li>
<li>线性阶<br>  O(n)：如循环结构，根据循环次数决定。</li>
<li>对数阶<br>  O(logn): 例如如下循环</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span>(count &lt; n) &#123;</div><div class="line">    count = count * <span class="number">2</span>;</div><div class="line">    <span class="comment">/** 时间复杂度为O(1)的顺序步骤序列 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>如上所示，x为执行次数，2^x = n，即x = log2n，故时间复杂度为O(logn)。
</code></pre><ul>
<li>平方阶<br>  O(n^2)：如双重嵌套循环。</li>
</ul>
<h4 id="3-常见的时间复杂度排列"><a href="#3-常见的时间复杂度排列" class="headerlink" title="3. 常见的时间复杂度排列"></a>3. 常见的时间复杂度排列</h4><p>耗费时间从小到大依次为：</p>
<blockquote>
<p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法的时间复杂度一般是指算法的最坏执行情况（最大执行次数）。&lt;/p&gt;
&lt;h4 id=&quot;1-大O表示法&quot;&gt;&lt;a href=&quot;#1-大O表示法&quot; class=&quot;headerlink&quot; title=&quot;1. 大O表示法&quot;&gt;&lt;/a&gt;1. 大O表示法&lt;/h4&gt;&lt;p&gt;衡量算法的复杂度（一般指时间复杂度）通常使用大O表示法，其推导的一般方式为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用常数1取代运行时间中的所有加法常数。&lt;/li&gt;
&lt;li&gt;在修改后的运行次数函数中，只保留最高阶项。&lt;/li&gt;
&lt;li&gt;如果最高阶项存在且不是1，则去除与这个项乘积的常数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终得到的结果就是大O阶。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之修改约束</title>
    <link href="http://yoursite.com/2019/03/04/%20Autolayout%E4%B9%8B%E4%BF%AE%E6%94%B9%E7%BA%A6%E6%9D%9F/"/>
    <id>http://yoursite.com/2019/03/04/ Autolayout之修改约束/</id>
    <published>2019-03-04T08:55:42.105Z</published>
    <updated>2019-03-04T08:55:42.105Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW1" target="_blank" rel="external">Changing Constraints</a></p>
</blockquote>
<p>对一个约束进行所有的改变实质上就是修改该约束的数学表达式（见图17-1）。你可以在<a href="">Anatomy of a Constraint</a>中查看更多关于约束方程的信息。</p>
<a id="more"></a>
<p><strong>图17-1</strong> 约束方程式</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/view_formula_2x.png" alt="img"></p>
<p>下列所有行为都会改变一个或多个约束：</p>
<ul>
<li>激活或失效约束</li>
<li>修改约束的常数值（constant value）</li>
<li>修改约束的优先级</li>
<li>从视图层级中移除视图</li>
</ul>
<p>其他改变，如设置控件的属性，或是修改视图层级，都可以改变约束。当改变发生时，系统会预设置出一个延迟布局阶段（查看<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW3" target="_blank" rel="external">The Deferred Layout Pass</a>）。</p>
<p>一般来说，你可以在任意时刻设置这些修改。理想情况下，大多数约束都会在Interface Builder中设置，或者是在ViewController的初始化配置时（如<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621495-viewdidload" target="_blank" rel="external">viewDidLoad</a>）通过代码创建。如果你需要在运行时动态修改约束，通常最好的方式就是在应用程序状态变化时进行修改。例如，如果你想修改一个约束来响应按钮的点击操作，那就直接在该按钮的动作方法中进行修改。</p>
<p>有时候，为了优化性能，你可能需要分阶段进行一系列的修改。要了解更多信息，请查看<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW2" target="_blank" rel="external">Batching Changes</a>。</p>
<h4 id="延迟布局阶段（The-Deferred-Layout-Pass）"><a href="#延迟布局阶段（The-Deferred-Layout-Pass）" class="headerlink" title="延迟布局阶段（The Deferred Layout Pass）"></a>延迟布局阶段（The Deferred Layout Pass）</h4><p>为了避免直接更新受影响视图的frame，Auto Layout设置了一个稍后执行的布局阶段。此延迟阶段首先更新布局的约束，之后为视图层级中的所有视图计算frame。</p>
<p>你可以通过调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout" target="_blank" rel="external">setNeedsLayout</a>或<a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="external">setNeedsUpdateConstraints</a>方法设置自己的延迟布局阶段。</p>
<p>视图层级中的延迟布局阶段通常由两个阶段组成：</p>
<ol>
<li>如果需要，在更新阶段（Update Pass）更新约束</li>
<li>如果需要，在布局阶段（Layout Pass）重设视图的frame</li>
</ol>
<h5 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h5><p>系统会遍历视图层级，并在所有的ViewController上调用<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621379-updateviewconstraints" target="_blank" rel="external">updateViewConstraints</a>方法、在所有视图上调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="external">updateConstraints</a>方法。你可以覆盖这些方法来优化约束的修改（查看<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW2" target="_blank" rel="external">Batching Changes</a>）。</p>
<h5 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h5><p>系统再一次遍历视图层级，并在所有ViewController上调用<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews" target="_blank" rel="external">viewWillLayoutSubviews</a>、在所有视图上调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="external">layoutSubViews</a>。默认来说，<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="external">layoutSubViews</a>方法会使用Auto Layout引擎算出的矩形来更新每个子视图的frame。你可以覆盖这些方法来修改布局（查看<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW4" target="_blank" rel="external">Custom Layouts</a>）。</p>
<h4 id="分阶段修改（Batching-Changes）"><a href="#分阶段修改（Batching-Changes）" class="headerlink" title="分阶段修改（Batching Changes）"></a>分阶段修改（Batching Changes）</h4><p>在有影响的修改发生后，直接更新约束应该总是最简洁、最方便的方式。将这些修改延迟到之后的方法中执行，会使代码更加复杂并难以理解。</p>
<p>可是，总有一些时候你想要为了优化性能而进行分阶段的修改。如当修改约束的地方执行太慢，或是视图正在进行许多冗余修改时，使用这种方式便可以解决。</p>
<p>要对改变进行分阶段执行，不要直接进行修改，而是在包含该约束的视图上调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="external">setNeedsUpdateConstraints</a>方法。之后，覆盖视图的<a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="external">updateConstraints</a>方法来修改受影响的约束。</p>
<blockquote>
<p><strong>说明</strong></p>
<p>你的<a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="external">updateConstraints</a>的实现必须尽可能高效。不要让所有的约束失效（deactivate），可以根据需要失效其中一部分。此外，你的app必须存在某些方式来追踪约束，并且可以在每一个更新阶段来验证它们。只改变那些需要改变的项目。在每一次更新阶段中，你必须确保为app的当前状态提供了适合的约束。</p>
</blockquote>
<p>在<a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="external">updateConstraints</a>方法实现中，最后一步一定要调用父类的实现。</p>
<p>不要在你的<a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="external">updateConstraints</a>方法中调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="external">setNeedsUpdateConstraints</a>方法。调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="external">setNeedsUpdateConstraints</a>会设置另一个更新阶段，进而生成了调用循环。</p>
<h4 id="自定义布局（Custom-Layouts）"><a href="#自定义布局（Custom-Layouts）" class="headerlink" title="自定义布局（Custom Layouts）"></a>自定义布局（Custom Layouts）</h4><p>覆盖<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews" target="_blank" rel="external">viewWillLayoutSubViews</a>或<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="external">layoutSubViews</a>方法来修改layout引擎返回的结果。</p>
<blockquote>
<p><strong>重点</strong></p>
<p>如果可能，使用约束来定义所有的布局。这可以使布局结果更加健壮且更易调试。当你需要创建一个布局，且此布局仅仅通过约束无法达到要求时，你只能通过覆盖<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews" target="_blank" rel="external">viewWillLayoutSubViews</a>或<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="external">layoutSubViews</a>方法进行处理。</p>
</blockquote>
<p>在覆盖这些方法时，布局正处在一个不确定的状态。一部分视图可能已经布局完，另一部分则没有。在修改视图层级时，你需要非常小心，否则很可能就会导致调用循环。如下规则可以帮助你避免调用循环：</p>
<ul>
<li>你必须在方法的某处调用父类的实现。</li>
<li>你可以安全地在子树中让视图布局无效化；可是，你必须在调用父类的实现之前做这件事。</li>
<li>不要让在子树外的任何视图布局无效化。这会导致调用循环。</li>
<li>不要调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="external">setNeedsUpdateConstraints</a>。你刚刚完成了一次更新阶段。调用此方法会产生一个调用循环。</li>
<li>不要调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout" target="_blank" rel="external">setNeedsLayout</a>。调用此方法会产生一个调用循环。</li>
<li>修改约束时要格外小心。你不能意外地让子树外的视图布局无效化。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Changing Constraints&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对一个约束进行所有的改变实质上就是修改该约束的数学表达式（见图17-1）。你可以在&lt;a href=&quot;&quot;&gt;Anatomy of a Constraint&lt;/a&gt;中查看更多关于约束方程的信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
