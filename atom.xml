<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭吉吉的瞎记空间</title>
  <subtitle>技术的，瞎说的，啥都有吧。。。希望。。。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-18T03:28:39.995Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>臭吉吉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Objective-C Runtime编程指南之消息转发</title>
    <link href="http://yoursite.com/2019/07/18/Objective-C%20Runtime%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E4%B9%8B%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>http://yoursite.com/2019/07/18/Objective-C Runtime编程指南之消息转发/</id>
    <published>2019-07-18T03:28:28.431Z</published>
    <updated>2019-07-18T03:28:39.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html" target="_blank" rel="external">Message Forwarding</a></p>
</blockquote>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>给一个对象发送其不能处理的消息会产生错误。可是，在发生错误之前，运行时系统给接收对象一个二次机会来处理这个消息。</p>
<a id="more"></a>
<h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>如果你给一个对象发送其不能处理的消息时，在产生错误之前，运行时会发送给对象一个<em>forwardInvocation:</em> 消息，此消息包含一个<em>NSInvocation</em>对象作为唯一参数—-这个<em>NSInvocation</em>对象中包含了之前的原始消息和参数。</p>
<p>你可以实现<em>forwardInvocation:</em> 方法来提供一个默认消息响应，或者用某种其他方式来避免错误。就像名称所说那样，<em>forwardInvocation:</em> 一般用于将消息转发给其他对象。</p>
<p>要了解转发的适用范围和目的，设想下面的场景：首先，假设你正在设计一个对象，它可以响应一个叫<em>negotiate</em>的消息，并且你想要它的响应中包含其他种类对象的响应。你可以很容易地完成它：只需要在你的<em>negotiate</em>方法体中，给其他对象再发送一个<em>negotiate</em>消息。</p>
<p>再想深一点，设想你想要你的对象能够响应<em>negotiate</em>消息，但是其实现却其他类中。完成它的一种方法就是让你的类继承于其他类。可是，这种情况有可能做不到。也许有很多原因导致你的类和实现了<em>negotiate</em>方法的类在不同的继承体系中。</p>
<p>即使你的类不能继承到<em>negotiate</em>方法，你还可以通过”借“的方式来实现一个特别的版本，就是将这个消息直接传递给一个其他类的实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (id)negotiate</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ( [someOtherObject respondsTo:@selector(negotiate)] )</div><div class="line">        <span class="keyword">return</span> [someOtherObject negotiate];</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式可能有一点笨，特别是当你想把许多消息都赚给其他对象时。你必须把从其他类借到的方法依次实现。此外，有时候你不太可能处理到那些你不知道的情况，因为你只是写了那些你当时准备转发的消息代码。这一些消息可能取决于运行时，并且很有可能在未来变成一些新的方法和类。</p>
<p>通过<em>forwardInvocation:</em> 消息提供的第二次机会是一个不太特别的解决方案，而且是个动态方案。其工作过程如下：当一个对象不能响应一个消息时（因为它没有一个可以匹配消息中选择器的方法），运行时系统会给对象发送一个<em>forwardInvocation:</em> 消息。每一个对象都从<em>NSObject</em>类中继承了<em>forwardInvocation:</em> 方法。可是，<em>NSObject</em>的实现版本仅仅调用了<em>doesNotRecognizeSelector:</em> 方法。通过覆盖<em>NSObject</em>的版本并进行你自身的实现，你可以利用这次机会通过<em>forwardInvocation:</em> 将消息转发给其他对象。</p>
<p>要转发一个消息，所有的<em>forwardInvocation:</em> 方法需要按下面的方式去做：</p>
<ul>
<li>决定这个消息要去哪，并且</li>
<li>带着原始参数给它发送过去</li>
</ul>
<p>这个消息可以通过<em>invokeWithTarget:</em> 方法进行发送：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([someOtherObject respondsToSelector:</div><div class="line">            [anInvocation selector]])</div><div class="line">        [anInvocation invokeWithTarget:someOtherObject];</div><div class="line">    <span class="keyword">else</span></div><div class="line">        [super forwardInvocation:anInvocation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转发出的消息的返回值会被返回给原始的接收者。所有类型的返回值都可以被传递给接收者，包括id、结构体和双精度浮点数等。</p>
<p><em>forwardInvocation:</em> 方法对于不能识别的消息扮演着一个分发中心的角色，给这些消息打包发送给不同的接收者。或者它也可以当做一个中转站，发送所有消息到同一个目的地。它可以将一个消息转换为另一个，或者直接”吞掉“某些消息使其不产生响应或错误。一个<em>forwardInvocation:</em> 方法还可以将多个消息合并到一个响应中。<em>forwardInvocation:</em> 方法所做的事情都由实现者决定。可是，它提供的一种将对象链接到到转发链中的机会为程序设计提供了新的可能性。</p>
<blockquote>
<p>注意：</p>
<p><strong>只有当正常的接收者不能调用一个存在的方法时，<em>forwardInvocation:</em> 方法才会收到待处理消息</strong>。例如，如果你想要你的对象转发<em>negotiate</em>消息给另一个对象，那么它自己就不能包含<em>negotiate</em>方法。如果存在此方法，消息就绝不会到达<em>forwardInvocation:</em> 中。</p>
</blockquote>
<p>查看更多关于转发和调用的信息，请在Foundation框架参考中查看<em>NSInvocation</em>类的说明。</p>
<h4 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h4><p>转发模拟了继承，并且可以被用于在Objective-C程序中实现出一些多继承的效果。如<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-87317" target="_blank" rel="external">图表5-1</a>所示，通过转发来响应消息的对象就好像是从另一个类中”继承“了方法实现一样。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/forwarding.gif" alt="图表5-1"></p>
<p>在这个插图中，一个Warrior类的实例转发<em>negotiate</em>消息给了一个Diplomat类的实例。Warrior看起来就好像是一个Diplomat一样。就好像它响应了<em>negotiate</em>消息，并且从实际上看，它确实响应了（虽然是一个Diplomat完成的工作）。</p>
<p>转发消息的对象从而通过两个继承体系的分支中“继承”了方法—-它自己的分支和响应消息的那个对象的分支。在上面的例子中，和自己的父类一样，看起来就好像Warrior类也继承于Diplomat类。</p>
<p>转发提供了大多数的多继承特性。可是，在二者之间还是存在一点重要的不同：多继承将不同的能力合并在了一个对象中。而转发，却将不同的功能分配给了不同的对象。它将问题分解到小的对象中，却用一种对消息发送者透明的方式将这些对象联系起来。</p>
<h4 id="替代者对象"><a href="#替代者对象" class="headerlink" title="替代者对象"></a>替代者对象</h4><p>转发不仅模拟了多继承，它还使开发一个可以代表或者“隐藏”大量对象的轻量级对象成为可能。替代者替代了其他对象并且将消息过滤给它们。</p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163" target="_blank" rel="external">The Objective-C Programming Language</a>中的“Remote Messaging”中讨论的代理就是这样一个替代者。代理负责了将消息转发给远程接收者的所有管理细节，确保参数值通在连接中被拷贝和取回，等等。但是它并没有做更多工作；代理并没有复制远程对象的功能，只是简单地给远程对象一个本地地址，即一个可以从其他应用程序中接收消息的位置。</p>
<p>其他种类的替代者对象也可以做到这些。假设，你有一个可以操作许多数据的对象—-也许它创建了一个复杂的图片或者从磁盘上的文件中读取了内容。创建这个对象也许会非常耗时，所以你更想进行懒加载—-当真的需要时或者是系统资源空闲时。同时，你至少需要一个占位对象来保证应用程序中的其他对象可以正常工作。</p>
<p>在这种情况下，你并不需要创建一个完整的对象，而是一个轻量级的替代者。此对象可以做一些自己的事情，比如回答关于数据的问题，但多数情况下，它只是为那个大对象占用一个位置，当真的需要时，就转发消息给它。当替代者的<em>forwardInvocation:</em> 收到消息并指向其他对象时，它可以确保改对象存在或者当不存在时可以创建出来。大对象的所有消息都会通过替代者传送过来，因此，无论程序的其他部分如何关心，替代者和大对象都是相同的。</p>
<h4 id="转发和继承"><a href="#转发和继承" class="headerlink" title="转发和继承"></a>转发和继承</h4><p>虽然转发模拟了继承，但<em>NSObject</em>类从不会将二者弄混。<strong>像<em>respondsToSelector:</em> 和 <em>isKindOfClass:</em> 的这种方法只会在继承体系中查找，而绝不会在转发链中查找</strong>。例如，如果一个Warrior对象被询问是否可以响应<em>negotiate</em>消息时，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( [aWarrior respondsToSelector:@selector(negotiate)] )</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>答案是NO，尽管它可以接收<em>negotiate</em>消息，不发生错误并能够进行响应，在某种意义上，通过转发消息给Diplomat对象（见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-87317" target="_blank" rel="external">图表5-1</a>）。</p>
<p>在许多情况下，NO就是正确答案。但也可能不是。如果你通过转发来创建一个替代者对象或者扩展类的能力，转发机制应该和继承一样透明。如果你想让你的对象看起来就像真的继承于转发消息的对象，你就需要重新实现<em>respondsToSelector:</em> 和<em>isKindOfClass:</em> 方法，以便包含你的转发规则。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (BOOL)respondsToSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ( [super respondsToSelector:aSelector] )</div><div class="line">        <span class="keyword">return</span> YES;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* Here, test whether the aSelector message can     *</span></div><div class="line">         * be forwarded to another object and whether that  *</div><div class="line">         * object can respond to it. Return YES if it can.  */</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了<em>respondsToSelector:</em> 和<em>isKindOfClass:</em> 方法之外，<em>instancesRespondToSelector:</em> 方法也应该模拟转发规则。如果协议被使用了，<em>conformsToProtocol:</em> 方法也应该加到修改列表中。相似地，如果一个对象转发了任何它收到的远程消息，它应该包含一个<em>methodSignatureForSelector:</em> 方法的版本，它可以返回最终要响应的转发消息的准确描述。例如，如果一个对象正要转发消息给它的替代者，你可以向下面这样实现<em>methodSignatureForSelector:</em> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector</div><div class="line">&#123;</div><div class="line">    NSMethodSignature* signature = [super methodSignatureForSelector:selector];</div><div class="line">    <span class="keyword">if</span> (!signature) &#123;</div><div class="line">       signature = [surrogate methodSignatureForSelector:selector];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> signature;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你还可以考虑将转发规则放到一些私有代码中，并且让所有的待转发方法都调用它（包括<em>forwardInvocation:</em>）。</p>
<blockquote>
<p>注意：</p>
<p>这是一项高级技术，只适合那些没有其他解决方案时的场景。不能用它来代替继承。如果你必须使用此项技术，确保你完整地理解了使用转发的类和转发到的类的所有行为。</p>
</blockquote>
<p>在本节中提到的方法都在Foundation框架指南的<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/cl/NSObject" target="_blank" rel="external">NSObject</a>类的说明中都有描述。要查看<em>invokeWithTarget:</em> 的更多信息，请查看Foundation框架指南的<a href="https://developer.apple.com/documentation/foundation/nsinvocation" target="_blank" rel="external">NSInvocation</a>类的说明。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Message Forwarding&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;消息转发&quot;&gt;&lt;a href=&quot;#消息转发&quot; class=&quot;headerlink&quot; title=&quot;消息转发&quot;&gt;&lt;/a&gt;消息转发&lt;/h3&gt;&lt;p&gt;给一个对象发送其不能处理的消息会产生错误。可是，在发生错误之前，运行时系统给接收对象一个二次机会来处理这个消息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime编程指南之动态方法解析</title>
    <link href="http://yoursite.com/2019/07/18/Objective-C%20Runtime%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E4%B9%8B%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/07/18/Objective-C Runtime编程指南之动态方法解析/</id>
    <published>2019-07-18T03:27:44.799Z</published>
    <updated>2019-07-18T03:28:10.383Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html#//apple_ref/doc/uid/TP40008048-CH102-SW1" target="_blank" rel="external">Dynamic Method Resolution</a></p>
</blockquote>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>本章节描述了如何动态地为方法提供实现。</p>
<a id="more"></a>
<h4 id="动态方法解析-1"><a href="#动态方法解析-1" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>有一些情况下，你可能想要为方法动态地提供实现。比如，声明的Objective-C属性的特性（在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163" target="_blank" rel="external">The Objective-C Programming Language</a>中查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17" target="_blank" rel="external">Declared Properties</a>）中包含了 <em>@dynamic</em> 关键字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@dynamic propertyName;</div></pre></td></tr></table></figure>
<p>它告诉了编译器与属性相关的方法需要动态提供。</p>
<p>你分别可以通过实现<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418500-resolveinstancemethod" target="_blank" rel="external">resolveInstanceMethod:</a>和<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418889-resolveclassmethod" target="_blank" rel="external">resolveClassMethod:</a>方法为指定的实例方法或类方法的选择器动态地提供实现。</p>
<p>一个Objective-C方法就是一个至少包含了两个参数的C函数—-<em>self</em> 和 <em>_cmd</em> 。你可以通过使用<a href="https://developer.apple.com/documentation/objectivec/1418901-class_addmethod" target="_blank" rel="external">class_addMethod</a>函数给类添加一个函数。因此，给定了如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamicMethodIMP</span><span class="params">(id self, SEL _cmd)</span> </span>&#123;</div><div class="line">    <span class="comment">// implementation ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像下面这样，你可以使用<em>resolveInstanceMethod:</em> 方法来给类动态添加一个方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@implementation MyClass</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (aSEL == @selector(resolveThisMethodDynamically)) &#123;</div><div class="line">          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, <span class="string">"v@:"</span>);</div><div class="line">          <span class="keyword">return</span> YES;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [super resolveInstanceMethod:aSEL];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>转发方法（在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1" target="_blank" rel="external">Message Forwarding</a>中描述的那样）和动态方法解析是在对立面的。一个类在转发机制进入之前，有机会动态解析出一个方法。如果<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Protocols/NSObject/Description.html#//apple_ref/occ/intfm/NSObject/respondsToSelector:" target="_blank" rel="external">respondsToSelector:</a>或<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/clm/NSObject/instancesRespondToSelector:" target="_blank" rel="external">instancesRespondToSelector:</a>被调用，动态方法解析器就会首先给机会让选择器提供一个<em>IMP</em>。如果你实现了<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418500-resolveinstancemethod" target="_blank" rel="external">resolveInstanceMethod:</a>方法，但是想要指定选择器通过转发机制转发走，你可以在那些选择器中返回NO。</p>
<h4 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h4><p>一个Objective-C程序可以在运行的过程中加载和链接新的类和分类。新的代码被添加到程序中并且与在程序开始时加载的类和分类同等对待。</p>
<p>动态加载可以被用于做许多不同的事情。比如，在系统偏好设置程序中，各种模块都是动态加载的。</p>
<p>在Cocoa环境中，动态加载普遍用于允许程序的自定义上。第三方可以编写一些在运行时加载的模块—-就像Interface Builder加载自定义调色板或者是OS X系统偏好设置加载自定义设置模块一样。可加载的模块扩展了应用程序的功能。这个功能可以在你允许但是可能没有想到的方式上给应用程序提供帮助。你提供了框架，第三方可以提供代码。</p>
<p>虽然在Mach-O文件中，有一个运行时函数可以执行Objective-C模块的动态加载（<em>objc_loadModules</em>，定义在<em>objc/objc-load.h</em>文件中），Cocoa的<em>NSBundle</em>类提供了一个更加方便的接口用于动态加载—-一个面向对象的并且与相关服务结合到一起的接口。在Foundation框架参考中查看<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSBundle/Description.html#//apple_ref/occ/cl/NSBundle" target="_blank" rel="external">NSBundle</a>类的相关说明及使用方法。在OS X的ABI Mach-O文件格式参考中查看Mach-O文件的相关信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html#//apple_ref/doc/uid/TP40008048-CH102-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dynamic Method Resolution&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;动态方法解析&quot;&gt;&lt;a href=&quot;#动态方法解析&quot; class=&quot;headerlink&quot; title=&quot;动态方法解析&quot;&gt;&lt;/a&gt;动态方法解析&lt;/h3&gt;&lt;p&gt;本章节描述了如何动态地为方法提供实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime编程指南之发送消息</title>
    <link href="http://yoursite.com/2019/07/18/Objective-C%20Runtime%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E4%B9%8B%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2019/07/18/Objective-C Runtime编程指南之发送消息/</id>
    <published>2019-07-18T03:27:18.831Z</published>
    <updated>2019-07-18T03:27:18.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html" target="_blank" rel="external">Messaging</a></p>
</blockquote>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>本章描述了消息表达式如何被转化为<a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend" target="_blank" rel="external">objc_msgSend</a>函数调用，还有如何通过名字索引到方法。之后解释了你如何利用<em>objc_msgSend</em>，还有—-如果需要—-如何规避动态绑定过程。</p>
<a id="more"></a>
<h4 id="objc-msgSend函数"><a href="#objc-msgSend函数" class="headerlink" title="objc_msgSend函数"></a>objc_msgSend函数</h4><p>在Objective-C中，消息直到运行时才会被绑定到方法实现上。编译器将消息表达式进行转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[receiver message]</div></pre></td></tr></table></figure>
<p>转换为消息函数的调用，<a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend" target="_blank" rel="external">objc_msgSend</a>。此函数携带着消息中的<strong>接受者</strong>和<strong>方法名</strong>（即选择器）作为函数的两个必要参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector)</div></pre></td></tr></table></figure>
<p>消息中传入的其他参数也会被<em>objc_msgSend</em>进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure>
<p>这个消息函数为动态绑定做了所有必要的事情：</p>
<ul>
<li>首先，消息函数查找选择器指向的程序（即方法实现）。由于在不同的类中，相同的方法可以有不同的实现，因此确定的实现取决于查找的接收者的类。</li>
<li>之后要调用此实现程序，传入接收对象（其数据的指针），方法指定的其他参数也一同传入。</li>
<li>最后，消息函数将实现程序调用后的返回值传回来，就好像自己的返回值一样。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：</p>
<p>编译器会自动调用此消息函数。你一定不要在代码中直接调用它。</p>
</blockquote>
<p>发送消息的关键在于编译器为每个类和对象构建的结构体。每个类的结构体包含以下两个必要的元素：</p>
<ul>
<li><strong>一个指向父类的指针</strong></li>
<li><strong>一个类的<em>分发表</em>。此表包含一个入口，可以把方法选择器和指定类的方法地址连接在一起</strong>。<em>setOrigin::</em> 方法的选择器和 <em>setOrigin::</em> 的地址（实现程序）连接在了一起，<em>display</em> 方法的选择器和 <em>display</em> 的地址连接在了一起，等等。</li>
</ul>
<p>当一个新对象被创建出来时，其内存已经被分配好，其实例变量也已经初始化。此对象中的第一个变量是一个指向它所属类结构体的指针。这个指针，叫做<strong>isa</strong>，给予此对象访问其所属类的能力，并且通过这个类，还可以访问到所有其继承到的类。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<p>虽然不能严格算是编程语言的一部分，但对于一个对象来说，在与Objective-C运行时系统协同工作时，isa指针却是十分必要的。一个对象”等价于“一个包含了定义的所有字段的<strong>objc_object结构体</strong>（定义在<em>objc/objc.h</em>中）。可是，你几乎用不到自己来创建根对象，继承了NSObject和NSProxy类的对象早已自动包含了isa指针。</p>
</blockquote>
<p>这些类的元素和对象结构体如插图3-1中所示：</p>
<p><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt="发送消息框架"></p>
<p>当消息发送给某个对象时，发送消息函数会沿着对象的isa指针找到该类的结构体，在其中的分发表中查找方法的选择器。如果在这里找不到选择器，<em>objc_msgSend</em>会沿着其父类的指针继续，并试图在父类的分发表中查找该选择器。连续的失败会导致<em>objc_msgSend</em>会沿着类的层级一直向上爬，直到到达<em>NSObject</em>类。一旦锁定了选择器，此函数就会在分发表中进入此方法中进行调用，并且传入接收者对象的数据结构。</p>
<p>以上就是方法实现在运行时被查找的方式—-或者，用面向对象的行话来说，那个方法被动态绑定到了消息上。</p>
<p>为了加速消息发送过程，一旦被使用，运行时系统会缓存该方法的选择器和地址。在每个类中都包含一个独立的缓存区域，并且它同样可以包含继承来的方法选择器。在查找分发表之前，消息发送程序会首先检查接收者类中的缓存（理论上来说，一个方法只要被用过一次就极有可能再次被使用）。如果方法选择器在缓存中，消息发送过程就只会比直接的函数调用稍慢一些。一旦程序已经运行足够的时间来给缓存”热身“，几乎所有发送的消息就都可以找到对应的缓存方法。随着程序的运行，缓存会动态增长空间来缓存新保存的消息。</p>
<h4 id="使用隐藏参数"><a href="#使用隐藏参数" class="headerlink" title="使用隐藏参数"></a>使用隐藏参数</h4><p>当<a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend" target="_blank" rel="external">objc_msgSend</a>找到了方法的实现程序后，它便调用此程序且将消息中包含的所有参数传递进去。它还会传入两个隐藏参数：</p>
<ul>
<li>接收者对象</li>
<li>方法的选择器</li>
</ul>
<p>这些参数给每一个方法实现提供了代码调用时方法表达式中的两个明确信息。它们被叫做”隐藏“，是因为在定义的方法中没有声明二者。它们只在代码编译时被插入到实现中。</p>
<p>虽然这些参数没有明确声明，源码还是可以索引到它们（就像源码可以索引到接收者内部的实例变量一样）。<strong>一个方法把接收者对象称作<em>self</em>，把其自身的选择器称作 <em>_cmd</em></strong>。在下面的例子中，<em>_cmd</em>代表了<em>strange</em>方法的选择器，<em>self</em>则代表了接收<em>strange</em>消息的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- strange</div><div class="line">&#123;</div><div class="line">    id  target = getTheReceiver();</div><div class="line">    SEL method = getTheMethod();</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> ( target == self || method == _cmd )</div><div class="line">        <span class="keyword">return</span> nil;</div><div class="line">    <span class="keyword">return</span> [target performSelector:method];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这两个参数中，<em>self</em>更为有用。实际上，对于方法定义来说，<em>self</em>才是将接收者对象的实例变量变为可用的方式。</p>
<h4 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h4><p><strong>规避动态绑定过程的唯一方法，就是获取方法的地址，然后直接进行函数调用</strong>。这种情况也许非常罕见，也许只有当某个指定方法要连续执行许多次，并且你希望避免每次执行之前进行的消息发送过程。</p>
<p>有一个定义在NSObject类中的方法，名为<em>methodForSelector:</em>，你可以设置一个指向方法实现程序的指针，之后使用这个指针来调用程序。<em>methodForSelector:</em> 返回的指针必须被转换成合适的函数类型，返回值和参数类型都必须包含在类型转换中。</p>
<p>下面的例子展示了<em>setFilled:</em> 方法的实现程序如何是被调用的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (*setter)(id, SEL, BOOL);</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"> </div><div class="line">setter = (<span class="keyword">void</span> (*)(id, SEL, BOOL))[target</div><div class="line">    methodForSelector:@selector(setFilled:)];</div><div class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++ )</div><div class="line">    setter(targetList[i], @selector(setFilled:), YES);</div></pre></td></tr></table></figure>
<p>传入程序中的前两个参数是接收者对象（self）和方法选择器（_cmd）。这些参数被隐藏在方法的语法中，但在方法被作为函数调用时必须明确声明。</p>
<p>使用<em>methodForSelector:</em> 来规避动态绑定过程可以节约消息发送过程中的大部分时间。可是，这种时间节约只有在特定的消息被重复执行许多次时才有意义，就像上面的for循环一样。</p>
<p>注意，<em>methodForSelector:</em> 方法是由Cocoa的运行时系统提供；它并不是Objective-C语言本身的特性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Messaging&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;发送消息&quot;&gt;&lt;a href=&quot;#发送消息&quot; class=&quot;headerlink&quot; title=&quot;发送消息&quot;&gt;&lt;/a&gt;发送消息&lt;/h3&gt;&lt;p&gt;本章描述了消息表达式如何被转化为&lt;a href=&quot;https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;objc_msgSend&lt;/a&gt;函数调用，还有如何通过名字索引到方法。之后解释了你如何利用&lt;em&gt;objc_msgSend&lt;/em&gt;，还有—-如果需要—-如何规避动态绑定过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime编程指南之与运行时系统进行交互</title>
    <link href="http://yoursite.com/2019/07/18/Objective-C%20Runtime%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E4%B9%8B%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B3%BB%E7%BB%9F%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92/"/>
    <id>http://yoursite.com/2019/07/18/Objective-C Runtime编程指南之与运行时系统进行交互/</id>
    <published>2019-07-18T03:26:14.107Z</published>
    <updated>2019-07-18T03:26:37.012Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtInteracting.html" target="_blank" rel="external">Interacting with the Runtime
</a></p>
</blockquote>
<h3 id="与运行时系统进行交互"><a href="#与运行时系统进行交互" class="headerlink" title="与运行时系统进行交互"></a>与运行时系统进行交互</h3><p>Objective-C程序通过三种不同方式与运行时系统进行交互：通过Objective-C代码；通过<em>Foundation</em>框架中定义在<em>NSObject</em>类中的方法；还有通过直接调用运行时的函数。</p>
<a id="more"></a>
<h4 id="Objective-C代码"><a href="#Objective-C代码" class="headerlink" title="Objective-C代码"></a>Objective-C代码</h4><p>对于绝大多数场景下，运行时系统会自动在幕后工作。你需要做的仅仅是编写和编译Objective-C代码即可。</p>
<p>当你编译包含Objective-C类和方法的代码时，编译器会创建对应的数据结构和方法调用来体现语言的动态性。这些数据结构会捕获到类、分类和协议声明中的相关信息；它们包含着在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163" target="_blank" rel="external">The Objective-C Programming Language</a>中<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocDefiningClasses.html#//apple_ref/doc/uid/TP30001163-CH12" target="_blank" rel="external">Defining a Class</a>和<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15" target="_blank" rel="external">Protocols</a>描述的类和协议对象，还有方法选择器、实例变量模板，还有从源代码中提取的其他信息等。最重要的运行时函数就是那个可以发送消息的对象，就像<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html#//apple_ref/doc/uid/TP40008048-CH104-SW1" target="_blank" rel="external">Messaging</a>中描述的一样。它通过源代码消息表达式进行调用。</p>
<h4 id="NSObject的方法"><a href="#NSObject的方法" class="headerlink" title="NSObject的方法"></a>NSObject的方法</h4><p>大多数Cocoa中的对象都是NSObject类的子类，因此大多数对象都继承了其中的方法（例外的是<em>NSProxy</em>类；更多信息请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1" target="_blank" rel="external">Message Forwarding</a>）。因此它的方法会表现出继承的实例和类的默认行为。可是，在某些情况下，NSObject类仅仅是定义了某些事如何做的一个模板；它自身并没有提供所有必要的代码。</p>
<p>例如，NSObject类定义了<em>description</em>实例方法来返回描述类内容的字符串。这个主要用于调试过程—-GDB对象打印命令打印出此方法返回的字符串。NSObject中此方法的实现并不知道本类包含的内容，因此该方法只返回了包含对象名称和内存地址的字符串。NSObject的子类可以实现此方法来返回更多信息。比如，Foundation的<em>NSArray</em>类会返回其包含的所有对象的描述信息。</p>
<p>一些NSObject中的方法只是向运行时系统查询信息。这些方法允许对象来进行”自省“（即查看自身的某些信息）。比如这些方法中的<em>class</em>方法，它让对象来识别出自身的类；<em>isKindOfClass:</em>和<em>isMemberOfClass:</em>，可以检测对象在继承链中的位置；<em>respondsToSelector:</em> 可以判定某对象是否可以接收指定消息；<em>conformsToProtocol:</em> 判定某对象是否声明已经实现了指定协议中的方法（即该类是否遵循了协议）；<em>methodForSelector:</em> 提供了方法实现的地址。形如这些方法都给予了对象检查自身的能力。</p>
<h4 id="运行时的函数"><a href="#运行时的函数" class="headerlink" title="运行时的函数"></a>运行时的函数</h4><p>运行时系统是一个带有公共接口的动态共享库，其内部由一系列函数和数据结构组成，公共接口定义在 <em>/usr/include/objc</em> 目录的头文件中。这些函数中的许多都允许你使用纯C语言来做那些编译器为Objective-C代码所做的事。其他一些则输出形成了NSObject类的基本功能。这些函数使为运行时系统开发其他接口或者为增强开发环境制作工具成为了可能；因为它们无需使用Objective-C进行编码。可是，一小部分的运行时函数也会在编写Objective-C代码时非常有用。所有这些函数都被记录在了<a href="https://developer.apple.com/documentation/objectivec/objective_c_runtime" target="_blank" rel="external">Objective-C Runtime Reference</a>中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtInteracting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Interacting with the Runtime
&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;与运行时系统进行交互&quot;&gt;&lt;a href=&quot;#与运行时系统进行交互&quot; class=&quot;headerlink&quot; title=&quot;与运行时系统进行交互&quot;&gt;&lt;/a&gt;与运行时系统进行交互&lt;/h3&gt;&lt;p&gt;Objective-C程序通过三种不同方式与运行时系统进行交互：通过Objective-C代码；通过&lt;em&gt;Foundation&lt;/em&gt;框架中定义在&lt;em&gt;NSObject&lt;/em&gt;类中的方法；还有通过直接调用运行时的函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》之树</title>
    <link href="http://yoursite.com/2019/04/12/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E4%B9%8B%E6%A0%91/"/>
    <id>http://yoursite.com/2019/04/12/《大话数据结构》之树/</id>
    <published>2019-04-12T15:10:28.591Z</published>
    <updated>2019-04-12T15:10:28.591Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>与线性结构的“一对一”不同，<strong>树是“一对多”的数据结构</strong>。</p>
<blockquote>
<p><strong>树是有限个结点n（n &gt;= 0）的集合</strong>。</p>
<ul>
<li>n为0时称为空树；</li>
<li>不为0时，<strong>有且只有一个结点作为树的根结点</strong>。</li>
<li>n大于1时，除根结点外的其他结点可以分为m（m &gt; 0）个互不相交的有限集合T1…Tm，每个子集合又是一棵树，称为子树。</li>
</ul>
</blockquote>
<a id="more"></a>
<p>下图即为一棵树：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554708278-%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5.jpg" alt="树"></p>
<h4 id="1-1-树的“度”"><a href="#1-1-树的“度”" class="headerlink" title="1.1 树的“度”"></a>1.1 树的“度”</h4><p><strong>每个结点包含的子结点的个数称为结点的“度”（degree）</strong>。<br>度为0的结点为“<em>叶子结点</em>”或“<em>终端结点</em>”；度不为0的结点称为“<em>分支结点</em>”或“<em>非终端结点</em>”。</p>
<p>我们将一棵树中所有子结点的“度”中的最大值称作<strong>树的度</strong>。</p>
<p>示意图中树的度为3（结点D的度最大，是3）。</p>
<h4 id="1-2-结点间的关系"><a href="#1-2-结点间的关系" class="headerlink" title="1.2 结点间的关系"></a>1.2 结点间的关系</h4><p>结点的子树中的根结点叫做该结点的<strong>孩子（Child）结点</strong>；该结点称为孩子的<strong>双亲（Parent）结点</strong>；同一双亲结点的子结点互为<strong>兄弟（Sibling）结点</strong>。</p>
<p>例如，在示意图中，结点D是B的孩子结点，C是B的兄弟结点，A是B的双亲结点。</p>
<blockquote>
<p>注：以下将双亲结点简称为“父结点”，孩子结点称为“子结点”。</p>
</blockquote>
<h4 id="1-3-树的“深度”"><a href="#1-3-树的“深度”" class="headerlink" title="1.3 树的“深度”"></a>1.3 树的“深度”</h4><p>从根结点开始，作为树的第一<strong>层（Level）</strong>；其子结点作为第二层，以此类推。</p>
<p><strong>树的最大层数称为该树的“深度”（Depth）</strong>。</p>
<p>由于示意图中的树分为四层，故其深度为4。其中，同一层的结点互为<strong>堂兄弟结点</strong>。如第三层的D、E和F结点。</p>
<h4 id="1-4-其他概念"><a href="#1-4-其他概念" class="headerlink" title="1.4 其他概念"></a>1.4 其他概念</h4><ol>
<li>若树从左至右为有序，且各子结点的顺序不可调换，则此树可以称为“<strong>有序树</strong>”。</li>
<li><strong>森林</strong>（Forest）是m（m &gt;= 0）棵互不相交的树的集合。</li>
</ol>
<h4 id="1-5-结构对比"><a href="#1-5-结构对比" class="headerlink" title="1.5 结构对比"></a>1.5 结构对比</h4><p>与线性结构的对比如下：</p>
<blockquote>
<p>线性结构：</p>
<ul>
<li>头元素：无前驱结点</li>
<li>尾元素：无后继结点</li>
<li>中间元素：一个前驱结点，一个后继结点</li>
</ul>
<p>树结构：</p>
<ul>
<li>根结点：无父结点，唯一</li>
<li>叶子结点：无子结点，自身可以有多个</li>
<li>分支结点：有父结点，存在1个或多个子结点</li>
</ul>
</blockquote>
<h3 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2. 存储结构"></a>2. 存储结构</h3><p>利用顺序和链式存储方式，我们可以将树的存储方式简单介绍三种：</p>
<ol>
<li>双亲表示法</li>
<li>孩子表示法</li>
<li>孩子兄弟表示法（二叉树）</li>
</ol>
<h4 id="2-1-双亲表示法"><a href="#2-1-双亲表示法" class="headerlink" title="2.1 双亲表示法"></a>2.1 双亲表示法</h4><p>双亲表示法使用顺序存储结构，将所有结点依次存储在连续的空间中。<br>最简单的就是使用一个parent域来标明自身的父结点。其结构如下：</p>
<table>
<thead>
<tr>
<th>data</th>
<th>parent</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据域</td>
<td>父结点索引（数组下标）</td>
</tr>
</tbody>
</table>
<p>以示意图为例，使用双亲表示法可以表示为：</p>
<table>
<thead>
<tr>
<th>下标</th>
<th>data</th>
<th>parent</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>A</td>
<td>-1</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>3</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>3</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>根据此存储方式，可以直接<strong>查询出每个子结点的父结点，其时间复杂度固定为O(1)</strong>。</p>
<p>可以根据需要，对结点的数据结构进行扩展：如添加指向第一个孩子结点的索引域firstChild；添加指向兄弟结点的索引域rightSib等。这种方式可以适时通过扩展并添加存储空间来提高访问效率。</p>
<h4 id="2-2-孩子表示法"><a href="#2-2-孩子表示法" class="headerlink" title="2.2 孩子表示法"></a>2.2 孩子表示法</h4><p>由于每个结点的子结点个数不确定，可以通过链表来表示每个结点下的子树。且由于我们在需要时可以方便地遍历树中的所有结点，可以考虑将所有结点保存在顺序存储结构中。故<strong>孩子表示法的具体方法为：把每个结点的孩子结点排列起来，以单链表为存储结构，则n个结点有n个孩子链表，如果该结点是叶子结点，则此单链表为空表。然后，将n个头指针又组成一个线性表，以顺序存储结构存储在一个一维数组中</strong>。</p>
<p>故示意图中的树，使用孩子表示法可以表示为：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554713216-%E6%A0%91--%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg" alt="树--孩子表示法"></p>
<p>其中结点分为两种：</p>
<ul>
<li>孩子链表中的孩子结点：</li>
</ul>
<table>
<thead>
<tr>
<th>child</th>
<th>next</th>
</tr>
</thead>
<tbody>
<tr>
<td>结点索引（顺序数组的下标）</td>
<td>兄弟结点索引</td>
</tr>
</tbody>
</table>
<ul>
<li>表头数组的表头结点</li>
</ul>
<table>
<thead>
<tr>
<th>data</th>
<th>firstChild</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据域</td>
<td>头指针域（存储对应孩子链表的头指针）</td>
</tr>
</tbody>
</table>
<p>对于此存储结构，要查找某结点的孩子结点，或查找某结点的兄弟结点，只要查找对应的孩子结点单链表即可。</p>
<h4 id="2-3-孩子兄弟表示法"><a href="#2-3-孩子兄弟表示法" class="headerlink" title="2.3 孩子兄弟表示法"></a>2.3 孩子兄弟表示法</h4><p><strong>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的</strong>。因此此节点包括两个指针域，分别指向该结点的第一个孩子结点和此结点的右兄弟结点。</p>
<table>
<thead>
<tr>
<th>data</th>
<th>firstChild</th>
<th>rightSib</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据域</td>
<td>第一个孩子结点的存储地址</td>
<td>右兄弟结点的存储地址</td>
</tr>
</tbody>
</table>
<p>故示意图中的树，使用孩子兄弟表示法可以表示为：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554728801-%E6%A0%91--%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg" alt="树--孩子兄弟表示法"></p>
<p>使用此方式，可以很方便地查找某结点的第几个子结点：只要找到该结点的第一个孩子结点后，依次查找其兄弟结点即可。</p>
<p>通过此种表示方法，我们可以发现，标准的树被转换成了<em>二叉树</em>表示（每个结点最多只有两个子结点）。</p>
<h3 id="3-二叉树"><a href="#3-二叉树" class="headerlink" title="3. 二叉树"></a>3. 二叉树</h3><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h4><ul>
<li><strong>每个结点最多有两棵子树（子结点），故二叉树的度不超过2</strong>。</li>
<li><strong>左右子树有序，不能颠倒</strong>。</li>
<li><strong>结点若只有一棵子树，也要区分是左还是右子树</strong>。</li>
</ul>
<p>如下图，二者是两棵不同的二叉树：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554791292-%E6%A0%91--%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8C%BA%E5%88%86.jpg" alt="树--二叉树区分"></p>
<h4 id="3-2-存储结构"><a href="#3-2-存储结构" class="headerlink" title="3.2 存储结构"></a>3.2 存储结构</h4><h5 id="3-2-1-顺序存储结构"><a href="#3-2-1-顺序存储结构" class="headerlink" title="3.2.1 顺序存储结构"></a>3.2.1 顺序存储结构</h5><p><strong>二叉树的顺序存储结构一般只适用于<em>完全二叉树</em></strong>。</p>
<blockquote>
<p>完全二叉树：</p>
<ul>
<li>叶子结点只出现在二叉树的最后两层</li>
<li>最后一层的叶子结点都是左结点；倒数第二层的叶子结点都是右结点</li>
<li>满二叉树（只有最后一层存在，且全都是叶子结点的二叉树）属于完全二叉树</li>
</ul>
</blockquote>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554792962-%E6%A0%91--%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.jpg" alt="树--二叉树的顺序存储"></p>
<p>如图所示，用一维数组存储二叉树的所有结点，通过数组下标来提现二叉树中结点间的关系。<br>但是，当二叉树中有过多空余结点（如图中的黄色不存在结点）时会导致空间浪费，故一般只使用顺序结构存储完全二叉树。</p>
<h5 id="3-2-2-链式存储结构–二叉链表"><a href="#3-2-2-链式存储结构–二叉链表" class="headerlink" title="3.2.2 链式存储结构–二叉链表"></a>3.2.2 链式存储结构–二叉链表</h5><p>二叉链表：<strong>每个数据节点包含本身的数据域和两个指针域</strong>，分别指向两个可能的孩子结点，这种结点组成的链表称为二叉链表。</p>
<p>结点结构如下：</p>
<table>
<thead>
<tr>
<th>lchild</th>
<th>data</th>
<th>rchild</th>
</tr>
</thead>
<tbody>
<tr>
<td>左孩子结点的存储地址</td>
<td>数据域</td>
<td>右孩子结点的存储地址</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 二叉链表的结点结构体 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></div><div class="line">    TElemType data; <span class="comment">// 数据域</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>;</span> <span class="comment">// 左孩子结点指针</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">rchild</span>;</span> <span class="comment">// 右孩子结点指针</span></div><div class="line">&#125; BiTNode, *BiTree;</div></pre></td></tr></table></figure>
<p>下图为二叉链表的表述示意图：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554794334-%E6%A0%91--%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.jpg" alt="树--二叉链表"></p>
<h4 id="3-3-二叉树的遍历"><a href="#3-3-二叉树的遍历" class="headerlink" title="3.3 二叉树的遍历"></a>3.3 二叉树的遍历</h4><blockquote>
<p>二叉树的遍历（traversing binary tree）是指从根结点出发，<strong>按照某种次序依次访问</strong>二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。</p>
</blockquote>
<p>若以从左到右方向限定，主要的遍历方式分为以下四种：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历</li>
</ul>
<p>与定义<strong>二叉树</strong>的方式一样，其遍历也是以<strong>递归</strong>的方式进行。</p>
<h5 id="3-3-1-前序遍历"><a href="#3-3-1-前序遍历" class="headerlink" title="3.3.1 前序遍历"></a>3.3.1 前序遍历</h5><p>遍历方式：<strong>先访问根节点，然后前序遍历左子树，再前序遍历右子树</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 访问根节点</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</div><div class="line">    <span class="comment">// 遍历左子树</span></div><div class="line">    PreOrderTraverse(T-&gt;lchild);</div><div class="line">    <span class="comment">// 遍历右子树</span></div><div class="line">    PreOrderTraverse(T-&gt;rchild);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-3-2-中序遍历"><a href="#3-3-2-中序遍历" class="headerlink" title="3.3.2 中序遍历"></a>3.3.2 中序遍历</h5><p>遍历方式：<strong>先中序遍历根节点的左子树，然后是根节点，再中序遍历右子树</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 遍历左子树</span></div><div class="line">    InOrderTraverse(T-&gt;lchild);</div><div class="line">    <span class="comment">// 访问根节点</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</div><div class="line">    <span class="comment">// 遍历右子树</span></div><div class="line">    InOrderTraverse(T-&gt;rchild);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-3-3-后续遍历"><a href="#3-3-3-后续遍历" class="headerlink" title="3.3.3 后续遍历"></a>3.3.3 后续遍历</h5><p>遍历方式：<strong>从左到右，先叶子后结点，全部访问完左右子树后，最后访问根结点</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 遍历左子树</span></div><div class="line">    PostOrderTraverse(T-&gt;lchild);</div><div class="line">    <span class="comment">// 遍历右子树</span></div><div class="line">    PostOrderTraverse(T-&gt;rchild);</div><div class="line">    <span class="comment">// 访问根节点</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-4-二叉树的创建"><a href="#3-4-二叉树的创建" class="headerlink" title="3.4 二叉树的创建"></a>3.4 二叉树的创建</h4><p>这里以前序方式创建。与前序遍历相同，创建时按照前序遍历的方式依次递归输入结点数据即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 创建二叉树【前序遍历法创建：根--左--右】 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span> </span>&#123;</div><div class="line">    TElemType ch;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</div><div class="line">    <span class="keyword">if</span> (ch == <span class="string">'#'</span>) &#123;</div><div class="line">        *T = <span class="literal">NULL</span>; <span class="comment">// 代表此结点位置无数据（数据为空）</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 分配空间，创建新结点</span></div><div class="line">        *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</div><div class="line">        <span class="comment">// 内存分配失败，退出</span></div><div class="line">        <span class="keyword">if</span> (!*T) &#123;</div><div class="line">            <span class="built_in">exit</span>(OVERFLOW);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 前序遍历方式赋值</span></div><div class="line">        </div><div class="line">        <span class="comment">// 1. 赋值根节点</span></div><div class="line">        (*T)-&gt;data = ch;</div><div class="line">        <span class="comment">// 2. 左孩子结点递归</span></div><div class="line">        CreateBiTree(&amp;((*T)-&gt;lchild));</div><div class="line">        <span class="comment">// 3. 右孩子结点递归</span></div><div class="line">        CreateBiTree(&amp;((*T)-&gt;rchild));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下图所示，依照代码，先<strong>将给定的二叉树转化为<em>扩展二叉树</em></strong>。</p>
<blockquote>
<p>扩展二叉树：<br>将给定的二叉树的每个结点的空指针设置一个虚拟结点，并指定一个特殊值（这里定义为“#”）。</p>
</blockquote>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554827002-%E6%A0%91--%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA.jpg" alt="树--二叉树的创建"></p>
<blockquote>
<p>二叉树的创建与三种遍历方式，可查看此示例：<a href="https://github.com/Choujiji/PlayWithDataStructure-Code/tree/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="external">项目地址</a></p>
</blockquote>
<h4 id="3-5-线索二叉树"><a href="#3-5-线索二叉树" class="headerlink" title="3.5 线索二叉树"></a>3.5 线索二叉树</h4><h5 id="3-5-1-线索化过程"><a href="#3-5-1-线索化过程" class="headerlink" title="3.5.1 线索化过程"></a>3.5.1 线索化过程</h5><p>此二叉链表虽然功能强大，但弱点显而易见：就是<strong>每次只能通过指定方式的遍历，才可以确定每个结点的前趋结点和后缀结点</strong>。而且我们可以发现，在下面的二叉链表示意图中，有n+1（即2n个总lchild和rchild指针个数 与 n-1个连线 的差）个空余指针域（存储的是“^”），随着二叉树的增长，浪费的空间会越来越多。</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554794334-%E6%A0%91--%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.jpg" alt="树--二叉链表"></p>
<p>因此，<strong>我们可以使用这些空余空间来保存每个结点的前趋和后继结点的信息，以解决上述问题。而解决此问题的过程，叫做线索化，线索化后的二叉链表叫做线索链表，对应的树叫做线索二叉树</strong>。</p>
<p>具体做法是：<strong>在使用某种顺序遍历每个结点时，若没有左孩子结点，其lchild保存的是前趋结点的指针；若没有右孩子结点，其rchild保存的是后继结点的指针</strong>。</p>
<p>如上图中的二叉树，其中序遍历后的结果为HDIBJEAFCG，根据遍历结果对该二叉链表进行线索化的结果如下：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554880420-%E6%A0%91--%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%911.jpg" alt="树--线索二叉树1"></p>
<p>可以看到，通过线索化，不仅解决了空间浪费问题，还解决了前趋和后继结点的记录问题，提高了访问效率。</p>
<h5 id="3-5-2-区分结点类型"><a href="#3-5-2-区分结点类型" class="headerlink" title="3.5.2 区分结点类型"></a>3.5.2 区分结点类型</h5><p>此时线索二叉树还存在一个问题：我们<strong>无法区分lchild指向的结点是前趋结点还是左孩子节点</strong>，对于rchild也是如此。</p>
<p>此时，<strong>需要针对每个指针域分别设置一个布尔类型的数据域，在线索化的过程中，根据实际情况进行区分（是前趋或后继结点时为1，是孩子结点时为0）</strong>。</p>
<p>结点结构如下：</p>
<table>
<thead>
<tr>
<th>左孩子结点地址</th>
<th>左标识符</th>
<th>数据域</th>
<th>右标识符</th>
<th>右孩子结点地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>lchild</td>
<td>ltag</td>
<td>data</td>
<td>rtag</td>
<td>rchild</td>
</tr>
</tbody>
</table>
<p>对应实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 枚举变量，用于标识符赋值 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</div><div class="line">    <span class="comment">/** 是孩子结点 */</span></div><div class="line">    Link,</div><div class="line">    <span class="comment">/** 是前趋或后缀结点 */</span></div><div class="line">    Thread</div><div class="line">&#125; PointerTag;</div><div class="line"></div><div class="line"><span class="comment">/** 线索二叉树结点结构 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> &#123;</span></div><div class="line">    <span class="comment">/** 数据域 */</span></div><div class="line">    TElemType data;</div><div class="line">    <span class="comment">/** 左结点指针 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>;</span></div><div class="line">    <span class="comment">/** 左结点标识符 */</span></div><div class="line">    PointerTag LTag;</div><div class="line">    <span class="comment">/** 右结点指针 */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">rchild</span>;</span></div><div class="line">    <span class="comment">/** 右结点标识符 */</span></div><div class="line">    PointerTag RTag;</div><div class="line">&#125; BiThrNode, *BiThrTree; <span class="comment">// 定义为线索二叉树结点及线索二叉树指针</span></div></pre></td></tr></table></figure>
<p>添加结点类型区分后的线索二叉树如下：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554886236-%E6%A0%91--%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%912.jpg" alt="树--线索二叉树2"></p>
<p>这样在访问指定节点时，根据ltag和rtag的值即可区分相邻结点是前趋后继结点或是孩子结点了。</p>
<p>线索化过程的代码如下（这里使用中序遍历方式）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 当前访问节点 */</span></div><div class="line">BiThrTree currentP = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="comment">/** 中序遍历线索化 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!p) &#123;</div><div class="line">        <span class="comment">// 结点不存在，返回</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!p-&gt;lchild &amp;&amp; !p-&gt;rchild) &#123;</div><div class="line">        <span class="comment">// 左右子结点均不存在，即是叶子结点【防止最后一个结点无修改RTag】</span></div><div class="line">        p-&gt;LTag = Thread;</div><div class="line">        p-&gt;RTag = Thread;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 递归线索化左结点</span></div><div class="line">    InThreading(p-&gt;lchild);</div><div class="line">    </div><div class="line">    <span class="comment">// 自身数据线索化（由于是中序遍历【左--中--右】，此时右结点还没有访问到，故只处理当前和前一个结点即可）</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!(p-&gt;lchild)) &#123;</div><div class="line">        <span class="comment">// 左结点为空，即没有左孩子，故当前指向前趋结点</span></div><div class="line">        p-&gt;LTag = Thread;</div><div class="line">        p-&gt;lchild = currentP;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 包含左孩子</span></div><div class="line">        p-&gt;LTag = Link;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (currentP) &#123;</div><div class="line">        <span class="keyword">if</span> (!(currentP-&gt;rchild)) &#123;</div><div class="line">            <span class="comment">// 前一个结点的右结点指针为空，即没有右孩子，故指向后继结点（当前结点）</span></div><div class="line">            currentP-&gt;RTag = Thread;</div><div class="line">            currentP-&gt;rchild = p;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 包含右孩子</span></div><div class="line">            currentP-&gt;RTag = Link;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 记录当前结点</span></div><div class="line">    currentP = p;</div><div class="line">    </div><div class="line">    <span class="comment">// 递归线索化右结点</span></div><div class="line">    InThreading(p-&gt;rchild);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由上图即可看出，如果在二叉树的根结点之前再插入一个头结点，此时的<strong>线索二叉树实际上就是一个双向链表结构</strong>。其结构示意图如下：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1554973426-%E6%A0%91--%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%913.jpg" alt="树--线索二叉树3"></p>
<p>插入头结点的简单方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 向线索二叉树中插入头结点 */</span></div><div class="line"><span class="function">BiThrTree <span class="title">insertHeadNodeToBiThrTree</span><span class="params">(BiThrTree biTree)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (biTree == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建头节点</span></div><div class="line">    BiThrTree headNode = (BiThrTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode));</div><div class="line">    <span class="comment">// 左孩子指向线索二叉树的根结点</span></div><div class="line">    headNode-&gt;lchild = biTree;</div><div class="line">    headNode-&gt;LTag = Link;</div><div class="line">    <span class="comment">// 右孩子指向中序遍历的最后一个结点</span></div><div class="line">    BiThrTree inOrderTailNode = biTree;</div><div class="line">    <span class="keyword">while</span> (inOrderTailNode-&gt;RTag == Link) &#123;</div><div class="line">        inOrderTailNode = inOrderTailNode-&gt;rchild;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 此时inOrderTailNode即为最后一个结点</span></div><div class="line">    headNode-&gt;rchild = inOrderTailNode;</div><div class="line">    headNode-&gt;RTag = Thread; <span class="comment">// 并不是右孩子</span></div><div class="line">    </div><div class="line">    <span class="comment">// targetNode的后继结点指向头结点</span></div><div class="line">    inOrderTailNode-&gt;rchild = headNode;</div><div class="line">    </div><div class="line">    <span class="comment">// 中序遍历的第一个结点的前趋结点指向头结点</span></div><div class="line">    BiThrTree inOrderFirstNode = biTree;</div><div class="line">    <span class="keyword">while</span> (inOrderFirstNode-&gt;LTag == Link) &#123;</div><div class="line">        inOrderFirstNode = inOrderFirstNode-&gt;lchild;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 此时inOrderFirstNode即为第一个结点</span></div><div class="line">    inOrderFirstNode-&gt;lchild = headNode;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> headNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终，通过访问双向链表的方式，中序遍历输出此二叉树的方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 中序遍历【扫描二叉链表方式】 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span> </span>&#123;</div><div class="line">    <span class="comment">// 中序遍历，即从头结点开始扫描，</span></div><div class="line">    <span class="comment">// 1. 首先找到最左边的结点（没有左孩子的），</span></div><div class="line">    <span class="comment">// 2. 然后找其后继结点（子树的根），</span></div><div class="line">    <span class="comment">// 3. 最后是其右结点（右孩子或后继）</span></div><div class="line">    <span class="comment">// 直到扫描到的结点是头结点，结束</span></div><div class="line">    </div><div class="line">    <span class="comment">// 指向根结点（从根结点开始）</span></div><div class="line">    BiThrTree currentNode = T-&gt;lchild;</div><div class="line">    </div><div class="line">    <span class="comment">// 遍历结束时，指向头结点</span></div><div class="line">    <span class="keyword">while</span> (currentNode != T) &#123;</div><div class="line">        <span class="comment">// 1. 找到当前子树最左边的结点（没有左孩子的）</span></div><div class="line">        <span class="keyword">while</span> (currentNode-&gt;LTag == Link) &#123;</div><div class="line">            <span class="comment">// 有左孩子，继续查找</span></div><div class="line">            currentNode = currentNode-&gt;lchild;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 找到了最左边的结点，输出</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%hhd "</span>, currentNode-&gt;data);</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 一直向后找到所有后继结点（即对应子树的根）</span></div><div class="line">        <span class="keyword">while</span> (currentNode-&gt;RTag == Thread &amp;&amp; currentNode-&gt;rchild != T) &#123;</div><div class="line">            currentNode = currentNode-&gt;rchild;</div><div class="line">            <span class="comment">// 找到了后继结点，输出</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%hhd "</span>, currentNode-&gt;data);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 3. 指向右结点（下一个结点，不管结点类型，准备下次循环）</span></div><div class="line">        currentNode = currentNode-&gt;rchild;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>线索化及遍历的完整过程，可查看此示例：<a href="https://github.com/Choujiji/PlayWithDataStructure-Code/tree/master/%E6%A0%91/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/ThreadedBinaryTree" target="_blank" rel="external">项目地址</a></p>
</blockquote>
<h4 id="3-6-树、森林转换为二叉树"><a href="#3-6-树、森林转换为二叉树" class="headerlink" title="3.6 树、森林转换为二叉树"></a>3.6 树、森林转换为二叉树</h4><p>由于二叉树的结构稳定（每个结点只有左右两个孩子），其性质也容易研究，故在某些情况下，将普通的树甚至森林转换为二叉树即可对它们进行问题的研究（如遍历等）。</p>
<h5 id="3-6-1-树-gt-二叉树"><a href="#3-6-1-树-gt-二叉树" class="headerlink" title="3.6.1 树 =&gt; 二叉树"></a>3.6.1 树 =&gt; 二叉树</h5><p>转换规则：</p>
<ol>
<li><strong>在兄弟结点与其左方的结点之间添加连接线</strong>。</li>
<li><strong>在结点的所有子孩子中，除了左边第一个孩子结点外，其他所有兄弟孩子结点与父结点间的连线去除</strong>。</li>
<li><strong>调整层次，结点的第一个子孩子作为二叉的左孩子，兄弟孩子作为“前一个”结点的右孩子</strong>。</li>
</ol>
<p>示例：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555052420-%E6%A0%91--%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="树--树转换二叉树"></p>
<p>转换过程：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555052792-%E6%A0%91--%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%912.jpg" alt="树--树转换二叉树2"></p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555052889-%E6%A0%91--%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%913.jpg" alt="树--树转换二叉树3"></p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555053130-%E6%A0%91--%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%914.jpg" alt="树--树转换二叉树4"></p>
<h5 id="3-6-2-森林-gt-二叉树"><a href="#3-6-2-森林-gt-二叉树" class="headerlink" title="3.6.2 森林 =&gt; 二叉树"></a>3.6.2 森林 =&gt; 二叉树</h5><p>可以将森林中的每一棵树看做是兄弟，利用兄弟结点的合并方式（作为前一个结点的右孩子）进行合并，最终合成一棵二叉树：</p>
<ol>
<li><strong>把每一棵树转换为二叉树</strong>。</li>
<li><strong>依次将后一棵树的根结点作为前一棵树的根结点的右孩子。连线完成后，即可得到合成的二叉树</strong>。</li>
</ol>
<p>示例：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555054041-%E6%A0%91--%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="树--森林转二叉树"></p>
<p>转换过程：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555054266-%E6%A0%91--%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%912.jpg" alt="树--森林转二叉树2"></p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555054387-%E6%A0%91--%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%913.jpg" alt="树--森林转二叉树3"></p>
<h4 id="3-7-赫夫曼树及霍夫曼编码"><a href="#3-7-赫夫曼树及霍夫曼编码" class="headerlink" title="3.7 赫夫曼树及霍夫曼编码"></a>3.7 赫夫曼树及霍夫曼编码</h4><h5 id="3-7-1-概念介绍"><a href="#3-7-1-概念介绍" class="headerlink" title="3.7.1 概念介绍"></a>3.7.1 概念介绍</h5><p>赫夫曼树是在二叉树的基础上设计而来。赫夫曼树的每个叶子结点都包含对应的权值（Weight）。<em>两个结点之间经过的所有分支叫做路径，路径上分支的个数叫做路径长度</em>。<strong>树的路径长度就是从<em>根结点</em>到<em>每个叶子结点</em>的路径长度的总和</strong>。</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555056066-%E6%A0%91--%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91.jpg" alt="树--赫夫曼树"></p>
<p>图中的二叉树的路径长度为（以A-E的顺序）：3 + 3 + 2 + 2 + 2 = 12。</p>
<p>霍夫曼树需要引入权的概念，故我们得到了带权路径的算法：<br><strong>结点的带权路径 = 结点从根到自身的路径长度 * 自身权重</strong></p>
<p>因此<strong>树的带权路径长度即为所有叶子结点带权路径的总和</strong>，称作<strong>WPL</strong>。</p>
<p>图中二叉树的WPL为：3 <em> 5 + 3 </em> 15 + 2 <em> 40 + 2 </em> 30 + 2 * 10 = 220。</p>
<p><strong>在带有权重的一组叶子结点所组成的二叉树中，WPL最小的可称作霍夫曼树</strong>。</p>
<h5 id="3-7-2-生成方法"><a href="#3-7-2-生成方法" class="headerlink" title="3.7.2 生成方法"></a>3.7.2 生成方法</h5><ol>
<li>将所有结点按照权值升序排列，生成有序树集合（每棵树即为单独的叶子结点）。</li>
<li>取前两棵树（权值最小）作为左右子树，生成新二叉树，其根结点的权值为原两树权值之和。</li>
<li>在集合中使用新的二叉树替换原始的两棵树并重新排序。</li>
<li>重复步骤2和3，直到序列只剩下一棵树为止，此树即为霍夫曼树。</li>
</ol>
<p>示例：</p>
<table>
<thead>
<tr>
<th>结点</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>权值</td>
<td>5</td>
<td>15</td>
<td>40</td>
<td>30</td>
<td>10</td>
</tr>
</tbody>
</table>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555062192-%E6%A0%91--%E7%94%9F%E6%88%90%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91.jpg" alt="树--生成霍夫曼树"></p>
<h5 id="3-7-3-霍夫曼编码"><a href="#3-7-3-霍夫曼编码" class="headerlink" title="3.7.3 霍夫曼编码"></a>3.7.3 霍夫曼编码</h5><p><strong>将霍夫曼树中所有结点（包括合成结点）的权值改为0和1（左分支权值为0，右分支权值为1），这样从根结点到指定叶子结点所生成的0和1序列即为霍夫曼编码</strong>。</p>
<p>上面的霍夫曼树转换后的结果为：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1555066450-%E6%A0%91--%E8%BD%AC%E5%8C%96%E5%90%8E%E7%9A%84%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91.jpg" alt="树--转化后的霍夫曼树"></p>
<p>因此，图中每个字符所生成的霍夫曼编码如下：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>霍夫曼编码</td>
<td>1000</td>
<td>101</td>
<td>0</td>
<td>11</td>
<td>1001</td>
</tr>
</tbody>
</table>
<p><strong>霍夫曼编码可以用来压缩数据，进而提高了传输效率</strong>。</p>
<p>假设传输”BADBEC“这个字符串，使用传统的等长编码，可能会使用如下方式：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>等长编码</td>
<td>100</td>
<td>101</td>
<td>010</td>
<td>011</td>
<td>110</td>
</tr>
</tbody>
</table>
<p>故在此方式下，编码后的数据为”101100011101110010“，长度为18位；而使用霍夫曼编码，编码后的数据为”1011000101101110“，长度仅为16位，故数据得到了压缩。且随着编码字符的增多，霍夫曼编码的数据优势会越来越大。</p>
<p>像霍夫曼编码这样<strong>长短不一的编码方式，由于容易混淆，故必须设计成任一字符的编码都不是其他字符编码的前缀（否则解码时无法区分），这种编码方式叫做前缀编码</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h3&gt;&lt;p&gt;与线性结构的“一对一”不同，&lt;strong&gt;树是“一对多”的数据结构&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;树是有限个结点n（n &amp;gt;= 0）的集合&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n为0时称为空树；&lt;/li&gt;
&lt;li&gt;不为0时，&lt;strong&gt;有且只有一个结点作为树的根结点&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;n大于1时，除根结点外的其他结点可以分为m（m &amp;gt; 0）个互不相交的有限集合T1…Tm，每个子集合又是一棵树，称为子树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>STMAssembleView源码学习</title>
    <link href="http://yoursite.com/2019/03/24/STMAssembleView%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/03/24/STMAssembleView源码学习/</id>
    <published>2019-03-24T05:33:40.517Z</published>
    <updated>2019-03-24T05:33:53.681Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目地址：<a href="https://github.com/ming1016/STMAssembleView" target="_blank" rel="external">STMAssembleView</a></p>
</blockquote>
<h4 id="1-结构设计简洁"><a href="#1-结构设计简洁" class="headerlink" title="1. 结构设计简洁"></a>1. 结构设计简洁</h4><ul>
<li><strong>只公开最外层的STMAssembleView类，调用者只需引入一个类即可使用</strong>。</li>
<li><strong>将业务与功能解耦，生成对应的类：“View”视图类（STMAssembleView、STMPartView）与“Maker”类（STMAssemvleMaker、STMPartMaker）</strong>。“Maker”类负责抽象出支持的功能属性，“View”类通过使用Maker，将子功能进行组合并实现最终业务功能（视图配置）。</li>
</ul>
<a id="more"></a>
<h4 id="2-代码设计巧妙"><a href="#2-代码设计巧妙" class="headerlink" title="2. 代码设计巧妙"></a>2. 代码设计巧妙</h4><ul>
<li>对于“Maker”类，属性用于提供给调用者进行配置调用（即只使用getter），而<strong>属性的setter则另提供配套的设置方法，且设置方法返回的是对应“Maker”类型的Block对象，以实现链式调用</strong>。例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// STMAssembleMaker.m</span></div><div class="line"></div><div class="line">- (STMAssembleMaker *(^)(STMAssembleAlignment))alignmentEqualTo &#123;</div><div class="line">    <span class="keyword">return</span> ^STMAssembleMaker *(STMAssembleAlignment alignment) &#123;</div><div class="line">        <span class="comment">// jiji - 设置对齐方式</span></div><div class="line">        self.alignment = alignment;</div><div class="line">        <span class="keyword">return</span> self;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// 调用时</span></div><div class="line">make.alignmentEqualTo(STMAssembleAlignmentCenter);</div></pre></td></tr></table></figure>
<blockquote>
<p>如代码所示：</p>
<p>由于方法<em>alignmentEqualTo</em>返回的是Block对象，调用方法时，通过添加()即直接隐含执行了Block。且由于Block执行后返回的仍然为make自身，可以在后面继续连续调用其他实例方法，实现了链式调用。</p>
</blockquote>
<ul>
<li><strong>使用__weak指针，防止Block对象导致的内存引用循环</strong>。如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// STMAssembleMaker.m</span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)fsAsync:(NSString *)<span class="built_in">string</span> objects:(NSDictionary *)objs completion:(ParsingFormatStringCompleteBlock)completeBlock&#123;</div><div class="line">    __weak __typeof(<span class="built_in">string</span>) weakString = <span class="built_in">string</span>; <span class="comment">// 弱指针，防止Block执行时对该对象强引用</span></div><div class="line">    __weak __typeof(objs) weakObjs = objs;</div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), ^&#123;</div><div class="line">        __strong __typeof(weakString) strongString = weakString; <span class="comment">// 声明临时的__strong指针并指向__weak指向的对象，可以保证在Block执行过程中该对象不被释放。</span></div><div class="line">        __strong __typeof(weakObjs) strongObjs = weakObjs;</div><div class="line">        <span class="keyword">if</span> (strongString) &#123;</div><div class="line">            [STMAssembleView createViewWithFormatString:strongString objects:strongObjs completion:completeBlock];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如代码所示：</p>
<p>使用<strong>weak和</strong>strong指针的情况在Block声明时具有统一性，可以很好地避免引用循环的产生，且能保证在Block执行时捕获对象的有效性。</p>
<p>注：在单独使用GCD时，由于dispatch_async的Block会在执行后进行release，理论上可以不必担心循环引用的问题。这里铭神这样做的目的是保证自身不会保留传入的对象，需要调用者自己负责参数的生命周期。</p>
</blockquote>
<h4 id="3-知识点："><a href="#3-知识点：" class="headerlink" title="3. 知识点："></a>3. 知识点：</h4><h5 id="3-1-字符串的扫描处理"><a href="#3-1-字符串的扫描处理" class="headerlink" title="3.1 字符串的扫描处理"></a>3.1 字符串的扫描处理</h5><p>使用了<em>NSScanner</em>类对字符串进行扫描，按需将扫描结果进行归类，完成描述字符串的解析（后面根据解析结果调用对应的“View”类进行处理，生成页面）。</p>
<h5 id="3-2-使用变参合成字符串"><a href="#3-2-使用变参合成字符串" class="headerlink" title="3.2 使用变参合成字符串"></a>3.2 使用变参合成字符串</h5><p>使用va_list指向变参列表的第一个参数地址，通过NSString合成出完整字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//宏</span></div><div class="line"><span class="function">NSString *<span class="title">ASS</span><span class="params">(NSString *format, ...)</span> </span>&#123;</div><div class="line">    <span class="comment">// jiji - 声明变参指针</span></div><div class="line">    va_list args;</div><div class="line">    <span class="keyword">if</span> (format) &#123;</div><div class="line">        <span class="comment">// jiji - 初始化变参指针（指向第一个参数的地址，如这里的format的地址）</span></div><div class="line">        va_start(args, format);</div><div class="line">        </div><div class="line">        <span class="comment">// jiji - NSString直接通过变参指针读取并生成字符串</span></div><div class="line">        NSString *str = [[NSString alloc] initWithFormat:format arguments:args];</div><div class="line">        </div><div class="line">        <span class="comment">// jiji - 清除变参指针对象</span></div><div class="line">        va_end(args);</div><div class="line">        <span class="keyword">return</span> str;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> @<span class="string">""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/ming1016/STMAssembleView&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;STMAssembleView&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-结构设计简洁&quot;&gt;&lt;a href=&quot;#1-结构设计简洁&quot; class=&quot;headerlink&quot; title=&quot;1. 结构设计简洁&quot;&gt;&lt;/a&gt;1. 结构设计简洁&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;只公开最外层的STMAssembleView类，调用者只需引入一个类即可使用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将业务与功能解耦，生成对应的类：“View”视图类（STMAssembleView、STMPartView）与“Maker”类（STMAssemvleMaker、STMPartMaker）&lt;/strong&gt;。“Maker”类负责抽象出支持的功能属性，“View”类通过使用Maker，将子功能进行组合并实现最终业务功能（视图配置）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>出现“ld：library not found for -lPods”的解决办法</title>
    <link href="http://yoursite.com/2019/03/20/%E5%B7%A5%E7%A8%8B%E5%AE%89%E8%A3%85CocoaPods%E5%90%8E%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/20/工程安装CocoaPods后错误的解决办法/</id>
    <published>2019-03-20T02:57:18.103Z</published>
    <updated>2019-03-20T03:01:20.946Z</updated>
    
    <content type="html"><![CDATA[<p>有的时候，下载的使用CocoaPods配置的工程时，使用“pod install”后，编译时会遇到“<strong>ld: library not found for -lPods</strong>”错误。可以按如下方式试着解决：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/450996-85fee0ff00dcf0b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ld- library not found for -lPods.jpg"></p>
<a id="more"></a>
<p>如图所示，在当前<strong>Target</strong>的<strong>Build Phrase</strong>选项视图中，编辑<strong>Link Binary With Libraries</strong>选项。<strong>移除其中的“libPods.a”</strong>，只保留对应Target打包出的.a文件（添加.a文件时，主工程目录中Frameworks下回自动引入libPods.a依赖，如下图所示）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/450996-24c7e3e8e4d6a410.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Frameworks目录.jpg"></p>
<p>再进行编译一般就会解决问题。</p>
<blockquote>
<p>注：<br>此问题一般来说是由于原工程使用的是老版本的CocoaPods，通过新版CocoaPods安装配置后出现的问题。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有的时候，下载的使用CocoaPods配置的工程时，使用“pod install”后，编译时会遇到“&lt;strong&gt;ld: library not found for -lPods&lt;/strong&gt;”错误。可以按如下方式试着解决：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/450996-85fee0ff00dcf0b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ld- library not found for -lPods.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout的生命周期</title>
    <link href="http://yoursite.com/2019/03/19/Autolayout%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/03/19/Autolayout的生命周期/</id>
    <published>2019-03-19T08:37:21.285Z</published>
    <updated>2019-03-19T08:38:38.827Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/450996-247348e79ae353ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Autolayout生命周期.jpg"></p>
<p>上图即为Autolayout的生命周期过程（截取自<a href="https://developer.apple.com/videos/play/wwdc2015/219/" target="_blank" rel="external">219_mysteries_of_auto_layout_part_2</a>）。</p>
<a id="more"></a>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ol>
<li>APP启动后，随着<strong>RunLoop</strong>的运行，系统<strong>在其内部监听着约束变化（Constraints Change）</strong>：如激活或失效约束、修改优先级、修改常量值等任意造成约束方程式修改的操作，甚至是直接添加或删除视图等操作，都可以导致约束发生变化。</li>
<li>在接收到布局变化后，Layout Engine会根据变化的约束重新计算布局，并将需要更新布局的视图进行标记（<strong>对其父视图调用setNeedsLayout方法</strong>），之后便进入延迟布局阶段（Deffered Layout Pass）。<blockquote>
<p>注意：</p>
<p>在进入延迟布局阶段之前，Layout Engine已经将更新的约束计算完毕并将视图的新frame求出。但并不在此时更新视图。</p>
</blockquote>
</li>
<li>延迟布局阶段：此阶段的主要作用是将错误位置的视图重新定位（Reposition misplaced views）。其在视图层级中执行，分为两步：<ul>
<li>更新约束：<strong>从下往上（子视图到父视图），依次遍历视图层级，调用View的updateConstraints方法（或ViewController的updateViewConstraints方法）来更新约束</strong>（你可以在此覆盖本方法来设置自定义约束，且在此设置时，执行效率最高。记得最后调用父类实现）。</li>
<li>给视图及子视图重新设定位置（给view的frame赋值）：<strong>从上到下依次调用View的layoutSubViews方法（或ViewController的viewLayoutSubViews方法），从Layout Engine中取出预算好的frame进行赋值</strong>（你可以覆盖此方法实现自定义布局，不过此刻不是稳态，需要在适合时候调用父类实现）。</li>
</ul>
</li>
</ol>
<h4 id="延迟布局阶段的触发条件"><a href="#延迟布局阶段的触发条件" class="headerlink" title="延迟布局阶段的触发条件"></a>延迟布局阶段的触发条件</h4><table>
<thead>
<tr>
<th>调用方法</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>setNeedsUpdateConstraints</td>
<td>下一次loop执行updateConstraints</td>
</tr>
<tr>
<td>updateConstraintsIfNeeded</td>
<td>立即执行updateConstraints</td>
</tr>
<tr>
<td>setNeedsLayout</td>
<td>下一次loop执行layoutSubViews</td>
</tr>
<tr>
<td>layoutIfNeeded</td>
<td>立即执行layoutSubViews</td>
</tr>
<tr>
<td>setNeedDisplay</td>
<td>下一次loop执行draw</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/450996-247348e79ae353ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Autolayout生命周期.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图即为Autolayout的生命周期过程（截取自&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/219/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;219_mysteries_of_auto_layout_part_2&lt;/a&gt;）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》之串</title>
    <link href="http://yoursite.com/2019/03/17/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E4%B9%8B%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/03/17/《大话数据结构》之串/</id>
    <published>2019-03-17T10:10:44.688Z</published>
    <updated>2019-03-17T15:47:25.356Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-朴素的字符串匹配方法"><a href="#1-朴素的字符串匹配方法" class="headerlink" title="1. 朴素的字符串匹配方法"></a>1. 朴素的字符串匹配方法</h3><h4 id="1-1-比较过程"><a href="#1-1-比较过程" class="headerlink" title="1.1 比较过程"></a>1.1 比较过程</h4><p>以主串T为基础，根据索引i对每个字符进行遍历，依次与目标串P的每个索引j的字符进行匹配。若字符相同，则两索引均后移，继续匹配；若不相同，则j恢复为0，从头开始，i回溯到开始成功匹配时索引的下一位。</p>
<a id="more"></a>
<h4 id="1-2-比较结果"><a href="#1-2-比较结果" class="headerlink" title="1.2 比较结果"></a>1.2 比较结果</h4><p>遍历索引i结束之后，若此时j已经达到目标串P的最后，则证明目标串的所有字符均匹配成功，目标串在主串中的位置即length(T) - j；否则匹配失败，P不是T的子串。</p>
<h4 id="1-3-主要实现"><a href="#1-3-主要实现" class="headerlink" title="1.3 主要实现"></a>1.3 主要实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSInteger <span class="title">findIndex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sourceStr, <span class="keyword">const</span> <span class="keyword">char</span> *targetStr)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取二者长度</span></div><div class="line">    NSInteger sourceLength = <span class="built_in">strlen</span>(sourceStr);</div><div class="line">    NSInteger targetLength = <span class="built_in">strlen</span>(targetStr);</div><div class="line">    </div><div class="line">    NSInteger i = <span class="number">0</span>; <span class="comment">// 主串索引</span></div><div class="line">    NSInteger j = <span class="number">0</span>; <span class="comment">// 目标串索引</span></div><div class="line">    </div><div class="line">    <span class="keyword">while</span> ((i &lt; sourceLength) &amp;&amp; (j &lt; targetLength)) &#123;</div><div class="line">        <span class="keyword">if</span> (sourceStr[i] == targetStr[j]) &#123;</div><div class="line">            <span class="comment">// 字符相同，继续向后</span></div><div class="line">            i += <span class="number">1</span>;</div><div class="line">            j += <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 字符不同</span></div><div class="line">            <span class="comment">// 主串索引恢复到开始成功匹配时的下一位</span></div><div class="line">            i = i - j + <span class="number">1</span>;</div><div class="line">            <span class="comment">// 目标串索引恢复到头</span></div><div class="line">            j = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 注：这里的大于只是防止最后一位匹配成功后的+1操作</span></div><div class="line">    <span class="keyword">if</span> (j &gt;= targetLength) &#123;</div><div class="line">        <span class="comment">// 主串的最终遍历索引 前移 目标串长度，即为子串的起始位置</span></div><div class="line">        <span class="keyword">return</span> i - targetLength;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> NSNotFound;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-KMP的字符串匹配方法"><a href="#2-KMP的字符串匹配方法" class="headerlink" title="2. KMP的字符串匹配方法"></a>2. KMP的字符串匹配方法</h3><p>KMP方法的作用主要是去掉了一些可避免的比较，提高了匹配效率。</p>
<h4 id="2-1-匹配过程"><a href="#2-1-匹配过程" class="headerlink" title="2.1 匹配过程"></a>2.1 匹配过程</h4><p>KMP的主要匹配过程与朴素一致，都是字符依次比较。优化点是在字符匹配失败时，尽量让主串T的索引i不回溯，目标串的索引j回溯到需要的位置（而不是直接到0）。从而达到减少比较次数的目的。</p>
<p>如上所述，KMP的核心就是<strong>在任意位置匹配失败时，目标串的索引j回溯到的位置</strong>。</p>
<p>我们将所有回溯位置的信息保存到数组next中，故最终目的就是计算出next数组的完整信息。</p>
<h5 id="2-1-1-匹配表（Partial-Match-Table）"><a href="#2-1-1-匹配表（Partial-Match-Table）" class="headerlink" title="2.1.1 匹配表（Partial Match Table）"></a>2.1.1 匹配表（Partial Match Table）</h5><p>要说next数组，就先要了解<strong>匹配表PMT</strong>的含义。以字符串“abababca”为例，其匹配表如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/450996-925461fd2eb0fd34.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>其中，value行即为PMT的值。其意义是什么呢？</p>
<p>value的值是子串中<strong>前缀与后缀集合中，最长的公共子串的长度</strong>。例如，下表分别为当index为2和5时，value的得出过程：</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>子串</th>
<th>前缀集合</th>
<th>后缀集合</th>
<th>交集</th>
<th>最长子串长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>“aba”</td>
<td>{“a”，“ab”}</td>
<td>{“ba”，“a”}</td>
<td>{“a”}</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>“ababab”</td>
<td>{“a”，“ab”，“aba”，“abab”，“ababa”}</td>
<td>{“b”，“ab”，“bab”，“abab”，“babab”}</td>
<td>{“ab”，“abab”}</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>故目标字符串有几位，就会有几个PMT中对应的值。</p>
<h5 id="2-1-2-next表（PMT表的修改形式）"><a href="#2-1-2-next表（PMT表的修改形式）" class="headerlink" title="2.1.2 next表（PMT表的修改形式）"></a>2.1.2 next表（PMT表的修改形式）</h5><p>先抛图（主串“ababababca”和子串“abababca”进行匹配的过程之一）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/450996-996f2e16ee46bf0d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>如图所示，当在主串的i处匹配失败，其之前长度为6的字符串“ababab”均已匹配成功。此时，由PMT表我们可知，子串“ababab”的value为4，即其四位前缀与四位后缀是一致的。又因为在主串中，i之前的四位与j之前的四位字符均一致。故，目标串的四位前缀与主串中i之前的四位字符一致。我们可以省略对该子串的比较，直接在目标串的j=4的位置与主串的当前位置i继续比较。</p>
<p>在上面是叙述中，我们发现，匹配失败，并不会导致主串索引i改变，只会影响目标串索引j出现变化。并且，有趣的是，以图中的过程为例，<strong>当j=6时，匹配失败，即最后一个成功匹配的j是5。之后j回溯的位置4正好是PMT表中index为5时的value值</strong>。根据这个原理，我们就可以跳过不需要的比较，只通过修改目标串索引的位置即可进行快速匹配。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/450996-6082a942ee67f143.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>那么，我们引入next表的目的是什么呢？由于在某一位置匹配失败时，都要查看其前一个位置对应的PMT值，故我们将PMT数据均偏移一位，直接对应于当前位置，以便在快速查找下一步时，可以直接得到目标串索引j的位置。因此，我们<strong>把PMT值偏移后的数据叫做next数据</strong>，为了补位，next的首位赋值为-1。</p>
<p>因此，有了next的方式，我们就可以对朴素匹配法进行优化了。</p>
<h4 id="2-2-匹配过程"><a href="#2-2-匹配过程" class="headerlink" title="2.2 匹配过程"></a>2.2 匹配过程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSInteger <span class="title">KMPFindIndex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sourceStr, <span class="keyword">const</span> <span class="keyword">char</span> *targetStr)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取目标串的next信息，以备匹配时进行回溯（KMP算法核心）</span></div><div class="line">    NSArray *nextInfo = getNextInfo(targetStr);</div><div class="line">    NSLog(@<span class="string">"next - %@"</span>, nextInfo);</div><div class="line">    </div><div class="line">    <span class="comment">// 获取两串长度</span></div><div class="line">    NSInteger sourceLength = <span class="built_in">strlen</span>(sourceStr);</div><div class="line">    NSInteger targetLength = <span class="built_in">strlen</span>(targetStr);</div><div class="line">    </div><div class="line">    <span class="comment">// 主串索引</span></div><div class="line">    NSInteger i = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 目标串索引</span></div><div class="line">    NSInteger j = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 均在范围内查找</span></div><div class="line">    <span class="keyword">while</span> ((i &lt; sourceLength)</div><div class="line">           &amp;&amp; (j &lt; targetLength)) &#123;</div><div class="line">        <span class="keyword">if</span> ((j == <span class="number">-1</span>) </div><div class="line">            || (sourceStr[i] == targetStr[j])) &#123;</div><div class="line">                <span class="comment">// 字符匹配时，索引均后移，准备下一次匹配(j为-1即为了防止出现next[0] = -1的情况出现)</span></div><div class="line">                i += <span class="number">1</span>;</div><div class="line">                j += <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 字符不匹配，i不变，j回溯为next中对应的位置，作为下次匹配的起点</span></div><div class="line">                j = [nextInfo[j] integerValue];</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (j == tragetLength) &#123;</div><div class="line">        <span class="keyword">return</span> i - j;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> NSNotFound;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-3-生成Next数组的过程"><a href="#2-3-生成Next数组的过程" class="headerlink" title="2.3 生成Next数组的过程"></a>2.3 生成Next数组的过程</h4><p>我们知道，生成Next数据的过程，即<strong>在每一个位置上，获取前面子串里，前后缀集合中最长的公共子串的长度</strong>。</p>
<p>如目标字符串“ABCDABDE”，我们以k作为前缀索引，j为后缀索引。如下图，当在字符索引在“D”时（即j为6时），其子串“ABCDAB”的最长前后缀公共子串长度为2（子串“AB”的长度），故next[6] = 2。我们还可知，在j为5时，next[5] = 1，即在j = 5时，公共子串最大长度为1（子串“A”的长度）。故我们可以得到：<strong>在当前字符存在有效next值时（Pk == Pj时），下一个字符的next即为之前next位置的下一个，即next[j + 1] = next[j] + 1 = k + 1</strong>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/450996-b06de1c2fa5c7f75?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>若Pk与Pj不相等，如图中k为2，j为6时。按照KMP的思想，<strong>后缀j不变，需要更新前缀k，以便找到另一个字符与Pj相同</strong>。故<strong>将前缀索引k修改为next[k]以继续进行比较（缩小前缀查找范围）</strong>，直到找到相同的字符“D”或没有相同字符为止。</p>
<p>按照这个思想，生成next数据的实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSArray *<span class="title">getNextInfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *targetStr)</span> </span>&#123;</div><div class="line">    <span class="comment">// 创建返回的next数组</span></div><div class="line">    NSMutableArray *nextInfo = [[NSMutableArray alloc] initWithCapacity:<span class="number">10</span>];</div><div class="line">    nextInfo[<span class="number">0</span>] = @(<span class="number">-1</span>); <span class="comment">// 人为指定首位的next值为-1（首位无法回溯，故此值只是占位用）</span></div><div class="line">    </div><div class="line">    <span class="comment">// 获取字符串长度</span></div><div class="line">    NSInteger strLength = strLen(targetStr);</div><div class="line">    </div><div class="line">    NSInteger k = <span class="number">-1</span>; <span class="comment">// 前缀索引初始值</span></div><div class="line">    NSInteger j = <span class="number">0</span>; <span class="comment">// 后缀索引初始值（后缀必须大于前缀才有效）</span></div><div class="line">    </div><div class="line">    <span class="comment">// 以后缀索引作为遍历范围（-1为了防止最后无效的自加1）</span></div><div class="line">    <span class="keyword">while</span> (j &lt; strLength - <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((k == <span class="number">-1</span>)</div><div class="line">            || (targetStr[k] == targetStr[j])) &#123;</div><div class="line">                <span class="comment">// 前缀为初值索引时，无条件后移并记录（即没有有效前后缀公共串）</span></div><div class="line">                <span class="comment">// 当前位置的字符相同，即找到了公共前后缀字符串，记录下一个位置的next值</span></div><div class="line">                </div><div class="line">                <span class="comment">// 下一位置的next值即为当前next的索引值k再加1</span></div><div class="line">                k += <span class="number">1</span>;</div><div class="line">                j += <span class="number">1</span>;</div><div class="line">                </div><div class="line">                nextInfo[j] = @(k);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 当前位置字符不同</span></div><div class="line">                <span class="comment">// 按照KMP思想，j不回溯，k回溯为下一次的查找索引</span></div><div class="line">                k = [next[k] integerValue];</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [nextInfo copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Objective-C实现的代码地址：<a href="https://github.com/Choujiji/PlayWithDataStructure-Code/tree/master/%E4%B8%B2/KMP%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/SimplyStringCompare" target="_blank" rel="external">点击查看</a></p>
</blockquote>
<h4 id="2-4-Next数组的优化"><a href="#2-4-Next数组的优化" class="headerlink" title="2.4 Next数组的优化"></a>2.4 Next数组的优化</h4><p>我们设想一下这种情况：目标串为“abcabc”，主串为“abacababc”，其中一种比较情况如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/450996-037df26c5e3b176f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>即此时，第四位比较失败（“c”与“b”不同）。我们知道，此时目标串下一次比较的索引j为next[j]，即第二位。也就是目标串右移j-next[j]位（2位）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/450996-a8288306a47b5796.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>如图所示，由于移动后，第二位的字符仍然为“b”，显然比较失败。在这种情况下，本次比较实际上是没有意义的。那么应该如何避免这种比较呢？</p>
<p>其实，在正常情况下，当匹配失败时，我们还会进一步缩小匹配范围（j = next[j]），故<strong>在这种情况下（next[j]指向的字符与当前字符相同时），我们只需再次递归next[j]，跳过相同字符即可</strong>。</p>
<p>因此，解决办法就是，<strong>在生成next数组时，在当前Pk和Pj相同的情况下，若下一位的j与k指向的字符相同，直接设置该位置的next为next[k]即可</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSArray *<span class="title">getNextInfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *targetStr)</span> </span>&#123;</div><div class="line">    NSMutableArray *nextInfo = [[NSMutableArray alloc] initWithCapacity:<span class="number">10</span>];</div><div class="line">    nextInfo[<span class="number">0</span>] = @(<span class="number">-1</span>); </div><div class="line">    </div><div class="line">    NSInteger strLength = strLen(targetStr);</div><div class="line">    </div><div class="line">    NSInteger k = <span class="number">-1</span>; <span class="comment">// 前缀索引初始值</span></div><div class="line">    NSInteger j = <span class="number">0</span>; <span class="comment">// 后缀索引初始值（后缀必须大于前缀才有效）</span></div><div class="line">    </div><div class="line">    <span class="comment">// 以后缀索引作为遍历范围</span></div><div class="line">    <span class="keyword">while</span> (j &lt; strLength - <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((k == <span class="number">-1</span>)</div><div class="line">            || (targetStr[k] == targetStr[j])) &#123;</div><div class="line">                <span class="comment">// 前缀为初值索引时，无条件后移并记录（即没有有效前后缀公共串）</span></div><div class="line">                <span class="comment">// 当前位置的字符相同，即找到了公共前后缀字符串，记录下一个位置的next值</span></div><div class="line">                </div><div class="line">                k += <span class="number">1</span>;</div><div class="line">                j += <span class="number">1</span>;</div><div class="line">                </div><div class="line">                <span class="comment">// nextInfo[j] = @(k); // 修改</span></div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (targetStr[k] == targetStr[j]) &#123;</div><div class="line">                    <span class="comment">// 下一位的前后缀字符相同</span></div><div class="line">                    nextInfo[j] = @(nextInfo[k]); <span class="comment">// next跳过当前的前缀位置，直接指向前缀位置的next位置</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 下一位的前后缀字符不同（正常情况）</span></div><div class="line">                    nextInfo[j] = @(k); <span class="comment">// 原始匹配，next指向前缀后面的位置</span></div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                </div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 当前位置字符不同</span></div><div class="line">                k = [next[k] integerValue];</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [nextInfo copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终，优化后的next数组信息如下表所示（以目标串“abab”为例）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/450996-daddb3d9b0bbd0b0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>使用优化后的next数组，可以再次减少一些不必要的比较。</p>
<h4 id="2-5-时间复杂度"><a href="#2-5-时间复杂度" class="headerlink" title="2.5 时间复杂度"></a>2.5 时间复杂度</h4><p>KMP方式的运算次数为<em>计算next数组的次数</em>与<em>匹配主串的次数</em>之和，即O(m + n)。</p>
<blockquote>
<p>参考引用：</p>
<ul>
<li><a href="https://www.zhihu.com/question/21923021/answer/281346746" target="_blank" rel="external">如何更好的理解和掌握 KMP 算法?</a></li>
<li><a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html" target="_blank" rel="external">很详尽KMP算法（厉害）</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-朴素的字符串匹配方法&quot;&gt;&lt;a href=&quot;#1-朴素的字符串匹配方法&quot; class=&quot;headerlink&quot; title=&quot;1. 朴素的字符串匹配方法&quot;&gt;&lt;/a&gt;1. 朴素的字符串匹配方法&lt;/h3&gt;&lt;h4 id=&quot;1-1-比较过程&quot;&gt;&lt;a href=&quot;#1-1-比较过程&quot; class=&quot;headerlink&quot; title=&quot;1.1 比较过程&quot;&gt;&lt;/a&gt;1.1 比较过程&lt;/h4&gt;&lt;p&gt;以主串T为基础，根据索引i对每个字符进行遍历，依次与目标串P的每个索引j的字符进行匹配。若字符相同，则两索引均后移，继续匹配；若不相同，则j恢复为0，从头开始，i回溯到开始成功匹配时索引的下一位。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》之栈与队列</title>
    <link href="http://yoursite.com/2019/03/11/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E4%B9%8B%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/03/11/《大话数据结构》之栈与队列/</id>
    <published>2019-03-11T14:54:44.101Z</published>
    <updated>2019-03-11T14:55:05.041Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p><strong>栈，即只能在表尾进行插入或删除操作的线性表。</strong></p>
<p>其中，“表尾”称为“<strong>栈顶</strong>”，另一端则为“栈底”。栈是“<strong>后进先出</strong>”（LIFO）的线性表。</p>
<a id="more"></a>
<h4 id="1-2-栈的顺序存储结构"><a href="#1-2-栈的顺序存储结构" class="headerlink" title="1.2 栈的顺序存储结构"></a>1.2 栈的顺序存储结构</h4><p>我们使用数组来描述栈的顺序存储结构。使用指针top来定义栈顶指针，其一直指向数组的最后一个元素的索引。<strong>空栈即top为-1</strong>。由于使用数组实现，故顺序栈在初始化时需要指定最大存储容量。</p>
<h5 id="1-2-1-入栈"><a href="#1-2-1-入栈" class="headerlink" title="1.2.1 入栈"></a>1.2.1 入栈</h5><p>取出数组下一位置的索引（同时更新栈顶top指针），插入数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// S为栈（data为保存的数据，top为栈顶指针），e为插入数据，下同</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (S-&gt;top == MAX_SIZE - <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> False;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 栈顶指针后移</span></div><div class="line">S-&gt;top += <span class="number">1</span>;</div><div class="line"><span class="comment">// 在数组的该位置插入数据</span></div><div class="line">S-&gt;data[S-&gt;top] = e;</div><div class="line"></div><div class="line"><span class="keyword">return</span> True;</div></pre></td></tr></table></figure>
<h6 id="1-2-2-出栈"><a href="#1-2-2-出栈" class="headerlink" title="1.2.2 出栈"></a>1.2.2 出栈</h6><p>取出栈顶top指针指向的数据，之后top指针前移。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>) &#123;</div><div class="line">    <span class="comment">// 空栈</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 取出待返回数据</span></div><div class="line">result = S-&gt;data[S-&gt;top];</div><div class="line"></div><div class="line"><span class="comment">// 栈顶指针前移</span></div><div class="line">S-&gt;top -= <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">return</span> result;</div></pre></td></tr></table></figure>
<p><strong>入栈、出栈操作的时间复杂度均为O(1)</strong>。</p>
<h4 id="1-3-栈的链式存储结构"><a href="#1-3-栈的链式存储结构" class="headerlink" title="1.3 栈的链式存储结构"></a>1.3 栈的链式存储结构</h4><p>由于顺序栈仍然需要提前考虑空间的存储问题，我们可以使用“单链表”来实现栈结构。</p>
<p>使用“头插法”实现链栈的“入栈”和“出栈”操作，可以有效降低时间复杂度。</p>
<p>对于链栈来说，<strong>空栈即栈顶指针top=NULL</strong>。</p>
<h5 id="1-3-1-入栈"><a href="#1-3-1-入栈" class="headerlink" title="1.3.1 入栈"></a>1.3.1 入栈</h5><p>入栈操作，类似于单链表的插入操作，直接在链表头部进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// S为栈（top为栈顶指针，count为元素数量），e为插入数据结点（data为数据域，next为指针域），下同</span></div><div class="line"></div><div class="line"><span class="comment">// 新数据的next指向原top指针的节点，并将top指针指向新数据，更新表长</span></div><div class="line"></div><div class="line">node = ...; <span class="comment">// 创建新结点</span></div><div class="line">node-&gt;data = e;</div><div class="line">node-&gt;next = S-&gt;top;</div><div class="line">S-&gt;top = node;</div><div class="line">S-&gt;count += <span class="number">1</span>;</div></pre></td></tr></table></figure>
<h5 id="1-3-2-出栈"><a href="#1-3-2-出栈" class="headerlink" title="1.3.2 出栈"></a>1.3.2 出栈</h5><p>出栈操作，类似于单链表的删除操作，直接在链表头部进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (S-&gt;count == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// 空栈</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 取出待返回的结点</span></div><div class="line">p = S-&gt;top; </div><div class="line"><span class="comment">// 取出待返回数据</span></div><div class="line">result = p-&gt;data;</div><div class="line"><span class="comment">// 栈顶指针指向后一个结点</span></div><div class="line">S-&gt;top = S-&gt;top-&gt;next;</div><div class="line"><span class="comment">// 更新表长</span></div><div class="line">S-&gt;count -= <span class="number">1</span>;</div><div class="line"><span class="comment">// 释放对象</span></div><div class="line"><span class="built_in">free</span>(p);</div><div class="line"></div><div class="line"><span class="keyword">return</span> result;</div></pre></td></tr></table></figure>
<p><strong>链栈操作的时间复杂度仍然为O(1)</strong>。但由于其实际占用的存储空间会大于顺序栈（单链表结点额外包含指针域数据），故可以依情况自行决定使用哪种结构对栈进行实现。</p>
<h4 id="1-4-栈的应用：使用栈进行四则运算"><a href="#1-4-栈的应用：使用栈进行四则运算" class="headerlink" title="1.4 栈的应用：使用栈进行四则运算"></a>1.4 栈的应用：使用栈进行四则运算</h4><p>这里我们使用栈（demo中使用链栈进行实现）进行四则运算表达式的求值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">9</span> + ( <span class="number">3</span> - <span class="number">1</span> ) * <span class="number">3</span> + <span class="number">10</span> / <span class="number">2</span></div></pre></td></tr></table></figure>
<p>其中，主要步骤分为两步：</p>
<ol>
<li>将（操作符）中缀表达式转换为后缀表达式（<em>栈用来进出操作符</em>）：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">9</span> <span class="number">3</span> <span class="number">1</span> - <span class="number">3</span> * + <span class="number">10</span> <span class="number">2</span> / +</div></pre></td></tr></table></figure>
<ol>
<li>使用后缀表达式计算结果（<em>栈用来进出操作数</em>）。</li>
</ol>
<blockquote>
<p>Objective-C版本实现：<a href="https://github.com/Choujiji/PlayWithDataStructure-Code/tree/master/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%A0%88" target="_blank" rel="external">代码地址</a>。</p>
</blockquote>
<h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p><strong>队列，即只能在一端进行插入操作，在另一端进行删除操作的线性表。</strong></p>
<p>插入的一端叫做<strong>队尾</strong>，删除的一端叫做<strong>队头</strong>。队列是<strong>先进先出</strong>（FIFO）的线性表。</p>
<h4 id="2-2-队列的顺序存储结构"><a href="#2-2-队列的顺序存储结构" class="headerlink" title="2.2 队列的顺序存储结构"></a>2.2 队列的顺序存储结构</h4><p>仍然使用数组对队列进行描述。我们<strong>使用两个指针</strong>（front和rear）<strong>分别指向队头</strong>（首个元素）<strong>和队尾</strong>（末尾元素的下一个索引）。故初始时，front=rear。</p>
<h5 id="2-2-1-顺序队列的入队"><a href="#2-2-1-顺序队列的入队" class="headerlink" title="2.2.1 顺序队列的入队"></a>2.2.1 顺序队列的入队</h5><p>入队，即rear指针位置插入新数据，之后rear指针后移。<strong>时间复杂度为O(1)</strong>。</p>
<h5 id="2-2-2-顺序队列的出队"><a href="#2-2-2-顺序队列的出队" class="headerlink" title="2.2.2 顺序队列的出队"></a>2.2.2 顺序队列的出队</h5><p>出队，按标准数组的删除数据逻辑可知，front指针位置数据移除，之后<strong>后面的所有数据依次前移</strong>。此时<strong>算法的时间复杂度为O(n)</strong>。</p>
<p>若是不考虑移动元素的问题，则可以在front指向的数据移除后，front指针后移，达到目的且<strong>复杂度仍然为O(1)</strong>。但此时会造成数据的“假溢出”：在队列存储已满的情况下，插入新数据时无法插入，但队列头部明明有剩余空间却无法使用。</p>
<h4 id="2-3-循环队列"><a href="#2-3-循环队列" class="headerlink" title="2.3 循环队列"></a>2.3 循环队列</h4><p>为了解决上述“假溢出”的问题，引入了<strong>循环队列</strong>这个特殊的顺序存储队列。</p>
<h5 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h5><p><strong>队列中，头尾相接的顺序存储结构叫做循环队列。</strong></p>
<p>利用循环队列，在尾部存满之后，如果头部存在剩余空间，可以从头开始继续存储。</p>
<h5 id="2-3-2-循环队列的问题"><a href="#2-3-2-循环队列的问题" class="headerlink" title="2.3.2 循环队列的问题"></a>2.3.2 循环队列的问题</h5><p>队列为空时，front=rear。但当队列存满时，仍旧为front=rear。故在使用循环队列时，需要区分开这两种情况。</p>
<ol>
<li>设置标志位flag：当队列为空时，flag=0；当队列占满时，flag=1。</li>
<li>少存一个数据。即当rear与front差1时，就认为队列已满。</li>
</ol>
<p>故循环队列最大的问题是<strong>如何处理入队与出队操作时的溢出问题</strong>。</p>
<h5 id="2-3-3-循环队列的满队及长度判定"><a href="#2-3-3-循环队列的满队及长度判定" class="headerlink" title="2.3.3 循环队列的满队及长度判定"></a>2.3.3 循环队列的满队及长度判定</h5><p>对于上面的第二种情况，由于在队列已满时，rear与front的大小不确定（绝对值差1），故可以使用“取模”的方式确定队列是否已满：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((rear + <span class="number">1</span>) % MaxSize == front) &#123;</div><div class="line">    <span class="comment">// 队列已满</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而计算队列数据个数时，当rear &gt; front时，队列长度即为rear - front；当rear &lt; front时，队列为两部分：右半部分为QueueSize - front，左半部分为 rear - 0，故总长度为 rear - front + QueueSize。仍旧使用“取模”的方式，故最终队列长度为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 队列总长度</span></div><div class="line">QueueLength = (rear - front + MaxSize) % MaxSize;</div></pre></td></tr></table></figure>
<h5 id="2-3-3-循环队列的入队操作"><a href="#2-3-3-循环队列的入队操作" class="headerlink" title="2.3.3 循环队列的入队操作"></a>2.3.3 循环队列的入队操作</h5><p>按照循环存储的方式，当队尾已满，但仍有空间可用时，将新元素重新放入到队列头部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Q为队列（data为数据数组，rear和front为其头尾指针），e为将入队的新元素，下同</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MaxSize == Q-&gt;front) &#123;</div><div class="line">    <span class="comment">// 队列已满，不可入队</span></div><div class="line">    <span class="keyword">return</span> False;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 队尾设置数据</span></div><div class="line">Q-&gt;data[Q-&gt;rear] = e;</div><div class="line"><span class="comment">// 队尾指针后移（取模，填满后可从头赋值）</span></div><div class="line">Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MaxSize;</div><div class="line"></div><div class="line"><span class="keyword">return</span> True;</div></pre></td></tr></table></figure>
<h5 id="2-3-4-循环队列的出队操作"><a href="#2-3-4-循环队列的出队操作" class="headerlink" title="2.3.4 循环队列的出队操作"></a>2.3.4 循环队列的出队操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Q-&gt;rear == Q-&gt;front) &#123;</div><div class="line">    <span class="comment">// 空队列，不可出队</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// e为出队对象</span></div><div class="line">Element e = Q-&gt;front;</div><div class="line"><span class="comment">// 对首指针后移（取模，填满后可从头赋值）</span></div><div class="line">Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MaxSize;</div><div class="line"></div><div class="line"><span class="keyword">return</span> e;</div></pre></td></tr></table></figure>
<h4 id="2-4-队列的链式存储结构"><a href="#2-4-队列的链式存储结构" class="headerlink" title="2.4 队列的链式存储结构"></a>2.4 队列的链式存储结构</h4><p><strong>队列的链式存储结构，本质上就是使用链表实现的队列</strong>。最简单的实现就是“单链表”。队首指针front指向链表的头结点，队尾指针rear指向链表的尾部结点。</p>
<h5 id="2-4-1-链式队列的入队"><a href="#2-4-1-链式队列的入队" class="headerlink" title="2.4.1 链式队列的入队"></a>2.4.1 链式队列的入队</h5><p>链式队列的入队操作，实质上就是“尾插法”插入结点到单链表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Q为队列（front和rear分别为队列的头尾指针），s为待插入结点（data为数据域，next为指针域），下同</span></div><div class="line"></div><div class="line"><span class="comment">// 创建新结点s</span></div><div class="line">s = ...;</div><div class="line">s-&gt;data = e;</div><div class="line">s-&gt;next = <span class="literal">NULL</span>;</div><div class="line"><span class="comment">// 原尾部结点的next指向新结点</span></div><div class="line">Q-&gt;rear-&gt;next = s;</div><div class="line"><span class="comment">// 队尾指针指向新结点</span></div><div class="line">Q-&gt;rear = s;</div></pre></td></tr></table></figure>
<h5 id="2-4-2-链式队列的入队"><a href="#2-4-2-链式队列的入队" class="headerlink" title="2.4.2 链式队列的入队"></a>2.4.2 链式队列的入队</h5><p>链式队列的出队操作，实质上就是在链表头部移除首个结点。注意，出队后，若得到空队列，队尾指针rear也应指向链表的头结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) &#123;</div><div class="line">    <span class="comment">// 空队列，不可出队</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 得到当前待出队结点p</span></div><div class="line">p = Q-&gt;front-&gt;next;</div><div class="line"><span class="comment">// 获取出队元素</span></div><div class="line">e = p-&gt;data;</div><div class="line"><span class="comment">// 队首指针指向出队结点的下一个结点</span></div><div class="line">Q-&gt;front-&gt;next = p-&gt;next;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (Q-&gt;rear == p) &#123;</div><div class="line">    <span class="comment">// 判空，若出队后为空队列，则更新队尾指针（均指向单链表的头结点）</span></div><div class="line">    Q-&gt;rear = Q-&gt;front;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">free</span>(p);</div><div class="line"></div><div class="line"><span class="keyword">return</span> e;</div></pre></td></tr></table></figure>
<h4 id="2-5-两种存储结构队列的比较"><a href="#2-5-两种存储结构队列的比较" class="headerlink" title="2.5 两种存储结构队列的比较"></a>2.5 两种存储结构队列的比较</h4><p>比较两种存储结构的队列的异同，如同比较顺序存储和链式存储的优劣。首先，对于灵活程度来说，链式队列由于无需考虑存储空间的大小，且无需担心数据溢出或空间浪费，而显得更加灵活。但是，由于其单个数据占用空间略大，且创建和释放存在部分消耗，在纯性能上略差于顺序队列。</p>
<p>还是那句话，<strong>确定存储空间大小时，使用顺序队列；否则使用链式队列</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-栈&quot;&gt;&lt;a href=&quot;#1-栈&quot; class=&quot;headerlink&quot; title=&quot;1. 栈&quot;&gt;&lt;/a&gt;1. 栈&lt;/h3&gt;&lt;h4 id=&quot;1-1-定义&quot;&gt;&lt;a href=&quot;#1-1-定义&quot; class=&quot;headerlink&quot; title=&quot;1.1 定义&quot;&gt;&lt;/a&gt;1.1 定义&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;栈，即只能在表尾进行插入或删除操作的线性表。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中，“表尾”称为“&lt;strong&gt;栈顶&lt;/strong&gt;”，另一端则为“栈底”。栈是“&lt;strong&gt;后进先出&lt;/strong&gt;”（LIFO）的线性表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》之线性表</title>
    <link href="http://yoursite.com/2019/03/06/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/03/06/《大话数据结构》之线性表/</id>
    <published>2019-03-06T10:55:37.657Z</published>
    <updated>2019-03-07T05:45:22.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-线性表的主要类型"><a href="#1-线性表的主要类型" class="headerlink" title="1. 线性表的主要类型"></a>1. 线性表的主要类型</h3><p>线性表在存储方式上划分，可分为：</p>
<ul>
<li><strong>顺序存储结构</strong>，如标准数组</li>
<li><strong>链式存储结构</strong>，如单链表</li>
</ul>
<a id="more"></a>
<h3 id="2-顺序存储结构"><a href="#2-顺序存储结构" class="headerlink" title="2. 顺序存储结构"></a>2. 顺序存储结构</h3><p>所谓顺序存储结构，即使用一段地址连续的存储单依次存储线性表的数据元素。</p>
<p>我们可以使用数组来描述线性表的顺序存储结构。</p>
<h4 id="2-1-地址计算方法（读取数据）"><a href="#2-1-地址计算方法（读取数据）" class="headerlink" title="2.1 地址计算方法（读取数据）"></a>2.1 地址计算方法（读取数据）</h4><p>通俗地讲，与数据下标访问的方式类似，后一个数据的地址是前一个地址加上数据大小。对于第i个数据的储存位置，即可使用以下方式得出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LOC(a(i + <span class="number">1</span>)) = LOC(a(i)) + (i - <span class="number">1</span>) * c</div></pre></td></tr></table></figure>
<p>由于任意地址的数据均可以由以上公式一步得出，故<strong>顺序存储结构的存储时间为O(1)，即时间复杂度为常数阶</strong>。</p>
<h4 id="2-2-插入数据"><a href="#2-2-插入数据" class="headerlink" title="2.2 插入数据"></a>2.2 插入数据</h4><p>主要步骤为：</p>
<ol>
<li>查找到要插入的位置i</li>
<li>将i之后的数据依次后移一个位置</li>
<li>在i的位置上插入数据e</li>
<li>表长加1</li>
</ol>
<p>总的执行次数为 1 + n + 1 + 1，故<strong>插入操作的时间复杂度为O(n)</strong>。</p>
<h4 id="2-3-删除数据"><a href="#2-3-删除数据" class="headerlink" title="2.3 删除数据"></a>2.3 删除数据</h4><p>主要步骤为：</p>
<ol>
<li>查找到要删除的位置i</li>
<li>在i的位置上取出数据e</li>
<li>将i之后的数据依次前移一个位置</li>
<li>表长减1</li>
</ol>
<p>总的执行次数为 1 + 1 + n + 1，故<strong>删除操作的时间复杂度为O(n)</strong>。</p>
<h4 id="2-4-顺序存储结构的优缺点"><a href="#2-4-顺序存储结构的优缺点" class="headerlink" title="2.4 顺序存储结构的优缺点"></a>2.4 顺序存储结构的优缺点</h4><p>优点：</p>
<ul>
<li>无需为数据元素之间的逻辑关系增加额外存储空间</li>
<li>可以快速读取任一位置的元素</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入和删除数据需要移动大量元素</li>
<li>当线性表长度变化较大时，难以确定存储空间的长度</li>
<li>造成存储空间的”碎片“</li>
</ul>
<h3 id="3-链式存储结构（以单链表为例）"><a href="#3-链式存储结构（以单链表为例）" class="headerlink" title="3. 链式存储结构（以单链表为例）"></a>3. 链式存储结构（以单链表为例）</h3><p>链式存储结构的特点，是使用一组任意的存储单元存储线性表的数据元素。这些存储单元可以是不连续的，任意位置均可。</p>
<p>链式存储结构中的数据结点（Node），除了包含自身数据（数据域），还需要存储一个后继结点的地址（指针域）。</p>
<p>当n个数据结点组成一个链表，其中每一个结点都只包含一个指针域时，这种链式结构称为<strong>单链表</strong>。</p>
<p>我们这里使用单链表来描述线性表的链式存储结构。</p>
<h4 id="3-1-单链表的基本描述"><a href="#3-1-单链表的基本描述" class="headerlink" title="3.1 单链表的基本描述"></a>3.1 单链表的基本描述</h4><ul>
<li><strong>头指针</strong>：指向单链表第一个结点存储位置（即第一个结点的地址）的指针。</li>
<li><strong>头结点</strong>：在第一个结点前设置的一个结点，其指针域为头指针地址。</li>
<li>线性表最后一个结点的指针域为NULL或^。</li>
</ul>
<h4 id="3-2-头指针与头结点的异同"><a href="#3-2-头指针与头结点的异同" class="headerlink" title="3.2 头指针与头结点的异同"></a>3.2 头指针与头结点的异同</h4><p>头指针：</p>
<ul>
<li>指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。</li>
<li>有标识作用，常用头指针冠以链表的名字。</li>
<li>无论链表是否为空，头指针均不为空。<strong>头指针是链表的必要元素</strong>。</li>
</ul>
<p>头结点：</p>
<ul>
<li>为了操作统一和方便而设置，放在第一个结点之前，其数据域一般无意义（可以存放链表长度）。</li>
<li>有了头结点，对在第一个结点前插入结点或删除第一结点，其操作与其他结点完成统一。</li>
<li><strong>头结点不一定是链表的必须要素</strong>。</li>
</ul>
<h4 id="3-3-单链表的读取"><a href="#3-3-单链表的读取" class="headerlink" title="3.3 单链表的读取"></a>3.3 单链表的读取</h4><p>由于每一个结点的存储位置都在前一个结点的指针域中保存，故获取指定位置的结点数据，需要从单链表的头结点开始，依次查找。故其<strong>查找的时间复杂度为O(n)</strong>。</p>
<p>查找方式，即循环”指针后移“。</p>
<h4 id="3-4-单链表的插入"><a href="#3-4-单链表的插入" class="headerlink" title="3.4 单链表的插入"></a>3.4 单链表的插入</h4><p>单链表的插入过程，如下图所示：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1551764374-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5.jpg" alt="单链表的插入"></p>
<p>其中，待插入的结点s（数据e），插入到结点p和p-&gt;next之间（数据a(i)和数据a(i+1)）之间。其关键操作为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将插入结点s的指针域指向原后结点p-&gt;next</span></div><div class="line">s-&gt;next = p-&gt;next;</div><div class="line"><span class="comment">// 原结点p的指针域指向插入结点s</span></div><div class="line">p-&gt;next = s;</div></pre></td></tr></table></figure>
<p>故此插入行为的复杂度为O(1)。</p>
<p>不过，由于查找插入位置结点的复杂度为O(n)，故最终<strong>单链表插入操作的时间复杂度为O(n)</strong>。</p>
<h4 id="3-5-单链表的删除"><a href="#3-5-单链表的删除" class="headerlink" title="3.5 单链表的删除"></a>3.5 单链表的删除</h4><p>单链表的删除过程，如下图所示：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1551764879-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4.jpg" alt="单链表的删除"></p>
<p>其中，a(i)为待删除元素，即p-&gt;next结点。删除后即将结点p的指针域指向a(i+1)元素的结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 待删除结点的前一个结点的指针域 指向 待删除结点的后一个结点</span></div><div class="line">p-&gt;next = p-&gt;next-&gt;next;</div><div class="line"></div><div class="line"><span class="comment">// 或</span></div><div class="line"></div><div class="line">q = p-&gt;next;</div><div class="line">p-&gt;next = q-&gt;next;</div><div class="line"></div><div class="line"><span class="comment">// 最后，释放删除结点的内存</span></div><div class="line"><span class="built_in">free</span>(q);</div></pre></td></tr></table></figure>
<p>故此删除行为的复杂度为O(1)。</p>
<p>不过，由于查找删除位置结点的复杂度为O(n)，故最终<strong>单链表删除操作的时间复杂度为O(n)</strong>。</p>
<h4 id="3-6-单链表的整表创建"><a href="#3-6-单链表的整表创建" class="headerlink" title="3.6 单链表的整表创建"></a>3.6 单链表的整表创建</h4><ul>
<li><strong>头插法</strong>：每次均从头指针插入新结点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建单链表L(空表)</span></div><div class="line">*L = (LinkList)<span class="built_in">malloc</span>(sizeOf(Node));</div><div class="line">(*L-&gt;next) = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">    <span class="comment">// L为单链表的头结点，p为待插入结点</span></div><div class="line">    p-&gt;next = (*L)-&gt;next;</div><div class="line">    (*L)-&gt;next = p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>尾插法</strong>：每次均插入到尾结点的后面。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建单链表L(空表)</span></div><div class="line">*L = (LinkList)<span class="built_in">malloc</span>(sizeOf(Node));</div><div class="line">(*L-&gt;next) = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="comment">// r为指向尾部的结点</span></div><div class="line">r = *L;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">    <span class="comment">// p为待插入结点，插入到尾结点后面</span></div><div class="line">    r-&gt;next = p;</div><div class="line">    <span class="comment">// 新加入结点作为新的尾结点</span></div><div class="line">    r = p;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 尾结点指针域赋值</span></div><div class="line">r-&gt;next = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure>
<h4 id="3-7-单链表的整表删除"><a href="#3-7-单链表的整表删除" class="headerlink" title="3.7 单链表的整表删除"></a>3.7 单链表的整表删除</h4><p>做法：依次边遍历边删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// L为待删除链表，p和q分别指向当前结点</span></div><div class="line"></div><div class="line"><span class="comment">// p指向第一个结点</span></div><div class="line">p = (*L)-&gt;next;</div><div class="line"></div><div class="line"><span class="keyword">while</span>(p) &#123;</div><div class="line">    <span class="comment">// q指向后继结点</span></div><div class="line">    q = p-&gt;next;</div><div class="line">    <span class="comment">// 删除当前结点</span></div><div class="line">    <span class="built_in">free</span>(p);</div><div class="line">    <span class="comment">// p指向后继结点</span></div><div class="line">    p = q;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 循环结束后，p结点已经不存在</span></div><div class="line"><span class="comment">// 置为空表，让头结点的头指针为空</span></div><div class="line">(*L)-&gt;next = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure>
<h4 id="3-8-单链表与顺序存储结构实用性对比"><a href="#3-8-单链表与顺序存储结构实用性对比" class="headerlink" title="3.8 单链表与顺序存储结构实用性对比"></a>3.8 单链表与顺序存储结构实用性对比</h4><ul>
<li>在频繁查找，且很少进行插入和删除操作时，可以考虑使用顺序存储结构。若频繁插入或删除，则考虑使用单链表。</li>
<li>在不确定线性表的元素个数时，可以考虑使用单链表，忽略存储空间的需求问题。</li>
</ul>
<h3 id="4-其他类型链表结构"><a href="#4-其他类型链表结构" class="headerlink" title="4. 其他类型链表结构"></a>4. 其他类型链表结构</h3><h4 id="4-1-静态链表"><a href="#4-1-静态链表" class="headerlink" title="4.1 静态链表"></a>4.1 静态链表</h4><p>静态链表是在没有指针的情况下实现的“模拟”单链表，本质上是使用数组进行描述并实现。</p>
<p>其结构如下所示：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1551867514-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8.jpg" alt="静态链表"></p>
<p>其中，数组分为两部分结构：</p>
<ol>
<li>以数组的末尾元素为头结点，根据游标（cur）索引，直到元素的游标为0为止，连接而成的结构，也就是真正的<strong>单链表</strong>。</li>
<li>以数组第一个元素为头结点，根据游标索引，直到元素的游标为末尾元素的下标为止，作为<strong>备用链表</strong>，用于动态分配数据（插入、移除数据使用）。</li>
</ol>
<p>主要结构：</p>
<ul>
<li>数组的末尾元素：初始状态下，末尾元素的游标指向首元素，即为空表。当插入数据后，其游标永远指向链表第一个数据。</li>
<li>数组的首元素：初始状态下，其游标指向数组的下一个元素。当插入数据后，其游标总是指向备用链表的第一个数据。</li>
<li>数组的其他元素：默认情况下，当前元素的游标指向下一个元素。当插入数据后，数据的游标即保存的是下一个插入数据所在数组的下标。单链表最后一个数据的游标保存的是0，即数组首元素下标，标识单链表已结束。</li>
</ul>
<blockquote>
<p><strong>静态链表的优缺点</strong>：</p>
<p>优点：<br>避免了插入和删除数据时对大量数据的移动，只要修改游标即可实现。</p>
<p>缺点：</p>
<ul>
<li>由于使用数组进行实现，依然无法避免对内存空间进行考虑。</li>
<li>失去了顺序存储结构随机存取的特性。</li>
</ul>
<p>备注：</p>
<p>静态链表的创建、插入和删除等操作的Objective-C版本实现：<a href="https://github.com/Choujiji/PlayWithDataStructure-Code/tree/master/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8" target="_blank" rel="external">项目地址</a></p>
</blockquote>
<h4 id="4-2-循环链表"><a href="#4-2-循环链表" class="headerlink" title="4.2 循环链表"></a>4.2 循环链表</h4><p>循环链表作为单链表的扩展，在链表尾部定义了尾指针，指向最后一个结点rear。其指针域next指向链表的头结点。</p>
<p>同时，判定链表结束的条件变为了rear-&gt;next == 头指针p。</p>
<h4 id="4-3-双向链表"><a href="#4-3-双向链表" class="headerlink" title="4.3 双向链表"></a>4.3 双向链表</h4><p>双向链表作为单链表的扩展，在结点的头部和尾部均设有指针域（prior和next），分别指向前驱结点和后继结点。可以双向访问链表的元素。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-线性表的主要类型&quot;&gt;&lt;a href=&quot;#1-线性表的主要类型&quot; class=&quot;headerlink&quot; title=&quot;1. 线性表的主要类型&quot;&gt;&lt;/a&gt;1. 线性表的主要类型&lt;/h3&gt;&lt;p&gt;线性表在存储方式上划分，可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顺序存储结构&lt;/strong&gt;，如标准数组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链式存储结构&lt;/strong&gt;，如单链表&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之可视化语言（Visual Format Language）</title>
    <link href="http://yoursite.com/2019/03/05/Autolayout%E4%B9%8B%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AF%AD%E8%A8%80%EF%BC%88Visual%20Format%20Language%EF%BC%89/"/>
    <id>http://yoursite.com/2019/03/05/Autolayout之可视化语言（Visual Format Language）/</id>
    <published>2019-03-05T09:08:02.615Z</published>
    <updated>2019-03-05T09:08:32.238Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1" target="_blank" rel="external">Visual Format Language</a></p>
</blockquote>
<p>这篇附录阐述了如何使用Auto Layout可视化语言来设定普通约束，包括标准间距、尺寸、垂直布局和带有不同优先级的约束等。此外，本附录还包含了一个完整的语法说明。</p>
<a id="more"></a>
<h4 id="可视化句法"><a href="#可视化句法" class="headerlink" title="可视化句法"></a>可视化句法</h4><p>以下是一些通过可视化格式指定的约束示例。请注意其中文字是如何匹配示意图的。</p>
<ul>
<li>标准间距</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[button]-[textField]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/standardSpace.png" alt="img"></p>
<ul>
<li>宽度约束</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[button(&gt;=<span class="number">50</span>)]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/widthConstraint.png" alt="img"></p>
<ul>
<li>连接到父视图</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">|<span class="number">-50</span>-[purpleBox]<span class="number">-50</span>-|</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/connectionToSuperview.png" alt="img"></p>
<ul>
<li>垂直布局</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">V:[topField]<span class="number">-10</span>-[bottomField]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/verticalLayout.png" alt="img"></p>
<ul>
<li>对齐的视图</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[maroonView][blueView]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/flushViews.png" alt="img"></p>
<ul>
<li>优先级</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[button(<span class="number">100</span>@<span class="number">20</span>)] <span class="comment">// 这里优先级为20</span></div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/priority.png" alt="img"></p>
<ul>
<li>等宽</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[button1(==button2)]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/equalWidths.png" alt="img"></p>
<ul>
<li>多项描述</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[flexibleButton(&gt;=<span class="number">70</span>,&lt;=<span class="number">100</span>)]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/multiplePredicates.png" alt="img"></p>
<ul>
<li>完整的一行布局</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">|-[find]-[findNext]-[findField(&gt;=<span class="number">20</span>)]-|</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/completeLayout.png" alt="img"></p>
<p>这种表示法通过完整的表达式提高了可读性。大多数的可用约束都可以通过可视化格式句法在用户界面中表示出来，但是还是有一些不可以。一种不能表示的约束即指定的宽高比（例如，<em>imageView.width = 2 </em> imageView.height*）。要创建这个约束，你必须使用<a href="https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init" target="_blank" rel="external">constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:</a>方法。</p>
<h4 id="可视化格式字符串语法"><a href="#可视化格式字符串语法" class="headerlink" title="可视化格式字符串语法"></a>可视化格式字符串语法</h4><p>可视化格式字符串语法的定义如下（字面量使用<em>代码字体</em>表示，<strong>e</strong>代表空字符串）。</p>
<blockquote>
<p>译者注：</p>
<ul>
<li>表中的“?”代表修饰项为可选的，</li>
<li>“*”代表前面的修饰项的个数是任意的</li>
<li>“替换规则”中的每一项“&lt;…&gt;”可当做变量在“符号”中查找替换</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>符号</th>
<th>替换规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;可视化格式字符串&gt;</td>
<td>(&lt;方向&gt;:)?(&lt;父视图&gt;&lt;连接&gt;)?&lt;视图&gt;(&lt;连接&gt;&lt;视图&gt;)*(&lt;连接&gt;&lt;父视图&gt;)?</td>
</tr>
<tr>
<td>&lt;方向&gt;</td>
<td><em>H</em> 或 <em>V</em></td>
</tr>
<tr>
<td>&lt;父视图&gt;</td>
<td>&#124;</td>
</tr>
<tr>
<td>&lt;视图&gt;</td>
<td><em>[</em> &lt;视图名&gt;(&lt;带括号的描述列表&gt;)? <em>]</em></td>
</tr>
<tr>
<td>&lt;连接&gt;</td>
<td><strong>e</strong> 或 <em>-</em>&lt;描述列表&gt;<em>-</em> 或 <em>-</em></td>
</tr>
<tr>
<td>&lt;描述列表&gt;</td>
<td>&lt;简单描述&gt; 或 &lt;带括号的描述列表&gt;</td>
</tr>
<tr>
<td>&lt;简单描述&gt;</td>
<td>&lt;度量名称&gt; 或 &lt;确定数字&gt;</td>
</tr>
<tr>
<td>&lt;带括号的描述列表&gt;</td>
<td><em>(</em> &lt;描述&gt;(,&lt;描述&gt;)<em> </em>)*</td>
</tr>
<tr>
<td>&lt;描述&gt;</td>
<td>(&lt;关系&gt;)?(&lt;描述的对象&gt;)(<em>@</em>&lt;优先级&gt;)?</td>
</tr>
<tr>
<td>&lt;关系&gt;</td>
<td><em>==</em> 或 <em>&lt;=</em> 或 <em>&gt;=</em></td>
</tr>
<tr>
<td>&lt;描述的对象&gt;</td>
<td>&lt;常量值&gt; 或 &lt;视图名称&gt; <em>（见说明）</em></td>
</tr>
<tr>
<td>&lt;优先级&gt;</td>
<td>&lt;度量名称&gt; 或 &lt;数字&gt;</td>
</tr>
<tr>
<td>&lt;常量值&gt;</td>
<td>&lt;度量名称&gt; 或 &lt;数字&gt;</td>
</tr>
<tr>
<td>&lt;视图名称&gt;</td>
<td>解析为C语言符号。此对象必须是传入的视图字典中，一个UIView实例对应的key值。</td>
</tr>
<tr>
<td>&lt;度量名称&gt;</td>
<td>解析为C语言符号。此对象必须是传入的度量字典中，一个NSNumber实例对应的key值。</td>
</tr>
<tr>
<td>&lt;数字&gt;</td>
<td>通过<em>strtod_l</em>解析（注：解析成浮点数），使用C语言格式</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>说明</strong></p>
<p>在<em>描述的对象</em>的生成方式中，只有当描述的对象是<em>视图</em>的宽或高时，<em>视图名称</em>才可以作为其中的一部分。也就是说，你可以使用 <em>[view1(==view2)]</em> 的方式来指定<em>view1</em>和<em>view2</em>拥有相同宽度。</p>
</blockquote>
<p>如果你产生了句法错误，系统会抛出异常并带有诊断信息。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Expected <span class="string">':'</span> after <span class="string">'V'</span> to specify vertical arrangement</div><div class="line">V|[backgroundBox]|</div><div class="line"> ^</div><div class="line"> </div><div class="line">A predicate on a view's thickness must end with <span class="string">')'</span> <span class="keyword">and</span> the view must end with <span class="string">']'</span></div><div class="line">|[whiteBox1][blackBox4(blackWidth][redBox]|</div><div class="line">                                 ^</div><div class="line"> </div><div class="line">Unable to find view with name blackBox</div><div class="line">|[whiteBox2][blackBox]</div><div class="line">                     ^</div><div class="line"> </div><div class="line">Unknown relation. Must be ==, &gt;=, <span class="keyword">or</span> &lt;=</div><div class="line">V:|[blackBox4(&gt;<span class="number">30</span>)]|</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Visual Format Language&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇附录阐述了如何使用Auto Layout可视化语言来设定普通约束，包括标准间距、尺寸、垂直布局和带有不同优先级的约束等。此外，本附录还包含了一个完整的语法说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》之算法的时间复杂度</title>
    <link href="http://yoursite.com/2019/03/05/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E4%B9%8B%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://yoursite.com/2019/03/05/《大话数据结构》之算法的时间复杂度/</id>
    <published>2019-03-05T07:23:16.914Z</published>
    <updated>2019-03-05T07:23:38.227Z</updated>
    
    <content type="html"><![CDATA[<p>算法的时间复杂度一般是指算法的最坏执行情况（最大执行次数）。</p>
<h4 id="1-大O表示法"><a href="#1-大O表示法" class="headerlink" title="1. 大O表示法"></a>1. 大O表示法</h4><p>衡量算法的复杂度（一般指时间复杂度）通常使用大O表示法，其推导的一般方式为：</p>
<ol>
<li>用常数1取代运行时间中的所有加法常数。</li>
<li>在修改后的运行次数函数中，只保留最高阶项。</li>
<li>如果最高阶项存在且不是1，则去除与这个项乘积的常数。</li>
</ol>
<p>最终得到的结果就是大O阶。</p>
<a id="more"></a>
<h4 id="2-常用的大O阶"><a href="#2-常用的大O阶" class="headerlink" title="2. 常用的大O阶"></a>2. 常用的大O阶</h4><ul>
<li>常数阶<br>  O(1)：如顺序结构的复杂度或是分支结构（if–else–），执行次数恒定，不会随n变化而变化。</li>
<li>线性阶<br>  O(n)：如循环结构，根据循环次数决定。</li>
<li>对数阶<br>  O(logn): 例如如下循环</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span>(count &lt; n) &#123;</div><div class="line">    count = count * <span class="number">2</span>;</div><div class="line">    <span class="comment">/** 时间复杂度为O(1)的顺序步骤序列 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>如上所示，x为执行次数，2^x = n，即x = log2n，故时间复杂度为O(logn)。
</code></pre><ul>
<li>平方阶<br>  O(n^2)：如双重嵌套循环。</li>
</ul>
<h4 id="3-常见的时间复杂度排列"><a href="#3-常见的时间复杂度排列" class="headerlink" title="3. 常见的时间复杂度排列"></a>3. 常见的时间复杂度排列</h4><p>耗费时间从小到大依次为：</p>
<blockquote>
<p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法的时间复杂度一般是指算法的最坏执行情况（最大执行次数）。&lt;/p&gt;
&lt;h4 id=&quot;1-大O表示法&quot;&gt;&lt;a href=&quot;#1-大O表示法&quot; class=&quot;headerlink&quot; title=&quot;1. 大O表示法&quot;&gt;&lt;/a&gt;1. 大O表示法&lt;/h4&gt;&lt;p&gt;衡量算法的复杂度（一般指时间复杂度）通常使用大O表示法，其推导的一般方式为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用常数1取代运行时间中的所有加法常数。&lt;/li&gt;
&lt;li&gt;在修改后的运行次数函数中，只保留最高阶项。&lt;/li&gt;
&lt;li&gt;如果最高阶项存在且不是1，则去除与这个项乘积的常数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终得到的结果就是大O阶。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之修改约束</title>
    <link href="http://yoursite.com/2019/03/04/%20Autolayout%E4%B9%8B%E4%BF%AE%E6%94%B9%E7%BA%A6%E6%9D%9F/"/>
    <id>http://yoursite.com/2019/03/04/ Autolayout之修改约束/</id>
    <published>2019-03-04T08:55:42.105Z</published>
    <updated>2019-03-04T08:55:42.105Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW1" target="_blank" rel="external">Changing Constraints</a></p>
</blockquote>
<p>对一个约束进行所有的改变实质上就是修改该约束的数学表达式（见图17-1）。你可以在<a href="">Anatomy of a Constraint</a>中查看更多关于约束方程的信息。</p>
<a id="more"></a>
<p><strong>图17-1</strong> 约束方程式</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/view_formula_2x.png" alt="img"></p>
<p>下列所有行为都会改变一个或多个约束：</p>
<ul>
<li>激活或失效约束</li>
<li>修改约束的常数值（constant value）</li>
<li>修改约束的优先级</li>
<li>从视图层级中移除视图</li>
</ul>
<p>其他改变，如设置控件的属性，或是修改视图层级，都可以改变约束。当改变发生时，系统会预设置出一个延迟布局阶段（查看<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW3" target="_blank" rel="external">The Deferred Layout Pass</a>）。</p>
<p>一般来说，你可以在任意时刻设置这些修改。理想情况下，大多数约束都会在Interface Builder中设置，或者是在ViewController的初始化配置时（如<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621495-viewdidload" target="_blank" rel="external">viewDidLoad</a>）通过代码创建。如果你需要在运行时动态修改约束，通常最好的方式就是在应用程序状态变化时进行修改。例如，如果你想修改一个约束来响应按钮的点击操作，那就直接在该按钮的动作方法中进行修改。</p>
<p>有时候，为了优化性能，你可能需要分阶段进行一系列的修改。要了解更多信息，请查看<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW2" target="_blank" rel="external">Batching Changes</a>。</p>
<h4 id="延迟布局阶段（The-Deferred-Layout-Pass）"><a href="#延迟布局阶段（The-Deferred-Layout-Pass）" class="headerlink" title="延迟布局阶段（The Deferred Layout Pass）"></a>延迟布局阶段（The Deferred Layout Pass）</h4><p>为了避免直接更新受影响视图的frame，Auto Layout设置了一个稍后执行的布局阶段。此延迟阶段首先更新布局的约束，之后为视图层级中的所有视图计算frame。</p>
<p>你可以通过调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout" target="_blank" rel="external">setNeedsLayout</a>或<a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="external">setNeedsUpdateConstraints</a>方法设置自己的延迟布局阶段。</p>
<p>视图层级中的延迟布局阶段通常由两个阶段组成：</p>
<ol>
<li>如果需要，在更新阶段（Update Pass）更新约束</li>
<li>如果需要，在布局阶段（Layout Pass）重设视图的frame</li>
</ol>
<h5 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h5><p>系统会遍历视图层级，并在所有的ViewController上调用<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621379-updateviewconstraints" target="_blank" rel="external">updateViewConstraints</a>方法、在所有视图上调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="external">updateConstraints</a>方法。你可以覆盖这些方法来优化约束的修改（查看<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW2" target="_blank" rel="external">Batching Changes</a>）。</p>
<h5 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h5><p>系统再一次遍历视图层级，并在所有ViewController上调用<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews" target="_blank" rel="external">viewWillLayoutSubviews</a>、在所有视图上调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="external">layoutSubViews</a>。默认来说，<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="external">layoutSubViews</a>方法会使用Auto Layout引擎算出的矩形来更新每个子视图的frame。你可以覆盖这些方法来修改布局（查看<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW4" target="_blank" rel="external">Custom Layouts</a>）。</p>
<h4 id="分阶段修改（Batching-Changes）"><a href="#分阶段修改（Batching-Changes）" class="headerlink" title="分阶段修改（Batching Changes）"></a>分阶段修改（Batching Changes）</h4><p>在有影响的修改发生后，直接更新约束应该总是最简洁、最方便的方式。将这些修改延迟到之后的方法中执行，会使代码更加复杂并难以理解。</p>
<p>可是，总有一些时候你想要为了优化性能而进行分阶段的修改。如当修改约束的地方执行太慢，或是视图正在进行许多冗余修改时，使用这种方式便可以解决。</p>
<p>要对改变进行分阶段执行，不要直接进行修改，而是在包含该约束的视图上调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="external">setNeedsUpdateConstraints</a>方法。之后，覆盖视图的<a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="external">updateConstraints</a>方法来修改受影响的约束。</p>
<blockquote>
<p><strong>说明</strong></p>
<p>你的<a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="external">updateConstraints</a>的实现必须尽可能高效。不要让所有的约束失效（deactivate），可以根据需要失效其中一部分。此外，你的app必须存在某些方式来追踪约束，并且可以在每一个更新阶段来验证它们。只改变那些需要改变的项目。在每一次更新阶段中，你必须确保为app的当前状态提供了适合的约束。</p>
</blockquote>
<p>在<a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="external">updateConstraints</a>方法实现中，最后一步一定要调用父类的实现。</p>
<p>不要在你的<a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="external">updateConstraints</a>方法中调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="external">setNeedsUpdateConstraints</a>方法。调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="external">setNeedsUpdateConstraints</a>会设置另一个更新阶段，进而生成了调用循环。</p>
<h4 id="自定义布局（Custom-Layouts）"><a href="#自定义布局（Custom-Layouts）" class="headerlink" title="自定义布局（Custom Layouts）"></a>自定义布局（Custom Layouts）</h4><p>覆盖<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews" target="_blank" rel="external">viewWillLayoutSubViews</a>或<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="external">layoutSubViews</a>方法来修改layout引擎返回的结果。</p>
<blockquote>
<p><strong>重点</strong></p>
<p>如果可能，使用约束来定义所有的布局。这可以使布局结果更加健壮且更易调试。当你需要创建一个布局，且此布局仅仅通过约束无法达到要求时，你只能通过覆盖<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews" target="_blank" rel="external">viewWillLayoutSubViews</a>或<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="external">layoutSubViews</a>方法进行处理。</p>
</blockquote>
<p>在覆盖这些方法时，布局正处在一个不确定的状态。一部分视图可能已经布局完，另一部分则没有。在修改视图层级时，你需要非常小心，否则很可能就会导致调用循环。如下规则可以帮助你避免调用循环：</p>
<ul>
<li>你必须在方法的某处调用父类的实现。</li>
<li>你可以安全地在子树中让视图布局无效化；可是，你必须在调用父类的实现之前做这件事。</li>
<li>不要让在子树外的任何视图布局无效化。这会导致调用循环。</li>
<li>不要调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="external">setNeedsUpdateConstraints</a>。你刚刚完成了一次更新阶段。调用此方法会产生一个调用循环。</li>
<li>不要调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout" target="_blank" rel="external">setNeedsLayout</a>。调用此方法会产生一个调用循环。</li>
<li>修改约束时要格外小心。你不能意外地让子树外的视图布局无效化。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Changing Constraints&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对一个约束进行所有的改变实质上就是修改该约束的数学表达式（见图17-1）。你可以在&lt;a href=&quot;&quot;&gt;Anatomy of a Constraint&lt;/a&gt;中查看更多关于约束方程的信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之自定义TableViewCell的尺寸</title>
    <link href="http://yoursite.com/2019/03/04/Autolayout%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89TableViewCell%E7%9A%84%E5%B0%BA%E5%AF%B8/"/>
    <id>http://yoursite.com/2019/03/04/Autolayout之自定义TableViewCell的尺寸/</id>
    <published>2019-03-04T03:52:42.581Z</published>
    <updated>2019-03-04T03:53:14.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithSelf-SizingTableViewCells.html#//apple_ref/doc/uid/TP40010853-CH25-SW1" target="_blank" rel="external">Working with Self-Sizing Table View Cells</a></p>
</blockquote>
<p>在iOS中，你可以使用Auto Layout定义TableViewCell的高度；但是，此特性默认没有开启。</p>
<a id="more"></a>
<p>一般来说，cell的高度是由tableView代理对象的<a href="https://developer.apple.com/documentation/uikit/uitableviewdelegate/1614998-tableview" target="_blank" rel="external">tableView:heightForRowAtIndexPath:</a>方法来决定的。要实现自定义尺寸的TableViewCell，你必须将tableView的<a href="https://developer.apple.com/documentation/uikit/uitableview/1614852-rowheight" target="_blank" rel="external">rowHeight</a>属性设置为<a href="https://developer.apple.com/documentation/uikit/uitableviewautomaticdimension" target="_blank" rel="external">UITableViewAutomaticDimension</a>。你还需要给<a href="https://developer.apple.com/documentation/uikit/uitableview/1614925-estimatedrowheight" target="_blank" rel="external">estimatedRowHeight</a>属性赋一个值。一旦这两个属性都被设置后，系统就会使用Auto Layout来计算每一行的实际高度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tableView.estimatedRowHeight = <span class="number">85.0</span></div><div class="line">tableView.rowHeight = UITableViewAutomaticDimension</div></pre></td></tr></table></figure>
<p>下一步，在TableViewCell的ContentView中布局相关内容。要定义cell的高度，你需要从ContentView的顶部到底部边界设置一个完整的约束和视图链来填满整个区域。如果你的视图中存在真实内容尺寸高度，系统便会使用这些值。如果没有，你就必须添加相应的高度约束，要么设置到视图上，要么就直接设置到ContentView自身。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Chain_of_Views_and_Constraints_2x.png" alt="img"></p>
<p>此外，尽可能让估算的行高精确一些。系统计算的项目，比如滑动条的高度，是基于这个估算值的。估算值越精确，用户体验就会越连贯。</p>
<blockquote>
<p><strong>说明</strong></p>
<p>当使用TableViewCell时，你不能改变预定义内容的布局（如<a href="https://developer.apple.com/documentation/uikit/uitableviewcell/1623210-textlabel" target="_blank" rel="external">textLabel</a>、<a href="https://developer.apple.com/documentation/uikit/uitableviewcell/1623273-detailtextlabel" target="_blank" rel="external">detailTextLabel</a>和<a href="https://developer.apple.com/documentation/uikit/uitableviewcell/1623270-imageview" target="_blank" rel="external">imageView</a>属性）。</p>
<p>可支持如下约束：</p>
<ul>
<li>相对于cell的ContentView来定位子视图的约束。</li>
<li>相对于cell的bounds来定位子视图的约束。</li>
<li>相对于预定义内容来定位子视图的约束。</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithSelf-SizingTableViewCells.html#//apple_ref/doc/uid/TP40010853-CH25-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Working with Self-Sizing Table View Cells&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在iOS中，你可以使用Auto Layout定义TableViewCell的高度；但是，此特性默认没有开启。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之使用Scroll View</title>
    <link href="http://yoursite.com/2019/03/03/Autolayout%E4%B9%8B%E4%BD%BF%E7%94%A8Scroll%20View/"/>
    <id>http://yoursite.com/2019/03/03/Autolayout之使用Scroll View/</id>
    <published>2019-03-03T04:19:33.192Z</published>
    <updated>2019-03-03T04:19:59.696Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithScrollViews.html#//apple_ref/doc/uid/TP40010853-CH24-SW1" target="_blank" rel="external">Working with Scroll Views</a></p>
</blockquote>
<p>当使用ScrollView时，你需要在父视图内同时定义ScrollView的尺寸和位置，额外还有ScrollView的内容区域。所有的这些特性都可以通过Auto Layout进行设置。</p>
<a id="more"></a>
<p>为了支持ScrollView，系统会基于约束所处的位置，使用不同的方式来诠释约束。</p>
<ul>
<li>就像其他视图一样，在ScrollView和其外部对象之间的约束都会影响ScrollView的frame。</li>
<li>对于ScrollView和其自身内容之间的约束，其行为就会因属性的约束方式而有所不同：<ul>
<li>ScrollView的边界分隔和其自身内容之间的约束会影响ScrollView的内容区域。</li>
<li>高度、宽度或是中心点三者之间的约束会影响ScrollView的frame。</li>
</ul>
</li>
<li>你还可以在ScrollView自身内容和ScrollView外部对象之间设置约束来为ScrollView的内容生成一个可变的位置，以便这些内容看起来就像漂浮在ScrollView上面一样。</li>
</ul>
<p>对于大多数通常的布局来说，如果你对ScrollView的内容使用虚拟视图或是组合的方式进行布局，逻辑将会变得非常简单。当使用Interface Builder时，通常的做法如下所示：</p>
<ol>
<li>在场景中添加ScrollView</li>
<li>像平常一样，设置约束来定义ScrollView的尺寸和位置。</li>
<li>添加一个视图到ScrollView上。设置该视图的Xcode指定标签到ScrollView的内容视图（即ContentView，以下直接使用）上。</li>
<li>设置ContentView的顶部、底部、头部和尾部边界到ScrollView的对应边界上。ContentView现在决定了ScrollView的内容区域。<blockquote>
<p>重点：</p>
<p>此时ContentView还没有一个确定的尺寸。它可以拉伸或压缩来适配任何你放入的视图或控件。</p>
</blockquote>
</li>
<li>（可选）要禁止水平滑动，将ContentView的宽度设置为与ScrollView宽度相同。ContentView现在在水平方向上充满了ScrollView。</li>
<li>（可选）要禁止垂直滑动，将ContentView的高度设置为与ScrollView高度相同。ContentView现在在竖直方向上充满了ScrollView。</li>
<li>将ScrollView的内容布局到ContentView内部。像往常一样，在ContentView内部使用约束来设置内容的位置。<blockquote>
<p>重点：</p>
<p>你的布局必须完整定义了ContentView的尺寸（除了步骤5和6定义的位置）。要设置基于真实内容尺寸视图的ContentView的高度，你必须从ContentView的顶部到底部设置一个未被打破（broken）的约束和视图链。相似的，要设置该ContentView的宽度，你就必须从ContentView的头部到尾部设置一个未被打破（broken）的约束和视图链。</p>
<p>如果你的内容控件没有真实内容尺寸，你就必须添加合适的尺寸约束，或者是设置ContentView的，或者就设置内容的。</p>
<p>当ContentView比ScrollView高时，ScrollView在竖直方向上便可以滑动了。当ContentView比ScrollView宽时，ScrollView在水平方向上就可以滑动了。否则，默认来说ScrollView的滑动是被禁止的。</p>
</blockquote>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithScrollViews.html#//apple_ref/doc/uid/TP40010853-CH24-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Working with Scroll Views&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当使用ScrollView时，你需要在父视图内同时定义ScrollView的尺寸和位置，额外还有ScrollView的内容区域。所有的这些特性都可以通过Auto Layout进行设置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之指定类型尺寸的布局（Size Class）</title>
    <link href="http://yoursite.com/2019/03/01/Autolayout%E4%B9%8B%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E5%B0%BA%E5%AF%B8%E7%9A%84%E5%B8%83%E5%B1%80%EF%BC%88Size%20Class%EF%BC%89/"/>
    <id>http://yoursite.com/2019/03/01/Autolayout之指定类型尺寸的布局（Size Class）/</id>
    <published>2019-03-01T07:35:41.941Z</published>
    <updated>2019-03-01T07:45:11.646Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Size-ClassSpecificLayout.html#//apple_ref/doc/uid/TP40010853-CH26-SW1" target="_blank" rel="external">Size-Class-Specific Layout
</a></p>
</blockquote>
<p>Interface Builder中的Storyboard默认使用了尺寸类型（以下写作Size Class）。所有的Size Class都会被赋值给UI元素，如场景和视图等。他们给元素的尺寸提供了一个粗略定义。Interface Builder可以让你基于当前Size Class自定义许多布局特性。布局便可以自动适应Size Class的改变。特别的是，你可以在每一个Size Class下设置如下特性：</p>
<a id="more"></a>
<ul>
<li>加载（install）或卸载（uninstall）一个视图或控件。</li>
<li>安装或卸载一个约束。</li>
<li>设置选中的属性值（如字体或布局边距设置）。</li>
</ul>
<p>当系统读取了一个场景对象（scene），它便初始化了所有的视图、控件和约束，并且把这些对象赋值给相应的插口（outlet）上（如果存在）。你可以通过outlet访问任意对象而不必考虑场景当前的Size Class。可是，这些对象只有在当前Size Class中设为为“已加载”（installed）的情况下，系统才会将它们添加到视图层级当中。</p>
<p>当视图的Size Class改变时（如当你旋转iPhone或在iPad上切换全屏和分隔屏模式时），系统会自动将所需的对象从视图层级上添加或移除。系统还会将视图布局的改变动态的表现出来。</p>
<blockquote>
<p><strong>说明</strong></p>
<p>系统会保持着“已卸载”（uninstalled）对象的关联关系，因此从视图层级中移除后，这些对象不会被释放。</p>
</blockquote>
<h4 id="“最终Size-Class”和“基础Size-Class”"><a href="#“最终Size-Class”和“基础Size-Class”" class="headerlink" title="“最终Size Class”和“基础Size Class”"></a>“最终Size Class”和“基础Size Class”</h4><p>Interface Builder区分了九中不同的Size Class。</p>
<p>其中的四种是“最终Size Class”：<em>Compact-Compact</em>、<em>Compact-Regular</em>、<em>Regular-Compact</em>和<em>Regular-Regular</em>。这些“最终”类型代表了设备显示的实际尺寸。</p>
<p>剩下的五种是“基础Size Class”：<em>Compact-Any</em>、<em>Regular-Any</em>、<em>Any-Compact</em>、<em>Any-Regular</em>和<em>Any-Any</em>。抽象的尺寸类型，他们代表了能同时代表两种或更多种类的“最终Size Class”。例如，在<em>Compact-Any</em>的Size Class中，“已安装”的对象会同时出现在<em>Compact-Compact</em>和<em>Compact-Regular</em>尺寸的视图中。</p>
<p>指定Size Class中的设置项总是会覆盖掉通用Size Class中的内容。此外，你必须为九种Size Class提供出无歧义并满足条件的布局。因此，从通用的Size Class到指定的Size Class进行设置是非常容易的。为你的app选择好默认布局，并在<em>Any-Any</em>的Size Class中设置好布局。之后只要根据需要修改其他的”基础“或”最终“Size Class即可。</p>
<h4 id="使用Size-Class工具"><a href="#使用Size-Class工具" class="headerlink" title="使用Size Class工具"></a>使用Size Class工具</h4><blockquote>
<p>（注意：本节对应Xcode8）</p>
</blockquote>
<p>使用Interface Builder中的Size Class工具，选择你当前编辑中的Size Class。此工具显示在编辑窗口的底部中心位置。默认来说，Interface Builder会将<em>Any-Any</em>作为初始选项。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Size_Class_Tool_2x.png" alt="img"></p>
<p>要切换至一个新的Size Class，点击Size Class工具。Interface Builder会弹出一个3 x 3的网格视图。从网格中拖动鼠标来切换Size Class。网格会在顶部显示所选Size Class的名称并在底部显示出描述信息（包含它影响的设备和朝向等）。它还会在被当前Size Class的设置所影响的每一个Size Class中显示出一个绿点。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Selecting_A__Size_Class_2x.png" alt="img"></p>
<p>添加到画布中的所有视图和约束都只会在当前Size Class中被加载。当在移除这些对象时，其删除行为会根据原先加载的位置和方式有所不同。</p>
<ul>
<li>在画布中或是在整个项目的目录列表中删除一个对象，则会直接删除它。</li>
<li>在画布中或是在文档缩略图中，使用<em>Command-Delete</em>删除一个对象，系统只会从当前Size Class中卸载它。</li>
<li>当一个场景对象包含多个Size Class时，除了在画布或目录列表以外，在任何地方删除对象（如，从尺寸检查器中选择并删除约束），只会将其从当前Size Class中卸载掉。</li>
<li>如果你只编辑了<em>Any-Any</em>的Size Class，那么删除一个对象就是从项目中直接移除了。</li>
</ul>
<p>如果你编辑的是除了<em>Any-Any</em>以外的其他Size Class，Interface Builder会将编辑窗口底部的工具栏高亮显示为蓝色。这会使你在指定Size Class下工作时区别更加明显。</p>
<h4 id="使用检查器"><a href="#使用检查器" class="headerlink" title="使用检查器"></a>使用检查器</h4><p>你还可以在检查器中修改指定Size Class的设置。所有支持指定Size Class的设置项都会在检查器中显示为一个带有”＋“号的选项。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Size-Class_Specific_Attributes_2x.png" alt="img"></p>
<p>默认来说，检查器中的值都是在<em>Any-Any</em>的Size Class下设置的。要为指定的Size Class设置不同的值，点击”+“号来新建一个Size Class。同时为这个Size Class选择宽度和高度。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Adding_Size_Class_2x.png" alt="img"></p>
<p>检查器现在用单独的一行显示了每一个Size Class—-<em>Any-Any</em>设置在最顶端，其他的Size Class在下面列出。你可以单独编辑每一行的值。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Setting_Size-Class_Specific_Values_2x.png" alt="img"></p>
<p>要删除一个自定义Size Class，直接单击每行开头的”x“号即可。</p>
<p>要了解关于在Interface Builder中使用Size Class的更多信息，请查看Size Class设计帮助。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Size-ClassSpecificLayout.html#//apple_ref/doc/uid/TP40010853-CH26-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Size-Class-Specific Layout
&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Interface Builder中的Storyboard默认使用了尺寸类型（以下写作Size Class）。所有的Size Class都会被赋值给UI元素，如场景和视图等。他们给元素的尺寸提供了一个粗略定义。Interface Builder可以让你基于当前Size Class自定义许多布局特性。布局便可以自动适应Size Class的改变。特别的是，你可以在每一个Size Class下设置如下特性：&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>对数组按需分组</title>
    <link href="http://yoursite.com/2019/03/01/%E5%AF%B9%E6%95%B0%E7%BB%84%E6%8C%89%E9%9C%80%E5%88%86%E7%BB%84/"/>
    <id>http://yoursite.com/2019/03/01/对数组按需分组/</id>
    <published>2019-03-01T03:22:57.720Z</published>
    <updated>2019-03-01T03:23:24.037Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p>
<a id="more"></a>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">输入: [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]</div><div class="line"></div><div class="line">输出: <span class="number">4</span></div><div class="line">解释: n 等于 <span class="number">2</span>, 最大总和为 <span class="number">4</span> = min(<span class="number">1</span>, <span class="number">2</span>) + min(<span class="number">3</span>, <span class="number">4</span>)。</div></pre></td></tr></table></figure>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>对于示例数组，所有的分组情况为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.</span></div><div class="line">[<span class="number">1</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>] <span class="comment">// 结果为 1 + 2 = 3</span></div><div class="line"><span class="comment">// 2.</span></div><div class="line">[<span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>] <span class="comment">// 结果为 1 + 2 = 3</span></div><div class="line"><span class="comment">// 3.</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>] <span class="comment">// 结果为 1 + 3 = 4</span></div></pre></td></tr></table></figure>
<p>然而，当数据过多时，无法直接列举出所有情况。<br>因此，我们首先可以考虑将数据进行排序。并且，我们知道，min函数的功能即获取较小的数，忽略较大的数。根据以上列举情况可以也看出，最大和的分组方式即为从小到大依次分组。故可以得出结论：</p>
<ol>
<li>升序排列数组，得到有序数据。</li>
<li>依次间隔获取数据并求和。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSInteger <span class="title">getMaxSumWithSeparatingArray</span><span class="params">(NSArray &lt;NSNumber *&gt;* info)</span> </span>&#123;</div><div class="line">    <span class="comment">// 1. 升序排列</span></div><div class="line">    NSArray *sortedInfo = [info sortedArrayUsingComparator:^NSComparisonResult(NSNumber *obj1, NSNumber *obj2) &#123;</div><div class="line">        <span class="keyword">return</span> [obj1 compare:obj2];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="comment">// 2. 依次对奇数项求和</span></div><div class="line">    NSInteger sum = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    NSInteger index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (index &lt; sortedInfo.count) &#123;</div><div class="line">        sum += [sortedInfo[index] integerValue];</div><div class="line">        index += <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法学习" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>如何排列硬币？</title>
    <link href="http://yoursite.com/2019/02/25/%E5%A6%82%E4%BD%95%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/02/25/如何排列硬币？/</id>
    <published>2019-02-25T06:25:24.535Z</published>
    <updated>2019-02-25T06:25:24.536Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。给定一个数字 n，找出可形成完整阶梯行的总行数。n 是一个非负整数，并且在32位有符号整型的范围。</p>
<a id="more"></a>
<ul>
<li>示例1：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">n = <span class="number">5</span></div><div class="line"></div><div class="line">硬币可排列成以下几行:</div><div class="line">¤</div><div class="line">¤ ¤</div><div class="line">¤ ¤</div><div class="line"></div><div class="line">因为第三行不完整，所以返回<span class="number">2.</span></div></pre></td></tr></table></figure>
<ul>
<li>示例2：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">n = <span class="number">8</span></div><div class="line"></div><div class="line">硬币可排列成以下几行:</div><div class="line">¤</div><div class="line">¤ ¤</div><div class="line">¤ ¤ ¤</div><div class="line">¤ ¤</div><div class="line"></div><div class="line">因为第四行不完整，所以返回<span class="number">3.</span></div></pre></td></tr></table></figure>
<h4 id="解法1：直接排列"><a href="#解法1：直接排列" class="headerlink" title="解法1：直接排列"></a>解法1：直接排列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSInteger <span class="title">maxRowCountWithCoins1</span><span class="params">(NSInteger coins)</span> </span>&#123;</div><div class="line">    NSInteger leftCoins = coins;</div><div class="line">    NSInteger rowCount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (leftCoins &gt;= rowCount) &#123;</div><div class="line">        rowCount += <span class="number">1</span>;</div><div class="line">        <span class="comment">// 按行数减去相应值</span></div><div class="line">        leftCoins -= rowCount;</div><div class="line">        <span class="keyword">if</span> (leftCoins &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 不够数，减1</span></div><div class="line">            rowCount -= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> rowCount;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="解法2：数学公式"><a href="#解法2：数学公式" class="headerlink" title="解法2：数学公式"></a>解法2：数学公式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSInteger <span class="title">maxRowCountWithCoins2</span><span class="params">(NSInteger coins)</span> </span>&#123;</div><div class="line">    <span class="comment">// 公式法，由于是等差数列（1，2，3...n，和为coins），使用等差数列求和公式，算出最小的整数n，即为行数</span></div><div class="line">    <span class="comment">// 1. 等差数列求和公式为：((A1 + An) * n) / 2 = Sn，带入公式，得</span></div><div class="line">    <span class="comment">//      ((1 + n) * n) / 2 = coins</span></div><div class="line">    <span class="comment">//      变形得  n^2 + n - 2 * coins = 0，可知此为一元二次方程</span></div><div class="line">    <span class="comment">// 2. 根据一元二次方程的求根公式，x = (-b +- sqrt(b^2 - 4ac)) / 2a，带入公式，得</span></div><div class="line">    <span class="comment">//      n = (-1 +- sqrt(1 + 8 * coins)) / 2</span></div><div class="line">    <span class="comment">//      变形，得 n = sqrt(0.25 + 2 * coins) - 0.5</span></div><div class="line">    <span class="comment">// 3. 故只要求出最小的正整数n即可</span></div><div class="line">    <span class="keyword">return</span> (NSInteger)(<span class="built_in">sqrt</span>(<span class="number">0.25</span> + <span class="number">2</span> * coins) - <span class="number">0.5</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。给定一个数字 n，找出可形成完整阶梯行的总行数。n 是一个非负整数，并且在32位有符号整型的范围。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法学习" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之调试技巧和提示</title>
    <link href="http://yoursite.com/2019/02/24/Autolayout%E4%B9%8B%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E5%92%8C%E6%8F%90%E7%A4%BA/"/>
    <id>http://yoursite.com/2019/02/24/Autolayout之调试技巧和提示/</id>
    <published>2019-02-24T05:23:50.351Z</published>
    <updated>2019-02-24T05:24:02.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文节选并翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/DebuggingTricksandTips.html#//apple_ref/doc/uid/TP40010853-CH21-SW1" target="_blank" rel="external">Debugging Tricks and Tips
</a></p>
</blockquote>
<p>以下话题描述了在布局中总结提炼出的信息，同时描述了一些你可能遇到的意料之外的情况。你也许不会再每次布局中都会用到这些技术，但是它们可以在一些难题上给你提供帮助。</p>
<a id="more"></a>
<h4 id="理解日志"><a href="#理解日志" class="headerlink" title="理解日志"></a>理解日志</h4><p>视图的信息可以在控制台中输出，也许是因为存在了不满足条件的布局，或是因为你明确使用了<a href="https://developer.apple.com/documentation/uikit/uiview/1622432-constraintsaffectinglayoutforaxi" target="_blank" rel="external">constraintsAffectingLayoutForAxis:</a>或<a href="https://developer.apple.com/documentation/appkit/nsview/1525968-constraintsaffectinglayout" target="_blank" rel="external">constraintsAffectingLayoutForOrientation:</a>的调试方法所致。</p>
<p>无论哪种方式，你都可以在这些日志中找到许多有用信息。下面是一个关于不满足条件的布局错误的示例输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-26</span> <span class="number">14</span>:<span class="number">27</span>:<span class="number">54.790</span> Auto Layout Cookbook[<span class="number">10040</span>:<span class="number">1906606</span>] Unable to simultaneously satisfy constraints.</div><div class="line">    Probably at least one of the constraints in the following <span class="built_in">list</span> is one you don't want. Try <span class="keyword">this</span>: (<span class="number">1</span>) look at each constraint <span class="keyword">and</span> <span class="keyword">try</span> to figure out which you don't expect; (<span class="number">2</span>) find the code that added the unwanted constraint <span class="keyword">or</span> constraints <span class="keyword">and</span> fix it. (Note: If you're seeing NSAutoresizingMaskLayoutConstraints that you don't understand, refer to the documentation <span class="keyword">for</span> the UIView property translatesAutoresizingMaskIntoConstraints) </div><div class="line">(</div><div class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7a87b000 H:[UILabel:0x7a8724b0'Name'(&gt;=400)]&gt;"</span>,</div><div class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7a895e30 UILabel:0x7a8724b0'Name'.leading == UIView:0x7a887ee0.leadingMargin&gt;"</span>,</div><div class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7a886d20 H:[UILabel:0x7a8724b0'Name']-(NSSpace(8))-[UITextField:0x7a88cff0]&gt;"</span>,</div><div class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7a87b2e0 UITextField:0x7a88cff0.trailing == UIView:0x7a887ee0.trailingMargin&gt;"</span>,</div><div class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7ac7c430 'UIView-Encapsulated-Layout-Width' H:[UIView:0x7a887ee0(320)]&gt;"</span></div><div class="line">)</div><div class="line"> </div><div class="line">Will attempt to recover by breaking constraint</div><div class="line">&lt;NSLayoutConstraint:<span class="number">0x7a87b000</span> H:[UILabel:<span class="number">0x7a8724b0'</span>Name'(&gt;=<span class="number">400</span>)]&gt;</div><div class="line"> </div><div class="line">Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to <span class="keyword">catch</span> <span class="keyword">this</span> in the debugger.</div><div class="line">The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit/UIView.h&gt; may also be helpful.</div></pre></td></tr></table></figure>
<p>这个错误消息展示了五个冲突约束。这些约束无法同时满足。你应该要么移除一个，要么把一个约束变成可选约束。</p>
<p>幸运的是，这个视图层级相对简单。你有一个父视图，它包含着一个label和一个text field。冲突的约束被设置成了如下关系：</p>
<ol>
<li>label的宽度大于等于400点。</li>
<li>label的起始边等于父视图的起始空白区域。</li>
<li>在label和text field之间包含8个点的空间。</li>
<li>text field的尾边等于父视图的尾部空白区域。</li>
<li>父视图的宽度为320点。</li>
</ol>
<p>系统试图通过移除label的宽度来恢复正常。</p>
<blockquote>
<p><strong>说明</strong></p>
<p>控制台中写入的约束使用的是可视化语言（Visual Format Language，以后写做VFL）。即使你从不会使用VFL来创建约束，你也必须可以阅读并理解它以便有效调试Auto Layout的问题。要获取更多信息，请看<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1" target="_blank" rel="external">可视化语言</a>。</p>
</blockquote>
<p>这些约束当中，最后一个是系统创建的。你不能改变它。并且，它和第一个约束一起产生了一个明显的冲突。如果你的父视图只有320点宽度，你不可能会有一个400点宽度的label。幸运的是，你不必移除首个约束。如果你把它的优先级降到999，系统还是会试图提供一个可选宽度—-尽可能地接近它（400宽度），并同时满足其他约束。</p>
<p>基于视图的autoresizing mask的约束（例如，当<a href="https://developer.apple.com/documentation/uikit/uiview/1622572-translatesautoresizingmaskintoco" target="_blank" rel="external">translatesAutoresizingMaskIntoConstraints</a>为YES时，约束被创建）在mask上存在额外信息。在约束被定位后，日志字符串会显示”<em>h=</em>“，且其后跟随着三个字符，“<em>v=</em>”后同样跟随三个字符。一个“<em>-</em>”（连字符）字符代表一个确定值，同时一个“<em>&amp;</em>”（与符号）字符代表一个可变值。对于水平方向（<em>h=</em>），三个字符分别代表了左间距、<br>宽度和右间距。在垂直方向上（<em>v=</em>），他们分别代表了顶部间距、高度和底部间距。</p>
<p>例如，考虑如下日志：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;NSAutoresizingMaskLayoutConstraint:<span class="number">0x7ff28252e480</span> h=--&amp; v=--&amp; H:[UIView:<span class="number">0x7ff282617cc0</span>(<span class="number">50</span>)]&gt;<span class="string">"</span></div></pre></td></tr></table></figure>
<p>此信息由如下部分组成：</p>
<ul>
<li><em>NSAutoresizingMaskLayoutConstraint:0x7ff28252e480</em>：约束的类和地址。本例中，此类说明它基于视图的autoresizing mask。</li>
<li><em>h=–&amp; v=–&amp;</em>：视图的autoresizing mask。这是默认的mask。在水平方向上它包含一个确定的左间距、一个确定的宽度和一个可变的右间距。在竖直方向上它存在一个确定的顶部间距、一个确定的高度和一个可变的底部间距。换句话说，在父视图尺寸改变时，这个视图的左上角和尺寸保持不变。</li>
<li><em>H:[UIView:0x7ff282617cc0(50)]</em>：使用VFL描述的约束。在本例中，它描述了一个单独的50点宽度的视图。此描述还包含了约束涉及到的所有视图的类和地址。</li>
</ul>
<h4 id="给日志添加识别符号"><a href="#给日志添加识别符号" class="headerlink" title="给日志添加识别符号"></a>给日志添加识别符号</h4><p>虽然前一个例子相对容易理解，越来越长的约束列表很快就变得难以理解。你可以通过给每个视图和约束设置一个有意义的识别符来让日志容易阅读。</p>
<p>如果视图有一个明显的文字组件，Xcode就直接使用它来做识别符。例如，Xcode使用一个label的文字，一个button的标题，或者一个text field的占位字来识别这些视图。其他情况下，需要在识别检查器（Identity inspector）中设置指定的标签。Interface Builder在交互设置中使用这些识别符。大多数的这些识别符都会在控制台日志中显示。</p>
<p>对于约束来说，通过代码或者属性检查器（Attribute inspector）来设置<em>identifier</em>属性。当在控制台打印信息时，Auto Layout就会使用这些识别符。</p>
<p>举例来说，这是一个带有识别符版本的相同的错误约束：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">2015-08-26 14:29:32.870 Auto Layout Cookbook[10208:1918826] Unable to simultaneously satisfy constraints.</div><div class="line">    Probably at least one of the constraints in the following list is one you don't want. Try this: (1) look at each constraint and try to figure out which you don't expect; (2) find the code that added the unwanted constraint or constraints and fix it. (Note: If you're seeing NSAutoresizingMaskLayoutConstraints that you don't understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints) </div><div class="line">(</div><div class="line">    "&lt;NSLayoutConstraint:0x7b58bac0 'Label Leading' UILabel:0x7b58b040'Name'.leading == UIView:0x7b590790.leadingMargin&gt;",</div><div class="line">    "&lt;NSLayoutConstraint:0x7b56d020 'Label Width' H:[UILabel:0x7b58b040'Name'(&gt;=400)]&gt;",</div><div class="line">    "&lt;NSLayoutConstraint:0x7b58baf0 'Space Between Controls' H:[UILabel:0x7b58b040'Name']-(NSSpace(8))-[UITextField:0x7b589490]&gt;",</div><div class="line">    "&lt;NSLayoutConstraint:0x7b51cb10 'Text Field Trailing' UITextField:0x7b589490.trailing == UIView:0x7b590790.trailingMargin&gt;",</div><div class="line">    "&lt;NSLayoutConstraint:0x7b0758c0 'UIView-Encapsulated-Layout-Width' H:[UIView:0x7b590790(320)]&gt;"</div><div class="line">)</div><div class="line"> </div><div class="line">Will attempt to recover by breaking constraint</div><div class="line">&lt;NSLayoutConstraint:0x7b56d020 'Label Width' H:[UILabel:0x7b58b040'Name'(&gt;=400)]&gt;</div><div class="line"> </div><div class="line">Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.</div><div class="line">The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit/UIView.h&gt; may also be helpful.</div></pre></td></tr></table></figure>
<p>正如所见，这些识别符可以让你在日志中快速且容易地识别出约束。</p>
<h4 id="理解边界案例"><a href="#理解边界案例" class="headerlink" title="理解边界案例"></a>理解边界案例</h4><p>这里有一些可能导致Auto Layout出现不可预料情况的边界案例：</p>
<ul>
<li>Auto Layout是基于视图的对齐矩形来定位视图的，而不是frame。大多时候，二者是相等的。可是，在布局计算时，一些视图可能会设置了自定义的对齐矩形进而超出了视图本身（如badges）。<br>  了解更多信息，在<a href="https://developer.apple.com/documentation/uikit/uiview" target="_blank" rel="external">UIView类参考</a>中查看使用Auto Layout对齐视图的相关内容。</li>
<li>在iOS中，你可以使用视图的<a href="https://developer.apple.com/documentation/uikit/uiview/1622459-transform" target="_blank" rel="external">transform</a>属性来设置尺寸、旋转或移动视图；可是，这些变换根本不会影响Auto Layout的计算。Auto Layout是通过视图未变换时的frame来计算其对齐矩形的。</li>
<li>一个视图可以在其边界范围之外显示内容。大多时候，视图会正常显示并将其内容限制在边界之内。可是，有时出于性能考虑，这不会被图像引擎强制实现。这意味着该视图（特别是那些自定义绘制的视图）可能会以一个不同于本身frame的尺寸进行绘制。<br>  你可以将视图的<a href="https://developer.apple.com/documentation/uikit/uiview/1622415-clipstobounds" target="_blank" rel="external">clipsToBounds</a>属性置为YES来测试这个问题，或者通过视图的frame进行验证。</li>
<li>只有当所有视图以它们的真实内容尺寸高度显示时，<a href="https://developer.apple.com/documentation/appkit/nslayoutattribute/nslayoutattributebaseline" target="_blank" rel="external">NSLayoutAttributeBaseline</a>、<a href="https://developer.apple.com/documentation/appkit/nslayoutattribute/nslayoutattributefirstbaseline" target="_blank" rel="external">NSLayoutAttributeFirstBaseline</a>和<a href="https://developer.apple.com/documentation/appkit/nslayoutconstraint/attribute/lastbaseline" target="_blank" rel="external">NSLayoutAttributeLastBaseline</a>属性才会正确对齐文字。如果其中一个视图在竖直方向上被拉伸或压缩，其文字就可能出现在错误的位置上。</li>
<li>约束优先级会在整个视图层级中作为全局属性出现。你可能会经常使用stack view、layout guide或者虚拟视图将视图进行分组；可是，这种做法并不能将所需的视图优先级封装到内部。Auto Layout会继续将组内的优先级同外面的进行比较（甚至是其他组中的优先级）。</li>
<li>宽高比约束允许水平和竖直约束进行交互。一般来说，水平和竖直布局是单独计算的。可是，如果你使用一个视图的宽度来约束其高度时，你便创建了一个水平和竖直约束间的连接关系：他们现在会对其他约束产生影响甚至发生冲突。这种交互会明显增加布局的复杂度，并且可能会与一些不相干的布局产生某些不可预期的冲突。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文节选并翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/DebuggingTricksandTips.html#//apple_ref/doc/uid/TP40010853-CH21-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Debugging Tricks and Tips
&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下话题描述了在布局中总结提炼出的信息，同时描述了一些你可能遇到的意料之外的情况。你也许不会再每次布局中都会用到这些技术，但是它们可以在一些难题上给你提供帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
