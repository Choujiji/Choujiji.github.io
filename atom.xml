<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭吉吉的瞎记空间</title>
  <subtitle>技术的，瞎说的，啥都有吧。。。希望。。。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-07T05:45:22.080Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>臭吉吉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《大话数据结构》之线性表</title>
    <link href="http://yoursite.com/2019/03/06/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/03/06/《大话数据结构》之线性表/</id>
    <published>2019-03-06T10:55:37.657Z</published>
    <updated>2019-03-07T05:45:22.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-线性表的主要类型"><a href="#1-线性表的主要类型" class="headerlink" title="1. 线性表的主要类型"></a>1. 线性表的主要类型</h3><p>线性表在存储方式上划分，可分为：</p>
<ul>
<li><strong>顺序存储结构</strong>，如标准数组</li>
<li><strong>链式存储结构</strong>，如单链表</li>
</ul>
<a id="more"></a>
<h3 id="2-顺序存储结构"><a href="#2-顺序存储结构" class="headerlink" title="2. 顺序存储结构"></a>2. 顺序存储结构</h3><p>所谓顺序存储结构，即使用一段地址连续的存储单依次存储线性表的数据元素。</p>
<p>我们可以使用数组来描述线性表的顺序存储结构。</p>
<h4 id="2-1-地址计算方法（读取数据）"><a href="#2-1-地址计算方法（读取数据）" class="headerlink" title="2.1 地址计算方法（读取数据）"></a>2.1 地址计算方法（读取数据）</h4><p>通俗地讲，与数据下标访问的方式类似，后一个数据的地址是前一个地址加上数据大小。对于第i个数据的储存位置，即可使用以下方式得出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LOC(a(i + <span class="number">1</span>)) = LOC(a(i)) + (i - <span class="number">1</span>) * c</div></pre></td></tr></table></figure>
<p>由于任意地址的数据均可以由以上公式一步得出，故<strong>顺序存储结构的存储时间为O(1)，即时间复杂度为常数阶</strong>。</p>
<h4 id="2-2-插入数据"><a href="#2-2-插入数据" class="headerlink" title="2.2 插入数据"></a>2.2 插入数据</h4><p>主要步骤为：</p>
<ol>
<li>查找到要插入的位置i</li>
<li>将i之后的数据依次后移一个位置</li>
<li>在i的位置上插入数据e</li>
<li>表长加1</li>
</ol>
<p>总的执行次数为 1 + n + 1 + 1，故<strong>插入操作的时间复杂度为O(n)</strong>。</p>
<h4 id="2-3-删除数据"><a href="#2-3-删除数据" class="headerlink" title="2.3 删除数据"></a>2.3 删除数据</h4><p>主要步骤为：</p>
<ol>
<li>查找到要删除的位置i</li>
<li>在i的位置上取出数据e</li>
<li>将i之后的数据依次前移一个位置</li>
<li>表长减1</li>
</ol>
<p>总的执行次数为 1 + 1 + n + 1，故<strong>删除操作的时间复杂度为O(n)</strong>。</p>
<h4 id="2-4-顺序存储结构的优缺点"><a href="#2-4-顺序存储结构的优缺点" class="headerlink" title="2.4 顺序存储结构的优缺点"></a>2.4 顺序存储结构的优缺点</h4><p>优点：</p>
<ul>
<li>无需为数据元素之间的逻辑关系增加额外存储空间</li>
<li>可以快速读取任一位置的元素</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入和删除数据需要移动大量元素</li>
<li>当线性表长度变化较大时，难以确定存储空间的长度</li>
<li>造成存储空间的”碎片“</li>
</ul>
<h3 id="3-链式存储结构（以单链表为例）"><a href="#3-链式存储结构（以单链表为例）" class="headerlink" title="3. 链式存储结构（以单链表为例）"></a>3. 链式存储结构（以单链表为例）</h3><p>链式存储结构的特点，是使用一组任意的存储单元存储线性表的数据元素。这些存储单元可以是不连续的，任意位置均可。</p>
<p>链式存储结构中的数据结点（Node），除了包含自身数据（数据域），还需要存储一个后继结点的地址（指针域）。</p>
<p>当n个数据结点组成一个链表，其中每一个结点都只包含一个指针域时，这种链式结构称为<strong>单链表</strong>。</p>
<p>我们这里使用单链表来描述线性表的链式存储结构。</p>
<h4 id="3-1-单链表的基本描述"><a href="#3-1-单链表的基本描述" class="headerlink" title="3.1 单链表的基本描述"></a>3.1 单链表的基本描述</h4><ul>
<li><strong>头指针</strong>：指向单链表第一个结点存储位置（即第一个结点的地址）的指针。</li>
<li><strong>头结点</strong>：在第一个结点前设置的一个结点，其指针域为头指针地址。</li>
<li>线性表最后一个结点的指针域为NULL或^。</li>
</ul>
<h4 id="3-2-头指针与头结点的异同"><a href="#3-2-头指针与头结点的异同" class="headerlink" title="3.2 头指针与头结点的异同"></a>3.2 头指针与头结点的异同</h4><p>头指针：</p>
<ul>
<li>指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。</li>
<li>有标识作用，常用头指针冠以链表的名字。</li>
<li>无论链表是否为空，头指针均不为空。<strong>头指针是链表的必要元素</strong>。</li>
</ul>
<p>头结点：</p>
<ul>
<li>为了操作统一和方便而设置，放在第一个结点之前，其数据域一般无意义（可以存放链表长度）。</li>
<li>有了头结点，对在第一个结点前插入结点或删除第一结点，其操作与其他结点完成统一。</li>
<li><strong>头结点不一定是链表的必须要素</strong>。</li>
</ul>
<h4 id="3-3-单链表的读取"><a href="#3-3-单链表的读取" class="headerlink" title="3.3 单链表的读取"></a>3.3 单链表的读取</h4><p>由于每一个结点的存储位置都在前一个结点的指针域中保存，故获取指定位置的结点数据，需要从单链表的头结点开始，依次查找。故其<strong>查找的时间复杂度为O(n)</strong>。</p>
<p>查找方式，即循环”指针后移“。</p>
<h4 id="3-4-单链表的插入"><a href="#3-4-单链表的插入" class="headerlink" title="3.4 单链表的插入"></a>3.4 单链表的插入</h4><p>单链表的插入过程，如下图所示：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1551764374-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5.jpg" alt="单链表的插入"></p>
<p>其中，待插入的结点s（数据e），插入到结点p和p-&gt;next之间（数据a(i)和数据a(i+1)）之间。其关键操作为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将插入结点s的指针域指向原后结点p-&gt;next</span></div><div class="line">s-&gt;next = p-&gt;next;</div><div class="line"><span class="comment">// 原结点p的指针域指向插入结点s</span></div><div class="line">p-&gt;next = s;</div></pre></td></tr></table></figure>
<p>故此插入行为的复杂度为O(1)。</p>
<p>不过，由于查找插入位置结点的复杂度为O(n)，故最终<strong>单链表插入操作的时间复杂度为O(n)</strong>。</p>
<h4 id="3-5-单链表的删除"><a href="#3-5-单链表的删除" class="headerlink" title="3.5 单链表的删除"></a>3.5 单链表的删除</h4><p>单链表的删除过程，如下图所示：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1551764879-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4.jpg" alt="单链表的删除"></p>
<p>其中，a(i)为待删除元素，即p-&gt;next结点。删除后即将结点p的指针域指向a(i+1)元素的结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 待删除结点的前一个结点的指针域 指向 待删除结点的后一个结点</span></div><div class="line">p-&gt;next = p-&gt;next-&gt;next;</div><div class="line"></div><div class="line"><span class="comment">// 或</span></div><div class="line"></div><div class="line">q = p-&gt;next;</div><div class="line">p-&gt;next = q-&gt;next;</div><div class="line"></div><div class="line"><span class="comment">// 最后，释放删除结点的内存</span></div><div class="line"><span class="built_in">free</span>(q);</div></pre></td></tr></table></figure>
<p>故此删除行为的复杂度为O(1)。</p>
<p>不过，由于查找删除位置结点的复杂度为O(n)，故最终<strong>单链表删除操作的时间复杂度为O(n)</strong>。</p>
<h4 id="3-6-单链表的整表创建"><a href="#3-6-单链表的整表创建" class="headerlink" title="3.6 单链表的整表创建"></a>3.6 单链表的整表创建</h4><ul>
<li><strong>头插法</strong>：每次均从头指针插入新结点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建单链表L(空表)</span></div><div class="line">*L = (LinkList)<span class="built_in">malloc</span>(sizeOf(Node));</div><div class="line">(*L-&gt;next) = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">    <span class="comment">// L为单链表的头结点，p为待插入结点</span></div><div class="line">    p-&gt;next = (*L)-&gt;next;</div><div class="line">    (*L)-&gt;next = p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>尾插法</strong>：每次均插入到尾结点的后面。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建单链表L(空表)</span></div><div class="line">*L = (LinkList)<span class="built_in">malloc</span>(sizeOf(Node));</div><div class="line">(*L-&gt;next) = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="comment">// r为指向尾部的结点</span></div><div class="line">r = *L;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">    <span class="comment">// p为待插入结点，插入到尾结点后面</span></div><div class="line">    r-&gt;next = p;</div><div class="line">    <span class="comment">// 新加入结点作为新的尾结点</span></div><div class="line">    r = p;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 尾结点指针域赋值</span></div><div class="line">r-&gt;next = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure>
<h4 id="3-7-单链表的整表删除"><a href="#3-7-单链表的整表删除" class="headerlink" title="3.7 单链表的整表删除"></a>3.7 单链表的整表删除</h4><p>做法：依次边遍历边删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// L为待删除链表，p和q分别指向当前结点</span></div><div class="line"></div><div class="line"><span class="comment">// p指向第一个结点</span></div><div class="line">p = (*L)-&gt;next;</div><div class="line"></div><div class="line"><span class="keyword">while</span>(p) &#123;</div><div class="line">    <span class="comment">// q指向后继结点</span></div><div class="line">    q = p-&gt;next;</div><div class="line">    <span class="comment">// 删除当前结点</span></div><div class="line">    <span class="built_in">free</span>(p);</div><div class="line">    <span class="comment">// p指向后继结点</span></div><div class="line">    p = q;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 循环结束后，p结点已经不存在</span></div><div class="line"><span class="comment">// 置为空表，让头结点的头指针为空</span></div><div class="line">(*L)-&gt;next = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure>
<h4 id="3-8-单链表与顺序存储结构实用性对比"><a href="#3-8-单链表与顺序存储结构实用性对比" class="headerlink" title="3.8 单链表与顺序存储结构实用性对比"></a>3.8 单链表与顺序存储结构实用性对比</h4><ul>
<li>在频繁查找，且很少进行插入和删除操作时，可以考虑使用顺序存储结构。若频繁插入或删除，则考虑使用单链表。</li>
<li>在不确定线性表的元素个数时，可以考虑使用单链表，忽略存储空间的需求问题。</li>
</ul>
<h3 id="4-其他类型链表结构"><a href="#4-其他类型链表结构" class="headerlink" title="4. 其他类型链表结构"></a>4. 其他类型链表结构</h3><h4 id="4-1-静态链表"><a href="#4-1-静态链表" class="headerlink" title="4.1 静态链表"></a>4.1 静态链表</h4><p>静态链表是在没有指针的情况下实现的“模拟”单链表，本质上是使用数组进行描述并实现。</p>
<p>其结构如下所示：</p>
<p><img src="http://jiji-blog-image.oss-cn-beijing.aliyuncs.com/1551867514-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8.jpg" alt="静态链表"></p>
<p>其中，数组分为两部分结构：</p>
<ol>
<li>以数组的末尾元素为头结点，根据游标（cur）索引，直到元素的游标为0为止，连接而成的结构，也就是真正的<strong>单链表</strong>。</li>
<li>以数组第一个元素为头结点，根据游标索引，直到元素的游标为末尾元素的下标为止，作为<strong>备用链表</strong>，用于动态分配数据（插入、移除数据使用）。</li>
</ol>
<p>主要结构：</p>
<ul>
<li>数组的末尾元素：初始状态下，末尾元素的游标指向首元素，即为空表。当插入数据后，其游标永远指向链表第一个数据。</li>
<li>数组的首元素：初始状态下，其游标指向数组的下一个元素。当插入数据后，其游标总是指向备用链表的第一个数据。</li>
<li>数组的其他元素：默认情况下，当前元素的游标指向下一个元素。当插入数据后，数据的游标即保存的是下一个插入数据所在数组的下标。单链表最后一个数据的游标保存的是0，即数组首元素下标，标识单链表已结束。</li>
</ul>
<blockquote>
<p><strong>静态链表的优缺点</strong>：</p>
<p>优点：<br>避免了插入和删除数据时对大量数据的移动，只要修改游标即可实现。</p>
<p>缺点：</p>
<ul>
<li>由于使用数组进行实现，依然无法避免对内存空间进行考虑。</li>
<li>失去了顺序存储结构随机存取的特性。</li>
</ul>
<p>备注：</p>
<p>静态链表的创建、插入和删除等操作的Objective-C版本实现：<a href="https://github.com/Choujiji/PlayWithDataStructure-Code/tree/master/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8" target="_blank" rel="external">项目地址</a></p>
</blockquote>
<h4 id="4-2-循环链表"><a href="#4-2-循环链表" class="headerlink" title="4.2 循环链表"></a>4.2 循环链表</h4><p>循环链表作为单链表的扩展，在链表尾部定义了尾指针，指向最后一个结点rear。其指针域next指向链表的头结点。</p>
<p>同时，判定链表结束的条件变为了rear-&gt;next == 头指针p。</p>
<h4 id="4-3-双向链表"><a href="#4-3-双向链表" class="headerlink" title="4.3 双向链表"></a>4.3 双向链表</h4><p>双向链表作为单链表的扩展，在结点的头部和尾部均设有指针域（prior和next），分别指向前驱结点和后继结点。可以双向访问链表的元素。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-线性表的主要类型&quot;&gt;&lt;a href=&quot;#1-线性表的主要类型&quot; class=&quot;headerlink&quot; title=&quot;1. 线性表的主要类型&quot;&gt;&lt;/a&gt;1. 线性表的主要类型&lt;/h3&gt;&lt;p&gt;线性表在存储方式上划分，可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顺序存储结构&lt;/strong&gt;，如标准数组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链式存储结构&lt;/strong&gt;，如单链表&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之可视化语言（Visual Format Language）</title>
    <link href="http://yoursite.com/2019/03/05/Autolayout%E4%B9%8B%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AF%AD%E8%A8%80%EF%BC%88Visual%20Format%20Language%EF%BC%89/"/>
    <id>http://yoursite.com/2019/03/05/Autolayout之可视化语言（Visual Format Language）/</id>
    <published>2019-03-05T09:08:02.615Z</published>
    <updated>2019-03-05T09:08:32.238Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1" target="_blank" rel="external">Visual Format Language</a></p>
</blockquote>
<p>这篇附录阐述了如何使用Auto Layout可视化语言来设定普通约束，包括标准间距、尺寸、垂直布局和带有不同优先级的约束等。此外，本附录还包含了一个完整的语法说明。</p>
<a id="more"></a>
<h4 id="可视化句法"><a href="#可视化句法" class="headerlink" title="可视化句法"></a>可视化句法</h4><p>以下是一些通过可视化格式指定的约束示例。请注意其中文字是如何匹配示意图的。</p>
<ul>
<li>标准间距</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[button]-[textField]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/standardSpace.png" alt="img"></p>
<ul>
<li>宽度约束</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[button(&gt;=<span class="number">50</span>)]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/widthConstraint.png" alt="img"></p>
<ul>
<li>连接到父视图</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">|<span class="number">-50</span>-[purpleBox]<span class="number">-50</span>-|</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/connectionToSuperview.png" alt="img"></p>
<ul>
<li>垂直布局</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">V:[topField]<span class="number">-10</span>-[bottomField]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/verticalLayout.png" alt="img"></p>
<ul>
<li>对齐的视图</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[maroonView][blueView]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/flushViews.png" alt="img"></p>
<ul>
<li>优先级</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[button(<span class="number">100</span>@<span class="number">20</span>)] <span class="comment">// 这里优先级为20</span></div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/priority.png" alt="img"></p>
<ul>
<li>等宽</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[button1(==button2)]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/equalWidths.png" alt="img"></p>
<ul>
<li>多项描述</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[flexibleButton(&gt;=<span class="number">70</span>,&lt;=<span class="number">100</span>)]</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/multiplePredicates.png" alt="img"></p>
<ul>
<li>完整的一行布局</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">|-[find]-[findNext]-[findField(&gt;=<span class="number">20</span>)]-|</div></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/completeLayout.png" alt="img"></p>
<p>这种表示法通过完整的表达式提高了可读性。大多数的可用约束都可以通过可视化格式句法在用户界面中表示出来，但是还是有一些不可以。一种不能表示的约束即指定的宽高比（例如，<em>imageView.width = 2 </em> imageView.height*）。要创建这个约束，你必须使用<a href="https://developer.apple.com/documentation/appkit/nslayoutconstraint/1526954-init" target="_blank" rel="external">constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:</a>方法。</p>
<h4 id="可视化格式字符串语法"><a href="#可视化格式字符串语法" class="headerlink" title="可视化格式字符串语法"></a>可视化格式字符串语法</h4><p>可视化格式字符串语法的定义如下（字面量使用<em>代码字体</em>表示，<strong>e</strong>代表空字符串）。</p>
<blockquote>
<p>译者注：</p>
<ul>
<li>表中的“?”代表修饰项为可选的，</li>
<li>“*”代表前面的修饰项的个数是任意的</li>
<li>“替换规则”中的每一项“&lt;…&gt;”可当做变量在“符号”中查找替换</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>符号</th>
<th>替换规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;可视化格式字符串&gt;</td>
<td>(&lt;方向&gt;:)?(&lt;父视图&gt;&lt;连接&gt;)?&lt;视图&gt;(&lt;连接&gt;&lt;视图&gt;)*(&lt;连接&gt;&lt;父视图&gt;)?</td>
</tr>
<tr>
<td>&lt;方向&gt;</td>
<td><em>H</em> 或 <em>V</em></td>
</tr>
<tr>
<td>&lt;父视图&gt;</td>
<td>&#124;</td>
</tr>
<tr>
<td>&lt;视图&gt;</td>
<td><em>[</em> &lt;视图名&gt;(&lt;带括号的描述列表&gt;)? <em>]</em></td>
</tr>
<tr>
<td>&lt;连接&gt;</td>
<td><strong>e</strong> 或 <em>-</em>&lt;描述列表&gt;<em>-</em> 或 <em>-</em></td>
</tr>
<tr>
<td>&lt;描述列表&gt;</td>
<td>&lt;简单描述&gt; 或 &lt;带括号的描述列表&gt;</td>
</tr>
<tr>
<td>&lt;简单描述&gt;</td>
<td>&lt;度量名称&gt; 或 &lt;确定数字&gt;</td>
</tr>
<tr>
<td>&lt;带括号的描述列表&gt;</td>
<td><em>(</em> &lt;描述&gt;(,&lt;描述&gt;)<em> </em>)*</td>
</tr>
<tr>
<td>&lt;描述&gt;</td>
<td>(&lt;关系&gt;)?(&lt;描述的对象&gt;)(<em>@</em>&lt;优先级&gt;)?</td>
</tr>
<tr>
<td>&lt;关系&gt;</td>
<td><em>==</em> 或 <em>&lt;=</em> 或 <em>&gt;=</em></td>
</tr>
<tr>
<td>&lt;描述的对象&gt;</td>
<td>&lt;常量值&gt; 或 &lt;视图名称&gt; <em>（见说明）</em></td>
</tr>
<tr>
<td>&lt;优先级&gt;</td>
<td>&lt;度量名称&gt; 或 &lt;数字&gt;</td>
</tr>
<tr>
<td>&lt;常量值&gt;</td>
<td>&lt;度量名称&gt; 或 &lt;数字&gt;</td>
</tr>
<tr>
<td>&lt;视图名称&gt;</td>
<td>解析为C语言符号。此对象必须是传入的视图字典中，一个UIView实例对应的key值。</td>
</tr>
<tr>
<td>&lt;度量名称&gt;</td>
<td>解析为C语言符号。此对象必须是传入的度量字典中，一个NSNumber实例对应的key值。</td>
</tr>
<tr>
<td>&lt;数字&gt;</td>
<td>通过<em>strtod_l</em>解析（注：解析成浮点数），使用C语言格式</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>说明</strong></p>
<p>在<em>描述的对象</em>的生成方式中，只有当描述的对象是<em>视图</em>的宽或高时，<em>视图名称</em>才可以作为其中的一部分。也就是说，你可以使用 <em>[view1(==view2)]</em> 的方式来指定<em>view1</em>和<em>view2</em>拥有相同宽度。</p>
</blockquote>
<p>如果你产生了句法错误，系统会抛出异常并带有诊断信息。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Expected <span class="string">':'</span> after <span class="string">'V'</span> to specify vertical arrangement</div><div class="line">V|[backgroundBox]|</div><div class="line"> ^</div><div class="line"> </div><div class="line">A predicate on a view's thickness must end with <span class="string">')'</span> <span class="keyword">and</span> the view must end with <span class="string">']'</span></div><div class="line">|[whiteBox1][blackBox4(blackWidth][redBox]|</div><div class="line">                                 ^</div><div class="line"> </div><div class="line">Unable to find view with name blackBox</div><div class="line">|[whiteBox2][blackBox]</div><div class="line">                     ^</div><div class="line"> </div><div class="line">Unknown relation. Must be ==, &gt;=, <span class="keyword">or</span> &lt;=</div><div class="line">V:|[blackBox4(&gt;<span class="number">30</span>)]|</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Visual Format Language&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇附录阐述了如何使用Auto Layout可视化语言来设定普通约束，包括标准间距、尺寸、垂直布局和带有不同优先级的约束等。此外，本附录还包含了一个完整的语法说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》之算法的时间复杂度</title>
    <link href="http://yoursite.com/2019/03/05/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E4%B9%8B%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://yoursite.com/2019/03/05/《大话数据结构》之算法的时间复杂度/</id>
    <published>2019-03-05T07:23:16.914Z</published>
    <updated>2019-03-05T07:23:38.227Z</updated>
    
    <content type="html"><![CDATA[<p>算法的时间复杂度一般是指算法的最坏执行情况（最大执行次数）。</p>
<h4 id="1-大O表示法"><a href="#1-大O表示法" class="headerlink" title="1. 大O表示法"></a>1. 大O表示法</h4><p>衡量算法的复杂度（一般指时间复杂度）通常使用大O表示法，其推导的一般方式为：</p>
<ol>
<li>用常数1取代运行时间中的所有加法常数。</li>
<li>在修改后的运行次数函数中，只保留最高阶项。</li>
<li>如果最高阶项存在且不是1，则去除与这个项乘积的常数。</li>
</ol>
<p>最终得到的结果就是大O阶。</p>
<a id="more"></a>
<h4 id="2-常用的大O阶"><a href="#2-常用的大O阶" class="headerlink" title="2. 常用的大O阶"></a>2. 常用的大O阶</h4><ul>
<li>常数阶<br>  O(1)：如顺序结构的复杂度或是分支结构（if–else–），执行次数恒定，不会随n变化而变化。</li>
<li>线性阶<br>  O(n)：如循环结构，根据循环次数决定。</li>
<li>对数阶<br>  O(logn): 例如如下循环</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span>(count &lt; n) &#123;</div><div class="line">    count = count * <span class="number">2</span>;</div><div class="line">    <span class="comment">/** 时间复杂度为O(1)的顺序步骤序列 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>如上所示，x为执行次数，2^x = n，即x = log2n，故时间复杂度为O(logn)。
</code></pre><ul>
<li>平方阶<br>  O(n^2)：如双重嵌套循环。</li>
</ul>
<h4 id="3-常见的时间复杂度排列"><a href="#3-常见的时间复杂度排列" class="headerlink" title="3. 常见的时间复杂度排列"></a>3. 常见的时间复杂度排列</h4><p>耗费时间从小到大依次为：</p>
<blockquote>
<p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法的时间复杂度一般是指算法的最坏执行情况（最大执行次数）。&lt;/p&gt;
&lt;h4 id=&quot;1-大O表示法&quot;&gt;&lt;a href=&quot;#1-大O表示法&quot; class=&quot;headerlink&quot; title=&quot;1. 大O表示法&quot;&gt;&lt;/a&gt;1. 大O表示法&lt;/h4&gt;&lt;p&gt;衡量算法的复杂度（一般指时间复杂度）通常使用大O表示法，其推导的一般方式为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用常数1取代运行时间中的所有加法常数。&lt;/li&gt;
&lt;li&gt;在修改后的运行次数函数中，只保留最高阶项。&lt;/li&gt;
&lt;li&gt;如果最高阶项存在且不是1，则去除与这个项乘积的常数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终得到的结果就是大O阶。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之修改约束</title>
    <link href="http://yoursite.com/2019/03/04/%20Autolayout%E4%B9%8B%E4%BF%AE%E6%94%B9%E7%BA%A6%E6%9D%9F/"/>
    <id>http://yoursite.com/2019/03/04/ Autolayout之修改约束/</id>
    <published>2019-03-04T08:55:42.105Z</published>
    <updated>2019-03-04T08:55:42.105Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW1" target="_blank" rel="external">Changing Constraints</a></p>
</blockquote>
<p>对一个约束进行所有的改变实质上就是修改该约束的数学表达式（见图17-1）。你可以在<a href="">Anatomy of a Constraint</a>中查看更多关于约束方程的信息。</p>
<a id="more"></a>
<p><strong>图17-1</strong> 约束方程式</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/view_formula_2x.png" alt="img"></p>
<p>下列所有行为都会改变一个或多个约束：</p>
<ul>
<li>激活或失效约束</li>
<li>修改约束的常数值（constant value）</li>
<li>修改约束的优先级</li>
<li>从视图层级中移除视图</li>
</ul>
<p>其他改变，如设置控件的属性，或是修改视图层级，都可以改变约束。当改变发生时，系统会预设置出一个延迟布局阶段（查看<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW3" target="_blank" rel="external">The Deferred Layout Pass</a>）。</p>
<p>一般来说，你可以在任意时刻设置这些修改。理想情况下，大多数约束都会在Interface Builder中设置，或者是在ViewController的初始化配置时（如<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621495-viewdidload" target="_blank" rel="external">viewDidLoad</a>）通过代码创建。如果你需要在运行时动态修改约束，通常最好的方式就是在应用程序状态变化时进行修改。例如，如果你想修改一个约束来响应按钮的点击操作，那就直接在该按钮的动作方法中进行修改。</p>
<p>有时候，为了优化性能，你可能需要分阶段进行一系列的修改。要了解更多信息，请查看<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW2" target="_blank" rel="external">Batching Changes</a>。</p>
<h4 id="延迟布局阶段（The-Deferred-Layout-Pass）"><a href="#延迟布局阶段（The-Deferred-Layout-Pass）" class="headerlink" title="延迟布局阶段（The Deferred Layout Pass）"></a>延迟布局阶段（The Deferred Layout Pass）</h4><p>为了避免直接更新受影响视图的frame，Auto Layout设置了一个稍后执行的布局阶段。此延迟阶段首先更新布局的约束，之后为视图层级中的所有视图计算frame。</p>
<p>你可以通过调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout" target="_blank" rel="external">setNeedsLayout</a>或<a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="external">setNeedsUpdateConstraints</a>方法设置自己的延迟布局阶段。</p>
<p>视图层级中的延迟布局阶段通常由两个阶段组成：</p>
<ol>
<li>如果需要，在更新阶段（Update Pass）更新约束</li>
<li>如果需要，在布局阶段（Layout Pass）重设视图的frame</li>
</ol>
<h5 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h5><p>系统会遍历视图层级，并在所有的ViewController上调用<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621379-updateviewconstraints" target="_blank" rel="external">updateViewConstraints</a>方法、在所有视图上调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="external">updateConstraints</a>方法。你可以覆盖这些方法来优化约束的修改（查看<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW2" target="_blank" rel="external">Batching Changes</a>）。</p>
<h5 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h5><p>系统再一次遍历视图层级，并在所有ViewController上调用<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews" target="_blank" rel="external">viewWillLayoutSubviews</a>、在所有视图上调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="external">layoutSubViews</a>。默认来说，<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="external">layoutSubViews</a>方法会使用Auto Layout引擎算出的矩形来更新每个子视图的frame。你可以覆盖这些方法来修改布局（查看<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW4" target="_blank" rel="external">Custom Layouts</a>）。</p>
<h4 id="分阶段修改（Batching-Changes）"><a href="#分阶段修改（Batching-Changes）" class="headerlink" title="分阶段修改（Batching Changes）"></a>分阶段修改（Batching Changes）</h4><p>在有影响的修改发生后，直接更新约束应该总是最简洁、最方便的方式。将这些修改延迟到之后的方法中执行，会使代码更加复杂并难以理解。</p>
<p>可是，总有一些时候你想要为了优化性能而进行分阶段的修改。如当修改约束的地方执行太慢，或是视图正在进行许多冗余修改时，使用这种方式便可以解决。</p>
<p>要对改变进行分阶段执行，不要直接进行修改，而是在包含该约束的视图上调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="external">setNeedsUpdateConstraints</a>方法。之后，覆盖视图的<a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="external">updateConstraints</a>方法来修改受影响的约束。</p>
<blockquote>
<p><strong>说明</strong></p>
<p>你的<a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="external">updateConstraints</a>的实现必须尽可能高效。不要让所有的约束失效（deactivate），可以根据需要失效其中一部分。此外，你的app必须存在某些方式来追踪约束，并且可以在每一个更新阶段来验证它们。只改变那些需要改变的项目。在每一次更新阶段中，你必须确保为app的当前状态提供了适合的约束。</p>
</blockquote>
<p>在<a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="external">updateConstraints</a>方法实现中，最后一步一定要调用父类的实现。</p>
<p>不要在你的<a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="external">updateConstraints</a>方法中调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="external">setNeedsUpdateConstraints</a>方法。调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="external">setNeedsUpdateConstraints</a>会设置另一个更新阶段，进而生成了调用循环。</p>
<h4 id="自定义布局（Custom-Layouts）"><a href="#自定义布局（Custom-Layouts）" class="headerlink" title="自定义布局（Custom Layouts）"></a>自定义布局（Custom Layouts）</h4><p>覆盖<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews" target="_blank" rel="external">viewWillLayoutSubViews</a>或<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="external">layoutSubViews</a>方法来修改layout引擎返回的结果。</p>
<blockquote>
<p><strong>重点</strong></p>
<p>如果可能，使用约束来定义所有的布局。这可以使布局结果更加健壮且更易调试。当你需要创建一个布局，且此布局仅仅通过约束无法达到要求时，你只能通过覆盖<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews" target="_blank" rel="external">viewWillLayoutSubViews</a>或<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="external">layoutSubViews</a>方法进行处理。</p>
</blockquote>
<p>在覆盖这些方法时，布局正处在一个不确定的状态。一部分视图可能已经布局完，另一部分则没有。在修改视图层级时，你需要非常小心，否则很可能就会导致调用循环。如下规则可以帮助你避免调用循环：</p>
<ul>
<li>你必须在方法的某处调用父类的实现。</li>
<li>你可以安全地在子树中让视图布局无效化；可是，你必须在调用父类的实现之前做这件事。</li>
<li>不要让在子树外的任何视图布局无效化。这会导致调用循环。</li>
<li>不要调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="external">setNeedsUpdateConstraints</a>。你刚刚完成了一次更新阶段。调用此方法会产生一个调用循环。</li>
<li>不要调用<a href="https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout" target="_blank" rel="external">setNeedsLayout</a>。调用此方法会产生一个调用循环。</li>
<li>修改约束时要格外小心。你不能意外地让子树外的视图布局无效化。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Changing Constraints&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对一个约束进行所有的改变实质上就是修改该约束的数学表达式（见图17-1）。你可以在&lt;a href=&quot;&quot;&gt;Anatomy of a Constraint&lt;/a&gt;中查看更多关于约束方程的信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之自定义TableViewCell的尺寸</title>
    <link href="http://yoursite.com/2019/03/04/Autolayout%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89TableViewCell%E7%9A%84%E5%B0%BA%E5%AF%B8/"/>
    <id>http://yoursite.com/2019/03/04/Autolayout之自定义TableViewCell的尺寸/</id>
    <published>2019-03-04T03:52:42.581Z</published>
    <updated>2019-03-04T03:53:14.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithSelf-SizingTableViewCells.html#//apple_ref/doc/uid/TP40010853-CH25-SW1" target="_blank" rel="external">Working with Self-Sizing Table View Cells</a></p>
</blockquote>
<p>在iOS中，你可以使用Auto Layout定义TableViewCell的高度；但是，此特性默认没有开启。</p>
<a id="more"></a>
<p>一般来说，cell的高度是由tableView代理对象的<a href="https://developer.apple.com/documentation/uikit/uitableviewdelegate/1614998-tableview" target="_blank" rel="external">tableView:heightForRowAtIndexPath:</a>方法来决定的。要实现自定义尺寸的TableViewCell，你必须将tableView的<a href="https://developer.apple.com/documentation/uikit/uitableview/1614852-rowheight" target="_blank" rel="external">rowHeight</a>属性设置为<a href="https://developer.apple.com/documentation/uikit/uitableviewautomaticdimension" target="_blank" rel="external">UITableViewAutomaticDimension</a>。你还需要给<a href="https://developer.apple.com/documentation/uikit/uitableview/1614925-estimatedrowheight" target="_blank" rel="external">estimatedRowHeight</a>属性赋一个值。一旦这两个属性都被设置后，系统就会使用Auto Layout来计算每一行的实际高度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tableView.estimatedRowHeight = <span class="number">85.0</span></div><div class="line">tableView.rowHeight = UITableViewAutomaticDimension</div></pre></td></tr></table></figure>
<p>下一步，在TableViewCell的ContentView中布局相关内容。要定义cell的高度，你需要从ContentView的顶部到底部边界设置一个完整的约束和视图链来填满整个区域。如果你的视图中存在真实内容尺寸高度，系统便会使用这些值。如果没有，你就必须添加相应的高度约束，要么设置到视图上，要么就直接设置到ContentView自身。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Chain_of_Views_and_Constraints_2x.png" alt="img"></p>
<p>此外，尽可能让估算的行高精确一些。系统计算的项目，比如滑动条的高度，是基于这个估算值的。估算值越精确，用户体验就会越连贯。</p>
<blockquote>
<p><strong>说明</strong></p>
<p>当使用TableViewCell时，你不能改变预定义内容的布局（如<a href="https://developer.apple.com/documentation/uikit/uitableviewcell/1623210-textlabel" target="_blank" rel="external">textLabel</a>、<a href="https://developer.apple.com/documentation/uikit/uitableviewcell/1623273-detailtextlabel" target="_blank" rel="external">detailTextLabel</a>和<a href="https://developer.apple.com/documentation/uikit/uitableviewcell/1623270-imageview" target="_blank" rel="external">imageView</a>属性）。</p>
<p>可支持如下约束：</p>
<ul>
<li>相对于cell的ContentView来定位子视图的约束。</li>
<li>相对于cell的bounds来定位子视图的约束。</li>
<li>相对于预定义内容来定位子视图的约束。</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithSelf-SizingTableViewCells.html#//apple_ref/doc/uid/TP40010853-CH25-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Working with Self-Sizing Table View Cells&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在iOS中，你可以使用Auto Layout定义TableViewCell的高度；但是，此特性默认没有开启。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之使用Scroll View</title>
    <link href="http://yoursite.com/2019/03/03/Autolayout%E4%B9%8B%E4%BD%BF%E7%94%A8Scroll%20View/"/>
    <id>http://yoursite.com/2019/03/03/Autolayout之使用Scroll View/</id>
    <published>2019-03-03T04:19:33.192Z</published>
    <updated>2019-03-03T04:19:59.696Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithScrollViews.html#//apple_ref/doc/uid/TP40010853-CH24-SW1" target="_blank" rel="external">Working with Scroll Views</a></p>
</blockquote>
<p>当使用ScrollView时，你需要在父视图内同时定义ScrollView的尺寸和位置，额外还有ScrollView的内容区域。所有的这些特性都可以通过Auto Layout进行设置。</p>
<a id="more"></a>
<p>为了支持ScrollView，系统会基于约束所处的位置，使用不同的方式来诠释约束。</p>
<ul>
<li>就像其他视图一样，在ScrollView和其外部对象之间的约束都会影响ScrollView的frame。</li>
<li>对于ScrollView和其自身内容之间的约束，其行为就会因属性的约束方式而有所不同：<ul>
<li>ScrollView的边界分隔和其自身内容之间的约束会影响ScrollView的内容区域。</li>
<li>高度、宽度或是中心点三者之间的约束会影响ScrollView的frame。</li>
</ul>
</li>
<li>你还可以在ScrollView自身内容和ScrollView外部对象之间设置约束来为ScrollView的内容生成一个可变的位置，以便这些内容看起来就像漂浮在ScrollView上面一样。</li>
</ul>
<p>对于大多数通常的布局来说，如果你对ScrollView的内容使用虚拟视图或是组合的方式进行布局，逻辑将会变得非常简单。当使用Interface Builder时，通常的做法如下所示：</p>
<ol>
<li>在场景中添加ScrollView</li>
<li>像平常一样，设置约束来定义ScrollView的尺寸和位置。</li>
<li>添加一个视图到ScrollView上。设置该视图的Xcode指定标签到ScrollView的内容视图（即ContentView，以下直接使用）上。</li>
<li>设置ContentView的顶部、底部、头部和尾部边界到ScrollView的对应边界上。ContentView现在决定了ScrollView的内容区域。<blockquote>
<p>重点：</p>
<p>此时ContentView还没有一个确定的尺寸。它可以拉伸或压缩来适配任何你放入的视图或控件。</p>
</blockquote>
</li>
<li>（可选）要禁止水平滑动，将ContentView的宽度设置为与ScrollView宽度相同。ContentView现在在水平方向上充满了ScrollView。</li>
<li>（可选）要禁止垂直滑动，将ContentView的高度设置为与ScrollView高度相同。ContentView现在在竖直方向上充满了ScrollView。</li>
<li>将ScrollView的内容布局到ContentView内部。像往常一样，在ContentView内部使用约束来设置内容的位置。<blockquote>
<p>重点：</p>
<p>你的布局必须完整定义了ContentView的尺寸（除了步骤5和6定义的位置）。要设置基于真实内容尺寸视图的ContentView的高度，你必须从ContentView的顶部到底部设置一个未被打破（broken）的约束和视图链。相似的，要设置该ContentView的宽度，你就必须从ContentView的头部到尾部设置一个未被打破（broken）的约束和视图链。</p>
<p>如果你的内容控件没有真实内容尺寸，你就必须添加合适的尺寸约束，或者是设置ContentView的，或者就设置内容的。</p>
<p>当ContentView比ScrollView高时，ScrollView在竖直方向上便可以滑动了。当ContentView比ScrollView宽时，ScrollView在水平方向上就可以滑动了。否则，默认来说ScrollView的滑动是被禁止的。</p>
</blockquote>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithScrollViews.html#//apple_ref/doc/uid/TP40010853-CH24-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Working with Scroll Views&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当使用ScrollView时，你需要在父视图内同时定义ScrollView的尺寸和位置，额外还有ScrollView的内容区域。所有的这些特性都可以通过Auto Layout进行设置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之指定类型尺寸的布局（Size Class）</title>
    <link href="http://yoursite.com/2019/03/01/Autolayout%E4%B9%8B%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E5%B0%BA%E5%AF%B8%E7%9A%84%E5%B8%83%E5%B1%80%EF%BC%88Size%20Class%EF%BC%89/"/>
    <id>http://yoursite.com/2019/03/01/Autolayout之指定类型尺寸的布局（Size Class）/</id>
    <published>2019-03-01T07:35:41.941Z</published>
    <updated>2019-03-01T07:45:11.646Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Size-ClassSpecificLayout.html#//apple_ref/doc/uid/TP40010853-CH26-SW1" target="_blank" rel="external">Size-Class-Specific Layout
</a></p>
</blockquote>
<p>Interface Builder中的Storyboard默认使用了尺寸类型（以下写作Size Class）。所有的Size Class都会被赋值给UI元素，如场景和视图等。他们给元素的尺寸提供了一个粗略定义。Interface Builder可以让你基于当前Size Class自定义许多布局特性。布局便可以自动适应Size Class的改变。特别的是，你可以在每一个Size Class下设置如下特性：</p>
<a id="more"></a>
<ul>
<li>加载（install）或卸载（uninstall）一个视图或控件。</li>
<li>安装或卸载一个约束。</li>
<li>设置选中的属性值（如字体或布局边距设置）。</li>
</ul>
<p>当系统读取了一个场景对象（scene），它便初始化了所有的视图、控件和约束，并且把这些对象赋值给相应的插口（outlet）上（如果存在）。你可以通过outlet访问任意对象而不必考虑场景当前的Size Class。可是，这些对象只有在当前Size Class中设为为“已加载”（installed）的情况下，系统才会将它们添加到视图层级当中。</p>
<p>当视图的Size Class改变时（如当你旋转iPhone或在iPad上切换全屏和分隔屏模式时），系统会自动将所需的对象从视图层级上添加或移除。系统还会将视图布局的改变动态的表现出来。</p>
<blockquote>
<p><strong>说明</strong></p>
<p>系统会保持着“已卸载”（uninstalled）对象的关联关系，因此从视图层级中移除后，这些对象不会被释放。</p>
</blockquote>
<h4 id="“最终Size-Class”和“基础Size-Class”"><a href="#“最终Size-Class”和“基础Size-Class”" class="headerlink" title="“最终Size Class”和“基础Size Class”"></a>“最终Size Class”和“基础Size Class”</h4><p>Interface Builder区分了九中不同的Size Class。</p>
<p>其中的四种是“最终Size Class”：<em>Compact-Compact</em>、<em>Compact-Regular</em>、<em>Regular-Compact</em>和<em>Regular-Regular</em>。这些“最终”类型代表了设备显示的实际尺寸。</p>
<p>剩下的五种是“基础Size Class”：<em>Compact-Any</em>、<em>Regular-Any</em>、<em>Any-Compact</em>、<em>Any-Regular</em>和<em>Any-Any</em>。抽象的尺寸类型，他们代表了能同时代表两种或更多种类的“最终Size Class”。例如，在<em>Compact-Any</em>的Size Class中，“已安装”的对象会同时出现在<em>Compact-Compact</em>和<em>Compact-Regular</em>尺寸的视图中。</p>
<p>指定Size Class中的设置项总是会覆盖掉通用Size Class中的内容。此外，你必须为九种Size Class提供出无歧义并满足条件的布局。因此，从通用的Size Class到指定的Size Class进行设置是非常容易的。为你的app选择好默认布局，并在<em>Any-Any</em>的Size Class中设置好布局。之后只要根据需要修改其他的”基础“或”最终“Size Class即可。</p>
<h4 id="使用Size-Class工具"><a href="#使用Size-Class工具" class="headerlink" title="使用Size Class工具"></a>使用Size Class工具</h4><blockquote>
<p>（注意：本节对应Xcode8）</p>
</blockquote>
<p>使用Interface Builder中的Size Class工具，选择你当前编辑中的Size Class。此工具显示在编辑窗口的底部中心位置。默认来说，Interface Builder会将<em>Any-Any</em>作为初始选项。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Size_Class_Tool_2x.png" alt="img"></p>
<p>要切换至一个新的Size Class，点击Size Class工具。Interface Builder会弹出一个3 x 3的网格视图。从网格中拖动鼠标来切换Size Class。网格会在顶部显示所选Size Class的名称并在底部显示出描述信息（包含它影响的设备和朝向等）。它还会在被当前Size Class的设置所影响的每一个Size Class中显示出一个绿点。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Selecting_A__Size_Class_2x.png" alt="img"></p>
<p>添加到画布中的所有视图和约束都只会在当前Size Class中被加载。当在移除这些对象时，其删除行为会根据原先加载的位置和方式有所不同。</p>
<ul>
<li>在画布中或是在整个项目的目录列表中删除一个对象，则会直接删除它。</li>
<li>在画布中或是在文档缩略图中，使用<em>Command-Delete</em>删除一个对象，系统只会从当前Size Class中卸载它。</li>
<li>当一个场景对象包含多个Size Class时，除了在画布或目录列表以外，在任何地方删除对象（如，从尺寸检查器中选择并删除约束），只会将其从当前Size Class中卸载掉。</li>
<li>如果你只编辑了<em>Any-Any</em>的Size Class，那么删除一个对象就是从项目中直接移除了。</li>
</ul>
<p>如果你编辑的是除了<em>Any-Any</em>以外的其他Size Class，Interface Builder会将编辑窗口底部的工具栏高亮显示为蓝色。这会使你在指定Size Class下工作时区别更加明显。</p>
<h4 id="使用检查器"><a href="#使用检查器" class="headerlink" title="使用检查器"></a>使用检查器</h4><p>你还可以在检查器中修改指定Size Class的设置。所有支持指定Size Class的设置项都会在检查器中显示为一个带有”＋“号的选项。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Size-Class_Specific_Attributes_2x.png" alt="img"></p>
<p>默认来说，检查器中的值都是在<em>Any-Any</em>的Size Class下设置的。要为指定的Size Class设置不同的值，点击”+“号来新建一个Size Class。同时为这个Size Class选择宽度和高度。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Adding_Size_Class_2x.png" alt="img"></p>
<p>检查器现在用单独的一行显示了每一个Size Class—-<em>Any-Any</em>设置在最顶端，其他的Size Class在下面列出。你可以单独编辑每一行的值。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Setting_Size-Class_Specific_Values_2x.png" alt="img"></p>
<p>要删除一个自定义Size Class，直接单击每行开头的”x“号即可。</p>
<p>要了解关于在Interface Builder中使用Size Class的更多信息，请查看Size Class设计帮助。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Size-ClassSpecificLayout.html#//apple_ref/doc/uid/TP40010853-CH26-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Size-Class-Specific Layout
&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Interface Builder中的Storyboard默认使用了尺寸类型（以下写作Size Class）。所有的Size Class都会被赋值给UI元素，如场景和视图等。他们给元素的尺寸提供了一个粗略定义。Interface Builder可以让你基于当前Size Class自定义许多布局特性。布局便可以自动适应Size Class的改变。特别的是，你可以在每一个Size Class下设置如下特性：&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>对数组按需分组</title>
    <link href="http://yoursite.com/2019/03/01/%E5%AF%B9%E6%95%B0%E7%BB%84%E6%8C%89%E9%9C%80%E5%88%86%E7%BB%84/"/>
    <id>http://yoursite.com/2019/03/01/对数组按需分组/</id>
    <published>2019-03-01T03:22:57.720Z</published>
    <updated>2019-03-01T03:23:24.037Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p>
<a id="more"></a>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">输入: [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]</div><div class="line"></div><div class="line">输出: <span class="number">4</span></div><div class="line">解释: n 等于 <span class="number">2</span>, 最大总和为 <span class="number">4</span> = min(<span class="number">1</span>, <span class="number">2</span>) + min(<span class="number">3</span>, <span class="number">4</span>)。</div></pre></td></tr></table></figure>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>对于示例数组，所有的分组情况为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.</span></div><div class="line">[<span class="number">1</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>] <span class="comment">// 结果为 1 + 2 = 3</span></div><div class="line"><span class="comment">// 2.</span></div><div class="line">[<span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>] <span class="comment">// 结果为 1 + 2 = 3</span></div><div class="line"><span class="comment">// 3.</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>] <span class="comment">// 结果为 1 + 3 = 4</span></div></pre></td></tr></table></figure>
<p>然而，当数据过多时，无法直接列举出所有情况。<br>因此，我们首先可以考虑将数据进行排序。并且，我们知道，min函数的功能即获取较小的数，忽略较大的数。根据以上列举情况可以也看出，最大和的分组方式即为从小到大依次分组。故可以得出结论：</p>
<ol>
<li>升序排列数组，得到有序数据。</li>
<li>依次间隔获取数据并求和。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSInteger <span class="title">getMaxSumWithSeparatingArray</span><span class="params">(NSArray &lt;NSNumber *&gt;* info)</span> </span>&#123;</div><div class="line">    <span class="comment">// 1. 升序排列</span></div><div class="line">    NSArray *sortedInfo = [info sortedArrayUsingComparator:^NSComparisonResult(NSNumber *obj1, NSNumber *obj2) &#123;</div><div class="line">        <span class="keyword">return</span> [obj1 compare:obj2];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="comment">// 2. 依次对奇数项求和</span></div><div class="line">    NSInteger sum = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    NSInteger index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (index &lt; sortedInfo.count) &#123;</div><div class="line">        sum += [sortedInfo[index] integerValue];</div><div class="line">        index += <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法学习" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>如何排列硬币？</title>
    <link href="http://yoursite.com/2019/02/25/%E5%A6%82%E4%BD%95%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/02/25/如何排列硬币？/</id>
    <published>2019-02-25T06:25:24.535Z</published>
    <updated>2019-02-25T06:25:24.536Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。给定一个数字 n，找出可形成完整阶梯行的总行数。n 是一个非负整数，并且在32位有符号整型的范围。</p>
<a id="more"></a>
<ul>
<li>示例1：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">n = <span class="number">5</span></div><div class="line"></div><div class="line">硬币可排列成以下几行:</div><div class="line">¤</div><div class="line">¤ ¤</div><div class="line">¤ ¤</div><div class="line"></div><div class="line">因为第三行不完整，所以返回<span class="number">2.</span></div></pre></td></tr></table></figure>
<ul>
<li>示例2：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">n = <span class="number">8</span></div><div class="line"></div><div class="line">硬币可排列成以下几行:</div><div class="line">¤</div><div class="line">¤ ¤</div><div class="line">¤ ¤ ¤</div><div class="line">¤ ¤</div><div class="line"></div><div class="line">因为第四行不完整，所以返回<span class="number">3.</span></div></pre></td></tr></table></figure>
<h4 id="解法1：直接排列"><a href="#解法1：直接排列" class="headerlink" title="解法1：直接排列"></a>解法1：直接排列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSInteger <span class="title">maxRowCountWithCoins1</span><span class="params">(NSInteger coins)</span> </span>&#123;</div><div class="line">    NSInteger leftCoins = coins;</div><div class="line">    NSInteger rowCount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (leftCoins &gt;= rowCount) &#123;</div><div class="line">        rowCount += <span class="number">1</span>;</div><div class="line">        <span class="comment">// 按行数减去相应值</span></div><div class="line">        leftCoins -= rowCount;</div><div class="line">        <span class="keyword">if</span> (leftCoins &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 不够数，减1</span></div><div class="line">            rowCount -= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> rowCount;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="解法2：数学公式"><a href="#解法2：数学公式" class="headerlink" title="解法2：数学公式"></a>解法2：数学公式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">NSInteger <span class="title">maxRowCountWithCoins2</span><span class="params">(NSInteger coins)</span> </span>&#123;</div><div class="line">    <span class="comment">// 公式法，由于是等差数列（1，2，3...n，和为coins），使用等差数列求和公式，算出最小的整数n，即为行数</span></div><div class="line">    <span class="comment">// 1. 等差数列求和公式为：((A1 + An) * n) / 2 = Sn，带入公式，得</span></div><div class="line">    <span class="comment">//      ((1 + n) * n) / 2 = coins</span></div><div class="line">    <span class="comment">//      变形得  n^2 + n - 2 * coins = 0，可知此为一元二次方程</span></div><div class="line">    <span class="comment">// 2. 根据一元二次方程的求根公式，x = (-b +- sqrt(b^2 - 4ac)) / 2a，带入公式，得</span></div><div class="line">    <span class="comment">//      n = (-1 +- sqrt(1 + 8 * coins)) / 2</span></div><div class="line">    <span class="comment">//      变形，得 n = sqrt(0.25 + 2 * coins) - 0.5</span></div><div class="line">    <span class="comment">// 3. 故只要求出最小的正整数n即可</span></div><div class="line">    <span class="keyword">return</span> (NSInteger)(<span class="built_in">sqrt</span>(<span class="number">0.25</span> + <span class="number">2</span> * coins) - <span class="number">0.5</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。给定一个数字 n，找出可形成完整阶梯行的总行数。n 是一个非负整数，并且在32位有符号整型的范围。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法学习" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之调试技巧和提示</title>
    <link href="http://yoursite.com/2019/02/24/Autolayout%E4%B9%8B%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E5%92%8C%E6%8F%90%E7%A4%BA/"/>
    <id>http://yoursite.com/2019/02/24/Autolayout之调试技巧和提示/</id>
    <published>2019-02-24T05:23:50.351Z</published>
    <updated>2019-02-24T05:24:02.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文节选并翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/DebuggingTricksandTips.html#//apple_ref/doc/uid/TP40010853-CH21-SW1" target="_blank" rel="external">Debugging Tricks and Tips
</a></p>
</blockquote>
<p>以下话题描述了在布局中总结提炼出的信息，同时描述了一些你可能遇到的意料之外的情况。你也许不会再每次布局中都会用到这些技术，但是它们可以在一些难题上给你提供帮助。</p>
<a id="more"></a>
<h4 id="理解日志"><a href="#理解日志" class="headerlink" title="理解日志"></a>理解日志</h4><p>视图的信息可以在控制台中输出，也许是因为存在了不满足条件的布局，或是因为你明确使用了<a href="https://developer.apple.com/documentation/uikit/uiview/1622432-constraintsaffectinglayoutforaxi" target="_blank" rel="external">constraintsAffectingLayoutForAxis:</a>或<a href="https://developer.apple.com/documentation/appkit/nsview/1525968-constraintsaffectinglayout" target="_blank" rel="external">constraintsAffectingLayoutForOrientation:</a>的调试方法所致。</p>
<p>无论哪种方式，你都可以在这些日志中找到许多有用信息。下面是一个关于不满足条件的布局错误的示例输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-26</span> <span class="number">14</span>:<span class="number">27</span>:<span class="number">54.790</span> Auto Layout Cookbook[<span class="number">10040</span>:<span class="number">1906606</span>] Unable to simultaneously satisfy constraints.</div><div class="line">    Probably at least one of the constraints in the following <span class="built_in">list</span> is one you don't want. Try <span class="keyword">this</span>: (<span class="number">1</span>) look at each constraint <span class="keyword">and</span> <span class="keyword">try</span> to figure out which you don't expect; (<span class="number">2</span>) find the code that added the unwanted constraint <span class="keyword">or</span> constraints <span class="keyword">and</span> fix it. (Note: If you're seeing NSAutoresizingMaskLayoutConstraints that you don't understand, refer to the documentation <span class="keyword">for</span> the UIView property translatesAutoresizingMaskIntoConstraints) </div><div class="line">(</div><div class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7a87b000 H:[UILabel:0x7a8724b0'Name'(&gt;=400)]&gt;"</span>,</div><div class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7a895e30 UILabel:0x7a8724b0'Name'.leading == UIView:0x7a887ee0.leadingMargin&gt;"</span>,</div><div class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7a886d20 H:[UILabel:0x7a8724b0'Name']-(NSSpace(8))-[UITextField:0x7a88cff0]&gt;"</span>,</div><div class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7a87b2e0 UITextField:0x7a88cff0.trailing == UIView:0x7a887ee0.trailingMargin&gt;"</span>,</div><div class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7ac7c430 'UIView-Encapsulated-Layout-Width' H:[UIView:0x7a887ee0(320)]&gt;"</span></div><div class="line">)</div><div class="line"> </div><div class="line">Will attempt to recover by breaking constraint</div><div class="line">&lt;NSLayoutConstraint:<span class="number">0x7a87b000</span> H:[UILabel:<span class="number">0x7a8724b0'</span>Name'(&gt;=<span class="number">400</span>)]&gt;</div><div class="line"> </div><div class="line">Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to <span class="keyword">catch</span> <span class="keyword">this</span> in the debugger.</div><div class="line">The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit/UIView.h&gt; may also be helpful.</div></pre></td></tr></table></figure>
<p>这个错误消息展示了五个冲突约束。这些约束无法同时满足。你应该要么移除一个，要么把一个约束变成可选约束。</p>
<p>幸运的是，这个视图层级相对简单。你有一个父视图，它包含着一个label和一个text field。冲突的约束被设置成了如下关系：</p>
<ol>
<li>label的宽度大于等于400点。</li>
<li>label的起始边等于父视图的起始空白区域。</li>
<li>在label和text field之间包含8个点的空间。</li>
<li>text field的尾边等于父视图的尾部空白区域。</li>
<li>父视图的宽度为320点。</li>
</ol>
<p>系统试图通过移除label的宽度来恢复正常。</p>
<blockquote>
<p><strong>说明</strong></p>
<p>控制台中写入的约束使用的是可视化语言（Visual Format Language，以后写做VFL）。即使你从不会使用VFL来创建约束，你也必须可以阅读并理解它以便有效调试Auto Layout的问题。要获取更多信息，请看<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1" target="_blank" rel="external">可视化语言</a>。</p>
</blockquote>
<p>这些约束当中，最后一个是系统创建的。你不能改变它。并且，它和第一个约束一起产生了一个明显的冲突。如果你的父视图只有320点宽度，你不可能会有一个400点宽度的label。幸运的是，你不必移除首个约束。如果你把它的优先级降到999，系统还是会试图提供一个可选宽度—-尽可能地接近它（400宽度），并同时满足其他约束。</p>
<p>基于视图的autoresizing mask的约束（例如，当<a href="https://developer.apple.com/documentation/uikit/uiview/1622572-translatesautoresizingmaskintoco" target="_blank" rel="external">translatesAutoresizingMaskIntoConstraints</a>为YES时，约束被创建）在mask上存在额外信息。在约束被定位后，日志字符串会显示”<em>h=</em>“，且其后跟随着三个字符，“<em>v=</em>”后同样跟随三个字符。一个“<em>-</em>”（连字符）字符代表一个确定值，同时一个“<em>&amp;</em>”（与符号）字符代表一个可变值。对于水平方向（<em>h=</em>），三个字符分别代表了左间距、<br>宽度和右间距。在垂直方向上（<em>v=</em>），他们分别代表了顶部间距、高度和底部间距。</p>
<p>例如，考虑如下日志：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;NSAutoresizingMaskLayoutConstraint:<span class="number">0x7ff28252e480</span> h=--&amp; v=--&amp; H:[UIView:<span class="number">0x7ff282617cc0</span>(<span class="number">50</span>)]&gt;<span class="string">"</span></div></pre></td></tr></table></figure>
<p>此信息由如下部分组成：</p>
<ul>
<li><em>NSAutoresizingMaskLayoutConstraint:0x7ff28252e480</em>：约束的类和地址。本例中，此类说明它基于视图的autoresizing mask。</li>
<li><em>h=–&amp; v=–&amp;</em>：视图的autoresizing mask。这是默认的mask。在水平方向上它包含一个确定的左间距、一个确定的宽度和一个可变的右间距。在竖直方向上它存在一个确定的顶部间距、一个确定的高度和一个可变的底部间距。换句话说，在父视图尺寸改变时，这个视图的左上角和尺寸保持不变。</li>
<li><em>H:[UIView:0x7ff282617cc0(50)]</em>：使用VFL描述的约束。在本例中，它描述了一个单独的50点宽度的视图。此描述还包含了约束涉及到的所有视图的类和地址。</li>
</ul>
<h4 id="给日志添加识别符号"><a href="#给日志添加识别符号" class="headerlink" title="给日志添加识别符号"></a>给日志添加识别符号</h4><p>虽然前一个例子相对容易理解，越来越长的约束列表很快就变得难以理解。你可以通过给每个视图和约束设置一个有意义的识别符来让日志容易阅读。</p>
<p>如果视图有一个明显的文字组件，Xcode就直接使用它来做识别符。例如，Xcode使用一个label的文字，一个button的标题，或者一个text field的占位字来识别这些视图。其他情况下，需要在识别检查器（Identity inspector）中设置指定的标签。Interface Builder在交互设置中使用这些识别符。大多数的这些识别符都会在控制台日志中显示。</p>
<p>对于约束来说，通过代码或者属性检查器（Attribute inspector）来设置<em>identifier</em>属性。当在控制台打印信息时，Auto Layout就会使用这些识别符。</p>
<p>举例来说，这是一个带有识别符版本的相同的错误约束：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">2015-08-26 14:29:32.870 Auto Layout Cookbook[10208:1918826] Unable to simultaneously satisfy constraints.</div><div class="line">    Probably at least one of the constraints in the following list is one you don't want. Try this: (1) look at each constraint and try to figure out which you don't expect; (2) find the code that added the unwanted constraint or constraints and fix it. (Note: If you're seeing NSAutoresizingMaskLayoutConstraints that you don't understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints) </div><div class="line">(</div><div class="line">    "&lt;NSLayoutConstraint:0x7b58bac0 'Label Leading' UILabel:0x7b58b040'Name'.leading == UIView:0x7b590790.leadingMargin&gt;",</div><div class="line">    "&lt;NSLayoutConstraint:0x7b56d020 'Label Width' H:[UILabel:0x7b58b040'Name'(&gt;=400)]&gt;",</div><div class="line">    "&lt;NSLayoutConstraint:0x7b58baf0 'Space Between Controls' H:[UILabel:0x7b58b040'Name']-(NSSpace(8))-[UITextField:0x7b589490]&gt;",</div><div class="line">    "&lt;NSLayoutConstraint:0x7b51cb10 'Text Field Trailing' UITextField:0x7b589490.trailing == UIView:0x7b590790.trailingMargin&gt;",</div><div class="line">    "&lt;NSLayoutConstraint:0x7b0758c0 'UIView-Encapsulated-Layout-Width' H:[UIView:0x7b590790(320)]&gt;"</div><div class="line">)</div><div class="line"> </div><div class="line">Will attempt to recover by breaking constraint</div><div class="line">&lt;NSLayoutConstraint:0x7b56d020 'Label Width' H:[UILabel:0x7b58b040'Name'(&gt;=400)]&gt;</div><div class="line"> </div><div class="line">Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.</div><div class="line">The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit/UIView.h&gt; may also be helpful.</div></pre></td></tr></table></figure>
<p>正如所见，这些识别符可以让你在日志中快速且容易地识别出约束。</p>
<h4 id="理解边界案例"><a href="#理解边界案例" class="headerlink" title="理解边界案例"></a>理解边界案例</h4><p>这里有一些可能导致Auto Layout出现不可预料情况的边界案例：</p>
<ul>
<li>Auto Layout是基于视图的对齐矩形来定位视图的，而不是frame。大多时候，二者是相等的。可是，在布局计算时，一些视图可能会设置了自定义的对齐矩形进而超出了视图本身（如badges）。<br>  了解更多信息，在<a href="https://developer.apple.com/documentation/uikit/uiview" target="_blank" rel="external">UIView类参考</a>中查看使用Auto Layout对齐视图的相关内容。</li>
<li>在iOS中，你可以使用视图的<a href="https://developer.apple.com/documentation/uikit/uiview/1622459-transform" target="_blank" rel="external">transform</a>属性来设置尺寸、旋转或移动视图；可是，这些变换根本不会影响Auto Layout的计算。Auto Layout是通过视图未变换时的frame来计算其对齐矩形的。</li>
<li>一个视图可以在其边界范围之外显示内容。大多时候，视图会正常显示并将其内容限制在边界之内。可是，有时出于性能考虑，这不会被图像引擎强制实现。这意味着该视图（特别是那些自定义绘制的视图）可能会以一个不同于本身frame的尺寸进行绘制。<br>  你可以将视图的<a href="https://developer.apple.com/documentation/uikit/uiview/1622415-clipstobounds" target="_blank" rel="external">clipsToBounds</a>属性置为YES来测试这个问题，或者通过视图的frame进行验证。</li>
<li>只有当所有视图以它们的真实内容尺寸高度显示时，<a href="https://developer.apple.com/documentation/appkit/nslayoutattribute/nslayoutattributebaseline" target="_blank" rel="external">NSLayoutAttributeBaseline</a>、<a href="https://developer.apple.com/documentation/appkit/nslayoutattribute/nslayoutattributefirstbaseline" target="_blank" rel="external">NSLayoutAttributeFirstBaseline</a>和<a href="https://developer.apple.com/documentation/appkit/nslayoutconstraint/attribute/lastbaseline" target="_blank" rel="external">NSLayoutAttributeLastBaseline</a>属性才会正确对齐文字。如果其中一个视图在竖直方向上被拉伸或压缩，其文字就可能出现在错误的位置上。</li>
<li>约束优先级会在整个视图层级中作为全局属性出现。你可能会经常使用stack view、layout guide或者虚拟视图将视图进行分组；可是，这种做法并不能将所需的视图优先级封装到内部。Auto Layout会继续将组内的优先级同外面的进行比较（甚至是其他组中的优先级）。</li>
<li>宽高比约束允许水平和竖直约束进行交互。一般来说，水平和竖直布局是单独计算的。可是，如果你使用一个视图的宽度来约束其高度时，你便创建了一个水平和竖直约束间的连接关系：他们现在会对其他约束产生影响甚至发生冲突。这种交互会明显增加布局的复杂度，并且可能会与一些不相干的布局产生某些不可预期的冲突。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文节选并翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/DebuggingTricksandTips.html#//apple_ref/doc/uid/TP40010853-CH21-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Debugging Tricks and Tips
&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下话题描述了在布局中总结提炼出的信息，同时描述了一些你可能遇到的意料之外的情况。你也许不会再每次布局中都会用到这些技术，但是它们可以在一些难题上给你提供帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>元素中有重复元素吗？（2）</title>
    <link href="http://yoursite.com/2019/02/22/%E5%85%83%E7%B4%A0%E4%B8%AD%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E5%90%97%EF%BC%9F%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/22/元素中有重复元素吗？（2）/</id>
    <published>2019-02-22T03:51:16.320Z</published>
    <updated>2019-02-22T03:51:16.320Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。</p>
<a id="more"></a>
<ul>
<li>示例1：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>], k = <span class="number">3</span></div><div class="line">输出: <span class="literal">true</span></div></pre></td></tr></table></figure>
<ul>
<li>示例2：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: nums = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">1</span></div><div class="line">输出: <span class="literal">true</span></div></pre></td></tr></table></figure>
<ul>
<li>示例3：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">2</span></div><div class="line">输出: <span class="literal">false</span></div></pre></td></tr></table></figure>
<h4 id="解法1：暴力法"><a href="#解法1：暴力法" class="headerlink" title="解法1：暴力法"></a>解法1：暴力法</h4><p>双重遍历，依次比较查找，时间复杂度为O(n^2)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">checkTheSameNumberWithSpecificIndex1</span><span class="params">(NSArray&lt;NSNumber *&gt; *nums, NSInteger target)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (nums.count &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; nums.count; i++) &#123;</div><div class="line">        <span class="comment">// 当前数值</span></div><div class="line">        NSInteger currentValue = [nums[i] integerValue];</div><div class="line">        <span class="comment">// 在依次查看之后的数据值是否相同</span></div><div class="line">        <span class="keyword">for</span> (NSInteger j = i + <span class="number">1</span>; j &lt; nums.count; j++) &#123;</div><div class="line">            NSInteger nextValue = [nums[j] integerValue];</div><div class="line">            <span class="keyword">if</span> (currentValue == nextValue) &#123;</div><div class="line">                <span class="comment">// 索引差是否符合要求</span></div><div class="line">                <span class="keyword">if</span> (<span class="built_in">labs</span>(j - i) &lt;= target) &#123;</div><div class="line">                    <span class="keyword">return</span> YES;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="解法2：哈希表"><a href="#解法2：哈希表" class="headerlink" title="解法2：哈希表"></a>解法2：哈希表</h4><p>利用哈希表（OC中使用NSDictionary对象）的快速查找降低了复杂度，同时进行比较并更新。时间复杂度降低为O(n)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">checkTheSameNumberWithSpecificIndex2</span><span class="params">(NSArray&lt;NSNumber *&gt; *nums, NSInteger target)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (nums.count &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 插入到哈希表中，同时检查：如果数值对应的key已经存在，则使用其索引与当前索引进行比较。符合要求则返回；不符合则插入新索引，继续向后检查</span></div><div class="line">    NSMutableDictionary *hashTable = [[NSMutableDictionary alloc] initWithCapacity:<span class="number">10</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (NSInteger index = <span class="number">0</span>; index &lt; nums.count; index++) &#123;</div><div class="line">        NSNumber *currentItem = nums[index];</div><div class="line">        NSNumber *indexItem = hashTable[currentItem];</div><div class="line">        <span class="keyword">if</span> (!indexItem) &#123;</div><div class="line">            <span class="comment">// 不存在，插入（key为数据值，value为索引）</span></div><div class="line">            hashTable[currentItem] = @(index);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 存在，取出value索引值，进行比较</span></div><div class="line">            <span class="keyword">if</span>(<span class="built_in">labs</span>(indexItem.integerValue - index) &lt;= target) &#123;</div><div class="line">                <span class="comment">// 符合要求</span></div><div class="line">                <span class="keyword">return</span> YES;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 不符合，更新此索引值</span></div><div class="line">                hashTable[currentItem] = @(index);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法学习" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数组中的两数之和为指定的值，求此两数的索引</title>
    <link href="http://yoursite.com/2019/02/21/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E5%80%BC%EF%BC%8C%E6%B1%82%E6%AD%A4%E4%B8%A4%E6%95%B0%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2019/02/21/数组中的两数之和为指定的值，求此两数的索引/</id>
    <published>2019-02-20T16:37:10.079Z</published>
    <updated>2019-02-20T16:37:10.079Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<a id="more"></a>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></div><div class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></div><div class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</div></pre></td></tr></table></figure>
<h4 id="解法1：暴力法"><a href="#解法1：暴力法" class="headerlink" title="解法1：暴力法"></a>解法1：暴力法</h4><p>依次遍历数组中的每个数据，查看与数组中的其他数据之和是否为指定的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">NSArray&lt;NSNumber *&gt; *getSumIndex1(NSArray&lt;NSNumber *&gt; *nums, NSInteger target) &#123;</div><div class="line">    <span class="comment">// 注意：标准解法需要双重遍历原数组确定索引，时间复杂度为O(n^2)，这里使用NSArray的API进行了简化</span></div><div class="line">    NSArray *sumIndexInfo;</div><div class="line">    <span class="keyword">for</span> (NSNumber *item in nums) &#123;</div><div class="line">        <span class="comment">// 当前索引</span></div><div class="line">        NSInteger currentIndex = [nums indexOfObject:item];</div><div class="line">        <span class="comment">// 获取差值</span></div><div class="line">        NSNumber *result = @(target - item.integerValue);</div><div class="line">        <span class="comment">// 查看是否在数组中</span></div><div class="line">        NSInteger resultIndex = [nums indexOfObject:result];</div><div class="line">        <span class="keyword">if</span> ((resultIndex != NSNotFound)</div><div class="line">            &amp;&amp; (resultIndex != currentIndex)) &#123;</div><div class="line">            <span class="comment">// 找到，得到索引并返回</span></div><div class="line">            sumIndexInfo = @[@(currentIndex), @(resultIndex)];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sumIndexInfo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="解法2：两次遍历哈希表"><a href="#解法2：两次遍历哈希表" class="headerlink" title="解法2：两次遍历哈希表"></a>解法2：两次遍历哈希表</h4><p>这里使用了NSDictionary类进行实现，目的是为了快速查找到数据对应的索引：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">NSArray&lt;NSNumber *&gt; *getSumIndex2(NSArray&lt;NSNumber *&gt; *nums, NSInteger target) &#123;</div><div class="line">    <span class="comment">// 使用哈希表进行存取，加快查找速度</span></div><div class="line">    NSMutableDictionary *hashTable = [@&#123;&#125; mutableCopy];</div><div class="line">    <span class="keyword">for</span> (NSInteger index = <span class="number">0</span>; index &lt; nums.count; index++) &#123;</div><div class="line">        <span class="comment">// key为数据值，value为索引（目的为了快速通过数值查询到索引）</span></div><div class="line">        [hashTable setObject:@(index) forKey:nums[index]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSArray *sumIndexInfo;</div><div class="line">    <span class="keyword">for</span> (NSInteger index = <span class="number">0</span>; index &lt; nums.count; index++) &#123;</div><div class="line">        NSInteger currentValue = [nums[index] integerValue];</div><div class="line">        <span class="comment">// 获取差值</span></div><div class="line">        NSNumber *result = @(target - currentValue);</div><div class="line">        <span class="comment">// 在哈希表中查找对应索引</span></div><div class="line">        NSNumber *resultIndex = [hashTable objectForKey:result];</div><div class="line">        <span class="keyword">if</span> ((resultIndex)</div><div class="line">            &amp;&amp; (resultIndex.integerValue != index)) &#123;</div><div class="line">            sumIndexInfo = @[@(index), resultIndex];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sumIndexInfo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="解法3：一次遍历哈希表"><a href="#解法3：一次遍历哈希表" class="headerlink" title="解法3：一次遍历哈希表"></a>解法3：一次遍历哈希表</h4><p>遍历插入哈希表的同时，直接在表中查询，符合直接返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">NSArray&lt;NSNumber *&gt; *getSumIndex3(NSArray&lt;NSNumber *&gt; *nums, NSInteger target) &#123;</div><div class="line">    <span class="comment">// 简化了方法2，一次遍历同时直接查询</span></div><div class="line">    </div><div class="line">    NSArray *sumIndexInfo;</div><div class="line">    <span class="comment">// 使用哈希表进行存取，加快查找速度</span></div><div class="line">    NSMutableDictionary *hashTable = [@&#123;&#125; mutableCopy];</div><div class="line">    <span class="keyword">for</span> (NSInteger index = <span class="number">0</span>; index &lt; nums.count; index++) &#123;</div><div class="line">        NSNumber *currentItem = nums[index];</div><div class="line">        <span class="comment">// 获取差值</span></div><div class="line">        NSNumber *result = @(target - currentItem.integerValue);</div><div class="line">        <span class="comment">// 直接查询当前哈希表中是否已经包含差值对象</span></div><div class="line">        NSNumber *resultIndex = [hashTable objectForKey:result];</div><div class="line">        <span class="keyword">if</span> ((resultIndex)</div><div class="line">            &amp;&amp; (resultIndex.integerValue != index)) &#123;</div><div class="line">            sumIndexInfo = @[@(index), resultIndex];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// key为数据值，value为索引（目的为了快速通过数值查询到索引）</span></div><div class="line">            [hashTable setObject:@(index) forKey:currentItem];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sumIndexInfo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>由于在OC的数组中已经包含了根据元素直接返回索引的高级API，故大幅度简化了解法1，使用哈希表快速返回索引也变得没有那么必要了。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法学习" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数组中有重复元素吗？</title>
    <link href="http://yoursite.com/2019/02/20/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E5%90%97%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/02/20/数组中有重复元素吗？/</id>
    <published>2019-02-20T04:32:39.180Z</published>
    <updated>2019-02-20T04:48:00.364Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<a id="more"></a>
<ul>
<li>示例1：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</div><div class="line">输出: <span class="literal">true</span></div></pre></td></tr></table></figure>
<ul>
<li>示例2：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</div><div class="line">输出: <span class="literal">false</span></div></pre></td></tr></table></figure>
<h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><ol>
<li>对数组进行排序；</li>
<li>遍历排序后的数组，若相邻数据相同，则包含重复数据；否则不包含。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">checkDuplicateNumber1</span><span class="params">(NSArray&lt;NSNumber *&gt;* targetInfo)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (targetInfo.count &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NO;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 1.排序</span></div><div class="line">    NSArray *sortedInfo = [targetInfo sortedArrayUsingComparator:^NSComparisonResult(NSNumber* _Nonnull obj1, NSNumber* _Nonnull obj2) &#123;</div><div class="line">        <span class="comment">// obj1比obj2，升序；用obj2比obj1，降序</span></div><div class="line">        <span class="keyword">return</span> [obj1 compare:obj2];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="comment">// 2.查看相邻两数是否相同</span></div><div class="line">    NSNumber *lastObj;</div><div class="line">    <span class="keyword">for</span> (NSNumber *currentObj in sortedInfo) &#123;</div><div class="line">        <span class="keyword">if</span> (!lastObj) &#123;</div><div class="line">            lastObj = currentObj;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (currentObj.integerValue == lastObj.integerValue) &#123;</div><div class="line">            <span class="keyword">return</span> YES;</div><div class="line">        &#125;</div><div class="line">        lastObj = currentObj;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><p>转换为NSSet集合对象，若元素数少于原数组，则包含重复数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">checkDuplicateNumber2</span><span class="params">(NSArray&lt;NSNumber *&gt;* targetInfo)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (targetInfo.count &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NO;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 转化为NSSet对象，若元素比原数组少，则有相同数据</span></div><div class="line">    NSSet *setInfo = [NSSet setWithArray:targetInfo];</div><div class="line">    <span class="keyword">return</span> setInfo.count != targetInfo.count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;p&gt;给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法学习" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之带有真实内容尺寸的视图</title>
    <link href="http://yoursite.com/2019/02/19/Autolayout%E4%B9%8B%E5%B8%A6%E6%9C%89%E7%9C%9F%E5%AE%9E%E5%86%85%E5%AE%B9%E5%B0%BA%E5%AF%B8%E7%9A%84%E8%A7%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/02/19/Autolayout之带有真实内容尺寸的视图/</id>
    <published>2019-02-19T03:56:24.828Z</published>
    <updated>2019-02-19T03:56:24.828Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文节选并翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW1" target="_blank" rel="external">Views with Intrinsic Content Size</a></p>
</blockquote>
<h4 id="动态高度的Label和Text-Field"><a href="#动态高度的Label和Text-Field" class="headerlink" title="动态高度的Label和Text Field"></a>动态高度的Label和Text Field</h4><p><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW8" target="_blank" rel="external">简单的Label和Text Field</a>示例中，通过假定text field总是比name label更高简化了布局逻辑。可是，这不总是准确的。如果你增加label的字体大小到一定程度，它将会比text field更高。</p>
<a id="more"></a>
<p>本示例通过在运行期间高度最高的控件动态设置了所有控件的垂直间距。当使用标准系统字体是，本示例看起来与<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW8" target="_blank" rel="external">简单的Label和Text Field</a>相同。可是，当你增加label的字体到36号时，布局的竖直间距会使用label的顶部距离重新计算。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Label_and_Text_Field_Pair_2x.png" alt="img"></p>
<p>这当然是一个人为设置的例子。毕竟，如果你增加了label字体大小，通常来说你还应该增加text field的字体大小。可是，在动态类型控件和指定尺寸控件（如图片）同时出现时，如果通过iPhone的辅助功能设置了超级超级大的字体时，此技术就可以证明是有效的。</p>
<h5 id="视图和约束"><a href="#视图和约束" class="headerlink" title="视图和约束"></a>视图和约束</h5><p>就像<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW8" target="_blank" rel="external">简单的Label和Text Field</a>中一样设置好视图层级，但是我们使用了稍微复杂一些的约束：</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/dynamic_height_label_and_text_field_2x.png" alt="img"></p>
<ol>
<li>Name Label.Leading = Superview.LeadingMargin</li>
<li>Name Text Field.Trailing = Superview.TrailingMargin</li>
<li>Name Text Field.Leading = Name Label.Trailing + Standard</li>
<li>Name Label.Top &gt;= Top Layout Guide.Bottom + 20.0</li>
<li>Name Label.Top = Top Layout Guide.Bottom + 20.0 (Priority 249)</li>
<li>Name Text Field.Top &gt;= Top Layout Guide.Bottom + 20.0</li>
<li>Name Text Field.Top = Top Layout Guide.Bottom + 20.0 (Priority 249)</li>
<li>Name label.Baseline = Name Text Field.Baseline</li>
</ol>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>要让text field拉伸来填满可用空间，它的抗拉伸优先级必须低于label的。默认来说，Interface Builder会自动将label的抗拉伸优先级设置为251，text field的为250.你可以在尺寸检查器中验证这个数值。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>Horizontal hugging</th>
<th>Vertical hugging</th>
<th>Horizontal resistance</th>
<th>Vertical resistance</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name Label</td>
<td>251</td>
<td>251</td>
<td>750</td>
<td>750</td>
</tr>
<tr>
<td>Name Text Field</td>
<td>250</td>
<td>250</td>
<td>750</td>
<td>750</td>
</tr>
</tbody>
</table>
<h5 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h5><p>本例中，对每一个控件都是用了一对约束。一个必须的且大于或等于的约束定义了控件自身和布局指导线之间的最小距离，同时，一个可选约束试图将此距离明确设置为20。</p>
<p>对于尺寸更高的控件，这两个约束全部满足，故系统会会在离布局指导线20点距离的地方放置该控件。可是，对于较矮的那个，只有最小距离约束可以满足。另一个约束会被忽略。这使得在运行期间，当控件的高度改变时，Auto Layout系统可以动态重新计算布局。</p>
<blockquote>
<p><strong>说明</strong></p>
<p>确保将可选约束优先级的值设置得低于默认抗拉伸优先级（250）。否则，系统会破坏抗拉伸约束并拉伸视图而不是重新定位。<br>当使用基线定位进行布局时，某些地方可能会导致特别疑惑，因为只有当文字的相关视图以真实内容尺寸显示时，基线定位才是有效的。尽管包含了一个必要的基线约束，如果系统修改了其中一个视图的尺寸，文字可能就不会正常排列了。</p>
</blockquote>
<h4 id="等间距的两个按钮"><a href="#等间距的两个按钮" class="headerlink" title="等间距的两个按钮"></a>等间距的两个按钮</h4><p>在样式上看，这个例子和<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW4" target="_blank" rel="external">两个等宽按钮</a>示例（见截图）基本相同。可是，在本例中，按钮的宽度基于带有最长标题的按钮。如果空间足够，所有按钮都会被拉伸直到他们同时满足最长按钮的真实内容尺寸。所有额外的空间会在按钮周围平均分配。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Two_Buttons_with_Equal_Spacing_screen_2x.png" alt="img"></p>
<p>在iPhone上，<em>两个等宽按钮</em>和<em>等间距的两个按钮</em>在竖屏状态下的布局基本相同。只有当你把设备旋转到横屏方向时区别才会变得明显（或使用更大的设备，如iPad）。</p>
<h5 id="视图和约束-1"><a href="#视图和约束-1" class="headerlink" title="视图和约束"></a>视图和约束</h5><p>在Interface Builder，拖拽并放置两个按钮和三个视图对象。把按钮放在视图中间，之后按照如下方式设置约束。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/two_buttons_with_equal_spacing_2x.png" alt="img"></p>
<ol>
<li>Leading Dummy View.Leading = Superview.LeadingMargin</li>
<li>Short Button.Leading = Leading Dummy View.Trailing</li>
<li>Center Dummy View.Leading = Short Button.Trailing</li>
<li>Long Button.Leading = Center Dummy View.Trailing</li>
<li>Trailing Dummy View.Leading = Long Button.Trailing</li>
<li>Trailing Dummy View.Trailing = Superview.TrailingMargin</li>
<li>Bottom Layout Guide.Top = Leading Dummy View.Bottom + 20.0</li>
<li>Bottom Layout Guide.Top = Short Button.Bottom + 20.0</li>
<li>Bottom Layout Guide.Top = Center Dummy View.Bottom + 20.0</li>
<li>Bottom Layout Guide.Top = Long Button.Bottom + 20.0</li>
<li>Bottom Layout Guide.Top = Trailing Dummy View.Bottom + 20.0</li>
<li>Short Button.Leading &gt;= Superview.LeadingMargin</li>
<li>Long Button.Leading &gt;= Short Button.Trailing + Standard</li>
<li>Superview.TrailingMargin &gt;= Long Button.Trailing</li>
<li>Leading Dummy View.Width = Center Dummy View.Width</li>
<li>Leading Dummy View.Width = Trailing Dummy View.Width</li>
<li>Short Button.Width = Long Button.Width</li>
<li>Leading Dummy View.Height = 0.0</li>
<li>Center Dummy View.Height = 0.0</li>
<li>Trailing Dummy View.Height = 0.0</li>
</ol>
<h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><p>给按钮设置一个可见的背景色，使在设备旋转时按钮的结构改变可以更容易看出来。此外，给按钮设置不同长度的标题。所有按钮应该基于最长标题来设置尺寸。</p>
<table>
<thead>
<tr>
<th>视图</th>
<th>属性</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Short Button</td>
<td>Background</td>
<td>Light Gray Color</td>
</tr>
<tr>
<td>Short Button</td>
<td>Title</td>
<td>Short</td>
</tr>
<tr>
<td>Long Button</td>
<td>Background</td>
<td>Light Gray Color</td>
</tr>
<tr>
<td>Long Button</td>
<td>Title</td>
<td>Much Longer Button Title</td>
</tr>
</tbody>
</table>
<h5 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h5><p>如图你看到的一样，这些约束已经变得复杂了。本例只是用来展示指定技术的，在真正的app里你应该考虑使用Stack View。</p>
<p>在本例中，你想要让空白区域随着父视图尺寸改变而改变。这意味着你需要一组等宽约束来控制空白区域的宽度；可是，你不能在空的地方直接设置约束。你可以设置尺寸约束的至少是一个对象。</p>
<p>在本例中，你用了几个虚拟视图来代表空白空间。这些视图是UIView类的空实例。在本例中，它们的高度被设置为0来最小化对视图层级的影响。</p>
<blockquote>
<p><strong>说明</strong></p>
<p>虚拟视图会增加布局的性能损耗，所以你应该谨慎使用。如果这些视图非常大，其图形上下文会占用大量的内存，尽管它们没有包含任何有用信息。</p>
<p>此外，这些视图加入到了视图层级的响应者链中。这意味着它们会响应消息，如触摸检测，这些消息会沿着响应者链进行传递。如果没有小心处理，这些视图可能会打断并响应这些消息，产生难以排查的bug。</p>
</blockquote>
<p>或者，你可以使用<a href="https://developer.apple.com/documentation/uikit/uilayoutguide" target="_blank" rel="external">UILayoutGuide</a>类实例来代表空白区域。这个轻量级的类使用一个矩形结构以便可以加入到Auto Layout的约束中。布局指导对象（layout guides）没有图形上下文，并且他们不会加入到视图层级中。这使布局指导对象对于分组项目或是定义空白区域来说特别合适。</p>
<p>不幸的是，你不能在Interface Builder的场景对象中添加布局指导对象，并且在基于story-board的场景中使用代码创建该对象会变得非常复杂。一般来说，使用StoryBoard和Interface Builder要比使用自定义布局指导对象更好。</p>
<p>本例使用了<em>大于等于</em>约束来设置按钮间的最小间距。“必须级”约束还确保了按钮一直拥有相同宽度，并且虚拟视图也都拥有相同宽度（虽然，他们与按钮的宽度不同）。剩下的约束通过按钮的CHCR优先级自行管理。如果空间不足，虚拟视图就会被忽略为0宽度，所有按钮会将虚拟视图的空间均分（在按钮之间使用基本间距）。一旦可用空间增加，所有按钮就会扩大直到达到最大按钮的真实内容尺寸为止，之后所有的虚拟视图也开始扩大。虚拟视图会持续扩大来填充所有可用空间。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文节选并翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Views with Intrinsic Content Size&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;动态高度的Label和Text-Field&quot;&gt;&lt;a href=&quot;#动态高度的Label和Text-Field&quot; class=&quot;headerlink&quot; title=&quot;动态高度的Label和Text Field&quot;&gt;&lt;/a&gt;动态高度的Label和Text Field&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;简单的Label和Text Field&lt;/a&gt;示例中，通过假定text field总是比name label更高简化了布局逻辑。可是，这不总是准确的。如果你增加label的字体大小到一定程度，它将会比text field更高。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之嵌套Stack View的使用</title>
    <link href="http://yoursite.com/2019/02/17/Autolayout%E4%B9%8B%E5%B5%8C%E5%A5%97Stack%20View%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/02/17/Autolayout之嵌套Stack View的使用/</id>
    <published>2019-02-17T09:03:48.866Z</published>
    <updated>2019-02-17T09:03:48.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文节选并翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW1" target="_blank" rel="external">Stack Views</a></p>
</blockquote>
<h4 id="嵌套的多个Stack-View"><a href="#嵌套的多个Stack-View" class="headerlink" title="嵌套的多个Stack View"></a>嵌套的多个Stack View</h4><p>以下做法展示了一个使用多层嵌套stack view组成的复杂布局。但是，此例中，stack view无法单独生成所有的约束。因此，我们额外需要提供更加完整的约束。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Nested_Stack_Views_Screenshot_2x.png" alt="img"></p>
<p>在视图层次完成之后，添加约束展示在下一章节，<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW12" target="_blank" rel="external">视图和约束</a>。</p>
<a id="more"></a>
<h5 id="视图和约束"><a href="#视图和约束" class="headerlink" title="视图和约束"></a>视图和约束</h5><p>在使用多个嵌套的stack view时，最容易的使用方式就是“<em>从内到外</em>”。首先，在Interface Builder中布局出名称行。把label和text field放到相对正确的位置上，同时选中，然后依次点击Editor &gt; Embed in &gt; Stack View菜单项。这便创建了一个水平stack view。</p>
<p>下一步，把这些对象水平放好，全选，再次点击Editor &gt; Embed in &gt; Stack View菜单项。这便创建了一个多行的水平stack view。如下图所示，继续创建界面。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/nested_stack_views_2x.png" alt="img"></p>
<ol>
<li>Root Stack View.Leading = Superview.LeadingMargin</li>
<li>Root Stack View.Trailing = Superview.TrailingMargin</li>
<li>Root Stack View.Top = Top Layout Guide.Bottom + 20.0</li>
<li>Bottom Layout Guide.Top = Root Stack View.Bottom + 20.0</li>
<li>Image View.Height = Image View.Width</li>
<li>First Name Text Field.Width = Middle Name Text Field.Width</li>
<li>First Name Text Field.Width = Last Name Text Field.Width</li>
</ol>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>每个stack都有自己的一系列属性。这些属性定义了每个stack如何布局自身内容。在属性检查器中，设置如下属性：</p>
<table>
<thead>
<tr>
<th>Stack</th>
<th>Axis（坐标轴）</th>
<th>Alignment（垂直轴方向）</th>
<th>Distribution（沿轴方向）</th>
<th>Spacing（间距）</th>
</tr>
</thead>
<tbody>
<tr>
<td>First Name</td>
<td>Horizontal</td>
<td>First Baseline</td>
<td>Fill</td>
<td>8</td>
</tr>
<tr>
<td>Middle Name</td>
<td>Horizontal</td>
<td>First Baseline</td>
<td>Fill</td>
<td>8</td>
</tr>
<tr>
<td>Last Name</td>
<td>Horizontal</td>
<td>First Baseline</td>
<td>Fill</td>
<td>8</td>
</tr>
<tr>
<td>Name Rows</td>
<td>Vertical</td>
<td>Fill</td>
<td>Fill</td>
<td>8</td>
</tr>
<tr>
<td>Upper</td>
<td>Horizontal</td>
<td>Fill</td>
<td>Fill</td>
<td>8</td>
</tr>
<tr>
<td>Button</td>
<td>Horizontal</td>
<td>First Baseline</td>
<td>Fill Equally</td>
<td>8</td>
</tr>
<tr>
<td>Root</td>
<td>Vertical</td>
<td>Fill</td>
<td>Fill</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>此外，CHCR属性定义了相关视图应该拉伸来填充可用空间。在尺寸检查器中，设置如下CHCR属性：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>Horizontal hugging（水平抗拉伸）</th>
<th>Vertical hugging（垂直抗拉伸）</th>
<th>Horizontal resistance（水平抗压缩）</th>
<th>Vertical resistance（水平抗压缩）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Image View</td>
<td>250</td>
<td>250</td>
<td>48（易被压缩）</td>
<td>48（易被压缩）</td>
</tr>
<tr>
<td>Text View</td>
<td>250</td>
<td>249（易被拉伸）</td>
<td>250</td>
<td>250</td>
</tr>
<tr>
<td>First, Middle, and Last Name Labels</td>
<td>251</td>
<td>251</td>
<td>750（不易被压缩）</td>
<td>750（不易被压缩）</td>
</tr>
<tr>
<td>First, Middle, and Last Name Text Fields</td>
<td>48（易被拉伸）</td>
<td>250</td>
<td>749</td>
<td>750</td>
</tr>
</tbody>
</table>
<h5 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h5><p>在此做法中，多个stack view共同作用来处理绝大多数的布局。但是，他们不能仅仅通过自身创建出所有需要的行为。比如，当image view尺寸变化时，图片应该可以保持自身的宽高比。不幸的是，在<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW2" target="_blank" rel="external">单独的Stack View</a>的做法在这里不起作用。布局需要尽可能同时适配图片的尾部和底部边界，且使用按比例适配（Aspect Fit）模式会给某些尺寸上增加额外空白。幸运的是，在本例中，图片的宽高比例总是正方形，所以你可以让图片完整填充image view的边界，并以1:1的比例拉伸image view。</p>
<blockquote>
<p><strong>说明</strong></p>
<p>在Interface Builder，宽高比（Aspect Ratio）约束简单来说就是视图自身宽高的约束。Interface Builder还可以用许多方式显示约束的倍数。一般来说，对于宽高比约束，将其显示为比例。因此，一个<em>View.Width = View.Height</em>约束可以显示为1:1的宽高比。</p>
</blockquote>
<p>此外，所有的text field应该拥有相同宽度。不幸的是，他们都在不同的stack view中，所以stack无法处理这种情况。因此，你必须添加明确的等宽约束。</p>
<p>像单独的stack view一样，你还必须修改一些CHCR属性。这些定义了视图在父视图尺寸改变时如何缩放。</p>
<p>在垂直方向上，你需要扩大text view，使其填充上部分stack和按钮stack视图以外的空间。因此，text view的垂直抗拉伸优先级必须必其他两者更低才行。</p>
<p>在水平方向上，所有的label应该以真实内容尺寸进行展示，同时所有的text field需要调整尺寸来填满额外空间。label的默认CHCR属性被Interface Builder调整的很好。它已经将抗拉伸约束设置为251，使其比text field的要高；可是，你还是需要同时调低text field的水平抗拉伸和抗压缩优先级。</p>
<p>当stack包含name rows时，image view应该压缩以保持相同高度。可是，所有的stack view只是简单的环绕着自身内容。这意味着image view的垂直抗压缩优先级必须非常低，才会使image view压缩而不是将外部的stack view撑大。此外，image view的宽高比约束使布局变复杂，因为它允许了水平和竖直约束进行交互。这意味着text field的水平抗拉伸优先级也必须非常低，否则他们会阻止image view的压缩。综合以上所有情况，将优先级的值设置为48或更低。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文节选并翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stack Views&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;嵌套的多个Stack-View&quot;&gt;&lt;a href=&quot;#嵌套的多个Stack-View&quot; class=&quot;headerlink&quot; title=&quot;嵌套的多个Stack View&quot;&gt;&lt;/a&gt;嵌套的多个Stack View&lt;/h4&gt;&lt;p&gt;以下做法展示了一个使用多层嵌套stack view组成的复杂布局。但是，此例中，stack view无法单独生成所有的约束。因此，我们额外需要提供更加完整的约束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Nested_Stack_Views_Screenshot_2x.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;在视图层次完成之后，添加约束展示在下一章节，&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW12&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;视图和约束&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Autolayout之真实内容尺寸（Intrinsic Content Size）</title>
    <link href="http://yoursite.com/2019/02/14/Autolayout%E4%B9%8B%E7%9C%9F%E5%AE%9E%E5%86%85%E5%AE%B9%E5%B0%BA%E5%AF%B8%EF%BC%88Intrinsic%20Content%20Size%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/14/Autolayout之真实内容尺寸（Intrinsic Content Size）/</id>
    <published>2019-02-14T08:56:47.594Z</published>
    <updated>2019-02-14T08:56:47.594Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文节选并翻译自<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1" target="_blank" rel="external">Anatomy of a Constraint</a></p>
</blockquote>
<h4 id="真实内容尺寸"><a href="#真实内容尺寸" class="headerlink" title="真实内容尺寸"></a>真实内容尺寸</h4><p>到目前为止，所有的示例都是用约束来定义视图的位置和尺寸的。可是，某些视图会根据当前内容生成出一个自然尺寸。这个尺寸即可参考着叫做<em>真实内容尺寸</em>。比如，一个按钮的真实内容尺寸就是它的标题加上一个小边缘。</p>
<p>不是所有的视图都有真实内容尺寸，对于普通视图来说，真实内容尺寸可以定义出视图的宽、高或者二者全部。下面的表格3-1中列出了一些示例。<br><a id="more"></a></p>
<ul>
<li><strong>表格3-1</strong> 基本控件的真实内容尺寸</li>
</ul>
<table>
<thead>
<tr>
<th>视图</th>
<th>真实内容尺寸</th>
</tr>
</thead>
<tbody>
<tr>
<td>UIView和NSView</td>
<td>无</td>
</tr>
<tr>
<td>Sliders</td>
<td>只定义了宽度（iOS）</td>
</tr>
<tr>
<td>Labels、buttons、switches和text fields</td>
<td>同时定义了宽度和高度</td>
</tr>
<tr>
<td>Text views和image views</td>
<td>不同情况下差别很大</td>
</tr>
</tbody>
</table>
<p>真实内容尺寸基于视图的当前内容。一个label或button的真实内容尺寸基于显示文字的总量和使用的字体。对于其他视图来说，真实内容尺寸可能会更复杂。例如，一个空的image view没有真实内容尺寸。一旦在上面添加图片之后，它的真实内容尺寸就被设置为图片的尺寸了。</p>
<p>一个text view的真实内容尺寸有多种不同情况，取决于其内容、是否可以滑动或者是给它添加的其他约束。比如，当可以滑动时，text view没有真实内容尺寸。当不可滑动时，默认来说视图的真实内容尺寸基于不换行的文字计算而来。再例，在文字中如果不存在换行，真实内容尺寸会计算出需要的宽和高，并将内容布局为一个单行文字。如果你添加约束指定了text view的宽，真实内容尺寸就会根据此宽度来定义出需要的高度并进行显示。</p>
<p>Autolayout通过对每一个尺寸使用一对约束来表示真实内容尺寸。抗拉伸约束（content hugging，内容包裹）把视图向内部推以保证它可以优雅地环抱着其内容。抗压缩约束（compression resistance）把视图向外推以便它不会轻易裁剪其内容。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/Art/intrinsic_content_size_2x.png" alt="img"></p>
<p>在列表3-5中展示的这些约束通过使用不等式来进行定义。这里，<em>IntrinsicHeight</em>和<em>IntrinsicWidth</em>常量代表了视图真实内容尺寸中的宽和高。</p>
<ul>
<li><strong>列表3-5</strong> 抗压缩和抗拉伸约束方程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抗压缩</span></div><div class="line">View.height &gt;= <span class="number">0.0</span> * NotAnAttribute + IntrinsicHeight</div><div class="line">View.width &gt;= <span class="number">0.0</span> * NotAnAttribute + IntrinsicWidth</div><div class="line"> </div><div class="line"><span class="comment">// 抗拉伸</span></div><div class="line">View.height &lt;= <span class="number">0.0</span> * NotAnAttribute + IntrinsicHeight</div><div class="line">View.width &lt;= <span class="number">0.0</span> * NotAnAttribute + IntrinsicWidth</div></pre></td></tr></table></figure>
<p>这些约束中的每一个都有自己的优先级。默认来说，视图使用250优先级来定义抗拉伸约束，而使用750优先级来定义抗压缩约束。因此，对于压缩视图来说，拉伸它更加容易。对大多数的控件来说，这都是默认行为。例如，你可以安全地将一个button拉伸到大于它本身的真实内容尺寸；但是，如果你压缩它，则很可能会裁剪其内容。记住，Interface Builder可能会适当修改这些优先级以避免此种情况发生。了解更多信息，请看<a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW2" target="_blank" rel="external">设置抗拉伸和抗压缩约束的优先级</a>。</p>
<p>尽可能地在布局中多使用视图的真实内容尺寸。它可以让你的布局动态适配视图内容的变化。它还可以减少约束的数量来创建出明确的、无冲突的布局，但是你需要管理该视图的抗拉伸和抗压缩约束（统称为<em>CHCR</em>）的优先级。这里是一些处理真实内容尺寸的指导建议：</p>
<ul>
<li>当拉伸一些列视图来填充空间时，如果所有视图都有相同的抗拉伸优先级，此布局就存在歧义了。Autolayout不知道应该拉伸哪个视图。<br>  一个普遍的例子就是label和text field的组合。一般来说，你想要让text field来拉伸填充额外空间，而label保持它自身的真实内容尺寸。要确保这种情况，要保证text field的水平抗拉伸优先级要低于label。<br>  实际上，这个例子如此普遍，Interface Builder已经可以自动处理此情况，自动将label的抗拉伸优先级设置为251。如果手动编码进行布局，你需要自己修改抗拉伸优先级。</li>
<li>当一些带有不可见背景的视图（如buttons或labels）被拉伸超过本身真实内容尺寸时，可能经常会显示出怪异或非预期的布局。导致的实际问题可能并不严重，因为文字直接出现在了错误位置上。要避免这种不必要的拉伸，增加抗拉伸优先级即可。</li>
<li>基准线约束只在那些存在真实内容高度的视图上才有效。如果一个视图被垂直拉伸或压缩，基准线约束便不再正常匹配。</li>
<li>一些视图，如switches，应该总是以真实内容尺寸进行显示。通过提高CHCR优先级来防止被拉伸或压缩。</li>
<li>避免给视图设置“必须级”CHCR优先级。对于视图来说错误的显示尺寸要比偶然出现的约束冲突要更好。如果一个视图需要一直保持真实内容尺寸，考虑将其设置为“非常高”（999）优先级。这个接近“满级”的优先级统称可以保证视图不被拉伸或压缩，而且还可以提供出一个紧急值，以免你的视图在一个与你期望的优先级不同的环境下显示。</li>
</ul>
<h4 id="真实内容尺寸-VS-合适尺寸"><a href="#真实内容尺寸-VS-合适尺寸" class="headerlink" title="真实内容尺寸 VS 合适尺寸"></a>真实内容尺寸 VS 合适尺寸</h4><p>真实内容尺寸在Autolayout中扮演着输入角色。当一个视图存在真实内容尺寸是，系统会生成对应约束来表示尺寸，并且该约束被用于布局的计算。</p>
<p>另一方面，合适尺寸，相当于Autolayout发动机的输出。它是一个视图基于约束计算而得出的尺寸。如果一个视图使用Autolayout来布局子视图，系统便会基于其内容（也就是子视图的布局）计算出该视图的合适尺寸。</p>
<p>UIStackView就是一个好例子。排除任何其他约束，系统会基于其内容和属性计算出stack view的尺寸。从各种角度来看，stack view就好像是存在真实内容尺寸一样：你可以仅仅通过一个单独的垂直约束和一个水平约束就可以定义其位置，进而生成一个完整布局。但是它的尺寸是通过Autolayout进行计算的—-所以尺寸并不是作为Autolayout的输入。设置stack view的CHCR优先级也没有作用，因为实际上stack view并不存在真实内容尺寸。</p>
<p>如果你想要让stack view与外部其他视图（不是stack view的子视图）进行自适应尺寸适配，要么就创建明确的约束来捕获那些关系，要么就参照外部其他视图来修改stack view子视图的CHCR优先级。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文节选并翻译自&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Anatomy of a Constraint&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;真实内容尺寸&quot;&gt;&lt;a href=&quot;#真实内容尺寸&quot; class=&quot;headerlink&quot; title=&quot;真实内容尺寸&quot;&gt;&lt;/a&gt;真实内容尺寸&lt;/h4&gt;&lt;p&gt;到目前为止，所有的示例都是用约束来定义视图的位置和尺寸的。可是，某些视图会根据当前内容生成出一个自然尺寸。这个尺寸即可参考着叫做&lt;em&gt;真实内容尺寸&lt;/em&gt;。比如，一个按钮的真实内容尺寸就是它的标题加上一个小边缘。&lt;/p&gt;
&lt;p&gt;不是所有的视图都有真实内容尺寸，对于普通视图来说，真实内容尺寸可以定义出视图的宽、高或者二者全部。下面的表格3-1中列出了一些示例。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>《a series about Grand Central Dispatch》博客学习笔记</title>
    <link href="http://yoursite.com/2019/01/30/%E3%80%8Aa%20series%20about%20Grand%20Central%20Dispatch%E3%80%8B%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/01/30/《a series about Grand Central Dispatch》博客学习笔记/</id>
    <published>2019-01-29T17:13:19.750Z</published>
    <updated>2019-01-29T17:13:19.750Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本篇是<a href="https://www.humancode.us/2014/07/28/intro-to-gcd.html" target="_blank" rel="external">a series about Grand Central Dispatch</a>的学习记录。<br>原文共6篇，循序渐进地介绍了GCD的基本使用及相关规范。</p>
</blockquote>
<a id="more"></a>
<h3 id="1-Why-GCD"><a href="#1-Why-GCD" class="headerlink" title="1. Why GCD?"></a>1. Why GCD?</h3><h4 id="1-1-在GCD出现之前，解决数据竞争的方式"><a href="#1-1-在GCD出现之前，解决数据竞争的方式" class="headerlink" title="1.1 在GCD出现之前，解决数据竞争的方式"></a>1.1 在GCD出现之前，解决数据竞争的方式</h4><ul>
<li>信号（Semaphore）：只允许使用固定的有限资源。在资源可用之前，线程需要一直等待。</li>
<li>互斥锁（Mutual Exclusion）：一次只允许一个线程执行。当前线程拥有锁时，其他线程等待。</li>
<li>条件变量（Condition Variable）：在指定条件为真之前，线程等待。</li>
</ul>
<h4 id="1-2-GCD队列"><a href="#1-2-GCD队列" class="headerlink" title="1.2 GCD队列"></a>1.2 GCD队列</h4><p>分为<strong>串行队列、并发队列和主队列</strong>三种。</p>
<h4 id="1-3-Blocks"><a href="#1-3-Blocks" class="headerlink" title="1.3 Blocks"></a>1.3 Blocks</h4><p>Blocks可以捕获上下文中的变量（保存当时的值）。</p>
<h4 id="1-4-你好，GCD"><a href="#1-4-你好，GCD" class="headerlink" title="1.4 你好，GCD"></a>1.4 你好，GCD</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.</span></div><div class="line">dispatch_main(); </div><div class="line"></div><div class="line"><span class="comment">// 2.</span></div><div class="line">[[NSRunLoop currentRunLoop] run];</div></pre></td></tr></table></figure>
<p>以上两者均可以启动主线程运行（在main函数中可以使队列不返回，程序不结束。）。但是建议用后者，因为NSRunLoop对象中可以支持NSTimer等资源执行，前者不可以。需要退出当前队列，在对应队列中执行<em>exit(0)</em>即可。</p>
<h3 id="2-Using-GCD-Queues-For-Synchronization"><a href="#2-Using-GCD-Queues-For-Synchronization" class="headerlink" title="2. Using GCD Queues For Synchronization"></a>2. Using GCD Queues For Synchronization</h3><p>传统情况下，数据竞争（多线程环境下更新同一份数据）需要使用排它锁进行数据更新，使用GCD可以通过串行队列直接解决。</p>
<h3 id="3-GCD-Concurrent-Queues"><a href="#3-GCD-Concurrent-Queues" class="headerlink" title="3. GCD Concurrent Queues"></a>3. GCD Concurrent Queues</h3><ul>
<li>GCD的并发队列是代替多线程的一种更好的方式。</li>
<li>GCD会自动管理在并发队列中运行任务的线程（创建、释放和重用等）。</li>
<li>使用GCD的栅栏配合并发队列，可以很容易创建读写锁（并发读取，同步写入）。</li>
</ul>
<h4 id="4-GCD-Target-Queues"><a href="#4-GCD-Target-Queues" class="headerlink" title="4. GCD Target Queues"></a>4. GCD Target Queues</h4><ul>
<li>所有我们自定义的队列都有一个目标队列。默认此目标队列即为默认优先级的全局并发队列。</li>
<li>当进队的block准备执行时，队列将会把此block重进使其进入到目标队列中，由目标队列进行block真正的执行。</li>
<li>只有全局并发队列和主队列二者才有真正执行block的能力。其他任何队列都是将此二者之一作为目标队列的。</li>
</ul>
<h5 id="4-1-使用目标队列规范执行时机"><a href="#4-1-使用目标队列规范执行时机" class="headerlink" title="4.1 使用目标队列规范执行时机"></a>4.1 使用目标队列规范执行时机</h5><p>直接看栗子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeCall</span><span class="params">(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, NSString *caller, NSArray *callees)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取随机接通对象</span></div><div class="line">    NSInteger targetIndex = arc4random() % callees.count;</div><div class="line">    NSString *callee = callees[targetIndex];</div><div class="line">    </div><div class="line">    NSLog(@<span class="string">"%@ 正在呼叫 %@..."</span>, caller, callee);</div><div class="line">    sleep(<span class="number">1</span>);</div><div class="line">    NSLog(@<span class="string">"%@ 与 %@ 呼叫完毕！"</span>, caller, callee);</div><div class="line">    </div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(arc4random() % <span class="number">1000</span> * NSEC_PER_SEC)), <span class="built_in">queue</span>, ^&#123;</div><div class="line">        makeCall(<span class="built_in">queue</span>, caller, callees);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        NSArray *house1Folks = @[@<span class="string">"小明"</span>, @<span class="string">"小华"</span>, @<span class="string">"小希"</span>];</div><div class="line">        NSArray *house2Folks = @[@<span class="string">"大明"</span>, @<span class="string">"大华"</span>, @<span class="string">"大希"</span>];</div><div class="line">        </div><div class="line">        <span class="comment">// 创建并发队列，用于执行block</span></div><div class="line">        <span class="keyword">dispatch_queue_t</span> house1Queue = dispatch_queue_create(<span class="string">"com.jiji.concurrent"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">        </div><div class="line">        <span class="comment">// 创建串行队列，作为并发队列的目标队列</span></div><div class="line">        <span class="keyword">dispatch_queue_t</span> targetQueue = dispatch_queue_create(<span class="string">"com.jiji.targetQueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">        dispatch_set_target_queue(house1Queue, targetQueue);</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (NSString *caller in house1Folks) &#123;</div><div class="line">            dispatch_async(house1Queue, ^&#123;</div><div class="line">                makeCall(house1Queue, caller, house2Folks);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 使主队列不返回</span></div><div class="line">        [[NSRunLoop currentRunLoop] run];</div><div class="line"><span class="comment">//        dispatch_main(); // Xcode都无法结束调试</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<blockquote>
<p>2019-01-28 11:09:09.259488+0800 GCDTest[92057:9310107] 小明 正在呼叫 大明…<br>2019-01-28 11:09:10.260182+0800 GCDTest[92057:9310107] 小明 与 大明 呼叫完毕！<br>2019-01-28 11:09:10.260306+0800 GCDTest[92057:9310107] 小华 正在呼叫 大希…<br>2019-01-28 11:09:11.262624+0800 GCDTest[92057:9310107] 小华 与 大希 呼叫完毕！<br>2019-01-28 11:09:11.262751+0800 GCDTest[92057:9310107] 小希 正在呼叫 大希…<br>2019-01-28 11:09:12.264263+0800 GCDTest[92057:9310107] 小希 与 大希 呼叫完毕！</p>
</blockquote>
<p>使用目标队列，在本例中，通过将串行队列设置为house1Queue的目标队列，将本来在并发队列中对于block的无序执行变为了串行执行。故<em>dispatch_set_target_queue</em>可以将原队列的优先级设置为与目标队列相同，在这里即变为了串行执行。而由于自定义的串行队列默认的目标为全局并发队列，故实际上block是在全局队列中重进进队并执行。</p>
<h5 id="4-2-使指定串行队列作为多个队列的共同目标"><a href="#4-2-使指定串行队列作为多个队列的共同目标" class="headerlink" title="4.2 使指定串行队列作为多个队列的共同目标"></a>4.2 使指定串行队列作为多个队列的共同目标</h5><p>这样设置，可以将子队列设置为同级（实质优先级相同，且执行block时都在目标队列中）。</p>
<h5 id="4-3-现实当中的应用"><a href="#4-3-现实当中的应用" class="headerlink" title="4.3 现实当中的应用"></a>4.3 现实当中的应用</h5><ul>
<li><strong>设置多个目标队列目标为一个串行队列，可以让你在多线程环境下，执行任务时变得有序可控</strong>。也就是这里所说的“同一时刻只做一件事”：如数据库访问、硬盘读写或其他硬件资源的访问等。</li>
<li>当需要在一大堆不同类型的事件资源中进行有序处理，比如“同一时间只做一件事”时，这种模式也非常有用。如，处理定时器、网络事件或文件系统活动等。</li>
<li>当处理不同框架的不同事件时，在你不方便修改源代码时，使用此模式可能也能解决问题。</li>
</ul>
<p>注意：</p>
<ul>
<li>对于必须并发执行的操作，使用这种模式时会发生死锁。</li>
<li><strong>一般来说，直接在串行队列中使用<em>dispatch_async</em>派发block即可代替本模式。</strong></li>
</ul>
<h4 id="5-Writing-Thread-Safe-Classes-with-GCD"><a href="#5-Writing-Thread-Safe-Classes-with-GCD" class="headerlink" title="5. Writing Thread-Safe Classes with GCD"></a>5. Writing Thread-Safe Classes with GCD</h4><blockquote>
<p>线程安全，<em>一般来说，在GCD中都需要使用串行队列或者在并发队列中的派发执行栅栏任务</em>。故一定需要记住一点：<strong>线程安全是以牺牲性能为代价的，一定不要滥用。</strong></p>
</blockquote>
<p>使用GCD实现线程安全的类，需要在内部设置上述二者之一的队列。作者以串行队列为例，并以优雅的封装方式进行了阐述。直接贴完整代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">// 头文件（公共API中没有任何需要调用者额外注意的事件）</div><div class="line"></div><div class="line">@interface Warrior: NSObject</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSString *leftHandEquippedItem;</div><div class="line">@property (nonatomic, strong) NSString *rightHandEquippedItem;</div><div class="line"></div><div class="line">- (void)swapLeftAndRightHandEquippedItems;</div><div class="line">- (NSString *)juggleNewItem:(NSString *)item; // return dropped item</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// 实现文件</div><div class="line"></div><div class="line">@interface Warrior()</div><div class="line"></div><div class="line">/** 串行队列，线程安全的基础 */</div><div class="line">@property (nonatomic, strong) dispatch_queue_t memberQueue;</div><div class="line">/** 线程安全的内部版本，该命名方式表明需要在队列中使用 */</div><div class="line">@property (nonatomic, strong) NSString *memberQueueLeftHandEquippedItem;</div><div class="line">/** 线程安全的内部版本，该命名方式表明需要在队列中使用 */</div><div class="line">@property (nonatomic, strong) NSString *memberQueueRightHandEquippedItem;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Warrior</div><div class="line"></div><div class="line">- (id)init &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        // 由于队列对象非常“轻”，实例化时可放心创建</div><div class="line">        _memberQueue = dispatch_queue_create("Queue", DISPATCH_QUEUE_SERIAL);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// private的setter（由于内部版本需要在队列中使用，故直接赋值即可）</div><div class="line"></div><div class="line">- (void)setMemberQueueLeftHandEquippedItem:(NSString *)item &#123;</div><div class="line">    NSLog(@"Left hand now holds %@", item);</div><div class="line">    _memberQueueLeftHandEquippedItem = item;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setMemberQueueRightHandEquippedItem:(NSString *)item &#123;</div><div class="line">    NSLog(@"Right hand now holds %@", item);</div><div class="line">    _memberQueueRightHandEquippedItem = item;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// public的getter（外部API的实现是调用的内部版本，需要在队列中使用，保证线程安全）</div><div class="line"></div><div class="line">- (NSString *)leftHandEquippedItem &#123;</div><div class="line">    __block NSString *retval;</div><div class="line">    dispatch_sync(self.memberQueue, ^&#123;</div><div class="line">        retval = self.memberQueueLeftHandEquippedItem;</div><div class="line">    &#125;);</div><div class="line">    return retval;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)rightHandEquippedItem &#123;</div><div class="line">    __block NSString *retval;</div><div class="line">    dispatch_sync(self.memberQueue, ^&#123;</div><div class="line">        retval = self.memberQueueRightHandEquippedItem;</div><div class="line">    &#125;);</div><div class="line">    return retval;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// public的setter（外部API的实现是调用的内部版本，需要在队列中使用，保证线程安全）</div><div class="line"></div><div class="line">- (void)setLeftHandEquippedItem:(NSString *)item &#123;</div><div class="line">    dispatch_sync(self.memberQueue, ^&#123;</div><div class="line">        self.memberQueueLeftHandEquippedItem = item;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setRightHandEquippedItem:(NSString *)item &#123;</div><div class="line">    dispatch_sync(self.memberQueue, ^&#123;</div><div class="line">        self.memberQueueRightHandEquippedItem = item;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// private的method（由于内部版本需要在队列中使用，故直接赋值即可）</div><div class="line"></div><div class="line">- (void)memberQueueSwapLeftAndRightHandEquippedItems &#123;</div><div class="line">    NSString *oldLeftHandEquippedItem = self.memberQueueLeftHandEquippedItem;</div><div class="line">    self.memberQueueLeftHandEquippedItem = self.memberQueueRightHandEquippedItem;</div><div class="line">    self.memberQueueRightHandEquippedItem = oldLeftHandEquippedItem;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// public的method（外部API的实现是调用的内部版本，需要在队列中使用，保证线程安全）</div><div class="line"></div><div class="line">- (void)swapLeftAndRightHandEquippedItems &#123;</div><div class="line">    dispatch_sync(self.memberQueue, ^&#123;</div><div class="line">        [self memberQueueSwapLeftAndRightHandEquippedItems];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)juggleNewItem:(NSString *)item &#123;</div><div class="line">    __block NSString *retval;</div><div class="line">    // 这里再说一遍，由于在队列中执行，故block内直接使用内部版本的变量和方法</div><div class="line">    dispatch_sync(self.memberQueue, ^&#123;</div><div class="line">        retval = self.memberQueueRightHandEquippedItem;</div><div class="line">        self.memberQueueRightHandEquippedItem = item;</div><div class="line">        // 这里调用外部方法会导致死锁</div><div class="line">        [self memberQueueSwapLeftAndRightHandEquippedItems];</div><div class="line">    &#125;);</div><div class="line">    return retval;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>以上便实现了一个“线程安全”类。其编码方式需要我们学习：</p>
<ul>
<li>外部API（即头文件的代码）的声明与普通类无异，使用者无需关心内部实现，直接使用即可。</li>
<li>内部实现文件中，将对应需要进行线程安全处理的属性和方法等单独声明并实现私有的版本，且在命名上进行区分（如代码中的“<em>memberQueue-</em>”前缀）：不仅增强了代码的可读性（根据命名即可知道是线程安全的版本）；还可以在当类的属性和方法增多，代码量增大时，保证类结构的清晰。</li>
<li>除了init和dealloc等方法中，尽量不要直接使用实例变量ivar，保证代码的风格统一，可读性不变。</li>
</ul>
<h4 id="6-Keeping-Things-Straight-with-GCD"><a href="#6-Keeping-Things-Straight-with-GCD" class="headerlink" title="6. Keeping Things Straight with GCD"></a>6. Keeping Things Straight with GCD</h4><h5 id="6-1-设计线程安全的类或库"><a href="#6-1-设计线程安全的类或库" class="headerlink" title="6.1 设计线程安全的类或库"></a>6.1 设计线程安全的类或库</h5><ul>
<li><p>设计线程安全的类或者库时，要把“线程安全”的细节设置到实现文件中，头文件或公有API中不要有相关体现（如线程和队列等）。</p>
</li>
<li><p>若整个库中的多个类都需要保证“线程安全”，使用同一个串行队列一般即可保证性能。如将此队列设置为私有的公共单例对象：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Bank_Private.h</span></div><div class="line"><span class="keyword">dispatch_queue_t</span> memberQueue();</div><div class="line"></div><div class="line"><span class="comment">// Bank.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"Bank_Private.h"</span></span></div><div class="line"><span class="keyword">dispatch_queue_t</span> memberQueue() &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"member queue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在设计“线程安全”的类或者库时，若要时刻保证调用正确，结构清晰，且不出现死锁或数据竞争的情况。需要遵循三条命名原则：<ol>
<li>必须在队列内访问的变量或方法，其命名必须以该队列的名称做前缀。</li>
<li>向队列中派发的block，其内部只能访问那些以队列前缀命名的变量或方法。</li>
<li>在“前缀”命名的方法中，只能访问带有同样前缀的变量或方法。</li>
</ol>
</li>
</ul>
<h5 id="6-2-使用单个队列的简易性"><a href="#6-2-使用单个队列的简易性" class="headerlink" title="6.2 使用单个队列的简易性"></a>6.2 使用单个队列的简易性</h5><h6 id="6-2-1-创建“读写锁”"><a href="#6-2-1-创建“读写锁”" class="headerlink" title="6.2.1 创建“读写锁”"></a>6.2.1 创建“读写锁”</h6><p>“读写锁”，即“随意读取，写入保护”。在创建时，可以设置两个带有前缀的方法，如“memberQueue<em>”和“memberQueueMutating</em>”。前者只能读取变量的值或调用无修改功能的方法，后者可以对变量进行读写或调用任意方法（包括可修改数据的方法）。</p>
<ul>
<li>“memberQueue_”前缀的方法，内部可以随意使用<em>dispatch_sync</em>或是<em>dispatch_async</em>进行配置；</li>
<li>“memberQueueMutating_”前缀的方法，内部必须使用<em>dispatch_barrier_sync</em>或是<em>dispatch_barrier_async</em>进行配置。</li>
</ul>
<h6 id="6-2-2-不要使用多个，嵌套的队列"><a href="#6-2-2-不要使用多个，嵌套的队列" class="headerlink" title="6.2.2 不要使用多个，嵌套的队列"></a>6.2.2 不要使用多个，嵌套的队列</h6><ul>
<li>自己的类的结构中，最多只需要一个串行队列即可。</li>
<li>一般来说，如果在一个类中，在需要使用多个串行队列来实现一个功能时，出于性能考虑，可以直接单独使用一个并发队列来进行替换。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇是&lt;a href=&quot;https://www.humancode.us/2014/07/28/intro-to-gcd.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;a series about Grand Central Dispatch&lt;/a&gt;的学习记录。&lt;br&gt;原文共6篇，循序渐进地介绍了GCD的基本使用及相关规范。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>FDFullscreenPopGesture源码学习</title>
    <link href="http://yoursite.com/2019/01/26/FDFullscreenPopGesture%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/01/26/FDFullscreenPopGesture源码学习/</id>
    <published>2019-01-26T08:24:50.622Z</published>
    <updated>2019-01-26T08:24:50.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>首先附上项目地址：<br><a href="https://github.com/forkingdog/FDFullscreenPopGesture/tree/1.1" target="_blank" rel="external">FDFullscreenPopGesture</a><br>本篇使用1.1版本源码进行学习</p>
</blockquote>
<p>此项目以AOP的方式实现了UINavigationController的“一行代码实现全屏滑动返回”功能。其主要功能是通过<em>UINavigationController</em>内置的<em>interactivePopGestureRecognizer</em>手势对象。通过使用自定义的UIPanGestureRecognizer类实例绑定原手势的<em>action</em>及<em>SEL</em>，使响应范围扩大到整个屏幕，巧妙地实现了此功能。详细解释可以查看原博客<a href="https://www.jianshu.com/p/d39f7d22db6c" target="_blank" rel="external">轻松学习之二——iOS利用Runtime自定义控制器POP手势动画</a>或本人的读后解析<a href="https://www.jianshu.com/p/3ed067b2620b" target="_blank" rel="external">UINavigationController的全屏拖动返回
</a>。</p>
<a id="more"></a>
<h4 id="1-主要结构说明"><a href="#1-主要结构说明" class="headerlink" title="1. 主要结构说明"></a>1. 主要结构说明</h4><p>整个项目非常简单，对外只有一组.h及.m文件。代码量也只有区区两三百行，足够轻量且高效，值得我等膜拜学习~</p>
<h5 id="1-1-头文件的结构说明"><a href="#1-1-头文件的结构说明" class="headerlink" title="1.1 头文件的结构说明"></a>1.1 头文件的结构说明</h5><p>项目对外公开的类及主要功能为：</p>
<ul>
<li>UINavigationController的扩展类：<em>UINavigationController + FDFullscreenPopGesture</em></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>fd_fullscreenPopGestureRecognizer</em></td>
<td>属性</td>
<td>真正的全屏拖动响应的手势对象</td>
</tr>
<tr>
<td><em>fd_viewControllerBasedNavigationBarAppearanceEnabled</em></td>
<td>属性</td>
<td>是否允许ViewController对象自定义导航栏外观（默认为YES）</td>
</tr>
</tbody>
</table>
<ul>
<li>UIViewController的扩展类：<em>UIViewController + FDFullscreenPopGesture</em></li>
</ul>
<blockquote>
<p>主要用于ViewController对象自主控制全屏手势的使能（以便ViewController的视图也处理自定义的拖动手势，防止手势冲突）</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fd_interactivePopDisabled</td>
<td>属性</td>
<td>是否允许响应UINavigationController的全屏拖动手势</td>
</tr>
<tr>
<td>fd_prefersNavigationBarHidden</td>
<td>属性</td>
<td>表名当前ViewController对象的导航栏是否隐藏（默认为NO）</td>
</tr>
</tbody>
</table>
<h5 id="1-2-实现文件的结构说明"><a href="#1-2-实现文件的结构说明" class="headerlink" title="1.2 实现文件的结构说明"></a>1.2 实现文件的结构说明</h5><ul>
<li>遵循<em>UIGestureRecognizerDelegate</em>协议的类：_FDFullscreenPopGestureRecognizerDelegate</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>navigationController</td>
<td>weak属性</td>
<td>内部需要根据导航器对象做处理</td>
</tr>
</tbody>
</table>
<blockquote>
<p>内部实现了<em>gestureRecognizerShouldBegin:</em>方法，用于处理不同情况下是否响应拖动手势。<br>设计此类的主要目的是将此功能独立出来，作为<em>UINavigationController + FDFullscreenPopGesture</em>的工具类使用，简化了原类代码，使结构更加清晰。</p>
</blockquote>
<ul>
<li>UIViewController的私有扩展类：<em>UIViewController + FDFullscreenPopGesturePrivate</em></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fd_willAppearInjectBlock</td>
<td>block对象，属性</td>
<td>保存注入的block对象到堆内存，等待合适时机执行【按命名来说，在ViewWillAppear方法中执行】</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在运行时交换了<em>ViewWillAppear:</em>方法实现，在其中注入执行了block对象。</p>
</blockquote>
<ul>
<li><em>UINavigationController + FDFullscreenPopGesture</em>的实现</li>
</ul>
<blockquote>
<p>交换了<em>pushViewController:animated:</em>方法实现，在内部实现了主要功能：</p>
<ol>
<li>使用自定义的UIPanGestureRecognizer对象绑定了原有手势的<em>action</em>和<em>SEL</em>，添加到UINavigationController的切换控制视图上。</li>
<li>声明并实现了注入的<em>_FDViewControllerWillAppearInjectBlock</em>对象，并赋值给指定的UIViewController对象。</li>
</ol>
</blockquote>
<ul>
<li><em>UIViewController + FDFullscreenPopGesture</em>的实现</li>
</ul>
<blockquote>
<p>只是对扩展中声明的属性进行实现。</p>
</blockquote>
<h4 id="2-使用Category扩展原类，并向指定方法注入新的功能"><a href="#2-使用Category扩展原类，并向指定方法注入新的功能" class="headerlink" title="2. 使用Category扩展原类，并向指定方法注入新的功能"></a>2. 使用Category扩展原类，并向指定方法注入新的功能</h4><p>在OC中，一般是通过Category对Class进行扩展的方式来实现AOP的。本项目即是如此。例如，通过对UINavigationController进行扩展，在load时对方法进行替换，将手势添加到导航器控制视图上，并绑定上原来的<em>target</em>和<em>SEL</em>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 交换push方法实现，用于执行自定义操作</span></div><div class="line">    Method originalMethod = class_getInstanceMethod(self, @selector(pushViewController:animated:));</div><div class="line">    Method swizzledMethod = class_getInstanceMethod(self, @selector(fd_pushViewController:animated:));</div><div class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)fd_pushViewController:(UIViewController *)viewController animated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 检查导航器的切换视图中的手势数组中，是否已经包含全屏拖动手势对象</span></div><div class="line">    <span class="keyword">if</span> (![self.interactivePopGestureRecognizer.view.gestureRecognizers containsObject:self.fd_fullscreenPopGestureRecognizer]) &#123;</div><div class="line">        <span class="comment">// 没有，则向其中添加自定义的拖拽手势</span></div><div class="line">        [self.interactivePopGestureRecognizer.view addGestureRecognizer:self.fd_fullscreenPopGestureRecognizer];</div><div class="line"></div><div class="line">        <span class="comment">// 通过查看运行时期间，手势对象内部的存储结构，获取原手势响应的target和执行的SEL</span></div><div class="line">        NSArray *internalTargets = [self.interactivePopGestureRecognizer valueForKey:@<span class="string">"targets"</span>];</div><div class="line">        id internalTarget = [internalTargets.firstObject valueForKey:@<span class="string">"target"</span>];</div><div class="line">        SEL internalAction = NSSelectorFromString(@<span class="string">"handleNavigationTransition:"</span>);</div><div class="line">        <span class="comment">// 设置自定义的拖拽手势代理，处理不同情况下手势是否响应（故上面的类用于解耦手势的代理方法实现，简化本类代码）</span></div><div class="line">        self.fd_fullscreenPopGestureRecognizer.delegate = self.fd_popGestureRecognizerDelegate;</div><div class="line">        <span class="comment">// 将原手势的action和SEL绑定到自定义的拖拽手势中</span></div><div class="line">        [self.fd_fullscreenPopGestureRecognizer addTarget:internalTarget action:internalAction];</div><div class="line"></div><div class="line">        <span class="comment">// 禁止原手势响应（原手势为边缘拖动手势）</span></div><div class="line">        self.interactivePopGestureRecognizer.enabled = NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 处理自定义导航栏外观</span></div><div class="line">    [self fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:viewController];</div><div class="line">    </div><div class="line">    [self fd_pushViewController:viewController animated:animated];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此实现，即可在引入头文件后，对应的UINavigationController实例自动添加全屏返回手势，对原类的耦合性降至最低。</p>
<p>本项目中，UIViewController的扩展也使用了此方式，以达到在<em>ViewWillAppear:</em>方法中执行注入block，实现运行时对导航栏隐藏设置的修改。充分利用了OC语言的动态性，使代码简洁易用，降低耦合。</p>
<h4 id="3-防止block对self捕获产生的引用循环，并保证block执行时的完整性"><a href="#3-防止block对self捕获产生的引用循环，并保证block执行时的完整性" class="headerlink" title="3. 防止block对self捕获产生的引用循环，并保证block执行时的完整性"></a>3. 防止block对self捕获产生的引用循环，并保证block执行时的完整性</h4><p>在<em>fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:</em>方法中，作者初始化了UIViewController对象在<em>ViewWillAppear:</em>方法中需要注入的block。先看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:(UIViewController *)appearingViewController</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 检查ViewController对象是否允许自定义导航栏外观</span></div><div class="line">    <span class="keyword">if</span> (!self.fd_viewControllerBasedNavigationBarAppearanceEnabled) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 声明self弱指针</span></div><div class="line">    __<span class="function">weak <span class="title">typeof</span><span class="params">(self)</span> weakSelf </span>= self;</div><div class="line">    <span class="comment">// 声明并实现注入的block对象</span></div><div class="line">    _FDViewControllerWillAppearInjectBlock block = ^(UIViewController *viewController, BOOL animated) &#123;</div><div class="line">        <span class="comment">// block内部捕获的是self的弱指针，不会对self进行强引用</span></div><div class="line">        __strong typeof(weakSelf) strongSelf = weakSelf;</div><div class="line">        <span class="keyword">if</span> (strongSelf) &#123;</div><div class="line">            <span class="comment">// 根据外部设置，隐藏或显示当前ViewController下的导航栏</span></div><div class="line">            [strongSelf setNavigationBarHidden:viewController.fd_prefersNavigationBarHidden animated:animated];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="comment">// 将block对象赋值给扩展后的ViewController对象（适时调用）</span></div><div class="line">    appearingViewController.fd_willAppearInjectBlock = block;</div><div class="line">    <span class="comment">// 获取导航栈的最后一个ViewController（即当前已显示的，马上要被新的ViewController压到栈中的）</span></div><div class="line">    UIViewController *disappearingViewController = self.viewControllers.lastObject;</div><div class="line">    <span class="keyword">if</span> (disappearingViewController &amp;&amp; !disappearingViewController.fd_willAppearInjectBlock) &#123;</div><div class="line">        <span class="comment">// 即将消失的ViewController若存在（即新push的ViewController不是根视图的情况），也将block赋值给它（以备pop时，前一个ViewController对象也能执行block，viewWillAppear时修改导航栏外观）</span></div><div class="line">        disappearingViewController.fd_willAppearInjectBlock = block;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，最为重要的是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// block外部声明</span></div><div class="line">__<span class="function">weak <span class="title">typeof</span><span class="params">(self)</span> weakSelf </span>= self;</div><div class="line"></div><div class="line"><span class="comment">// block函数体内部声明</span></div><div class="line"> __<span class="function">strong <span class="title">typeof</span><span class="params">(weakSelf)</span> strongSelf </span>= weakSelf;</div></pre></td></tr></table></figure>
<p>我们都知道，使用<strong>weak修饰的OC对象，可以防止</strong>NSMallocBlock对象在捕获时对其添加强引用（详见<a href="https://www.jianshu.com/p/46ed0de020f0" target="_blank" rel="external">《Objective-C高级编程 iOS与OS X多线程与内存管理》16</a>），避免产生引用循环。但是这样有一个弊端，就是假设当self释放后，若block在此时执行，self对象自动置为nil，预定的功能可能就无法正常实现了。为了防止这种情况发生，可以<strong>声明一个<strong>strong修饰的局部指针变量，指向捕获的弱对象，既可以保证在block执行过程中self不被释放，还可以避免对self进行强引用（</strong>strong变量会在作用域外被自动release）</strong>。</p>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><ul>
<li>FDFullscreenPopGesture主要通过Category的方式对UINavigationController和UIViewController进行功能扩展，避免了Class继承方式的“笨重”，简化了引入和使用。</li>
<li>在Category的load方法中，替换了原类的方法实现（原类的load加载要在扩展类之前），在其中注入了指定功能。</li>
<li>使用KVC的方式，巧妙地进行UIGestureRecognizer对象的替换，近乎“无损”地实现了全屏滑动返回功能，避免了使用传统的交互式动画方式实现自定义的UINavigationController。</li>
<li>使用<strong>weak对象避免block的引用循环，并用</strong>strong对象保证block执行过程中捕获对象不被释放。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;首先附上项目地址：&lt;br&gt;&lt;a href=&quot;https://github.com/forkingdog/FDFullscreenPopGesture/tree/1.1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FDFullscreenPopGesture&lt;/a&gt;&lt;br&gt;本篇使用1.1版本源码进行学习&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此项目以AOP的方式实现了UINavigationController的“一行代码实现全屏滑动返回”功能。其主要功能是通过&lt;em&gt;UINavigationController&lt;/em&gt;内置的&lt;em&gt;interactivePopGestureRecognizer&lt;/em&gt;手势对象。通过使用自定义的UIPanGestureRecognizer类实例绑定原手势的&lt;em&gt;action&lt;/em&gt;及&lt;em&gt;SEL&lt;/em&gt;，使响应范围扩大到整个屏幕，巧妙地实现了此功能。详细解释可以查看原博客&lt;a href=&quot;https://www.jianshu.com/p/d39f7d22db6c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;轻松学习之二——iOS利用Runtime自定义控制器POP手势动画&lt;/a&gt;或本人的读后解析&lt;a href=&quot;https://www.jianshu.com/p/3ed067b2620b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UINavigationController的全屏拖动返回
&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UINavigationController的全屏拖动返回</title>
    <link href="http://yoursite.com/2019/01/25/UINavigationController%E7%9A%84%E5%85%A8%E5%B1%8F%E6%8B%96%E5%8A%A8%E8%BF%94%E5%9B%9E/"/>
    <id>http://yoursite.com/2019/01/25/UINavigationController的全屏拖动返回/</id>
    <published>2019-01-25T06:44:59.235Z</published>
    <updated>2019-01-25T06:44:59.235Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>我们知道，导航控制器的边缘返回功能使用的是“<em>UIScreenEdgePanGestureRecognizer</em>”类配合交互式动画进行实现。</p>
<p>想要使用全屏滑动返回，可以通过两种方式进行实现：</p>
<ol>
<li>通过苹果提供的交互式动画方式，提供动画对象和交互对象，使用UIPanGestureRecognizer对象控制交互动画的过程，实现全屏滑动返回。</li>
<li>使用自定义的UIPanGestureRecognizer对象通过KVC的方式“替换”掉原来的UIScreenEdgePanGestureRecognizer对象，使我们可以通过拖拽手势触发导航控制器原交互方法，以达到目的。</li>
</ol>
<p>这里只第二种情况进行学习总结。<br><a id="more"></a></p>
</blockquote>
<p>注意：本文为<a href="https://www.jianshu.com/p/d39f7d22db6c" target="_blank" rel="external">轻松学习之二——iOS利用Runtime自定义控制器POP手势动画</a>的读后总结，感叹作者思路之妙。</p>
<h4 id="1-查看手势响应对象的存储方式"><a href="#1-查看手势响应对象的存储方式" class="headerlink" title="1. 查看手势响应对象的存储方式"></a>1. 查看手势响应对象的存储方式</h4><p>我们知道，手势触发是通过“<em>target-action</em>”方式进行。若想要进行手势替换，就需要了解手势是如何在UIGesture类内进行存储的。故我们先通过runtime的API对其一探究竟：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ivarCount = <span class="number">0</span>;</div><div class="line"><span class="comment">// 指向Ivar对象数组的头指针</span></div><div class="line">Ivar *ivarList = class_copyIvarList([UIGestureRecognizer class], &amp;ivarCount);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ivarCount; i++) &#123;</div><div class="line">    Ivar ivar = ivarList[i];</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(ivar);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type = ivar_getTypeEncoding(ivar);</div><div class="line">    </div><div class="line">    NSLog(@<span class="string">"name = %s, type = %s"</span>, name, type);</div><div class="line">    </div><div class="line">    <span class="comment">// 有效数据为： NSMutableArray *_targets</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">free</span>(ivarList);</div></pre></td></tr></table></figure>
<p>通过读取<em>UIGestureRecognizer</em>类的实例对象列表，可以查到，所有的手势响应的对象为类型为<em>NSMutableArray</em>的名为“<em>_targets</em>”的私有变量中。而对于内部真正对象的存储方式，我们需要在<em>UIGestureRecognizer</em>的实例中查看。现在，我们随意在UIView实例上添加一个手势，并通过以下方式查看我们定义的<em>target</em>和<em>action</em>是如何存储的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(lldb) po [ges valueForKey:@<span class="string">"_targets"</span>]</div><div class="line">&lt;__NSArrayM <span class="number">0x60000045e1b0</span>&gt;(</div><div class="line">(action=onGes:, target=&lt;DetailViewController <span class="number">0x7fd2f3e31fb0</span>&gt;)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>在debug时，我们可以看到<em>_target</em>数组内部为<em>target</em>和<em>action</em>组成的对象，在触发手势时，运行时系统就动态地向target发送action消息完成手势响应。且由于”_targets”是数组类型，可以在运行期间动态修改内部数据。这也就为我们实现全屏手势提供了可能。</p>
<h4 id="2-探究导航控制器的返回手势"><a href="#2-探究导航控制器的返回手势" class="headerlink" title="2. 探究导航控制器的返回手势"></a>2. 探究导航控制器的返回手势</h4><p>现在，我们转回到导航控制器中，使用同样方式查看其手势实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取导航控制器的交互手势对象</span></div><div class="line">UIGestureRecognizer *originGesture = self.navigationController.interactivePopGestureRecognizer;</div><div class="line"></div><div class="line"><span class="comment">// 取出存储的响应信息数组</span></div><div class="line">NSArray *targets = [originGesture valueForKey:@<span class="string">"_targets"</span>];</div></pre></td></tr></table></figure>
<p>通过调试，可以看到，内部执行的<em>target</em>和<em>action</em>对象如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(lldb) po [originGesture valueForKey:@<span class="string">"_targets"</span>]</div><div class="line">&lt;__NSArrayM <span class="number">0x604000450ec0</span>&gt;(</div><div class="line">(action=handleNavigationTransition:, target=&lt;_UINavigationInteractiveTransition <span class="number">0x7fd2f3c15fe0</span>&gt;)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>其中，<em>target</em>为私有类<em>_UINavigationInteractiveTransition</em>的实例，<em>action</em>为名为“<em>handleNavigationTransition:</em>”的SEL选择器。</p>
<h4 id="3-手势的替换"><a href="#3-手势的替换" class="headerlink" title="3. 手势的替换"></a>3. 手势的替换</h4><p>在上面，我们已经得到了边缘拖动时绑定的target和执行的SEL，现在我们只要利用runtime的动态性，将原手势与自定义的UIPanGestureRecognizer对象进行替换，使新手势绑定原<em>target</em>和<em>action</em>，并添加到原控制视图中，最后关闭原手势响应，即可完成神不知鬼不觉的“掉包”。完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">UIGestureRecognizer *originGesture = self.navigationController.interactivePopGestureRecognizer;</div><div class="line"><span class="comment">// 原始手势的绑定视图（并非当前视图）</span></div><div class="line">UIView *originGestureView = originGesture.view;</div><div class="line"><span class="comment">// 关闭原始手势</span></div><div class="line">originGesture.enabled = NO;</div><div class="line"></div><div class="line">NSArray *targets = [originGesture valueForKey:@<span class="string">"_targets"</span>];</div><div class="line">id target = targets[<span class="number">0</span>];</div><div class="line"></div><div class="line"><span class="comment">// 真正的触发对象</span></div><div class="line">id realTarget = [target valueForKey:@<span class="string">"_target"</span>];</div><div class="line"></div><div class="line"><span class="comment">// 真正的回调为名为“handleNavigationTransition:”的SEL</span></div><div class="line">SEL realAction = NSSelectorFromString(@<span class="string">"handleNavigationTransition:"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 使用自定义的全屏拖拽手势，使触发target和action均为原navigation的边缘手势，即扩大了手势响应范围。</span></div><div class="line">UIPanGestureRecognizer *gesture = [[UIPanGestureRecognizer alloc] initWithTarget:realTarget action:realAction];</div><div class="line">[originGestureView addGestureRecognizer:gesture];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们知道，导航控制器的边缘返回功能使用的是“&lt;em&gt;UIScreenEdgePanGestureRecognizer&lt;/em&gt;”类配合交互式动画进行实现。&lt;/p&gt;
&lt;p&gt;想要使用全屏滑动返回，可以通过两种方式进行实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过苹果提供的交互式动画方式，提供动画对象和交互对象，使用UIPanGestureRecognizer对象控制交互动画的过程，实现全屏滑动返回。&lt;/li&gt;
&lt;li&gt;使用自定义的UIPanGestureRecognizer对象通过KVC的方式“替换”掉原来的UIScreenEdgePanGestureRecognizer对象，使我们可以通过拖拽手势触发导航控制器原交互方法，以达到目的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里只第二种情况进行学习总结。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>MBProgressHUD源码学习2：实现方式简单分析</title>
    <link href="http://yoursite.com/2019/01/23/MBProgressHUD%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A02%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/01/23/MBProgressHUD源码学习2：实现方式简单分析/</id>
    <published>2019-01-23T10:40:09.240Z</published>
    <updated>2019-01-23T10:40:19.664Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>提要：</p>
<ol>
<li>“全能”实现方法；</li>
<li>“延后显示”和“最少显示时间”；</li>
<li>使用KVO更新UI；</li>
<li>使用通知方式处理自身视图的朝向变化；</li>
<li>总结<a id="more"></a>
<h3 id="1-“全能”实现方法"><a href="#1-“全能”实现方法" class="headerlink" title="1. “全能”实现方法"></a>1. “全能”实现方法</h3></li>
</ol>
</blockquote>
<p><strong>“全能”实现方法，即真正用于实现功能的方法</strong>。这一封装方式在MBProgressHUD.m中屡见不鲜。如“全能”初始化方法<em>initWithFrame</em>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 全能初始化方法 */</span></div><div class="line">- (id)initWithFrame:(CGRect)frame &#123;</div><div class="line">	self = [super initWithFrame:frame];</div><div class="line">	<span class="keyword">if</span> (self) &#123;</div><div class="line">		<span class="comment">// 各种属性初始值设置</span></div><div class="line">		...</div><div class="line">		</div><div class="line">        <span class="comment">// 初始化label</span></div><div class="line">		[self setupLabels];</div><div class="line">        <span class="comment">// 加载indicator</span></div><div class="line">		[self updateIndicators];</div><div class="line">        <span class="comment">// 注册KVO，将UI的属性修改绑定到一起</span></div><div class="line">		[self registerForKVO];</div><div class="line">        <span class="comment">// 注册屏幕朝向通知，自动旋转</span></div><div class="line">		[self registerForNotifications];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithView:(UIView *)view &#123;</div><div class="line">	NSAssert(view, @<span class="string">"View must not be nil."</span>);</div><div class="line">	<span class="keyword">return</span> [self initWithFrame:view.bounds];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithWindow:(UIWindow *)window &#123;</div><div class="line">	<span class="keyword">return</span> [self initWithView:window];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在以上代码中，可以看出，外部API使用的初始化最终都是通过调用<em>initWithFrame</em>方法完成的。该方法的主要功能如下：</p>
<ul>
<li>提供了主要属性的初始赋值；</li>
<li>对用于显示信息的的UILabel对象进行初始化，真正的布局在layoutSubView中进行处理；</li>
<li>根据mode属性，对不同类型的indicator视图对象进行初始化；</li>
<li>通过KVO，将用于更新UI的相关属性进行统一配置；</li>
<li>使用通知，监听系统屏幕转向消息，配置视图转向重绘方法。</li>
</ul>
<blockquote>
<p>类似的封装方式，在本类中还体现在：</p>
<ol>
<li>如线程block的任务配置api中，<em>showAnimated:whileExecutingBlock:onQueue:completionBlock:</em>方法作为真正的实现方法，其余均为本方法的不同调用版本。</li>
<li>显示和隐藏HUD方法，分别通过<em>showUsingAnimation:</em>和<em>hideUsingAnimation:</em>方法进行真正的功能实现。</li>
</ol>
<p>这种封装方式的好处是使实现代码集中，便于管理，且不易出错。</p>
</blockquote>
<h3 id="2-“延后显示”和“最少显示时间”"><a href="#2-“延后显示”和“最少显示时间”" class="headerlink" title="2. “延后显示”和“最少显示时间”"></a>2. “延后显示”和“最少显示时间”</h3><ol>
<li>MBProgressHUD中，存在<em>graceTime</em>这一属性，其意义为“延迟一定的时间显示HUD”。即当任务运行时间过短的情况下，防止“闪烁”情况发生（HUD刚刚显示就隐藏）。此值需要我们手动设置，默认为0。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 显示自身 */</span></div><div class="line">- (<span class="keyword">void</span>)show:(BOOL)animated &#123;</div><div class="line">	useAnimation = animated;</div><div class="line">	<span class="comment">// 设置了graceTime后，就会延时显示了</span></div><div class="line">	<span class="keyword">if</span> (self.graceTime &gt; <span class="number">0.0</span>) &#123;</div><div class="line">		self.graceTimer = [NSTimer scheduledTimerWithTimeInterval:self.graceTime target:self </div><div class="line">						   selector:@selector(handleGraceTimer:) userInfo:nil repeats:NO];</div><div class="line">	&#125; </div><div class="line">	<span class="comment">// 直接显示</span></div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		[self showUsingAnimation:useAnimation];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)handleGraceTimer:(NSTimer *)theTimer &#123;</div><div class="line">	<span class="comment">// 任务执行期间，才会显示；否则就不必显示HUD了</span></div><div class="line">	<span class="keyword">if</span> (taskInProgress) &#123;</div><div class="line">		[self showUsingAnimation:useAnimation];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>代码中还存在<em>minShowTime</em>这一属性，即“最小显示时长”。用于在HUD隐藏时，当少于指定显示时长时延迟消失时机，防止“闪烁”情况发生：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 隐藏自身 */</span></div><div class="line">- (<span class="keyword">void</span>)hide:(BOOL)animated &#123;</div><div class="line">	useAnimation = animated;</div><div class="line">    <span class="comment">// 存在最小显示时长，并且HUD已经在显示（showStarted中保存了显示时刻）</span></div><div class="line">	<span class="keyword">if</span> (self.minShowTime &gt; <span class="number">0.0</span> &amp;&amp; showStarted) &#123;</div><div class="line">        <span class="comment">// 计算已显示时长</span></div><div class="line">		NSTimeInterval interv = [[NSDate date] timeIntervalSinceDate:showStarted];</div><div class="line">		<span class="keyword">if</span> (interv &lt; self.minShowTime) &#123;</div><div class="line">            <span class="comment">// 小于最小显示时长，则补齐时长后，执行隐藏功能（防止过早隐藏，出现闪烁）</span></div><div class="line">			self.minShowTimer = [NSTimer scheduledTimerWithTimeInterval:(self.minShowTime - interv) target:self </div><div class="line">								selector:@selector(handleMinShowTimer:) userInfo:nil repeats:NO];</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125; </div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 直接隐藏</span></div><div class="line">	[self hideUsingAnimation:useAnimation];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)handleMinShowTimer:(NSTimer *)theTimer &#123;</div><div class="line">	[self hideUsingAnimation:useAnimation];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-使用KVO更新UI"><a href="#3-使用KVO更新UI" class="headerlink" title="3. 使用KVO更新UI"></a>3. 使用KVO更新UI</h3><p>对于MBProgressHUD中过于繁杂的各种配置属性（如mode、progress、各种文字及样式颜色等），设置后都需要进行UI更新。为了进行统一管理，且降低代码复杂程度，源码中使用了KVO的方式进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)registerForKVO &#123;</div><div class="line">    <span class="comment">// 依次设置需要的实例变量为KVO</span></div><div class="line">	<span class="keyword">for</span> (NSString *keyPath in [self observableKeypaths]) &#123;</div><div class="line">		[self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:<span class="literal">NULL</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSArray *)observableKeypaths &#123;</div><div class="line">    <span class="comment">// 返回所有需要设置为KVO的实例变量</span></div><div class="line">	<span class="keyword">return</span> [NSArray arrayWithObjects:@<span class="string">"mode"</span>, @<span class="string">"customView"</span>, @<span class="string">"labelText"</span>, @<span class="string">"labelFont"</span>, @<span class="string">"labelColor"</span>,</div><div class="line">			@<span class="string">"detailsLabelText"</span>, @<span class="string">"detailsLabelFont"</span>, @<span class="string">"detailsLabelColor"</span>, @<span class="string">"progress"</span>, @<span class="string">"activityIndicatorColor"</span>, nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    <span class="comment">// 由于所有KVO监听的实例变量均为UI相关，确保在主线程设置</span></div><div class="line">	<span class="keyword">if</span> (![NSThread isMainThread]) &#123;</div><div class="line">		[self performSelectorOnMainThread:@selector(updateUIForKeypath:) withObject:keyPath waitUntilDone:NO];</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		[self updateUIForKeypath:keyPath];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)updateUIForKeypath:(NSString *)keyPath &#123;</div><div class="line">    <span class="comment">// 统一进行属性设置</span></div><div class="line">	<span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"mode"</span>] || [keyPath isEqualToString:@<span class="string">"customView"</span>] ||</div><div class="line">		[keyPath isEqualToString:@<span class="string">"activityIndicatorColor"</span>]) &#123;</div><div class="line">		[self updateIndicators];</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"labelText"</span>]) &#123;</div><div class="line">		label.text = self.labelText;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"labelFont"</span>]) &#123;</div><div class="line">		label.font = self.labelFont;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"labelColor"</span>]) &#123;</div><div class="line">		label.textColor = self.labelColor;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"detailsLabelText"</span>]) &#123;</div><div class="line">		detailsLabel.text = self.detailsLabelText;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"detailsLabelFont"</span>]) &#123;</div><div class="line">		detailsLabel.font = self.detailsLabelFont;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"detailsLabelColor"</span>]) &#123;</div><div class="line">		detailsLabel.textColor = self.detailsLabelColor;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:@<span class="string">"progress"</span>]) &#123;</div><div class="line">		<span class="keyword">if</span> ([indicator respondsToSelector:@selector(setProgress:)]) &#123;</div><div class="line">			[(id)indicator setValue:@(progress) forKey:@<span class="string">"progress"</span>];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">    <span class="comment">// 设置完成后，更新布局（label等）并重绘界面（progress等）</span></div><div class="line">	[self setNeedsLayout];</div><div class="line">	[self setNeedsDisplay];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>通过<em>updateUIForKeypath:</em>方法，统一对所有UI相关修改进行属性设置，并在最后统一绘制并刷新布局，完成UI更新。</p>
</blockquote>
<p>移除KVO监听时，使用同样的方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)unregisterFromKVO &#123;</div><div class="line">    <span class="comment">// 依次移除KVO监听</span></div><div class="line">	<span class="keyword">for</span> (NSString *keyPath in [self observableKeypaths]) &#123;</div><div class="line">		[self removeObserver:self forKeyPath:keyPath];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSArray *)observableKeypaths &#123;</div><div class="line">    <span class="comment">// 返回所有需要设置为KVO的实例变量</span></div><div class="line">	<span class="keyword">return</span> [NSArray arrayWithObjects:@<span class="string">"mode"</span>, @<span class="string">"customView"</span>, @<span class="string">"labelText"</span>, @<span class="string">"labelFont"</span>, @<span class="string">"labelColor"</span>,</div><div class="line">			@<span class="string">"detailsLabelText"</span>, @<span class="string">"detailsLabelFont"</span>, @<span class="string">"detailsLabelColor"</span>, @<span class="string">"progress"</span>, @<span class="string">"activityIndicatorColor"</span>, nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-使用通知方式处理自身视图的朝向变化"><a href="#4-使用通知方式处理自身视图的朝向变化" class="headerlink" title="4. 使用通知方式处理自身视图的朝向变化"></a>4. 使用通知方式处理自身视图的朝向变化</h3><p>在设备朝向发生改变时，通过监听系统通知事件（<em>UIApplicationDidChangeStatusBarOrientationNotification</em>），重绘自身，以适应视图转向：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)registerForNotifications &#123;</div><div class="line">	NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];</div><div class="line">    <span class="comment">// 监听屏幕旋转消息</span></div><div class="line">	[nc addObserver:self selector:@selector(statusBarOrientationDidChange:)</div><div class="line">			   name:UIApplicationDidChangeStatusBarOrientationNotification object:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)unregisterFromNotifications &#123;</div><div class="line">	NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];</div><div class="line">	[nc removeObserver:self name:UIApplicationDidChangeStatusBarOrientationNotification object:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)statusBarOrientationDidChange:(NSNotification *)notification &#123;</div><div class="line">	UIView *superview = self.superview;</div><div class="line">	<span class="keyword">if</span> (!superview) &#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 依附于父视图上，则进行自身更新</span></div><div class="line">		[self updateForCurrentOrientationAnimated:YES];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)updateForCurrentOrientationAnimated:(BOOL)animated &#123;</div><div class="line">    <span class="comment">// Stay in sync with the superview in any case</span></div><div class="line">    <span class="keyword">if</span> (self.superview) &#123;</div><div class="line">        <span class="comment">// 自身尺寸为转向后的父视图尺寸</span></div><div class="line">        self.bounds = self.superview.bounds;</div><div class="line">        <span class="comment">// 重绘自身，更新为新样式</span></div><div class="line">        [self setNeedsDisplay];</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ol>
<li><strong>高效统一的UI更新</strong>：由于源码中将视图组件（如UILabel和）的布局配置封装于<em>layoutSubView:</em>方法中；将HUD的背景图及progress进度条绘制置于<em>drawRect:</em>方法中，故可以在任意时机通过调用<em>setNeedsLayout</em>以及<em>setNeedsDisplay</em>统一更新UI。再通过KVO、通知等方式统一进行绑定，实现了高效率的UI更新及代码规范的封装方式。</li>
<li><strong>对于“全能”实现方法的二次封装</strong>：只将真正的实现代码封装在指定方法中，并提供详细的配置参数。其他相关API只是对改方法进行不同配置上的二次封装，使代码机制，易于管理，减少了出错概率。</li>
<li><strong>灵活使用KVO等方式进行变量的自动设置</strong>：KVO可以在运行期间自动完成对应变量的更新，这对于大量对象的频繁修改尤其有效，也是集中管理代码的良好方式。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;提要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;“全能”实现方法；&lt;/li&gt;
&lt;li&gt;“延后显示”和“最少显示时间”；&lt;/li&gt;
&lt;li&gt;使用KVO更新UI；&lt;/li&gt;
&lt;li&gt;使用通知方式处理自身视图的朝向变化；&lt;/li&gt;
&lt;li&gt;总结
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
